"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ethers";
exports.ids = ["vendor-chunks/ethers"];
exports.modules = {

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/_version.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/_version.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"abi/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsVUFBVSxZQUFZLENBQ25DLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NsaW1lLWJldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL192ZXJzaW9uLmpzPzg3MDEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcImFiaS81LjcuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/abi-coder.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/abi-coder.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbiCoder: () => (/* binding */ AbiCoder),\n/* harmony export */   defaultAbiCoder: () => (/* binding */ defaultAbiCoder)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/_version.js\");\n/* harmony import */ var _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./coders/abstract-coder */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n/* harmony import */ var _coders_address__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./coders/address */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/address.js\");\n/* harmony import */ var _coders_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./coders/array */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/array.js\");\n/* harmony import */ var _coders_boolean__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./coders/boolean */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/boolean.js\");\n/* harmony import */ var _coders_bytes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./coders/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/bytes.js\");\n/* harmony import */ var _coders_fixed_bytes__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./coders/fixed-bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js\");\n/* harmony import */ var _coders_null__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./coders/null */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/null.js\");\n/* harmony import */ var _coders_number__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./coders/number */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/number.js\");\n/* harmony import */ var _coders_string__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./coders/string */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/string.js\");\n/* harmony import */ var _coders_tuple__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./coders/tuple */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/tuple.js\");\n/* harmony import */ var _fragments__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./fragments */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/fragments.js\");\n\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\n\n\n\n\n\n\n\n\n\n\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nclass AbiCoder {\n    constructor(coerceFunc){\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"coerceFunc\", coerceFunc || null);\n    }\n    _getCoder(param) {\n        switch(param.baseType){\n            case \"address\":\n                return new _coders_address__WEBPACK_IMPORTED_MODULE_3__.AddressCoder(param.name);\n            case \"bool\":\n                return new _coders_boolean__WEBPACK_IMPORTED_MODULE_4__.BooleanCoder(param.name);\n            case \"string\":\n                return new _coders_string__WEBPACK_IMPORTED_MODULE_5__.StringCoder(param.name);\n            case \"bytes\":\n                return new _coders_bytes__WEBPACK_IMPORTED_MODULE_6__.BytesCoder(param.name);\n            case \"array\":\n                return new _coders_array__WEBPACK_IMPORTED_MODULE_7__.ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);\n            case \"tuple\":\n                return new _coders_tuple__WEBPACK_IMPORTED_MODULE_8__.TupleCoder((param.components || []).map((component)=>{\n                    return this._getCoder(component);\n                }), param.name);\n            case \"\":\n                return new _coders_null__WEBPACK_IMPORTED_MODULE_9__.NullCoder(param.name);\n        }\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            if (size === 0 || size > 256 || size % 8 !== 0) {\n                logger.throwArgumentError(\"invalid \" + match[1] + \" bit length\", \"param\", param);\n            }\n            return new _coders_number__WEBPACK_IMPORTED_MODULE_10__.NumberCoder(size / 8, match[1] === \"int\", param.name);\n        }\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            if (size === 0 || size > 32) {\n                logger.throwArgumentError(\"invalid bytes length\", \"param\", param);\n            }\n            return new _coders_fixed_bytes__WEBPACK_IMPORTED_MODULE_11__.FixedBytesCoder(size, param.name);\n        }\n        return logger.throwArgumentError(\"invalid type\", \"type\", param.type);\n    }\n    _getWordSize() {\n        return 32;\n    }\n    _getReader(data, allowLoose) {\n        return new _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_12__.Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);\n    }\n    _getWriter() {\n        return new _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_12__.Writer(this._getWordSize());\n    }\n    getDefaultValue(types) {\n        const coders = types.map((type)=>this._getCoder(_fragments__WEBPACK_IMPORTED_MODULE_13__.ParamType.from(type)));\n        const coder = new _coders_tuple__WEBPACK_IMPORTED_MODULE_8__.TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n    encode(types, values) {\n        if (types.length !== values.length) {\n            logger.throwError(\"types/values length mismatch\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {\n                count: {\n                    types: types.length,\n                    values: values.length\n                },\n                value: {\n                    types: types,\n                    values: values\n                }\n            });\n        }\n        const coders = types.map((type)=>this._getCoder(_fragments__WEBPACK_IMPORTED_MODULE_13__.ParamType.from(type)));\n        const coder = new _coders_tuple__WEBPACK_IMPORTED_MODULE_8__.TupleCoder(coders, \"_\");\n        const writer = this._getWriter();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n    decode(types, data, loose) {\n        const coders = types.map((type)=>this._getCoder(_fragments__WEBPACK_IMPORTED_MODULE_13__.ParamType.from(type)));\n        const coder = new _coders_tuple__WEBPACK_IMPORTED_MODULE_8__.TupleCoder(coders, \"_\");\n        return coder.decode(this._getReader((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_14__.arrayify)(data), loose));\n    }\n}\nconst defaultAbiCoder = new AbiCoder(); //# sourceMappingURL=abi-coder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9hYmktY29kZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBYTtBQUNiLG1FQUFtRTtBQUNuQjtBQUNXO0FBQ1o7QUFDVjtBQUNyQyxNQUFNSSxTQUFTLElBQUlGLHlEQUFNQSxDQUFDQyw2Q0FBT0E7QUFDd0I7QUFDVDtBQUNKO0FBQ0k7QUFDSjtBQUNXO0FBQ2I7QUFDSTtBQUNBO0FBQ0Y7QUFDSjtBQUN4QyxNQUFNYyxpQkFBaUIsSUFBSUMsT0FBTztBQUNsQyxNQUFNQyxrQkFBa0IsSUFBSUQsT0FBTztBQUM1QixNQUFNRTtJQUNUQyxZQUFZQyxVQUFVLENBQUU7UUFDcEJyQix5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsY0FBY3FCLGNBQWM7SUFDckQ7SUFDQUMsVUFBVUMsS0FBSyxFQUFFO1FBQ2IsT0FBUUEsTUFBTUMsUUFBUTtZQUNsQixLQUFLO2dCQUNELE9BQU8sSUFBSWxCLHlEQUFZQSxDQUFDaUIsTUFBTUUsSUFBSTtZQUN0QyxLQUFLO2dCQUNELE9BQU8sSUFBSWpCLHlEQUFZQSxDQUFDZSxNQUFNRSxJQUFJO1lBQ3RDLEtBQUs7Z0JBQ0QsT0FBTyxJQUFJWix1REFBV0EsQ0FBQ1UsTUFBTUUsSUFBSTtZQUNyQyxLQUFLO2dCQUNELE9BQU8sSUFBSWhCLHFEQUFVQSxDQUFDYyxNQUFNRSxJQUFJO1lBQ3BDLEtBQUs7Z0JBQ0QsT0FBTyxJQUFJbEIscURBQVVBLENBQUMsSUFBSSxDQUFDZSxTQUFTLENBQUNDLE1BQU1HLGFBQWEsR0FBR0gsTUFBTUksV0FBVyxFQUFFSixNQUFNRSxJQUFJO1lBQzVGLEtBQUs7Z0JBQ0QsT0FBTyxJQUFJWCxxREFBVUEsQ0FBQyxDQUFDUyxNQUFNSyxVQUFVLElBQUksRUFBRSxFQUFFQyxHQUFHLENBQUMsQ0FBQ0M7b0JBQ2hELE9BQU8sSUFBSSxDQUFDUixTQUFTLENBQUNR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LENBQUMsSUFBSSxDQUFDbkIsVUFBVSxDQUFDdEMsK0RBQVFBLENBQUN1QyxPQUFPbUI7SUFDeEQ7QUFDSjtBQUNPLE1BQU1DLGtCQUFrQixJQUFJdkMsV0FBVyxDQUM5QyxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbGltZS1iZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9hYmktY29kZXIuanM/ZDljMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9FdGhlcmV1bS1Db250cmFjdC1BQklcbmltcG9ydCB7IGFycmF5aWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5pbXBvcnQgeyBSZWFkZXIsIFdyaXRlciB9IGZyb20gXCIuL2NvZGVycy9hYnN0cmFjdC1jb2RlclwiO1xuaW1wb3J0IHsgQWRkcmVzc0NvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2FkZHJlc3NcIjtcbmltcG9ydCB7IEFycmF5Q29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYXJyYXlcIjtcbmltcG9ydCB7IEJvb2xlYW5Db2RlciB9IGZyb20gXCIuL2NvZGVycy9ib29sZWFuXCI7XG5pbXBvcnQgeyBCeXRlc0NvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2J5dGVzXCI7XG5pbXBvcnQgeyBGaXhlZEJ5dGVzQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvZml4ZWQtYnl0ZXNcIjtcbmltcG9ydCB7IE51bGxDb2RlciB9IGZyb20gXCIuL2NvZGVycy9udWxsXCI7XG5pbXBvcnQgeyBOdW1iZXJDb2RlciB9IGZyb20gXCIuL2NvZGVycy9udW1iZXJcIjtcbmltcG9ydCB7IFN0cmluZ0NvZGVyIH0gZnJvbSBcIi4vY29kZXJzL3N0cmluZ1wiO1xuaW1wb3J0IHsgVHVwbGVDb2RlciB9IGZyb20gXCIuL2NvZGVycy90dXBsZVwiO1xuaW1wb3J0IHsgUGFyYW1UeXBlIH0gZnJvbSBcIi4vZnJhZ21lbnRzXCI7XG5jb25zdCBwYXJhbVR5cGVCeXRlcyA9IG5ldyBSZWdFeHAoL15ieXRlcyhbMC05XSopJC8pO1xuY29uc3QgcGFyYW1UeXBlTnVtYmVyID0gbmV3IFJlZ0V4cCgvXih1P2ludCkoWzAtOV0qKSQvKTtcbmV4cG9ydCBjbGFzcyBBYmlDb2RlciB7XG4gICAgY29uc3RydWN0b3IoY29lcmNlRnVuYykge1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImNvZXJjZUZ1bmNcIiwgY29lcmNlRnVuYyB8fCBudWxsKTtcbiAgICB9XG4gICAgX2dldENvZGVyKHBhcmFtKSB7XG4gICAgICAgIHN3aXRjaCAocGFyYW0uYmFzZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQm9vbGVhbkNvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwiYnl0ZXNcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ5dGVzQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5Q29kZXIodGhpcy5fZ2V0Q29kZXIocGFyYW0uYXJyYXlDaGlsZHJlbiksIHBhcmFtLmFycmF5TGVuZ3RoLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJ0dXBsZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHVwbGVDb2RlcigocGFyYW0uY29tcG9uZW50cyB8fCBbXSkubWFwKChjb21wb25lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENvZGVyKGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgfSksIHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcIlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTnVsbENvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHU/aW50WzAtOV0qXG4gICAgICAgIGxldCBtYXRjaCA9IHBhcmFtLnR5cGUubWF0Y2gocGFyYW1UeXBlTnVtYmVyKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzJdIHx8IFwiMjU2XCIpO1xuICAgICAgICAgICAgaWYgKHNpemUgPT09IDAgfHwgc2l6ZSA+IDI1NiB8fCAoc2l6ZSAlIDgpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgXCIgKyBtYXRjaFsxXSArIFwiIGJpdCBsZW5ndGhcIiwgXCJwYXJhbVwiLCBwYXJhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IE51bWJlckNvZGVyKHNpemUgLyA4LCAobWF0Y2hbMV0gPT09IFwiaW50XCIpLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBieXRlc1swLTldK1xuICAgICAgICBtYXRjaCA9IHBhcmFtLnR5cGUubWF0Y2gocGFyYW1UeXBlQnl0ZXMpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuICAgICAgICAgICAgaWYgKHNpemUgPT09IDAgfHwgc2l6ZSA+IDMyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYnl0ZXMgbGVuZ3RoXCIsIFwicGFyYW1cIiwgcGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaXhlZEJ5dGVzQ29kZXIoc2l6ZSwgcGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHR5cGVcIiwgXCJ0eXBlXCIsIHBhcmFtLnR5cGUpO1xuICAgIH1cbiAgICBfZ2V0V29yZFNpemUoKSB7IHJldHVybiAzMjsgfVxuICAgIF9nZXRSZWFkZXIoZGF0YSwgYWxsb3dMb29zZSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlYWRlcihkYXRhLCB0aGlzLl9nZXRXb3JkU2l6ZSgpLCB0aGlzLmNvZXJjZUZ1bmMsIGFsbG93TG9vc2UpO1xuICAgIH1cbiAgICBfZ2V0V3JpdGVyKCkge1xuICAgICAgICByZXR1cm4gbmV3IFdyaXRlcih0aGlzLl9nZXRXb3JkU2l6ZSgpKTtcbiAgICB9XG4gICAgZ2V0RGVmYXVsdFZhbHVlKHR5cGVzKSB7XG4gICAgICAgIGNvbnN0IGNvZGVycyA9IHR5cGVzLm1hcCgodHlwZSkgPT4gdGhpcy5fZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20odHlwZSkpKTtcbiAgICAgICAgY29uc3QgY29kZXIgPSBuZXcgVHVwbGVDb2Rlcihjb2RlcnMsIFwiX1wiKTtcbiAgICAgICAgcmV0dXJuIGNvZGVyLmRlZmF1bHRWYWx1ZSgpO1xuICAgIH1cbiAgICBlbmNvZGUodHlwZXMsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZXMubGVuZ3RoICE9PSB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInR5cGVzL3ZhbHVlcyBsZW5ndGggbWlzbWF0Y2hcIiwgTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICAgICAgY291bnQ6IHsgdHlwZXM6IHR5cGVzLmxlbmd0aCwgdmFsdWVzOiB2YWx1ZXMubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHsgdHlwZXM6IHR5cGVzLCB2YWx1ZXM6IHZhbHVlcyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2RlcnMgPSB0eXBlcy5tYXAoKHR5cGUpID0+IHRoaXMuX2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKHR5cGUpKSk7XG4gICAgICAgIGNvbnN0IGNvZGVyID0gKG5ldyBUdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpKTtcbiAgICAgICAgY29uc3Qgd3JpdGVyID0gdGhpcy5fZ2V0V3JpdGVyKCk7XG4gICAgICAgIGNvZGVyLmVuY29kZSh3cml0ZXIsIHZhbHVlcyk7XG4gICAgICAgIHJldHVybiB3cml0ZXIuZGF0YTtcbiAgICB9XG4gICAgZGVjb2RlKHR5cGVzLCBkYXRhLCBsb29zZSkge1xuICAgICAgICBjb25zdCBjb2RlcnMgPSB0eXBlcy5tYXAoKHR5cGUpID0+IHRoaXMuX2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKHR5cGUpKSk7XG4gICAgICAgIGNvbnN0IGNvZGVyID0gbmV3IFR1cGxlQ29kZXIoY29kZXJzLCBcIl9cIik7XG4gICAgICAgIHJldHVybiBjb2Rlci5kZWNvZGUodGhpcy5fZ2V0UmVhZGVyKGFycmF5aWZ5KGRhdGEpLCBsb29zZSkpO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBkZWZhdWx0QWJpQ29kZXIgPSBuZXcgQWJpQ29kZXIoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFiaS1jb2Rlci5qcy5tYXAiXSwibmFtZXMiOlsiYXJyYXlpZnkiLCJkZWZpbmVSZWFkT25seSIsIkxvZ2dlciIsInZlcnNpb24iLCJsb2dnZXIiLCJSZWFkZXIiLCJXcml0ZXIiLCJBZGRyZXNzQ29kZXIiLCJBcnJheUNvZGVyIiwiQm9vbGVhbkNvZGVyIiwiQnl0ZXNDb2RlciIsIkZpeGVkQnl0ZXNDb2RlciIsIk51bGxDb2RlciIsIk51bWJlckNvZGVyIiwiU3RyaW5nQ29kZXIiLCJUdXBsZUNvZGVyIiwiUGFyYW1UeXBlIiwicGFyYW1UeXBlQnl0ZXMiLCJSZWdFeHAiLCJwYXJhbVR5cGVOdW1iZXIiLCJBYmlDb2RlciIsImNvbnN0cnVjdG9yIiwiY29lcmNlRnVuYyIsIl9nZXRDb2RlciIsInBhcmFtIiwiYmFzZVR5cGUiLCJuYW1lIiwiYXJyYXlDaGlsZHJlbiIsImFycmF5TGVuZ3RoIiwiY29tcG9uZW50cyIsIm1hcCIsImNvbXBvbmVudCIsIm1hdGNoIiwidHlwZSIsInNpemUiLCJwYXJzZUludCIsInRocm93QXJndW1lbnRFcnJvciIsIl9nZXRXb3JkU2l6ZSIsIl9nZXRSZWFkZXIiLCJkYXRhIiwiYWxsb3dMb29zZSIsIl9nZXRXcml0ZXIiLCJnZXREZWZhdWx0VmFsdWUiLCJ0eXBlcyIsImNvZGVycyIsImZyb20iLCJjb2RlciIsImRlZmF1bHRWYWx1ZSIsImVuY29kZSIsInZhbHVlcyIsImxlbmd0aCIsInRocm93RXJyb3IiLCJlcnJvcnMiLCJJTlZBTElEX0FSR1VNRU5UIiwiY291bnQiLCJ2YWx1ZSIsIndyaXRlciIsImRlY29kZSIsImxvb3NlIiwiZGVmYXVsdEFiaUNvZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/abi-coder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Coder: () => (/* binding */ Coder),\n/* harmony export */   Reader: () => (/* binding */ Reader),\n/* harmony export */   Writer: () => (/* binding */ Writer),\n/* harmony export */   checkResultErrors: () => (/* binding */ checkResultErrors)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/_version.js\");\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nfunction checkResultErrors(result) {\n    // Find the first error (if any)\n    const errors = [];\n    const checkErrors = function(path, object) {\n        if (!Array.isArray(object)) {\n            return;\n        }\n        for(let key in object){\n            const childPath = path.slice();\n            childPath.push(key);\n            try {\n                checkErrors(childPath, object[key]);\n            } catch (error) {\n                errors.push({\n                    path: childPath,\n                    error: error\n                });\n            }\n        }\n    };\n    checkErrors([], result);\n    return errors;\n}\nclass Coder {\n    constructor(name, type, localName, dynamic){\n        // @TODO: defineReadOnly these\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n    _throwError(message, value) {\n        logger.throwArgumentError(message, this.localName, value);\n    }\n}\nclass Writer {\n    constructor(wordSize){\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"wordSize\", wordSize || 32);\n        this._data = [];\n        this._dataLength = 0;\n        this._padding = new Uint8Array(wordSize);\n    }\n    get data() {\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)(this._data);\n    }\n    get length() {\n        return this._dataLength;\n    }\n    _writeData(data) {\n        this._data.push(data);\n        this._dataLength += data.length;\n        return data.length;\n    }\n    appendWriter(writer) {\n        return this._writeData((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)(writer._data));\n    }\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value) {\n        let bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value);\n        const paddingOffset = bytes.length % this.wordSize;\n        if (paddingOffset) {\n            bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([\n                bytes,\n                this._padding.slice(paddingOffset)\n            ]);\n        }\n        return this._writeData(bytes);\n    }\n    _getValue(value) {\n        let bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            logger.throwError(\"value out-of-bounds\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([\n                this._padding.slice(bytes.length % this.wordSize),\n                bytes\n            ]);\n        }\n        return bytes;\n    }\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value) {\n        return this._writeData(this._getValue(value));\n    }\n    writeUpdatableValue() {\n        const offset = this._data.length;\n        this._data.push(this._padding);\n        this._dataLength += this.wordSize;\n        return (value)=>{\n            this._data[offset] = this._getValue(value);\n        };\n    }\n}\nclass Reader {\n    constructor(data, wordSize, coerceFunc, allowLoose){\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"_data\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(data));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"wordSize\", wordSize || 32);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"_coerceFunc\", coerceFunc);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"allowLoose\", allowLoose);\n        this._offset = 0;\n    }\n    get data() {\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(this._data);\n    }\n    get consumed() {\n        return this._offset;\n    }\n    // The default Coerce function\n    static coerce(name, value) {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) {\n            value = value.toNumber();\n        }\n        return value;\n    }\n    coerce(name, value) {\n        if (this._coerceFunc) {\n            return this._coerceFunc(name, value);\n        }\n        return Reader.coerce(name, value);\n    }\n    _peekBytes(offset, length, loose) {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n                alignedLength = length;\n            } else {\n                logger.throwError(\"data out-of-bounds\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {\n                    length: this._data.length,\n                    offset: this._offset + alignedLength\n                });\n            }\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength);\n    }\n    subReader(offset) {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n    readBytes(length, loose) {\n        let bytes = this._peekBytes(0, length, !!loose);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n    readValue() {\n        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(this.readBytes(this.wordSize));\n    }\n} //# sourceMappingURL=abstract-coder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvYWJzdHJhY3QtY29kZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQWE7QUFDK0Q7QUFDdkI7QUFDTTtBQUNaO0FBQ1Q7QUFDdEMsTUFBTVEsU0FBUyxJQUFJRix5REFBTUEsQ0FBQ0MsNkNBQU9BO0FBQzFCLFNBQVNFLGtCQUFrQkMsTUFBTTtJQUNwQyxnQ0FBZ0M7SUFDaEMsTUFBTUMsU0FBUyxFQUFFO0lBQ2pCLE1BQU1DLGNBQWMsU0FBVUMsSUFBSSxFQUFFQyxNQUFNO1FBQ3RDLElBQUksQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDRixTQUFTO1lBQ3hCO1FBQ0o7UUFDQSxJQUFLLElBQUlHLE9BQU9ILE9BQVE7WUFDcEIsTUFBTUksWUFBWUwsS0FBS00sS0FBSztZQUM1QkQsVUFBVUUsSUFBSSxDQUFDSDtZQUNmLElBQUk7Z0JBQ0FMLFlBQVlNLFdBQVdKLE1BQU0sQ0FBQ0csSUFBSTtZQUN0QyxFQUNBLE9BQU9JLE9BQU87Z0JBQ1ZWLE9BQU9TLElBQUksQ0FBQztvQkFBRVAsTUFBTUs7b0JBQVdHLE9BQU9BO2dCQUFNO1lBQ2hEO1FBQ0o7SUFDSjtJQUNBVCxZQUFZLEVBQUUsRUFBRUY7SUFDaEIsT0FBT0M7QUFDWDtBQUNPLE1BQU1XO0lBQ1RDLFlBQVlDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxTQUFTLEVBQUVDLE9BQU8sQ0FBRTtRQUN4Qyw4QkFBOEI7UUFDOUIsSUFBSSxDQUFDSCxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDQyxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDQyxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtJQUNuQjtJQUNBQyxZQUFZQyxPQUFPLEVBQUVDLEtBQUssRUFBRTtRQUN4QnRCLE9BQU91QixrQkFBa0IsQ0FBQ0YsU0FBUyxJQUFJLENBQUNILFNBQVMsRUFB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UUFBUSxJQUFJLENBQUNMLEtBQUssQ0FBQ0ssTUFBTTtvQkFDekJXLFFBQVEsSUFBSSxDQUFDTSxPQUFPLEdBQUdTO2dCQUMzQjtZQUNKO1FBQ0o7UUFDQSxPQUFPLElBQUksQ0FBQy9CLEtBQUssQ0FBQ2YsS0FBSyxDQUFDLElBQUksQ0FBQ3FDLE9BQU8sRUFBRSxJQUFJLENBQUNBLE9BQU8sR0FBR1M7SUFDekQ7SUFDQUcsVUFBVWxCLE1BQU0sRUFBRTtRQUNkLE9BQU8sSUFBSUcsT0FBTyxJQUFJLENBQUNuQixLQUFLLENBQUNmLEtBQUssQ0FBQyxJQUFJLENBQUNxQyxPQUFPLEdBQUdOLFNBQVMsSUFBSSxDQUFDakIsUUFBUSxFQUFFLElBQUksQ0FBQzZCLFdBQVcsRUFBRSxJQUFJLENBQUNQLFVBQVU7SUFDL0c7SUFDQWMsVUFBVTlCLE1BQU0sRUFBRXlCLEtBQUssRUFBRTtRQUNyQixJQUFJcEIsUUFBUSxJQUFJLENBQUNtQixVQUFVLENBQUMsR0FBR3hCLFFBQVEsQ0FBQyxDQUFDeUI7UUFDekMsSUFBSSxDQUFDUixPQUFPLElBQUlaLE1BQU1MLE1BQU07UUFDNUIsb0RBQW9EO1FBQ3BELE9BQU9LLE1BQU16QixLQUFLLENBQUMsR0FBR29CO0lBQzFCO0lBQ0ErQixZQUFZO1FBQ1IsT0FBT2xFLCtEQUFTQSxDQUFDMkMsSUFBSSxDQUFDLElBQUksQ0FBQ3NCLFNBQVMsQ0FBQyxJQUFJLENBQUNwQyxRQUFRO0lBQ3REO0FBQ0osRUFDQSwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbGltZS1iZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvYWJzdHJhY3QtY29kZXIuanM/ZmEyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGFycmF5aWZ5LCBjb25jYXQsIGhleENvbmNhdCwgaGV4bGlmeSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsgZGVmaW5lUmVhZE9ubHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmV4cG9ydCBmdW5jdGlvbiBjaGVja1Jlc3VsdEVycm9ycyhyZXN1bHQpIHtcbiAgICAvLyBGaW5kIHRoZSBmaXJzdCBlcnJvciAoaWYgYW55KVxuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIGNvbnN0IGNoZWNrRXJyb3JzID0gZnVuY3Rpb24gKHBhdGgsIG9iamVjdCkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IHBhdGguc2xpY2UoKTtcbiAgICAgICAgICAgIGNoaWxkUGF0aC5wdXNoKGtleSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNoZWNrRXJyb3JzKGNoaWxkUGF0aCwgb2JqZWN0W2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goeyBwYXRoOiBjaGlsZFBhdGgsIGVycm9yOiBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgY2hlY2tFcnJvcnMoW10sIHJlc3VsdCk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmV4cG9ydCBjbGFzcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKSB7XG4gICAgICAgIC8vIEBUT0RPOiBkZWZpbmVSZWFkT25seSB0aGVzZVxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmxvY2FsTmFtZSA9IGxvY2FsTmFtZTtcbiAgICAgICAgdGhpcy5keW5hbWljID0gZHluYW1pYztcbiAgICB9XG4gICAgX3Rocm93RXJyb3IobWVzc2FnZSwgdmFsdWUpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihtZXNzYWdlLCB0aGlzLmxvY2FsTmFtZSwgdmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHdvcmRTaXplKSB7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwid29yZFNpemVcIiwgd29yZFNpemUgfHwgMzIpO1xuICAgICAgICB0aGlzLl9kYXRhID0gW107XG4gICAgICAgIHRoaXMuX2RhdGFMZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9wYWRkaW5nID0gbmV3IFVpbnQ4QXJyYXkod29yZFNpemUpO1xuICAgIH1cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIGhleENvbmNhdCh0aGlzLl9kYXRhKTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuX2RhdGFMZW5ndGg7IH1cbiAgICBfd3JpdGVEYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fZGF0YS5wdXNoKGRhdGEpO1xuICAgICAgICB0aGlzLl9kYXRhTGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICByZXR1cm4gZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIGFwcGVuZFdyaXRlcih3cml0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlRGF0YShjb25jYXQod3JpdGVyLl9kYXRhKSk7XG4gICAgfVxuICAgIC8vIEFycmF5aXNoIGl0ZW1zOyBwYWRkZWQgb24gdGhlIHJpZ2h0IHRvIHdvcmRTaXplXG4gICAgd3JpdGVCeXRlcyh2YWx1ZSkge1xuICAgICAgICBsZXQgYnl0ZXMgPSBhcnJheWlmeSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdPZmZzZXQgPSBieXRlcy5sZW5ndGggJSB0aGlzLndvcmRTaXplO1xuICAgICAgICBpZiAocGFkZGluZ09mZnNldCkge1xuICAgICAgICAgICAgYnl0ZXMgPSBjb25jYXQoW2J5dGVzLCB0aGlzLl9wYWRkaW5nLnNsaWNlKHBhZGRpbmdPZmZzZXQpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlRGF0YShieXRlcyk7XG4gICAgfVxuICAgIF9nZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBsZXQgYnl0ZXMgPSBhcnJheWlmeShCaWdOdW1iZXIuZnJvbSh2YWx1ZSkpO1xuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID4gdGhpcy53b3JkU2l6ZSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ2YWx1ZSBvdXQtb2YtYm91bmRzXCIsIExvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHtcbiAgICAgICAgICAgICAgICBsZW5ndGg6IHRoaXMud29yZFNpemUsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBieXRlcy5sZW5ndGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggJSB0aGlzLndvcmRTaXplKSB7XG4gICAgICAgICAgICBieXRlcyA9IGNvbmNhdChbdGhpcy5fcGFkZGluZy5zbGljZShieXRlcy5sZW5ndGggJSB0aGlzLndvcmRTaXplKSwgYnl0ZXNdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICAgIC8vIEJpZ051bWJlcmlzaCBpdGVtczsgcGFkZGVkIG9uIHRoZSBsZWZ0IHRvIHdvcmRTaXplXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVEYXRhKHRoaXMuX2dldFZhbHVlKHZhbHVlKSk7XG4gICAgfVxuICAgIHdyaXRlVXBkYXRhYmxlVmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX2RhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLl9kYXRhLnB1c2godGhpcy5fcGFkZGluZyk7XG4gICAgICAgIHRoaXMuX2RhdGFMZW5ndGggKz0gdGhpcy53b3JkU2l6ZTtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZGF0YVtvZmZzZXRdID0gdGhpcy5fZ2V0VmFsdWUodmFsdWUpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIHdvcmRTaXplLCBjb2VyY2VGdW5jLCBhbGxvd0xvb3NlKSB7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2RhdGFcIiwgYXJyYXlpZnkoZGF0YSkpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIndvcmRTaXplXCIsIHdvcmRTaXplIHx8IDMyKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfY29lcmNlRnVuY1wiLCBjb2VyY2VGdW5jKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhbGxvd0xvb3NlXCIsIGFsbG93TG9vc2UpO1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSAwO1xuICAgIH1cbiAgICBnZXQgZGF0YSgpIHsgcmV0dXJuIGhleGxpZnkodGhpcy5fZGF0YSk7IH1cbiAgICBnZXQgY29uc3VtZWQoKSB7IHJldHVybiB0aGlzLl9vZmZzZXQ7IH1cbiAgICAvLyBUaGUgZGVmYXVsdCBDb2VyY2UgZnVuY3Rpb25cbiAgICBzdGF0aWMgY29lcmNlKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IG5hbWUubWF0Y2goXCJedT9pbnQoWzAtOV0rKSRcIik7XG4gICAgICAgIGlmIChtYXRjaCAmJiBwYXJzZUludChtYXRjaFsxXSkgPD0gNDgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvZXJjZShuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fY29lcmNlRnVuYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvZXJjZUZ1bmMobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWFkZXIuY29lcmNlKG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgX3BlZWtCeXRlcyhvZmZzZXQsIGxlbmd0aCwgbG9vc2UpIHtcbiAgICAgICAgbGV0IGFsaWduZWRMZW5ndGggPSBNYXRoLmNlaWwobGVuZ3RoIC8gdGhpcy53b3JkU2l6ZSkgKiB0aGlzLndvcmRTaXplO1xuICAgICAgICBpZiAodGhpcy5fb2Zmc2V0ICsgYWxpZ25lZExlbmd0aCA+IHRoaXMuX2RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGxvd0xvb3NlICYmIGxvb3NlICYmIHRoaXMuX29mZnNldCArIGxlbmd0aCA8PSB0aGlzLl9kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFsaWduZWRMZW5ndGggPSBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImRhdGEgb3V0LW9mLWJvdW5kc1wiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDogdGhpcy5fZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5fb2Zmc2V0ICsgYWxpZ25lZExlbmd0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnNsaWNlKHRoaXMuX29mZnNldCwgdGhpcy5fb2Zmc2V0ICsgYWxpZ25lZExlbmd0aCk7XG4gICAgfVxuICAgIHN1YlJlYWRlcihvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIodGhpcy5fZGF0YS5zbGljZSh0aGlzLl9vZmZzZXQgKyBvZmZzZXQpLCB0aGlzLndvcmRTaXplLCB0aGlzLl9jb2VyY2VGdW5jLCB0aGlzLmFsbG93TG9vc2UpO1xuICAgIH1cbiAgICByZWFkQnl0ZXMobGVuZ3RoLCBsb29zZSkge1xuICAgICAgICBsZXQgYnl0ZXMgPSB0aGlzLl9wZWVrQnl0ZXMoMCwgbGVuZ3RoLCAhIWxvb3NlKTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgLy8gQFRPRE86IE1ha2Ugc3VyZSB0aGUgbGVuZ3RoLi5lbmQgYnl0ZXMgYXJlIGFsbCAwP1xuICAgICAgICByZXR1cm4gYnl0ZXMuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgcmVhZFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20odGhpcy5yZWFkQnl0ZXModGhpcy53b3JkU2l6ZSkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFic3RyYWN0LWNvZGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJhcnJheWlmeSIsImNvbmNhdCIsImhleENvbmNhdCIsImhleGxpZnkiLCJCaWdOdW1iZXIiLCJkZWZpbmVSZWFkT25seSIsIkxvZ2dlciIsInZlcnNpb24iLCJsb2dnZXIiLCJjaGVja1Jlc3VsdEVycm9ycyIsInJlc3VsdCIsImVycm9ycyIsImNoZWNrRXJyb3JzIiwicGF0aCIsIm9iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsImtleSIsImNoaWxkUGF0aCIsInNsaWNlIiwicHVzaCIsImVycm9yIiwiQ29kZXIiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJ0eXBlIiwibG9jYWxOYW1lIiwiZHluYW1pYyIsIl90aHJvd0Vycm9yIiwibWVzc2FnZSIsInZhbHVlIiwidGhyb3dBcmd1bWVudEVycm9yIiwiV3JpdGVyIiwid29yZFNpemUiLCJfZGF0YSIsIl9kYXRhTGVuZ3RoIiwiX3BhZGRpbmciLCJVaW50OEFycmF5IiwiZGF0YSIsImxlbmd0aCIsIl93cml0ZURhdGEiLCJhcHBlbmRXcml0ZXIiLCJ3cml0ZXIiLCJ3cml0ZUJ5dGVzIiwiYnl0ZXMiLCJwYWRkaW5nT2Zmc2V0IiwiX2dldFZhbHVlIiwiZnJvbSIsInRocm93RXJyb3IiLCJCVUZGRVJfT1ZFUlJVTiIsIm9mZnNldCIsIndyaXRlVmFsdWUiLCJ3cml0ZVVwZGF0YWJsZVZhbHVlIiwiUmVhZGVyIiwiY29lcmNlRnVuYyIsImFsbG93TG9vc2UiLCJfb2Zmc2V0IiwiY29uc3VtZWQiLCJjb2VyY2UiLCJtYXRjaCIsInBhcnNlSW50IiwidG9OdW1iZXIiLCJfY29lcmNlRnVuYyIsIl9wZWVrQnl0ZXMiLCJsb29zZSIsImFsaWduZWRMZW5ndGgiLCJNYXRoIiwiY2VpbCIsInN1YlJlYWRlciIsInJlYWRCeXRlcyIsInJlYWRWYWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/address.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/address.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressCoder: () => (/* binding */ AddressCoder)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n\n\n\n\nclass AddressCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName){\n        super(\"address\", \"address\", localName, false);\n    }\n    defaultValue() {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n    encode(writer, value) {\n        try {\n            value = (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_1__.getAddress)(value);\n        } catch (error) {\n            this._throwError(error.message, value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_1__.getAddress)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexZeroPad)(reader.readValue().toHexString(), 20));\n    }\n} //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvYWRkcmVzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWE7QUFDdUM7QUFDRjtBQUNUO0FBQ2xDLE1BQU1HLHFCQUFxQkQsa0RBQUtBO0lBQ25DRSxZQUFZQyxTQUFTLENBQUU7UUFDbkIsS0FBSyxDQUFDLFdBQVcsV0FBV0EsV0FBVztJQUMzQztJQUNBQyxlQUFlO1FBQ1gsT0FBTztJQUNYO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRUMsS0FBSyxFQUFFO1FBQ2xCLElBQUk7WUFDQUEsUUFBUVQsa0VBQVVBLENBQUNTO1FBQ3ZCLEVBQ0EsT0FBT0MsT0FBTztZQUNWLElBQUksQ0FBQ0MsV0FBVyxDQUFDRCxNQUFNRSxPQUFPLEVBQUVIO1FBQ3BDO1FBQ0EsT0FBT0QsT0FBT0ssVUFBVSxDQUFDSjtJQUM3QjtJQUNBSyxPQUFPQyxNQUFNLEVBQUU7UUFDWCxPQUFPZixrRUFBVUEsQ0FBQ0MsZ0VBQVVBLENBQUNjLE9BQU9DLFNBQVMsR0FBR0MsV0FBVyxJQUFJO0lBQ25FO0FBQ0osRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbGltZS1iZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvYWRkcmVzcy5qcz8wZjk3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hZGRyZXNzXCI7XG5pbXBvcnQgeyBoZXhaZXJvUGFkIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyXCI7XG5leHBvcnQgY2xhc3MgQWRkcmVzc0NvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsdWUgPSBnZXRBZGRyZXNzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoZXJyb3IubWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldEFkZHJlc3MoaGV4WmVyb1BhZChyZWFkZXIucmVhZFZhbHVlKCkudG9IZXhTdHJpbmcoKSwgMjApKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBZGRyZXNzIiwiaGV4WmVyb1BhZCIsIkNvZGVyIiwiQWRkcmVzc0NvZGVyIiwiY29uc3RydWN0b3IiLCJsb2NhbE5hbWUiLCJkZWZhdWx0VmFsdWUiLCJlbmNvZGUiLCJ3cml0ZXIiLCJ2YWx1ZSIsImVycm9yIiwiX3Rocm93RXJyb3IiLCJtZXNzYWdlIiwid3JpdGVWYWx1ZSIsImRlY29kZSIsInJlYWRlciIsInJlYWRWYWx1ZSIsInRvSGV4U3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnonymousCoder: () => (/* binding */ AnonymousCoder)\n/* harmony export */ });\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n\n\n// Clones the functionality of an existing Coder, but without a localName\nclass AnonymousCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(coder){\n        super(coder.name, coder.type, undefined, coder.dynamic);\n        this.coder = coder;\n    }\n    defaultValue() {\n        return this.coder.defaultValue();\n    }\n    encode(writer, value) {\n        return this.coder.encode(writer, value);\n    }\n    decode(reader) {\n        return this.coder.decode(reader);\n    }\n} //# sourceMappingURL=anonymous.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvYW5vbnltb3VzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWE7QUFDNEI7QUFDekMseUVBQXlFO0FBQ2xFLE1BQU1DLHVCQUF1QkQsa0RBQUtBO0lBQ3JDRSxZQUFZQyxLQUFLLENBQUU7UUFDZixLQUFLLENBQUNBLE1BQU1DLElBQUksRUFBRUQsTUFBTUUsSUFBSSxFQUFFQyxXQUFXSCxNQUFNSSxPQUFPO1FBQ3RELElBQUksQ0FBQ0osS0FBSyxHQUFHQTtJQUNqQjtJQUNBSyxlQUFlO1FBQ1gsT0FBTyxJQUFJLENBQUNMLEtBQUssQ0FBQ0ssWUFBWTtJQUNsQztJQUNBQyxPQUFPQyxNQUFNLEVBQUVDLEtBQUssRUFBRTtRQUNsQixPQUFPLElBQUksQ0FBQ1IsS0FBSyxDQUFDTSxNQUFNLENBQUNDLFFBQVFDO0lBQ3JDO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRTtRQUNYLE9BQU8sSUFBSSxDQUFDVixLQUFLLENBQUNTLE1BQU0sQ0FBQ0M7SUFDN0I7QUFDSixFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NsaW1lLWJldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9hbm9ueW1vdXMuanM/ZTA3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXJcIjtcbi8vIENsb25lcyB0aGUgZnVuY3Rpb25hbGl0eSBvZiBhbiBleGlzdGluZyBDb2RlciwgYnV0IHdpdGhvdXQgYSBsb2NhbE5hbWVcbmV4cG9ydCBjbGFzcyBBbm9ueW1vdXNDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2Rlcikge1xuICAgICAgICBzdXBlcihjb2Rlci5uYW1lLCBjb2Rlci50eXBlLCB1bmRlZmluZWQsIGNvZGVyLmR5bmFtaWMpO1xuICAgICAgICB0aGlzLmNvZGVyID0gY29kZXI7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZXIuZGVmYXVsdFZhbHVlKCk7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmVuY29kZSh3cml0ZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2Rlci5kZWNvZGUocmVhZGVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbm9ueW1vdXMuanMubWFwIl0sIm5hbWVzIjpbIkNvZGVyIiwiQW5vbnltb3VzQ29kZXIiLCJjb25zdHJ1Y3RvciIsImNvZGVyIiwibmFtZSIsInR5cGUiLCJ1bmRlZmluZWQiLCJkeW5hbWljIiwiZGVmYXVsdFZhbHVlIiwiZW5jb2RlIiwid3JpdGVyIiwidmFsdWUiLCJkZWNvZGUiLCJyZWFkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/array.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/array.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayCoder: () => (/* binding */ ArrayCoder),\n/* harmony export */   pack: () => (/* binding */ pack),\n/* harmony export */   unpack: () => (/* binding */ unpack)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/_version.js\");\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n/* harmony import */ var _anonymous__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./anonymous */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js\");\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\n\nfunction pack(writer, coders, values) {\n    let arrayValues = null;\n    if (Array.isArray(values)) {\n        arrayValues = values;\n    } else if (values && typeof values === \"object\") {\n        let unique = {};\n        arrayValues = coders.map((coder)=>{\n            const name = coder.localName;\n            if (!name) {\n                logger.throwError(\"cannot encode object for signature with missing names\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n            if (unique[name]) {\n                logger.throwError(\"cannot encode object for signature with duplicate names\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n            unique[name] = true;\n            return values[name];\n        });\n    } else {\n        logger.throwArgumentError(\"invalid tuple value\", \"tuple\", values);\n    }\n    if (coders.length !== arrayValues.length) {\n        logger.throwArgumentError(\"types/value length mismatch\", \"tuple\", values);\n    }\n    let staticWriter = new _abstract_coder__WEBPACK_IMPORTED_MODULE_2__.Writer(writer.wordSize);\n    let dynamicWriter = new _abstract_coder__WEBPACK_IMPORTED_MODULE_2__.Writer(writer.wordSize);\n    let updateFuncs = [];\n    coders.forEach((coder, index)=>{\n        let value = arrayValues[index];\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset)=>{\n                updateFunc(baseOffset + dynamicOffset);\n            });\n        } else {\n            coder.encode(staticWriter, value);\n        }\n    });\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func)=>{\n        func(staticWriter.length);\n    });\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\nfunction unpack(reader, coders) {\n    let values = [];\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n    coders.forEach((coder)=>{\n        let value = null;\n        if (coder.dynamic) {\n            let offset = reader.readValue();\n            let offsetReader = baseReader.subReader(offset.toNumber());\n            try {\n                value = coder.decode(offsetReader);\n            } catch (error) {\n                // Cannot recover from this\n                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        } else {\n            try {\n                value = coder.decode(reader);\n            } catch (error) {\n                // Cannot recover from this\n                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        if (value != undefined) {\n            values.push(value);\n        }\n    });\n    // We only output named properties for uniquely named coders\n    const uniqueNames = coders.reduce((accum, coder)=>{\n        const name = coder.localName;\n        if (name) {\n            if (!accum[name]) {\n                accum[name] = 0;\n            }\n            accum[name]++;\n        }\n        return accum;\n    }, {});\n    // Add any named parameters (i.e. tuples)\n    coders.forEach((coder, index)=>{\n        let name = coder.localName;\n        if (!name || uniqueNames[name] !== 1) {\n            return;\n        }\n        if (name === \"length\") {\n            name = \"_length\";\n        }\n        if (values[name] != null) {\n            return;\n        }\n        const value = values[index];\n        if (value instanceof Error) {\n            Object.defineProperty(values, name, {\n                enumerable: true,\n                get: ()=>{\n                    throw value;\n                }\n            });\n        } else {\n            values[name] = value;\n        }\n    });\n    for(let i = 0; i < values.length; i++){\n        const value = values[i];\n        if (value instanceof Error) {\n            Object.defineProperty(values, i, {\n                enumerable: true,\n                get: ()=>{\n                    throw value;\n                }\n            });\n        }\n    }\n    return Object.freeze(values);\n}\nclass ArrayCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_2__.Coder {\n    constructor(coder, length, localName){\n        const type = coder.type + \"[\" + (length >= 0 ? length : \"\") + \"]\";\n        const dynamic = length === -1 || coder.dynamic;\n        super(\"array\", type, localName, dynamic);\n        this.coder = coder;\n        this.length = length;\n    }\n    defaultValue() {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n        const result = [];\n        for(let i = 0; i < this.length; i++){\n            result.push(defaultChild);\n        }\n        return result;\n    }\n    encode(writer, value) {\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n        let count = this.length;\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n        logger.checkArgumentCount(value.length, count, \"coder array\" + (this.localName ? \" \" + this.localName : \"\"));\n        let coders = [];\n        for(let i = 0; i < value.length; i++){\n            coders.push(this.coder);\n        }\n        return pack(writer, coders, value);\n    }\n    decode(reader) {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readValue().toNumber();\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            if (count * 32 > reader._data.length) {\n                logger.throwError(\"insufficient data length\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {\n                    length: reader._data.length,\n                    count: count\n                });\n            }\n        }\n        let coders = [];\n        for(let i = 0; i < count; i++){\n            coders.push(new _anonymous__WEBPACK_IMPORTED_MODULE_3__.AnonymousCoder(this.coder));\n        }\n        return reader.coerce(this.name, unpack(reader, coders));\n    }\n} //# sourceMappingURL=array.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvYXJyYXkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFhO0FBQ2tDO0FBQ1Q7QUFDdEMsTUFBTUUsU0FBUyxJQUFJRix5REFBTUEsQ0FBQ0MsNkNBQU9BO0FBQ2dCO0FBQ0o7QUFDdEMsU0FBU0ssS0FBS0MsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLE1BQU07SUFDdkMsSUFBSUMsY0FBYztJQUNsQixJQUFJQyxNQUFNQyxPQUFPLENBQUNILFNBQVM7UUFDdkJDLGNBQWNEO0lBQ2xCLE9BQ0ssSUFBSUEsVUFBVSxPQUFRQSxXQUFZLFVBQVU7UUFDN0MsSUFBSUksU0FBUyxDQUFDO1FBQ2RILGNBQWNGLE9BQU9NLEdBQUcsQ0FBQyxDQUFDQztZQUN0QixNQUFNQyxPQUFPRCxNQUFNRSxTQUFTO1lBQzVCLElBQUksQ0FBQ0QsTUFBTTtnQkFDUGQsT0FBT2dCLFVBQVUsQ0FBQyx5REFBeURsQix5REFBTUEsQ0FBQ21CLE1BQU0sQ0FBQ0MsZ0JBQWdCLEVBQUU7b0JBQ3ZHQyxVQUFVO29CQUNWTixPQUFPQTtvQkFDUE8sT0FBT2I7Z0JBQ1g7WUFDSjtZQUNBLElBQUlJLE1BQU0sQ0FBQ0csS0FBSyxFQUFFO2dCQUNkZCxPQUFPZ0IsVUFBVSxDQUFDLDJEQUEyRGxCLHlEQUFNQSxDQUFDbUIsTUFBTSxDQUFDQyxnQkFBZ0IsRUFBRTtvQkFDekdDLFVBQVU7b0JBQ1ZOLE9BQU9BO29CQUNQTyxPQUFPYjtnQkFDWDtZQUNKO1lBQ0FJLE1BQU0sQ0FBQ0csS0FBSyxHQUFHO1lBQ2YsT0FBT1AsTUFBTSxDQUFDTyxLQUFLO1FBQ3ZCO0lBQ0osT0FDSztRQUNEZCxPQUFPcUIsa0JBQWtCLENBQUMsdUJBQXVCLFNBQVNkO0lBQzlEO0lBQ0EsSUFBSUQsT0FBT2dCLE1BQU0sS0FBS2QsWUFBWWMsTUFBTSxFQUFFO1FBQ3RDdEIsT0FBT3FCLGtC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QUFPSSxTQUFTLEdBQUdFLFFBQVE7WUFDbkMsc0RBQXNEO1lBQ3RELHdEQUF3RDtZQUN4RCx5REFBeUQ7WUFDekQsc0RBQXNEO1lBQ3RELDREQUE0RDtZQUM1RCxJQUFJd0IsUUFBUSxLQUFLOUIsT0FBT2lDLEtBQUssQ0FBQ2xELE1BQU0sRUFBRTtnQkFDbEN0QixPQUFPZ0IsVUFBVSxDQUFDLDRCQUE0QmxCLHlEQUFNQSxDQUFDbUIsTUFBTSxDQUFDZ0MsY0FBYyxFQUFFO29CQUN4RTNCLFFBQVFpQixPQUFPaUMsS0FBSyxDQUFDbEQsTUFBTTtvQkFDM0IrQyxPQUFPQTtnQkFDWDtZQUNKO1FBQ0o7UUFDQSxJQUFJL0QsU0FBUyxFQUFFO1FBQ2YsSUFBSyxJQUFJdUQsSUFBSSxHQUFHQSxJQUFJUSxPQUFPUixJQUFLO1lBQzVCdkQsT0FBTzRCLElBQUksQ0FBQyxJQUFJL0Isc0RBQWNBLENBQUMsSUFBSSxDQUFDVSxLQUFLO1FBQzdDO1FBQ0EsT0FBTzBCLE9BQU9rQyxNQUFNLENBQUMsSUFBSSxDQUFDM0QsSUFBSSxFQUFFd0IsT0FBT0MsUUFBUWpDO0lBQ25EO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbGltZS1iZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvYXJyYXkuanM/ZTQ4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5pbXBvcnQgeyBDb2RlciwgV3JpdGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXJcIjtcbmltcG9ydCB7IEFub255bW91c0NvZGVyIH0gZnJvbSBcIi4vYW5vbnltb3VzXCI7XG5leHBvcnQgZnVuY3Rpb24gcGFjayh3cml0ZXIsIGNvZGVycywgdmFsdWVzKSB7XG4gICAgbGV0IGFycmF5VmFsdWVzID0gbnVsbDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgIGFycmF5VmFsdWVzID0gdmFsdWVzO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZXMgJiYgdHlwZW9mICh2YWx1ZXMpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGxldCB1bmlxdWUgPSB7fTtcbiAgICAgICAgYXJyYXlWYWx1ZXMgPSBjb2RlcnMubWFwKChjb2RlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGVuY29kZSBvYmplY3QgZm9yIHNpZ25hdHVyZSB3aXRoIG1pc3NpbmcgbmFtZXNcIiwgTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50OiBcInZhbHVlc1wiLFxuICAgICAgICAgICAgICAgICAgICBjb2RlcjogY29kZXIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmlxdWVbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBlbmNvZGUgb2JqZWN0IGZvciBzaWduYXR1cmUgd2l0aCBkdXBsaWNhdGUgbmFtZXNcIiwgTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50OiBcInZhbHVlc1wiLFxuICAgICAgICAgICAgICAgICAgICBjb2RlcjogY29kZXIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVuaXF1ZVtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzW25hbWVdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHR1cGxlIHZhbHVlXCIsIFwidHVwbGVcIiwgdmFsdWVzKTtcbiAgICB9XG4gICAgaWYgKGNvZGVycy5sZW5ndGggIT09IGFycmF5VmFsdWVzLmxlbmd0aCkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidHlwZXMvdmFsdWUgbGVuZ3RoIG1pc21hdGNoXCIsIFwidHVwbGVcIiwgdmFsdWVzKTtcbiAgICB9XG4gICAgbGV0IHN0YXRpY1dyaXRlciA9IG5ldyBXcml0ZXIod3JpdGVyLndvcmRTaXplKTtcbiAgICBsZXQgZHluYW1pY1dyaXRlciA9IG5ldyBXcml0ZXIod3JpdGVyLndvcmRTaXplKTtcbiAgICBsZXQgdXBkYXRlRnVuY3MgPSBbXTtcbiAgICBjb2RlcnMuZm9yRWFjaCgoY29kZXIsIGluZGV4KSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGFycmF5VmFsdWVzW2luZGV4XTtcbiAgICAgICAgaWYgKGNvZGVyLmR5bmFtaWMpIHtcbiAgICAgICAgICAgIC8vIEdldCBjdXJyZW50IGR5bmFtaWMgb2Zmc2V0IChmb3IgdGhlIGZ1dHVyZSBwb2ludGVyKVxuICAgICAgICAgICAgbGV0IGR5bmFtaWNPZmZzZXQgPSBkeW5hbWljV3JpdGVyLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIEVuY29kZSB0aGUgZHluYW1pYyB2YWx1ZSBpbnRvIHRoZSBkeW5hbWljV3JpdGVyXG4gICAgICAgICAgICBjb2Rlci5lbmNvZGUoZHluYW1pY1dyaXRlciwgdmFsdWUpO1xuICAgICAgICAgICAgLy8gUHJlcGFyZSB0byBwb3B1bGF0ZSB0aGUgY29ycmVjdCBvZmZzZXQgb25jZSB3ZSBhcmUgZG9uZVxuICAgICAgICAgICAgbGV0IHVwZGF0ZUZ1bmMgPSBzdGF0aWNXcml0ZXIud3JpdGVVcGRhdGFibGVWYWx1ZSgpO1xuICAgICAgICAgICAgdXBkYXRlRnVuY3MucHVzaCgoYmFzZU9mZnNldCkgPT4ge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUZ1bmMoYmFzZU9mZnNldCArIGR5bmFtaWNPZmZzZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2Rlci5lbmNvZGUoc3RhdGljV3JpdGVyLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBCYWNrZmlsbCBhbGwgdGhlIGR5bmFtaWMgb2Zmc2V0cywgbm93IHRoYXQgd2Uga25vdyB0aGUgc3RhdGljIGxlbmd0aFxuICAgIHVwZGF0ZUZ1bmNzLmZvckVhY2goKGZ1bmMpID0+IHsgZnVuYyhzdGF0aWNXcml0ZXIubGVuZ3RoKTsgfSk7XG4gICAgbGV0IGxlbmd0aCA9IHdyaXRlci5hcHBlbmRXcml0ZXIoc3RhdGljV3JpdGVyKTtcbiAgICBsZW5ndGggKz0gd3JpdGVyLmFwcGVuZFdyaXRlcihkeW5hbWljV3JpdGVyKTtcbiAgICByZXR1cm4gbGVuZ3RoO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVucGFjayhyZWFkZXIsIGNvZGVycykge1xuICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICAvLyBBIHJlYWRlciBhbmNob3JlZCB0byB0aGlzIGJhc2VcbiAgICBsZXQgYmFzZVJlYWRlciA9IHJlYWRlci5zdWJSZWFkZXIoMCk7XG4gICAgY29kZXJzLmZvckVhY2goKGNvZGVyKSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gcmVhZGVyLnJlYWRWYWx1ZSgpO1xuICAgICAgICAgICAgbGV0IG9mZnNldFJlYWRlciA9IGJhc2VSZWFkZXIuc3ViUmVhZGVyKG9mZnNldC50b051bWJlcigpKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjb2Rlci5kZWNvZGUob2Zmc2V0UmVhZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIENhbm5vdCByZWNvdmVyIGZyb20gdGhpc1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHZhbHVlLmJhc2VUeXBlID0gY29kZXIubmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS5uYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlLnR5cGUgPSBjb2Rlci50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvZGVyLmRlY29kZShyZWFkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2Fubm90IHJlY292ZXIgZnJvbSB0aGlzXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IExvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgdmFsdWUuYmFzZVR5cGUgPSBjb2Rlci5uYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlLm5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUudHlwZSA9IGNvZGVyLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gV2Ugb25seSBvdXRwdXQgbmFtZWQgcHJvcGVydGllcyBmb3IgdW5pcXVlbHkgbmFtZWQgY29kZXJzXG4gICAgY29uc3QgdW5pcXVlTmFtZXMgPSBjb2RlcnMucmVkdWNlKChhY2N1bSwgY29kZXIpID0+IHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGlmICghYWNjdW1bbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2N1bVtuYW1lXSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2N1bTtcbiAgICB9LCB7fSk7XG4gICAgLy8gQWRkIGFueSBuYW1lZCBwYXJhbWV0ZXJzIChpLmUuIHR1cGxlcylcbiAgICBjb2RlcnMuZm9yRWFjaCgoY29kZXIsIGluZGV4KSA9PiB7XG4gICAgICAgIGxldCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICBpZiAoIW5hbWUgfHwgdW5pcXVlTmFtZXNbbmFtZV0gIT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSA9PT0gXCJsZW5ndGhcIikge1xuICAgICAgICAgICAgbmFtZSA9IFwiX2xlbmd0aFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWx1ZXMsIG5hbWUsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogKCkgPT4geyB0aHJvdyB2YWx1ZTsgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlcywgaSwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiB7IHRocm93IHZhbHVlOyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh2YWx1ZXMpO1xufVxuZXhwb3J0IGNsYXNzIEFycmF5Q29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IoY29kZXIsIGxlbmd0aCwgbG9jYWxOYW1lKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSAoY29kZXIudHlwZSArIFwiW1wiICsgKGxlbmd0aCA+PSAwID8gbGVuZ3RoIDogXCJcIikgKyBcIl1cIik7XG4gICAgICAgIGNvbnN0IGR5bmFtaWMgPSAobGVuZ3RoID09PSAtMSB8fCBjb2Rlci5keW5hbWljKTtcbiAgICAgICAgc3VwZXIoXCJhcnJheVwiLCB0eXBlLCBsb2NhbE5hbWUsIGR5bmFtaWMpO1xuICAgICAgICB0aGlzLmNvZGVyID0gY29kZXI7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIC8vIFZlcmlmaWVzIHRoZSBjaGlsZCBjb2RlciBpcyB2YWxpZCAoZXZlbiBpZiB0aGUgYXJyYXkgaXMgZHluYW1pYyBvciAwLWxlbmd0aClcbiAgICAgICAgY29uc3QgZGVmYXVsdENoaWxkID0gdGhpcy5jb2Rlci5kZWZhdWx0VmFsdWUoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGVmYXVsdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwiZXhwZWN0ZWQgYXJyYXkgdmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAoY291bnQgPT09IC0xKSB7XG4gICAgICAgICAgICBjb3VudCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmNoZWNrQXJndW1lbnRDb3VudCh2YWx1ZS5sZW5ndGgsIGNvdW50LCBcImNvZGVyIGFycmF5XCIgKyAodGhpcy5sb2NhbE5hbWUgPyAoXCIgXCIgKyB0aGlzLmxvY2FsTmFtZSkgOiBcIlwiKSk7XG4gICAgICAgIGxldCBjb2RlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29kZXJzLnB1c2godGhpcy5jb2Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhY2sod3JpdGVyLCBjb2RlcnMsIHZhbHVlKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICBsZXQgY291bnQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvdW50ID09PSAtMSkge1xuICAgICAgICAgICAgY291bnQgPSByZWFkZXIucmVhZFZhbHVlKCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlcmUgaXMgKnJvdWdobHkqIGVub3VnaCBkYXRhIHRvIGVuc3VyZVxuICAgICAgICAgICAgLy8gc3RyYXkgcmFuZG9tIGRhdGEgaXMgbm90IGJlaW5nIHJlYWQgYXMgYSBsZW5ndGguIEVhY2hcbiAgICAgICAgICAgIC8vIHNsb3QgcmVxdWlyZXMgYXQgbGVhc3QgMzIgYnl0ZXMgZm9yIHRoZWlyIHZhbHVlIChvciAzMlxuICAgICAgICAgICAgLy8gYnl0ZXMgYXMgYSBsaW5rIHRvIHRoZSBkYXRhKS4gVGhpcyBjb3VsZCB1c2UgYSBtdWNoXG4gICAgICAgICAgICAvLyB0aWdodGVyIGJvdW5kLCBidXQgd2UgYXJlIGVycm9yaW5nIG9uIHRoZSBzaWRlIG9mIHNhZmV0eS5cbiAgICAgICAgICAgIGlmIChjb3VudCAqIDMyID4gcmVhZGVyLl9kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiaW5zdWZmaWNpZW50IGRhdGEgbGVuZ3RoXCIsIExvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiByZWFkZXIuX2RhdGEubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogY291bnRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY29kZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29kZXJzLnB1c2gobmV3IEFub255bW91c0NvZGVyKHRoaXMuY29kZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVhZGVyLmNvZXJjZSh0aGlzLm5hbWUsIHVucGFjayhyZWFkZXIsIGNvZGVycykpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFycmF5LmpzLm1hcCJdLCJuYW1lcyI6WyJMb2dnZXIiLCJ2ZXJzaW9uIiwibG9nZ2VyIiwiQ29kZXIiLCJXcml0ZXIiLCJBbm9ueW1vdXNDb2RlciIsInBhY2siLCJ3cml0ZXIiLCJjb2RlcnMiLCJ2YWx1ZXMiLCJhcnJheVZhbHVlcyIsIkFycmF5IiwiaXNBcnJheSIsInVuaXF1ZSIsIm1hcCIsImNvZGVyIiwibmFtZSIsImxvY2FsTmFtZSIsInRocm93RXJyb3IiLCJlcnJvcnMiLCJJTlZBTElEX0FSR1VNRU5UIiwiYXJndW1lbnQiLCJ2YWx1ZSIsInRocm93QXJndW1lbnRFcnJvciIsImxlbmd0aCIsInN0YXRpY1dyaXRlciIsIndvcmRTaXplIiwiZHluYW1pY1dyaXRlciIsInVwZGF0ZUZ1bmNzIiwiZm9yRWFjaCIsImluZGV4IiwiZHluYW1pYyIsImR5bmFtaWNPZmZzZXQiLCJlbmNvZGUiLCJ1cGRhdGVGdW5jIiwid3JpdGVVcGRhdGFibGVWYWx1ZSIsInB1c2giLCJiYXNlT2Zmc2V0IiwiZnVuYyIsImFwcGVuZFdyaXRlciIsInVucGFjayIsInJlYWRlciIsImJhc2VSZWFkZXIiLCJzdWJSZWFkZXIiLCJvZmZzZXQiLCJyZWFkVmFsdWUiLCJvZmZzZXRSZWFkZXIiLCJ0b051bWJlciIsImRlY29kZSIsImVycm9yIiwiY29kZSIsIkJVRkZFUl9PVkVSUlVOIiwiYmFzZVR5cGUiLCJ0eXBlIiwidW5kZWZpbmVkIiwidW5pcXVlTmFtZXMiLCJyZWR1Y2UiLCJhY2N1bSIsIkVycm9yIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiaSIsImZyZWV6ZSIsIkFycmF5Q29kZXIiLCJjb25zdHJ1Y3RvciIsImRlZmF1bHRWYWx1ZSIsImRlZmF1bHRDaGlsZCIsInJlc3VsdCIsIl90aHJvd0Vycm9yIiwiY291bnQiLCJ3cml0ZVZhbHVlIiwiY2hlY2tBcmd1bWVudENvdW50IiwiX2RhdGEiLCJjb2VyY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/array.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/boolean.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/boolean.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BooleanCoder: () => (/* binding */ BooleanCoder)\n/* harmony export */ });\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n\n\nclass BooleanCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName){\n        super(\"bool\", \"bool\", localName, false);\n    }\n    defaultValue() {\n        return false;\n    }\n    encode(writer, value) {\n        return writer.writeValue(value ? 1 : 0);\n    }\n    decode(reader) {\n        return reader.coerce(this.type, !reader.readValue().isZero());\n    }\n} //# sourceMappingURL=boolean.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvYm9vbGVhbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFhO0FBQzRCO0FBQ2xDLE1BQU1DLHFCQUFxQkQsa0RBQUtBO0lBQ25DRSxZQUFZQyxTQUFTLENBQUU7UUFDbkIsS0FBSyxDQUFDLFFBQVEsUUFBUUEsV0FBVztJQUNyQztJQUNBQyxlQUFlO1FBQ1gsT0FBTztJQUNYO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRUMsS0FBSyxFQUFFO1FBQ2xCLE9BQU9ELE9BQU9FLFVBQVUsQ0FBQ0QsUUFBUSxJQUFJO0lBQ3pDO0lBQ0FFLE9BQU9DLE1BQU0sRUFBRTtRQUNYLE9BQU9BLE9BQU9DLE1BQU0sQ0FBQyxJQUFJLENBQUNDLElBQUksRUFBRSxDQUFDRixPQUFPRyxTQUFTLEdBQUdDLE1BQU07SUFDOUQ7QUFDSixFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NsaW1lLWJldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9ib29sZWFuLmpzP2Y2MjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyXCI7XG5leHBvcnQgY2xhc3MgQm9vbGVhbkNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImJvb2xcIiwgXCJib29sXCIsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlID8gMSA6IDApO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiByZWFkZXIuY29lcmNlKHRoaXMudHlwZSwgIXJlYWRlci5yZWFkVmFsdWUoKS5pc1plcm8oKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9vbGVhbi5qcy5tYXAiXSwibmFtZXMiOlsiQ29kZXIiLCJCb29sZWFuQ29kZXIiLCJjb25zdHJ1Y3RvciIsImxvY2FsTmFtZSIsImRlZmF1bHRWYWx1ZSIsImVuY29kZSIsIndyaXRlciIsInZhbHVlIiwid3JpdGVWYWx1ZSIsImRlY29kZSIsInJlYWRlciIsImNvZXJjZSIsInR5cGUiLCJyZWFkVmFsdWUiLCJpc1plcm8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/boolean.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/bytes.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/bytes.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BytesCoder: () => (/* binding */ BytesCoder),\n/* harmony export */   DynamicBytesCoder: () => (/* binding */ DynamicBytesCoder)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n\n\n\nclass DynamicBytesCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(type, localName){\n        super(type, type, localName, true);\n    }\n    defaultValue() {\n        return \"0x\";\n    }\n    encode(writer, value) {\n        value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n    decode(reader) {\n        return reader.readBytes(reader.readValue().toNumber(), true);\n    }\n}\nclass BytesCoder extends DynamicBytesCoder {\n    constructor(localName){\n        super(\"bytes\", localName);\n    }\n    decode(reader) {\n        return reader.coerce(this.name, (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.hexlify)(super.decode(reader)));\n    }\n} //# sourceMappingURL=bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvYnl0ZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFhO0FBQzRDO0FBQ2hCO0FBQ2xDLE1BQU1HLDBCQUEwQkQsa0RBQUtBO0lBQ3hDRSxZQUFZQyxJQUFJLEVBQUVDLFNBQVMsQ0FBRTtRQUN6QixLQUFLLENBQUNELE1BQU1BLE1BQU1DLFdBQVc7SUFDakM7SUFDQUMsZUFBZTtRQUNYLE9BQU87SUFDWDtJQUNBQyxPQUFPQyxNQUFNLEVBQUVDLEtBQUssRUFBRTtRQUNsQkEsUUFBUVYsOERBQVFBLENBQUNVO1FBQ2pCLElBQUlDLFNBQVNGLE9BQU9HLFVBQVUsQ0FBQ0YsTUFBTUMsTUFBTTtRQUMzQ0EsVUFBVUYsT0FBT0ksVUFBVSxDQUFDSDtRQUM1QixPQUFPQztJQUNYO0lBQ0FHLE9BQU9DLE1BQU0sRUFBRTtRQUNYLE9BQU9BLE9BQU9DLFNBQVMsQ0FBQ0QsT0FBT0UsU0FBUyxHQUFHQyxRQUFRLElBQUk7SUFDM0Q7QUFDSjtBQUNPLE1BQU1DLG1CQUFtQmhCO0lBQzVCQyxZQUFZRSxTQUFTLENBQUU7UUFDbkIsS0FBSyxDQUFDLFNBQVNBO0lBQ25CO0lBQ0FRLE9BQU9DLE1BQU0sRUFBRTtRQUNYLE9BQU9BLE9BQU9LLE1BQU0sQ0FBQyxJQUFJLENBQUNDLElBQUksRUFBRXBCLDZEQUFPQSxDQUFDLEtBQUssQ0FBQ2EsT0FBT0M7SUFDekQ7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NsaW1lLWJldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9ieXRlcy5qcz8zYjE4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGhleGxpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXJcIjtcbmV4cG9ydCBjbGFzcyBEeW5hbWljQnl0ZXNDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIodHlwZSwgdHlwZSwgbG9jYWxOYW1lLCB0cnVlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCIweFwiO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHdyaXRlci53cml0ZVZhbHVlKHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIGxlbmd0aCArPSB3cml0ZXIud3JpdGVCeXRlcyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkQnl0ZXMocmVhZGVyLnJlYWRWYWx1ZSgpLnRvTnVtYmVyKCksIHRydWUpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBCeXRlc0NvZGVyIGV4dGVuZHMgRHluYW1pY0J5dGVzQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImJ5dGVzXCIsIGxvY2FsTmFtZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLCBoZXhsaWZ5KHN1cGVyLmRlY29kZShyZWFkZXIpKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ynl0ZXMuanMubWFwIl0sIm5hbWVzIjpbImFycmF5aWZ5IiwiaGV4bGlmeSIsIkNvZGVyIiwiRHluYW1pY0J5dGVzQ29kZXIiLCJjb25zdHJ1Y3RvciIsInR5cGUiLCJsb2NhbE5hbWUiLCJkZWZhdWx0VmFsdWUiLCJlbmNvZGUiLCJ3cml0ZXIiLCJ2YWx1ZSIsImxlbmd0aCIsIndyaXRlVmFsdWUiLCJ3cml0ZUJ5dGVzIiwiZGVjb2RlIiwicmVhZGVyIiwicmVhZEJ5dGVzIiwicmVhZFZhbHVlIiwidG9OdW1iZXIiLCJCeXRlc0NvZGVyIiwiY29lcmNlIiwibmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedBytesCoder: () => (/* binding */ FixedBytesCoder)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n\n\n\n// @TODO: Merge this with bytes\nclass FixedBytesCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(size, localName){\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        this.size = size;\n    }\n    defaultValue() {\n        return \"0x0000000000000000000000000000000000000000000000000000000000000000\".substring(0, 2 + this.size * 2);\n    }\n    encode(writer, value) {\n        let data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(value);\n        if (data.length !== this.size) {\n            this._throwError(\"incorrect data length\", value);\n        }\n        return writer.writeBytes(data);\n    }\n    decode(reader) {\n        return reader.coerce(this.name, (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.hexlify)(reader.readBytes(this.size)));\n    }\n} //# sourceMappingURL=fixed-bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvZml4ZWQtYnl0ZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWE7QUFDNEM7QUFDaEI7QUFDekMsK0JBQStCO0FBQ3hCLE1BQU1HLHdCQUF3QkQsa0RBQUtBO0lBQ3RDRSxZQUFZQyxJQUFJLEVBQUVDLFNBQVMsQ0FBRTtRQUN6QixJQUFJQyxPQUFPLFVBQVVDLE9BQU9IO1FBQzVCLEtBQUssQ0FBQ0UsTUFBTUEsTUFBTUQsV0FBVztRQUM3QixJQUFJLENBQUNELElBQUksR0FBR0E7SUFDaEI7SUFDQUksZUFBZTtRQUNYLE9BQU8scUVBQXVFQyxTQUFTLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQ0wsSUFBSSxHQUFHO0lBQy9HO0lBQ0FNLE9BQU9DLE1BQU0sRUFBRUMsS0FBSyxFQUFFO1FBQ2xCLElBQUlDLE9BQU9kLDhEQUFRQSxDQUFDYTtRQUNwQixJQUFJQyxLQUFLQyxNQUFNLEtBQUssSUFBSSxDQUFDVixJQUFJLEVBQUU7WUFDM0IsSUFBSSxDQUFDVyxXQUFXLENBQUMseUJBQXlCSDtRQUM5QztRQUNBLE9BQU9ELE9BQU9LLFVBQVUsQ0FBQ0g7SUFDN0I7SUFDQUksT0FBT0MsTUFBTSxFQUFFO1FBQ1gsT0FBT0EsT0FBT0MsTUFBTSxDQUFDLElBQUksQ0FBQ2IsSUFBSSxFQUFFTiw2REFBT0EsQ0FBQ2tCLE9BQU9FLFNBQVMsQ0FBQyxJQUFJLENBQUNoQixJQUFJO0lBQ3RFO0FBQ0osRUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbGltZS1iZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvZml4ZWQtYnl0ZXMuanM/MjJiNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGFycmF5aWZ5LCBoZXhsaWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyXCI7XG4vLyBAVE9ETzogTWVyZ2UgdGhpcyB3aXRoIGJ5dGVzXG5leHBvcnQgY2xhc3MgRml4ZWRCeXRlc0NvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKHNpemUsIGxvY2FsTmFtZSkge1xuICAgICAgICBsZXQgbmFtZSA9IFwiYnl0ZXNcIiArIFN0cmluZyhzaXplKTtcbiAgICAgICAgc3VwZXIobmFtZSwgbmFtZSwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIChcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiKS5zdWJzdHJpbmcoMCwgMiArIHRoaXMuc2l6ZSAqIDIpO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICBsZXQgZGF0YSA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSB0aGlzLnNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJpbmNvcnJlY3QgZGF0YSBsZW5ndGhcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVCeXRlcyhkYXRhKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gcmVhZGVyLmNvZXJjZSh0aGlzLm5hbWUsIGhleGxpZnkocmVhZGVyLnJlYWRCeXRlcyh0aGlzLnNpemUpKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zml4ZWQtYnl0ZXMuanMubWFwIl0sIm5hbWVzIjpbImFycmF5aWZ5IiwiaGV4bGlmeSIsIkNvZGVyIiwiRml4ZWRCeXRlc0NvZGVyIiwiY29uc3RydWN0b3IiLCJzaXplIiwibG9jYWxOYW1lIiwibmFtZSIsIlN0cmluZyIsImRlZmF1bHRWYWx1ZSIsInN1YnN0cmluZyIsImVuY29kZSIsIndyaXRlciIsInZhbHVlIiwiZGF0YSIsImxlbmd0aCIsIl90aHJvd0Vycm9yIiwid3JpdGVCeXRlcyIsImRlY29kZSIsInJlYWRlciIsImNvZXJjZSIsInJlYWRCeXRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/null.js":
/*!************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/null.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NullCoder: () => (/* binding */ NullCoder)\n/* harmony export */ });\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n\n\nclass NullCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName){\n        super(\"null\", \"\", localName, false);\n    }\n    defaultValue() {\n        return null;\n    }\n    encode(writer, value) {\n        if (value != null) {\n            this._throwError(\"not null\", value);\n        }\n        return writer.writeBytes([]);\n    }\n    decode(reader) {\n        reader.readBytes(0);\n        return reader.coerce(this.name, null);\n    }\n} //# sourceMappingURL=null.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvbnVsbC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFhO0FBQzRCO0FBQ2xDLE1BQU1DLGtCQUFrQkQsa0RBQUtBO0lBQ2hDRSxZQUFZQyxTQUFTLENBQUU7UUFDbkIsS0FBSyxDQUFDLFFBQVEsSUFBSUEsV0FBVztJQUNqQztJQUNBQyxlQUFlO1FBQ1gsT0FBTztJQUNYO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRUMsS0FBSyxFQUFFO1FBQ2xCLElBQUlBLFNBQVMsTUFBTTtZQUNmLElBQUksQ0FBQ0MsV0FBVyxDQUFDLFlBQVlEO1FBQ2pDO1FBQ0EsT0FBT0QsT0FBT0csVUFBVSxDQUFDLEVBQUU7SUFDL0I7SUFDQUMsT0FBT0MsTUFBTSxFQUFFO1FBQ1hBLE9BQU9DLFNBQVMsQ0FBQztRQUNqQixPQUFPRCxPQUFPRSxNQUFNLENBQUMsSUFBSSxDQUFDQyxJQUFJLEVBQUU7SUFDcEM7QUFDSixFQUNBLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NsaW1lLWJldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9udWxsLmpzPzcyODgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyXCI7XG5leHBvcnQgY2xhc3MgTnVsbENvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcIm51bGxcIiwgXCJcIiwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwibm90IG51bGxcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVCeXRlcyhbXSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmVhZGVyLnJlYWRCeXRlcygwKTtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLCBudWxsKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udWxsLmpzLm1hcCJdLCJuYW1lcyI6WyJDb2RlciIsIk51bGxDb2RlciIsImNvbnN0cnVjdG9yIiwibG9jYWxOYW1lIiwiZGVmYXVsdFZhbHVlIiwiZW5jb2RlIiwid3JpdGVyIiwidmFsdWUiLCJfdGhyb3dFcnJvciIsIndyaXRlQnl0ZXMiLCJkZWNvZGUiLCJyZWFkZXIiLCJyZWFkQnl0ZXMiLCJjb2VyY2UiLCJuYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/null.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/number.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/number.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NumberCoder: () => (/* binding */ NumberCoder)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/constants */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib.esm/bignumbers.js\");\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n\n\n\n\nclass NumberCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(size, signed, localName){\n        const name = (signed ? \"int\" : \"uint\") + size * 8;\n        super(name, name, localName, false);\n        this.size = size;\n        this.signed = signed;\n    }\n    defaultValue() {\n        return 0;\n    }\n    encode(writer, value) {\n        let v = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__.BigNumber.from(value);\n        // Check bounds are safe for encoding\n        let maxUintValue = _ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__.MaxUint256.mask(writer.wordSize * 8);\n        if (this.signed) {\n            let bounds = maxUintValue.mask(this.size * 8 - 1);\n            if (v.gt(bounds) || v.lt(bounds.add(_ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__.One).mul(_ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__.NegativeOne))) {\n                this._throwError(\"value out-of-bounds\", value);\n            }\n        } else if (v.lt(_ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__.Zero) || v.gt(maxUintValue.mask(this.size * 8))) {\n            this._throwError(\"value out-of-bounds\", value);\n        }\n        v = v.toTwos(this.size * 8).mask(this.size * 8);\n        if (this.signed) {\n            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);\n        }\n        return writer.writeValue(v);\n    }\n    decode(reader) {\n        let value = reader.readValue().mask(this.size * 8);\n        if (this.signed) {\n            value = value.fromTwos(this.size * 8);\n        }\n        return reader.coerce(this.name, value);\n    }\n} //# sourceMappingURL=number.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvbnVtYmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBYTtBQUN3QztBQUN5QjtBQUNyQztBQUNsQyxNQUFNTSxvQkFBb0JELGtEQUFLQTtJQUNsQ0UsWUFBWUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLFNBQVMsQ0FBRTtRQUNqQyxNQUFNQyxPQUFRLENBQUNGLFNBQVMsUUFBUSxNQUFLLElBQU1ELE9BQU87UUFDbEQsS0FBSyxDQUFDRyxNQUFNQSxNQUFNRCxXQUFXO1FBQzdCLElBQUksQ0FBQ0YsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtJQUNsQjtJQUNBRyxlQUFlO1FBQ1gsT0FBTztJQUNYO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRUMsS0FBSyxFQUFFO1FBQ2xCLElBQUlDLElBQUloQiwrREFBU0EsQ0FBQ2lCLElBQUksQ0FBQ0Y7UUFDdkIscUNBQXFDO1FBQ3JDLElBQUlHLGVBQWVqQixnRUFBVUEsQ0FBQ2tCLElBQUksQ0FBQ0wsT0FBT00sUUFBUSxHQUFHO1FBQ3JELElBQUksSUFBSSxDQUFDWCxNQUFNLEVBQUU7WUFDYixJQUFJWSxTQUFTSCxhQUFhQyxJQUFJLENBQUMsSUFBSSxDQUFDWCxJQUFJLEdBQUcsSUFBSTtZQUMvQyxJQUFJUSxFQUFFTSxFQUFFLENBQUNELFdBQVdMLEVBQUVPLEVBQUUsQ0FBQ0YsT0FBT0csR0FBRyxDQUFDckIseURBQUdBLEVBQUVzQixHQUFHLENBQUN2QixpRUFBV0EsSUFBSTtnQkFDeEQsSUFBSSxDQUFDd0IsV0FBVyxDQUFDLHVCQUF1Qlg7WUFDNUM7UUFDSixPQUNLLElBQUlDLEVBQUVPLEVBQUUsQ0FBQ25CLDBEQUFJQSxLQUFLWSxFQUFFTSxFQUFFLENBQUNKLGFBQWFDLElBQUksQ0FBQyxJQUFJLENBQUNYLElBQUksR0FBRyxLQUFLO1lBQzNELElBQUksQ0FBQ2tCLFdBQVcsQ0FBQyx1QkFBdUJYO1FBQzVDO1FBQ0FDLElBQUlBLEVBQUVXLE1BQU0sQ0FBQyxJQUFJLENBQUNuQixJQUFJLEdBQUcsR0FBR1csSUFBSSxDQUFDLElBQUksQ0FBQ1gsSUFBSSxHQUFHO1FBQzdDLElBQUksSUFBSSxDQUFDQyxNQUFNLEVBQUU7WUFDYk8sSUFBSUEsRUFBRVksUUFBUSxDQUFDLElBQUksQ0FBQ3BCLElBQUksR0FBRyxHQUFHbUIsTUFBTSxDQUFDLElBQUliLE9BQU9NLFFBQVE7UUFDNUQ7UUFDQSxPQUFPTixPQUFPZSxVQUFVLENBQUNiO0lBQzdCO0lBQ0FjLE9BQU9DLE1BQU0sRUFBRTtRQUNYLElBQUloQixRQUFRZ0IsT0FBT0MsU0FBUyxHQUFHYixJQUFJLENBQUMsSUFBSSxDQUFDWCxJQUFJLEdBQUc7UUFDaEQsSUFBSSxJQUFJLENBQUNDLE1BQU0sRUFBRTtZQUNiTSxRQUFRQSxNQUFNYSxRQUFRLENBQUMsSUFBSSxDQUFDcEIsSUFBSSxHQUFHO1FBQ3ZDO1FBQ0EsT0FBT3VCLE9BQU9FLE1BQU0sQ0FBQyxJQUFJLENBQUN0QixJQUFJLEVBQUVJO0lBQ3BDO0FBQ0osRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbGltZS1iZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvbnVtYmVyLmpzP2ZkZjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBNYXhVaW50MjU2LCBOZWdhdGl2ZU9uZSwgT25lLCBaZXJvIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2RlclwiO1xuZXhwb3J0IGNsYXNzIE51bWJlckNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKHNpemUsIHNpZ25lZCwgbG9jYWxOYW1lKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSAoKHNpZ25lZCA/IFwiaW50XCIgOiBcInVpbnRcIikgKyAoc2l6ZSAqIDgpKTtcbiAgICAgICAgc3VwZXIobmFtZSwgbmFtZSwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMuc2lnbmVkID0gc2lnbmVkO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICBsZXQgdiA9IEJpZ051bWJlci5mcm9tKHZhbHVlKTtcbiAgICAgICAgLy8gQ2hlY2sgYm91bmRzIGFyZSBzYWZlIGZvciBlbmNvZGluZ1xuICAgICAgICBsZXQgbWF4VWludFZhbHVlID0gTWF4VWludDI1Ni5tYXNrKHdyaXRlci53b3JkU2l6ZSAqIDgpO1xuICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgIGxldCBib3VuZHMgPSBtYXhVaW50VmFsdWUubWFzayh0aGlzLnNpemUgKiA4IC0gMSk7XG4gICAgICAgICAgICBpZiAodi5ndChib3VuZHMpIHx8IHYubHQoYm91bmRzLmFkZChPbmUpLm11bChOZWdhdGl2ZU9uZSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcInZhbHVlIG91dC1vZi1ib3VuZHNcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHYubHQoWmVybykgfHwgdi5ndChtYXhVaW50VmFsdWUubWFzayh0aGlzLnNpemUgKiA4KSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJ2YWx1ZSBvdXQtb2YtYm91bmRzXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2ID0gdi50b1R3b3ModGhpcy5zaXplICogOCkubWFzayh0aGlzLnNpemUgKiA4KTtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICB2ID0gdi5mcm9tVHdvcyh0aGlzLnNpemUgKiA4KS50b1R3b3MoOCAqIHdyaXRlci53b3JkU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHYpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHJlYWRlci5yZWFkVmFsdWUoKS5tYXNrKHRoaXMuc2l6ZSAqIDgpO1xuICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuZnJvbVR3b3ModGhpcy5zaXplICogOCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLCB2YWx1ZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVtYmVyLmpzLm1hcCJdLCJuYW1lcyI6WyJCaWdOdW1iZXIiLCJNYXhVaW50MjU2IiwiTmVnYXRpdmVPbmUiLCJPbmUiLCJaZXJvIiwiQ29kZXIiLCJOdW1iZXJDb2RlciIsImNvbnN0cnVjdG9yIiwic2l6ZSIsInNpZ25lZCIsImxvY2FsTmFtZSIsIm5hbWUiLCJkZWZhdWx0VmFsdWUiLCJlbmNvZGUiLCJ3cml0ZXIiLCJ2YWx1ZSIsInYiLCJmcm9tIiwibWF4VWludFZhbHVlIiwibWFzayIsIndvcmRTaXplIiwiYm91bmRzIiwiZ3QiLCJsdCIsImFkZCIsIm11bCIsIl90aHJvd0Vycm9yIiwidG9Ud29zIiwiZnJvbVR3b3MiLCJ3cml0ZVZhbHVlIiwiZGVjb2RlIiwicmVhZGVyIiwicmVhZFZhbHVlIiwiY29lcmNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/number.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/string.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/string.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StringCoder: () => (/* binding */ StringCoder)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/bytes.js\");\n\n\n\nclass StringCoder extends _bytes__WEBPACK_IMPORTED_MODULE_0__.DynamicBytesCoder {\n    constructor(localName){\n        super(\"string\", localName);\n    }\n    defaultValue() {\n        return \"\";\n    }\n    encode(writer, value) {\n        return super.encode(writer, (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(value));\n    }\n    decode(reader) {\n        return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__.toUtf8String)(super.decode(reader));\n    }\n} //# sourceMappingURL=string.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvc3RyaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFhO0FBQ3NEO0FBQ3ZCO0FBQ3JDLE1BQU1HLG9CQUFvQkQscURBQWlCQTtJQUM5Q0UsWUFBWUMsU0FBUyxDQUFFO1FBQ25CLEtBQUssQ0FBQyxVQUFVQTtJQUNwQjtJQUNBQyxlQUFlO1FBQ1gsT0FBTztJQUNYO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRUMsS0FBSyxFQUFFO1FBQ2xCLE9BQU8sS0FBSyxDQUFDRixPQUFPQyxRQUFRUixtRUFBV0EsQ0FBQ1M7SUFDNUM7SUFDQUMsT0FBT0MsTUFBTSxFQUFFO1FBQ1gsT0FBT1Ysb0VBQVlBLENBQUMsS0FBSyxDQUFDUyxPQUFPQztJQUNyQztBQUNKLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2xpbWUtYmV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vY29kZXJzL3N0cmluZy5qcz9kNjNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgdG9VdGY4Qnl0ZXMsIHRvVXRmOFN0cmluZyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9zdHJpbmdzXCI7XG5pbXBvcnQgeyBEeW5hbWljQnl0ZXNDb2RlciB9IGZyb20gXCIuL2J5dGVzXCI7XG5leHBvcnQgY2xhc3MgU3RyaW5nQ29kZXIgZXh0ZW5kcyBEeW5hbWljQnl0ZXNDb2RlciB7XG4gICAgY29uc3RydWN0b3IobG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKFwic3RyaW5nXCIsIGxvY2FsTmFtZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5lbmNvZGUod3JpdGVyLCB0b1V0ZjhCeXRlcyh2YWx1ZSkpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiB0b1V0ZjhTdHJpbmcoc3VwZXIuZGVjb2RlKHJlYWRlcikpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZy5qcy5tYXAiXSwibmFtZXMiOlsidG9VdGY4Qnl0ZXMiLCJ0b1V0ZjhTdHJpbmciLCJEeW5hbWljQnl0ZXNDb2RlciIsIlN0cmluZ0NvZGVyIiwiY29uc3RydWN0b3IiLCJsb2NhbE5hbWUiLCJkZWZhdWx0VmFsdWUiLCJlbmNvZGUiLCJ3cml0ZXIiLCJ2YWx1ZSIsImRlY29kZSIsInJlYWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/tuple.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/tuple.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TupleCoder: () => (/* binding */ TupleCoder)\n/* harmony export */ });\n/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/array.js\");\n\n\n\nclass TupleCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(coders, localName){\n        let dynamic = false;\n        const types = [];\n        coders.forEach((coder)=>{\n            if (coder.dynamic) {\n                dynamic = true;\n            }\n            types.push(coder.type);\n        });\n        const type = \"tuple(\" + types.join(\",\") + \")\";\n        super(\"tuple\", type, localName, dynamic);\n        this.coders = coders;\n    }\n    defaultValue() {\n        const values = [];\n        this.coders.forEach((coder)=>{\n            values.push(coder.defaultValue());\n        });\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder)=>{\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) {\n                    accum[name] = 0;\n                }\n                accum[name]++;\n            }\n            return accum;\n        }, {});\n        // Add named values\n        this.coders.forEach((coder, index)=>{\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) {\n                return;\n            }\n            if (name === \"length\") {\n                name = \"_length\";\n            }\n            if (values[name] != null) {\n                return;\n            }\n            values[name] = values[index];\n        });\n        return Object.freeze(values);\n    }\n    encode(writer, value) {\n        return (0,_array__WEBPACK_IMPORTED_MODULE_1__.pack)(writer, this.coders, value);\n    }\n    decode(reader) {\n        return reader.coerce(this.name, (0,_array__WEBPACK_IMPORTED_MODULE_1__.unpack)(reader, this.coders));\n    }\n} //# sourceMappingURL=tuple.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvdHVwbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWE7QUFDNEI7QUFDRjtBQUNoQyxNQUFNRyxtQkFBbUJILGtEQUFLQTtJQUNqQ0ksWUFBWUMsTUFBTSxFQUFFQyxTQUFTLENBQUU7UUFDM0IsSUFBSUMsVUFBVTtRQUNkLE1BQU1DLFFBQVEsRUFBRTtRQUNoQkgsT0FBT0ksT0FBTyxDQUFDLENBQUNDO1lBQ1osSUFBSUEsTUFBTUgsT0FBTyxFQUFFO2dCQUNmQSxVQUFVO1lBQ2Q7WUFDQUMsTUFBTUcsSUFBSSxDQUFDRCxNQUFNRSxJQUFJO1FBQ3pCO1FBQ0EsTUFBTUEsT0FBUSxXQUFXSixNQUFNSyxJQUFJLENBQUMsT0FBTztRQUMzQyxLQUFLLENBQUMsU0FBU0QsTUFBTU4sV0FBV0M7UUFDaEMsSUFBSSxDQUFDRixNQUFNLEdBQUdBO0lBQ2xCO0lBQ0FTLGVBQWU7UUFDWCxNQUFNQyxTQUFTLEVBQUU7UUFDakIsSUFBSSxDQUFDVixNQUFNLENBQUNJLE9BQU8sQ0FBQyxDQUFDQztZQUNqQkssT0FBT0osSUFBSSxDQUFDRCxNQUFNSSxZQUFZO1FBQ2xDO1FBQ0EsNERBQTREO1FBQzVELE1BQU1FLGNBQWMsSUFBSSxDQUFDWCxNQUFNLENBQUNZLE1BQU0sQ0FBQyxDQUFDQyxPQUFPUjtZQUMzQyxNQUFNUyxPQUFPVCxNQUFNSixTQUFTO1lBQzVCLElBQUlhLE1BQU07Z0JBQ04sSUFBSSxDQUFDRCxLQUFLLENBQUNDLEtBQUssRUFBRTtvQkFDZEQsS0FBSyxDQUFDQyxLQUFLLEdBQUc7Z0JBQ2xCO2dCQUNBRCxLQUFLLENBQUNDLEtBQUs7WUFDZjtZQUNBLE9BQU9EO1FBQ1gsR0FBRyxDQUFDO1FBQ0osbUJBQW1CO1FBQ25CLElBQUksQ0FBQ2IsTUFBTSxDQUFDSSxPQUFPLENBQUMsQ0FBQ0MsT0FBT1U7WUFDeEIsSUFBSUQsT0FBT1QsTUFBTUosU0FBUztZQUMxQixJQUFJLENBQUNhLFFBQVFILFdBQVcsQ0FBQ0csS0FBSyxLQUFLLEdBQUc7Z0JBQ2xDO1lBQ0o7WUFDQSxJQUFJQSxTQUFTLFVBQVU7Z0JBQ25CQSxPQUFPO1lBQ1g7WUFDQSxJQUFJSixNQUFNLENBQUNJLEtBQUssSUFBSSxNQUFNO2dCQUN0QjtZQUNKO1lBQ0FKLE1BQU0sQ0FBQ0ksS0FBSyxHQUFHSixNQUFNLENBQUNLLE1BQU07UUFDaEM7UUFDQSxPQUFPQyxPQUFPQyxNQUFNLENBQUNQO0lBQ3pCO0lBQ0FRLE9BQU9DLE1BQU0sRUFBRUMsS0FBSyxFQUFFO1FBQ2xCLE9BQU94Qiw0Q0FBSUEsQ0FBQ3VCLFFBQVEsSUFBSSxDQUFDbkIsTUFBTSxFQUFFb0I7SUFDckM7SUFDQUMsT0FBT0MsTUFBTSxFQUFFO1FBQ1gsT0FBT0EsT0FBT0MsTUFBTSxDQUFDLElBQUksQ0FBQ1QsSUFBSSxFQUFFakIsOENBQU1BLENBQUN5QixRQUFRLElBQUksQ0FBQ3RCLE1BQU07SUFDOUQ7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NsaW1lLWJldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy90dXBsZS5qcz80YmQ1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2RlclwiO1xuaW1wb3J0IHsgcGFjaywgdW5wYWNrIH0gZnJvbSBcIi4vYXJyYXlcIjtcbmV4cG9ydCBjbGFzcyBUdXBsZUNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvZGVycywgbG9jYWxOYW1lKSB7XG4gICAgICAgIGxldCBkeW5hbWljID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gW107XG4gICAgICAgIGNvZGVycy5mb3JFYWNoKChjb2RlcikgPT4ge1xuICAgICAgICAgICAgaWYgKGNvZGVyLmR5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGVzLnB1c2goY29kZXIudHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0eXBlID0gKFwidHVwbGUoXCIgKyB0eXBlcy5qb2luKFwiLFwiKSArIFwiKVwiKTtcbiAgICAgICAgc3VwZXIoXCJ0dXBsZVwiLCB0eXBlLCBsb2NhbE5hbWUsIGR5bmFtaWMpO1xuICAgICAgICB0aGlzLmNvZGVycyA9IGNvZGVycztcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jb2RlcnMuZm9yRWFjaCgoY29kZXIpID0+IHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKGNvZGVyLmRlZmF1bHRWYWx1ZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdlIG9ubHkgb3V0cHV0IG5hbWVkIHByb3BlcnRpZXMgZm9yIHVuaXF1ZWx5IG5hbWVkIGNvZGVyc1xuICAgICAgICBjb25zdCB1bmlxdWVOYW1lcyA9IHRoaXMuY29kZXJzLnJlZHVjZSgoYWNjdW0sIGNvZGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFjY3VtW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICAvLyBBZGQgbmFtZWQgdmFsdWVzXG4gICAgICAgIHRoaXMuY29kZXJzLmZvckVhY2goKGNvZGVyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICBpZiAoIW5hbWUgfHwgdW5pcXVlTmFtZXNbbmFtZV0gIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJsZW5ndGhcIikge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBcIl9sZW5ndGhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlc1tuYW1lXSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh2YWx1ZXMpO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcGFjayh3cml0ZXIsIHRoaXMuY29kZXJzLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLCB1bnBhY2socmVhZGVyLCB0aGlzLmNvZGVycykpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR1cGxlLmpzLm1hcCJdLCJuYW1lcyI6WyJDb2RlciIsInBhY2siLCJ1bnBhY2siLCJUdXBsZUNvZGVyIiwiY29uc3RydWN0b3IiLCJjb2RlcnMiLCJsb2NhbE5hbWUiLCJkeW5hbWljIiwidHlwZXMiLCJmb3JFYWNoIiwiY29kZXIiLCJwdXNoIiwidHlwZSIsImpvaW4iLCJkZWZhdWx0VmFsdWUiLCJ2YWx1ZXMiLCJ1bmlxdWVOYW1lcyIsInJlZHVjZSIsImFjY3VtIiwibmFtZSIsImluZGV4IiwiT2JqZWN0IiwiZnJlZXplIiwiZW5jb2RlIiwid3JpdGVyIiwidmFsdWUiLCJkZWNvZGUiLCJyZWFkZXIiLCJjb2VyY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/tuple.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/fragments.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/fragments.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConstructorFragment: () => (/* binding */ ConstructorFragment),\n/* harmony export */   ErrorFragment: () => (/* binding */ ErrorFragment),\n/* harmony export */   EventFragment: () => (/* binding */ EventFragment),\n/* harmony export */   FormatTypes: () => (/* binding */ FormatTypes),\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   FunctionFragment: () => (/* binding */ FunctionFragment),\n/* harmony export */   ParamType: () => (/* binding */ ParamType)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/_version.js\");\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n;\nconst _constructorGuard = {};\nlet ModifiersBytes = {\n    calldata: true,\n    memory: true,\n    storage: true\n};\nlet ModifiersNest = {\n    calldata: true,\n    memory: true\n};\nfunction checkModifier(type, name) {\n    if (type === \"bytes\" || type === \"string\") {\n        if (ModifiersBytes[name]) {\n            return true;\n        }\n    } else if (type === \"address\") {\n        if (name === \"payable\") {\n            return true;\n        }\n    } else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n        if (ModifiersNest[name]) {\n            return true;\n        }\n    }\n    if (ModifiersBytes[name] || name === \"payable\") {\n        logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n    }\n    return false;\n}\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\nfunction parseParamType(param, allowIndexed) {\n    let originalParam = param;\n    function throwError(i) {\n        logger.throwArgumentError(`unexpected character at position ${i}`, \"param\", param);\n    }\n    param = param.replace(/\\s/g, \" \");\n    function newNode(parent) {\n        let node = {\n            type: \"\",\n            name: \"\",\n            parent: parent,\n            state: {\n                allowType: true\n            }\n        };\n        if (allowIndexed) {\n            node.indexed = false;\n        }\n        return node;\n    }\n    let parent = {\n        type: \"\",\n        name: \"\",\n        state: {\n            allowType: true\n        }\n    };\n    let node = parent;\n    for(let i = 0; i < param.length; i++){\n        let c = param[i];\n        switch(c){\n            case \"(\":\n                if (node.state.allowType && node.type === \"\") {\n                    node.type = \"tuple\";\n                } else if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [\n                    newNode(node)\n                ];\n                node = node.components[0];\n                break;\n            case \")\":\n                delete node.state;\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) {\n                        throwError(i);\n                    }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n                if (checkModifier(node.type, node.name)) {\n                    node.name = \"\";\n                }\n                node.type = verifyType(node.type);\n                let child = node;\n                node = node.parent;\n                if (!node) {\n                    throwError(i);\n                }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n            case \",\":\n                delete node.state;\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) {\n                        throwError(i);\n                    }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n                if (checkModifier(node.type, node.name)) {\n                    node.name = \"\";\n                }\n                node.type = verifyType(node.type);\n                let sibling = newNode(node.parent);\n                //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n            // Hit a space...\n            case \" \":\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== \"\") {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== \"\") {\n                        if (node.name === \"indexed\") {\n                            if (!allowIndexed) {\n                                throwError(i);\n                            }\n                            if (node.indexed) {\n                                throwError(i);\n                            }\n                            node.indexed = true;\n                            node.name = \"\";\n                        } else if (checkModifier(node.type, node.name)) {\n                            node.name = \"\";\n                        } else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n                break;\n            case \"[\":\n                if (!node.state.allowArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n            case \"]\":\n                if (!node.state.readArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                } else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                } else if (node.state.readArray) {\n                    node.type += c;\n                } else {\n                    throwError(i);\n                }\n        }\n    }\n    if (node.parent) {\n        logger.throwArgumentError(\"unexpected eof\", \"param\", param);\n    }\n    delete parent.state;\n    if (node.name === \"indexed\") {\n        if (!allowIndexed) {\n            throwError(originalParam.length - 7);\n        }\n        if (node.indexed) {\n            throwError(originalParam.length - 7);\n        }\n        node.indexed = true;\n        node.name = \"\";\n    } else if (checkModifier(node.type, node.name)) {\n        node.name = \"\";\n    }\n    parent.type = verifyType(parent.type);\n    return parent;\n}\nfunction populate(object, params) {\n    for(let key in params){\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(object, key, params[key]);\n    }\n}\nconst FormatTypes = Object.freeze({\n    // Bare formatting, as is needed for computing a sighash of an event or function\n    sighash: \"sighash\",\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\n    minimal: \"minimal\",\n    // Human-Readable with nice spacing, including all names\n    full: \"full\",\n    // JSON-format a la Solidity\n    json: \"json\"\n});\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nclass ParamType {\n    constructor(constructorGuard, params){\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use fromString\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new ParamType()\"\n            });\n        }\n        populate(this, params);\n        let match = this.type.match(paramTypeArray);\n        if (match) {\n            populate(this, {\n                arrayLength: parseInt(match[2] || \"-1\"),\n                arrayChildren: ParamType.fromObject({\n                    type: match[1],\n                    components: this.components\n                }),\n                baseType: \"array\"\n            });\n        } else {\n            populate(this, {\n                arrayLength: null,\n                arrayChildren: null,\n                baseType: this.components != null ? \"tuple\" : this.type\n            });\n        }\n        this._isParamType = true;\n        Object.freeze(this);\n    }\n    // Format the parameter fragment\n    //   - sighash: \"(uint256,address)\"\n    //   - minimal: \"tuple(uint256,address) indexed\"\n    //   - full:    \"tuple(uint256 foo, address bar) indexed baz\"\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            let result = {\n                type: this.baseType === \"tuple\" ? \"tuple\" : this.type,\n                name: this.name || undefined\n            };\n            if (typeof this.indexed === \"boolean\") {\n                result.indexed = this.indexed;\n            }\n            if (this.components) {\n                result.components = this.components.map((comp)=>JSON.parse(comp.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n        let result = \"\";\n        // Array\n        if (this.baseType === \"array\") {\n            result += this.arrayChildren.format(format);\n            result += \"[\" + (this.arrayLength < 0 ? \"\" : String(this.arrayLength)) + \"]\";\n        } else {\n            if (this.baseType === \"tuple\") {\n                if (format !== FormatTypes.sighash) {\n                    result += this.type;\n                }\n                result += \"(\" + this.components.map((comp)=>comp.format(format)).join(format === FormatTypes.full ? \", \" : \",\") + \")\";\n            } else {\n                result += this.type;\n            }\n        }\n        if (format !== FormatTypes.sighash) {\n            if (this.indexed === true) {\n                result += \" indexed\";\n            }\n            if (format === FormatTypes.full && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n        return result;\n    }\n    static from(value, allowIndexed) {\n        if (typeof value === \"string\") {\n            return ParamType.fromString(value, allowIndexed);\n        }\n        return ParamType.fromObject(value);\n    }\n    static fromObject(value) {\n        if (ParamType.isParamType(value)) {\n            return value;\n        }\n        return new ParamType(_constructorGuard, {\n            name: value.name || null,\n            type: verifyType(value.type),\n            indexed: value.indexed == null ? null : !!value.indexed,\n            components: value.components ? value.components.map(ParamType.fromObject) : null\n        });\n    }\n    static fromString(value, allowIndexed) {\n        function ParamTypify(node) {\n            return ParamType.fromObject({\n                name: node.name,\n                type: node.type,\n                indexed: node.indexed,\n                components: node.components\n            });\n        }\n        return ParamTypify(parseParamType(value, !!allowIndexed));\n    }\n    static isParamType(value) {\n        return !!(value != null && value._isParamType);\n    }\n}\n;\nfunction parseParams(value, allowIndex) {\n    return splitNesting(value).map((param)=>ParamType.fromString(param, allowIndex));\n}\nclass Fragment {\n    constructor(constructorGuard, params){\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use a static from method\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new Fragment()\"\n            });\n        }\n        populate(this, params);\n        this._isFragment = true;\n        Object.freeze(this);\n    }\n    static from(value) {\n        if (Fragment.isFragment(value)) {\n            return value;\n        }\n        if (typeof value === \"string\") {\n            return Fragment.fromString(value);\n        }\n        return Fragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (Fragment.isFragment(value)) {\n            return value;\n        }\n        switch(value.type){\n            case \"function\":\n                return FunctionFragment.fromObject(value);\n            case \"event\":\n                return EventFragment.fromObject(value);\n            case \"constructor\":\n                return ConstructorFragment.fromObject(value);\n            case \"error\":\n                return ErrorFragment.fromObject(value);\n            case \"fallback\":\n            case \"receive\":\n                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n                return null;\n        }\n        return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n    }\n    static fromString(value) {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        value = value.replace(/\\s/g, \" \");\n        value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n        value = value.trim();\n        if (value.split(\" \")[0] === \"event\") {\n            return EventFragment.fromString(value.substring(5).trim());\n        } else if (value.split(\" \")[0] === \"function\") {\n            return FunctionFragment.fromString(value.substring(8).trim());\n        } else if (value.split(\"(\")[0].trim() === \"constructor\") {\n            return ConstructorFragment.fromString(value.trim());\n        } else if (value.split(\" \")[0] === \"error\") {\n            return ErrorFragment.fromString(value.substring(5).trim());\n        }\n        return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n    }\n    static isFragment(value) {\n        return !!(value && value._isFragment);\n    }\n}\nclass EventFragment extends Fragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((input)=>JSON.parse(input.format(format)))\n            });\n        }\n        let result = \"\";\n        if (format !== FormatTypes.sighash) {\n            result += \"event \";\n        }\n        result += this.name + \"(\" + this.inputs.map((input)=>input.format(format)).join(format === FormatTypes.full ? \", \" : \",\") + \") \";\n        if (format !== FormatTypes.sighash) {\n            if (this.anonymous) {\n                result += \"anonymous \";\n            }\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof value === \"string\") {\n            return EventFragment.fromString(value);\n        }\n        return EventFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (EventFragment.isEventFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"event\") {\n            logger.throwArgumentError(\"invalid event object\", \"value\", value);\n        }\n        const params = {\n            name: verifyIdentifier(value.name),\n            anonymous: value.anonymous,\n            inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n            type: \"event\"\n        };\n        return new EventFragment(_constructorGuard, params);\n    }\n    static fromString(value) {\n        let match = value.match(regexParen);\n        if (!match) {\n            logger.throwArgumentError(\"invalid event string\", \"value\", value);\n        }\n        let anonymous = false;\n        match[3].split(\" \").forEach((modifier)=>{\n            switch(modifier.trim()){\n                case \"anonymous\":\n                    anonymous = true;\n                    break;\n                case \"\":\n                    break;\n                default:\n                    logger.warn(\"unknown modifier: \" + modifier);\n            }\n        });\n        return EventFragment.fromObject({\n            name: match[1].trim(),\n            anonymous: anonymous,\n            inputs: parseParams(match[2], true),\n            type: \"event\"\n        });\n    }\n    static isEventFragment(value) {\n        return value && value._isFragment && value.type === \"event\";\n    }\n}\nfunction parseGas(value, params) {\n    params.gas = null;\n    let comps = value.split(\"@\");\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n        }\n        params.gas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(comps[1]);\n        return comps[0];\n    }\n    return value;\n}\nfunction parseModifiers(value, params) {\n    params.constant = false;\n    params.payable = false;\n    params.stateMutability = \"nonpayable\";\n    value.split(\" \").forEach((modifier)=>{\n        switch(modifier.trim()){\n            case \"constant\":\n                params.constant = true;\n                break;\n            case \"payable\":\n                params.payable = true;\n                params.stateMutability = \"payable\";\n                break;\n            case \"nonpayable\":\n                params.payable = false;\n                params.stateMutability = \"nonpayable\";\n                break;\n            case \"pure\":\n                params.constant = true;\n                params.stateMutability = \"pure\";\n                break;\n            case \"view\":\n                params.constant = true;\n                params.stateMutability = \"view\";\n                break;\n            case \"external\":\n            case \"public\":\n            case \"\":\n                break;\n            default:\n                console.log(\"unknown modifier: \" + modifier);\n        }\n    });\n}\nfunction verifyState(value) {\n    let result = {\n        constant: false,\n        payable: true,\n        stateMutability: \"payable\"\n    };\n    if (value.stateMutability != null) {\n        result.stateMutability = value.stateMutability;\n        // Set (and check things are consistent) the constant property\n        result.constant = result.stateMutability === \"view\" || result.stateMutability === \"pure\";\n        if (value.constant != null) {\n            if (!!value.constant !== result.constant) {\n                logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n        // Set (and check things are consistent) the payable property\n        result.payable = result.stateMutability === \"payable\";\n        if (value.payable != null) {\n            if (!!value.payable !== result.payable) {\n                logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n    } else if (value.payable != null) {\n        result.payable = !!value.payable;\n        // If payable we can assume non-constant; otherwise we can't assume\n        if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n            logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n        }\n        result.constant = !!value.constant;\n        if (result.constant) {\n            result.stateMutability = \"view\";\n        } else {\n            result.stateMutability = result.payable ? \"payable\" : \"nonpayable\";\n        }\n        if (result.payable && result.constant) {\n            logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n        }\n    } else if (value.constant != null) {\n        result.constant = !!value.constant;\n        result.payable = !result.constant;\n        result.stateMutability = result.constant ? \"view\" : \"payable\";\n    } else if (value.type !== \"constructor\") {\n        logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n    return result;\n}\nclass ConstructorFragment extends Fragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n                payable: this.payable,\n                gas: this.gas ? this.gas.toNumber() : undefined,\n                inputs: this.inputs.map((input)=>JSON.parse(input.format(format)))\n            });\n        }\n        if (format === FormatTypes.sighash) {\n            logger.throwError(\"cannot format a constructor for sighash\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"format(sighash)\"\n            });\n        }\n        let result = \"constructor(\" + this.inputs.map((input)=>input.format(format)).join(format === FormatTypes.full ? \", \" : \",\") + \") \";\n        if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n            result += this.stateMutability + \" \";\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof value === \"string\") {\n            return ConstructorFragment.fromString(value);\n        }\n        return ConstructorFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (ConstructorFragment.isConstructorFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n        }\n        let state = verifyState(value);\n        if (state.constant) {\n            logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n        }\n        const params = {\n            name: null,\n            type: value.type,\n            inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: value.gas ? _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(value.gas) : null\n        };\n        return new ConstructorFragment(_constructorGuard, params);\n    }\n    static fromString(value) {\n        let params = {\n            type: \"constructor\"\n        };\n        value = parseGas(value, params);\n        let parens = value.match(regexParen);\n        if (!parens || parens[1].trim() !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n        }\n        params.inputs = parseParams(parens[2].trim(), false);\n        parseModifiers(parens[3].trim(), params);\n        return ConstructorFragment.fromObject(params);\n    }\n    static isConstructorFragment(value) {\n        return value && value._isFragment && value.type === \"constructor\";\n    }\n}\nclass FunctionFragment extends ConstructorFragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n                payable: this.payable,\n                gas: this.gas ? this.gas.toNumber() : undefined,\n                inputs: this.inputs.map((input)=>JSON.parse(input.format(format))),\n                outputs: this.outputs.map((output)=>JSON.parse(output.format(format)))\n            });\n        }\n        let result = \"\";\n        if (format !== FormatTypes.sighash) {\n            result += \"function \";\n        }\n        result += this.name + \"(\" + this.inputs.map((input)=>input.format(format)).join(format === FormatTypes.full ? \", \" : \",\") + \") \";\n        if (format !== FormatTypes.sighash) {\n            if (this.stateMutability) {\n                if (this.stateMutability !== \"nonpayable\") {\n                    result += this.stateMutability + \" \";\n                }\n            } else if (this.constant) {\n                result += \"view \";\n            }\n            if (this.outputs && this.outputs.length) {\n                result += \"returns (\" + this.outputs.map((output)=>output.format(format)).join(\", \") + \") \";\n            }\n            if (this.gas != null) {\n                result += \"@\" + this.gas.toString() + \" \";\n            }\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof value === \"string\") {\n            return FunctionFragment.fromString(value);\n        }\n        return FunctionFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (FunctionFragment.isFunctionFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"function\") {\n            logger.throwArgumentError(\"invalid function object\", \"value\", value);\n        }\n        let state = verifyState(value);\n        const params = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            constant: state.constant,\n            inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n            outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: value.gas ? _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(value.gas) : null\n        };\n        return new FunctionFragment(_constructorGuard, params);\n    }\n    static fromString(value) {\n        let params = {\n            type: \"function\"\n        };\n        value = parseGas(value, params);\n        let comps = value.split(\" returns \");\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid function string\", \"value\", value);\n        }\n        let parens = comps[0].match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n        }\n        params.name = parens[1].trim();\n        if (params.name) {\n            verifyIdentifier(params.name);\n        }\n        params.inputs = parseParams(parens[2], false);\n        parseModifiers(parens[3].trim(), params);\n        // We have outputs\n        if (comps.length > 1) {\n            let returns = comps[1].match(regexParen);\n            if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n                logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n            }\n            params.outputs = parseParams(returns[2], false);\n        } else {\n            params.outputs = [];\n        }\n        return FunctionFragment.fromObject(params);\n    }\n    static isFunctionFragment(value) {\n        return value && value._isFragment && value.type === \"function\";\n    }\n}\n//export class StructFragment extends Fragment {\n//}\nfunction checkForbidden(fragment) {\n    const sig = fragment.format();\n    if (sig === \"Error(string)\" || sig === \"Panic(uint256)\") {\n        logger.throwArgumentError(`cannot specify user defined ${sig} error`, \"fragment\", fragment);\n    }\n    return fragment;\n}\nclass ErrorFragment extends Fragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input)=>JSON.parse(input.format(format)))\n            });\n        }\n        let result = \"\";\n        if (format !== FormatTypes.sighash) {\n            result += \"error \";\n        }\n        result += this.name + \"(\" + this.inputs.map((input)=>input.format(format)).join(format === FormatTypes.full ? \", \" : \",\") + \") \";\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof value === \"string\") {\n            return ErrorFragment.fromString(value);\n        }\n        return ErrorFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (ErrorFragment.isErrorFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"error\") {\n            logger.throwArgumentError(\"invalid error object\", \"value\", value);\n        }\n        const params = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []\n        };\n        return checkForbidden(new ErrorFragment(_constructorGuard, params));\n    }\n    static fromString(value) {\n        let params = {\n            type: \"error\"\n        };\n        let parens = value.match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid error signature\", \"value\", value);\n        }\n        params.name = parens[1].trim();\n        if (params.name) {\n            verifyIdentifier(params.name);\n        }\n        params.inputs = parseParams(parens[2], false);\n        return checkForbidden(ErrorFragment.fromObject(params));\n    }\n    static isErrorFragment(value) {\n        return value && value._isFragment && value.type === \"error\";\n    }\n}\nfunction verifyType(type) {\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = \"uint256\" + type.substring(4);\n    } else if (type.match(/^int($|[^1-9])/)) {\n        type = \"int256\" + type.substring(3);\n    }\n    // @TODO: more verification\n    return type;\n}\n// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234\nconst regexIdentifier = new RegExp(\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\");\nfunction verifyIdentifier(value) {\n    if (!value || !value.match(regexIdentifier)) {\n        logger.throwArgumentError(`invalid identifier \"${value}\"`, \"value\", value);\n    }\n    return value;\n}\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\nfunction splitNesting(value) {\n    value = value.trim();\n    let result = [];\n    let accum = \"\";\n    let depth = 0;\n    for(let offset = 0; offset < value.length; offset++){\n        let c = value[offset];\n        if (c === \",\" && depth === 0) {\n            result.push(accum);\n            accum = \"\";\n        } else {\n            accum += c;\n            if (c === \"(\") {\n                depth++;\n            } else if (c === \")\") {\n                depth--;\n                if (depth === -1) {\n                    logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n                }\n            }\n        }\n    }\n    if (accum) {\n        result.push(accum);\n    }\n    return result;\n} //# sourceMappingURL=fragments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9mcmFnbWVudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBYTtBQUN3QztBQUNNO0FBQ1o7QUFDVjtBQUNyQyxNQUFNSSxTQUFTLElBQUlGLHlEQUFNQSxDQUFDQyw2Q0FBT0E7O0FBRWpDLE1BQU1FLG9CQUFvQixDQUFDO0FBQzNCLElBQUlDLGlCQUFpQjtJQUFFQyxVQUFVO0lBQU1DLFFBQVE7SUFBTUMsU0FBUztBQUFLO0FBQ25FLElBQUlDLGdCQUFnQjtJQUFFSCxVQUFVO0lBQU1DLFFBQVE7QUFBSztBQUNuRCxTQUFTRyxjQUFjQyxJQUFJLEVBQUVDLElBQUk7SUFDN0IsSUFBSUQsU0FBUyxXQUFXQSxTQUFTLFVBQVU7UUFDdkMsSUFBSU4sY0FBYyxDQUFDTyxLQUFLLEVBQUU7WUFDdEIsT0FBTztRQUNYO0lBQ0osT0FDSyxJQUFJRCxTQUFTLFdBQVc7UUFDekIsSUFBSUMsU0FBUyxXQUFXO1lBQ3BCLE9BQU87UUFDWDtJQUNKLE9BQ0ssSUFBSUQsS0FBS0UsT0FBTyxDQUFDLFFBQVEsS0FBS0YsU0FBUyxTQUFTO1FBQ2pELElBQUlGLGFBQWEsQ0FBQ0csS0FBSyxFQUFFO1lBQ3JCLE9BQU87UUFDWDtJQUNKO0lBQ0EsSUFBSVAsY0FBYyxDQUFDTyxLQUFLLElBQUlBLFNBQVMsV0FBVztRQUM1Q1QsT0FBT1csa0JBQWtCLENBQUMsb0JBQW9CLFFBQVFGO0lBQzFEO0lBQ0EsT0FBTztBQUNYO0FBQ0Esb0ZBQW9GO0FBQ3BGLFNBQVNHLGVBQWVDLEtBQUssRUFBRUMsWUFBWTtJQUN2QyxJQUFJQyxnQkFBZ0JGO0lBQ3BCLFNBQVNHLFdBQVdDLENBQUM7UUFDakJqQixPQUFPVyxrQkFBa0IsQ0FBQyxDQUFDLGlDQUFpQyxFQUFFTSxFQUFFLENBQUMsRUFBRSxTQUFTSjtJQUNoRjtJQUNBQSxRQUFRQSxNQUFNSyxPQUFPLENB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S2lGLFNBQVMsQ0FBQztJQUNyQztJQUNBLDJCQUEyQjtJQUMzQixPQUFPakY7QUFDWDtBQUNBLDZIQUE2SDtBQUM3SCxNQUFNaUgsa0JBQWtCLElBQUl6RSxPQUFPO0FBQ25DLFNBQVM4QyxpQkFBaUJyQixLQUFLO0lBQzNCLElBQUksQ0FBQ0EsU0FBUyxDQUFDQSxNQUFNbEIsS0FBSyxDQUFDa0Usa0JBQWtCO1FBQ3pDekgsT0FBT1csa0JBQWtCLENBQUMsQ0FBQyxvQkFBb0IsRUFBRThELE1BQU0sQ0FBQyxDQUFDLEVBQUUsU0FBU0E7SUFDeEU7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsTUFBTXNCLGFBQWEsSUFBSS9DLE9BQU87QUFDOUIsU0FBUytCLGFBQWFOLEtBQUs7SUFDdkJBLFFBQVFBLE1BQU1jLElBQUk7SUFDbEIsSUFBSXhCLFNBQVMsRUFBRTtJQUNmLElBQUkyRCxRQUFRO0lBQ1osSUFBSUMsUUFBUTtJQUNaLElBQUssSUFBSUMsU0FBUyxHQUFHQSxTQUFTbkQsTUFBTWhELE1BQU0sRUFBRW1HLFNBQVU7UUFDbEQsSUFBSWxHLElBQUkrQyxLQUFLLENBQUNtRCxPQUFPO1FBQ3JCLElBQUlsRyxNQUFNLE9BQU9pRyxVQUFVLEdBQUc7WUFDMUI1RCxPQUFPN0IsSUFBSSxDQUFDd0Y7WUFDWkEsUUFBUTtRQUNaLE9BQ0s7WUFDREEsU0FBU2hHO1lBQ1QsSUFBSUEsTUFBTSxLQUFLO2dCQUNYaUc7WUFDSixPQUNLLElBQUlqRyxNQUFNLEtBQUs7Z0JBQ2hCaUc7Z0JBQ0EsSUFBSUEsVUFBVSxDQUFDLEdBQUc7b0JBQ2QzSCxPQUFPVyxrQkFBa0IsQ0FBQywwQkFBMEIsU0FBUzhEO2dCQUNqRTtZQUNKO1FBQ0o7SUFDSjtJQUNBLElBQUlpRCxPQUFPO1FBQ1AzRCxPQUFPN0IsSUFBSSxDQUFDd0Y7SUFDaEI7SUFDQSxPQUFPM0Q7QUFDWCxFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NsaW1lLWJldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2ZyYWdtZW50cy5qcz8wMTI1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsgZGVmaW5lUmVhZE9ubHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuO1xuY29uc3QgX2NvbnN0cnVjdG9yR3VhcmQgPSB7fTtcbmxldCBNb2RpZmllcnNCeXRlcyA9IHsgY2FsbGRhdGE6IHRydWUsIG1lbW9yeTogdHJ1ZSwgc3RvcmFnZTogdHJ1ZSB9O1xubGV0IE1vZGlmaWVyc05lc3QgPSB7IGNhbGxkYXRhOiB0cnVlLCBtZW1vcnk6IHRydWUgfTtcbmZ1bmN0aW9uIGNoZWNrTW9kaWZpZXIodHlwZSwgbmFtZSkge1xuICAgIGlmICh0eXBlID09PSBcImJ5dGVzXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoTW9kaWZpZXJzQnl0ZXNbbmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XG4gICAgICAgIGlmIChuYW1lID09PSBcInBheWFibGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZS5pbmRleE9mKFwiW1wiKSA+PSAwIHx8IHR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICBpZiAoTW9kaWZpZXJzTmVzdFtuYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKE1vZGlmaWVyc0J5dGVzW25hbWVdIHx8IG5hbWUgPT09IFwicGF5YWJsZVwiKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG1vZGlmaWVyXCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gQFRPRE86IE1ha2Ugc3VyZSB0aGF0IGNoaWxkcmVuIG9mIGFuIGluZGV4ZWQgdHVwbGUgYXJlIG1hcmtlZCB3aXRoIGEgbnVsbCBpbmRleGVkXG5mdW5jdGlvbiBwYXJzZVBhcmFtVHlwZShwYXJhbSwgYWxsb3dJbmRleGVkKSB7XG4gICAgbGV0IG9yaWdpbmFsUGFyYW0gPSBwYXJhbTtcbiAgICBmdW5jdGlvbiB0aHJvd0Vycm9yKGkpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgdW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgcG9zaXRpb24gJHtpfWAsIFwicGFyYW1cIiwgcGFyYW0pO1xuICAgIH1cbiAgICBwYXJhbSA9IHBhcmFtLnJlcGxhY2UoL1xccy9nLCBcIiBcIik7XG4gICAgZnVuY3Rpb24gbmV3Tm9kZShwYXJlbnQpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB7IHR5cGU6IFwiXCIsIG5hbWU6IFwiXCIsIHBhcmVudDogcGFyZW50LCBzdGF0ZTogeyBhbGxvd1R5cGU6IHRydWUgfSB9O1xuICAgICAgICBpZiAoYWxsb3dJbmRleGVkKSB7XG4gICAgICAgICAgICBub2RlLmluZGV4ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgbGV0IHBhcmVudCA9IHsgdHlwZTogXCJcIiwgbmFtZTogXCJcIiwgc3RhdGU6IHsgYWxsb3dUeXBlOiB0cnVlIH0gfTtcbiAgICBsZXQgbm9kZSA9IHBhcmVudDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjID0gcGFyYW1baV07XG4gICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgY2FzZSBcIihcIjpcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5zdGF0ZS5hbGxvd1R5cGUgJiYgbm9kZS50eXBlID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9IFwidHVwbGVcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIW5vZGUuc3RhdGUuYWxsb3dQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd1R5cGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2RlLnR5cGUgPSB2ZXJpZnlUeXBlKG5vZGUudHlwZSk7XG4gICAgICAgICAgICAgICAgbm9kZS5jb21wb25lbnRzID0gW25ld05vZGUobm9kZSldO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNvbXBvbmVudHNbMF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiKVwiOlxuICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnN0YXRlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5hbWUgPT09IFwiaW5kZXhlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWxsb3dJbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaW5kZXhlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGVja01vZGlmaWVyKG5vZGUudHlwZSwgbm9kZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLnR5cGUgPSB2ZXJpZnlUeXBlKG5vZGUudHlwZSk7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBjaGlsZC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd1BhcmFtcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dOYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93QXJyYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIixcIjpcbiAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5zdGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5uYW1lID09PSBcImluZGV4ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbG93SW5kZXhlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub2RlLmluZGV4ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tNb2RpZmllcihub2RlLnR5cGUsIG5vZGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5uYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS50eXBlID0gdmVyaWZ5VHlwZShub2RlLnR5cGUpO1xuICAgICAgICAgICAgICAgIGxldCBzaWJsaW5nID0gbmV3Tm9kZShub2RlLnBhcmVudCk7XG4gICAgICAgICAgICAgICAgLy97IHR5cGU6IFwiXCIsIG5hbWU6IFwiXCIsIHBhcmVudDogbm9kZS5wYXJlbnQsIHN0YXRlOiB7IGFsbG93VHlwZTogdHJ1ZSB9IH07XG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQuY29tcG9uZW50cy5wdXNoKHNpYmxpbmcpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICBub2RlID0gc2libGluZztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIEhpdCBhIHNwYWNlLi4uXG4gICAgICAgICAgICBjYXNlIFwiIFwiOlxuICAgICAgICAgICAgICAgIC8vIElmIHJlYWRpbmcgdHlwZSwgdGhlIHR5cGUgaXMgZG9uZSBhbmQgbWF5IHJlYWQgYSBwYXJhbSBvciBuYW1lXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuc3RhdGUuYWxsb3dUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9IHZlcmlmeVR5cGUobm9kZS50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnN0YXRlLmFsbG93VHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dOYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dQYXJhbXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHJlYWRpbmcgbmFtZSwgdGhlIG5hbWUgaXMgZG9uZVxuICAgICAgICAgICAgICAgIGlmIChub2RlLnN0YXRlLmFsbG93TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5uYW1lICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5uYW1lID09PSBcImluZGV4ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWxsb3dJbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5pbmRleGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2tNb2RpZmllcihub2RlLnR5cGUsIG5vZGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd05hbWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJbXCI6XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLnN0YXRlLmFsbG93QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS50eXBlICs9IGM7XG4gICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd0FycmF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd05hbWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2RlLnN0YXRlLnJlYWRBcnJheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiXVwiOlxuICAgICAgICAgICAgICAgIGlmICghbm9kZS5zdGF0ZS5yZWFkQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS50eXBlICs9IGM7XG4gICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5yZWFkQXJyYXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93QXJyYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dOYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuc3RhdGUuYWxsb3dUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSArPSBjO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93UGFyYW1zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd0FycmF5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5zdGF0ZS5hbGxvd05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5uYW1lICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnN0YXRlLmFsbG93QXJyYXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUuc3RhdGUucmVhZEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSArPSBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUucGFyZW50KSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmV4cGVjdGVkIGVvZlwiLCBcInBhcmFtXCIsIHBhcmFtKTtcbiAgICB9XG4gICAgZGVsZXRlIHBhcmVudC5zdGF0ZTtcbiAgICBpZiAobm9kZS5uYW1lID09PSBcImluZGV4ZWRcIikge1xuICAgICAgICBpZiAoIWFsbG93SW5kZXhlZCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihvcmlnaW5hbFBhcmFtLmxlbmd0aCAtIDcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmluZGV4ZWQpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Iob3JpZ2luYWxQYXJhbS5sZW5ndGggLSA3KTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLmluZGV4ZWQgPSB0cnVlO1xuICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGVja01vZGlmaWVyKG5vZGUudHlwZSwgbm9kZS5uYW1lKSkge1xuICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuICAgIH1cbiAgICBwYXJlbnQudHlwZSA9IHZlcmlmeVR5cGUocGFyZW50LnR5cGUpO1xuICAgIHJldHVybiBwYXJlbnQ7XG59XG5mdW5jdGlvbiBwb3B1bGF0ZShvYmplY3QsIHBhcmFtcykge1xuICAgIGZvciAobGV0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkob2JqZWN0LCBrZXksIHBhcmFtc1trZXldKTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgRm9ybWF0VHlwZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAvLyBCYXJlIGZvcm1hdHRpbmcsIGFzIGlzIG5lZWRlZCBmb3IgY29tcHV0aW5nIGEgc2lnaGFzaCBvZiBhbiBldmVudCBvciBmdW5jdGlvblxuICAgIHNpZ2hhc2g6IFwic2lnaGFzaFwiLFxuICAgIC8vIEh1bWFuLVJlYWRhYmxlIHdpdGggTWluaW1hbCBzcGFjaW5nIGFuZCB3aXRob3V0IG5hbWVzIChjb21wYWN0IGh1bWFuLXJlYWRhYmxlKVxuICAgIG1pbmltYWw6IFwibWluaW1hbFwiLFxuICAgIC8vIEh1bWFuLVJlYWRhYmxlIHdpdGggbmljZSBzcGFjaW5nLCBpbmNsdWRpbmcgYWxsIG5hbWVzXG4gICAgZnVsbDogXCJmdWxsXCIsXG4gICAgLy8gSlNPTi1mb3JtYXQgYSBsYSBTb2xpZGl0eVxuICAgIGpzb246IFwianNvblwiXG59KTtcbmNvbnN0IHBhcmFtVHlwZUFycmF5ID0gbmV3IFJlZ0V4cCgvXiguKilcXFsoWzAtOV0qKVxcXSQvKTtcbmV4cG9ydCBjbGFzcyBQYXJhbVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnN0cnVjdG9yR3VhcmQsIHBhcmFtcykge1xuICAgICAgICBpZiAoY29uc3RydWN0b3JHdWFyZCAhPT0gX2NvbnN0cnVjdG9yR3VhcmQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidXNlIGZyb21TdHJpbmdcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IFBhcmFtVHlwZSgpXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHBvcHVsYXRlKHRoaXMsIHBhcmFtcyk7XG4gICAgICAgIGxldCBtYXRjaCA9IHRoaXMudHlwZS5tYXRjaChwYXJhbVR5cGVBcnJheSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgcG9wdWxhdGUodGhpcywge1xuICAgICAgICAgICAgICAgIGFycmF5TGVuZ3RoOiBwYXJzZUludChtYXRjaFsyXSB8fCBcIi0xXCIpLFxuICAgICAgICAgICAgICAgIGFycmF5Q2hpbGRyZW46IFBhcmFtVHlwZS5mcm9tT2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogbWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IHRoaXMuY29tcG9uZW50c1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGJhc2VUeXBlOiBcImFycmF5XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9wdWxhdGUodGhpcywge1xuICAgICAgICAgICAgICAgIGFycmF5TGVuZ3RoOiBudWxsLFxuICAgICAgICAgICAgICAgIGFycmF5Q2hpbGRyZW46IG51bGwsXG4gICAgICAgICAgICAgICAgYmFzZVR5cGU6ICgodGhpcy5jb21wb25lbnRzICE9IG51bGwpID8gXCJ0dXBsZVwiIDogdGhpcy50eXBlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNQYXJhbVR5cGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICAvLyBGb3JtYXQgdGhlIHBhcmFtZXRlciBmcmFnbWVudFxuICAgIC8vICAgLSBzaWdoYXNoOiBcIih1aW50MjU2LGFkZHJlc3MpXCJcbiAgICAvLyAgIC0gbWluaW1hbDogXCJ0dXBsZSh1aW50MjU2LGFkZHJlc3MpIGluZGV4ZWRcIlxuICAgIC8vICAgLSBmdWxsOiAgICBcInR1cGxlKHVpbnQyNTYgZm9vLCBhZGRyZXNzIGJhcikgaW5kZXhlZCBiYXpcIlxuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFmb3JtYXQpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IEZvcm1hdFR5cGVzLnNpZ2hhc2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFGb3JtYXRUeXBlc1tmb3JtYXRdKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmb3JtYXQgdHlwZVwiLCBcImZvcm1hdFwiLCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLmpzb24pIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogKCh0aGlzLmJhc2VUeXBlID09PSBcInR1cGxlXCIpID8gXCJ0dXBsZVwiIDogdGhpcy50eXBlKSxcbiAgICAgICAgICAgICAgICBuYW1lOiAodGhpcy5uYW1lIHx8IHVuZGVmaW5lZClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0aGlzLmluZGV4ZWQpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5pbmRleGVkID0gdGhpcy5pbmRleGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50cykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jb21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzLm1hcCgoY29tcCkgPT4gSlNPTi5wYXJzZShjb21wLmZvcm1hdChmb3JtYXQpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgLy8gQXJyYXlcbiAgICAgICAgaWYgKHRoaXMuYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuYXJyYXlDaGlsZHJlbi5mb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIltcIiArICh0aGlzLmFycmF5TGVuZ3RoIDwgMCA/IFwiXCIgOiBTdHJpbmcodGhpcy5hcnJheUxlbmd0aCkpICsgXCJdXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdCAhPT0gRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy50eXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIoXCIgKyB0aGlzLmNvbXBvbmVudHMubWFwKChjb21wKSA9PiBjb21wLmZvcm1hdChmb3JtYXQpKS5qb2luKChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLmZ1bGwpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgIT09IEZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgaW5kZXhlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuZnVsbCAmJiB0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgXCIgKyB0aGlzLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmFsdWUsIGFsbG93SW5kZXhlZCkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJhbVR5cGUuZnJvbVN0cmluZyh2YWx1ZSwgYWxsb3dJbmRleGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGFyYW1UeXBlLmZyb21PYmplY3QodmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU9iamVjdCh2YWx1ZSkge1xuICAgICAgICBpZiAoUGFyYW1UeXBlLmlzUGFyYW1UeXBlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUGFyYW1UeXBlKF9jb25zdHJ1Y3Rvckd1YXJkLCB7XG4gICAgICAgICAgICBuYW1lOiAodmFsdWUubmFtZSB8fCBudWxsKSxcbiAgICAgICAgICAgIHR5cGU6IHZlcmlmeVR5cGUodmFsdWUudHlwZSksXG4gICAgICAgICAgICBpbmRleGVkOiAoKHZhbHVlLmluZGV4ZWQgPT0gbnVsbCkgPyBudWxsIDogISF2YWx1ZS5pbmRleGVkKSxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6ICh2YWx1ZS5jb21wb25lbnRzID8gdmFsdWUuY29tcG9uZW50cy5tYXAoUGFyYW1UeXBlLmZyb21PYmplY3QpIDogbnVsbClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlLCBhbGxvd0luZGV4ZWQpIHtcbiAgICAgICAgZnVuY3Rpb24gUGFyYW1UeXBpZnkobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIFBhcmFtVHlwZS5mcm9tT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBuYW1lOiBub2RlLm5hbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IG5vZGUuaW5kZXhlZCxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBub2RlLmNvbXBvbmVudHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQYXJhbVR5cGlmeShwYXJzZVBhcmFtVHlwZSh2YWx1ZSwgISFhbGxvd0luZGV4ZWQpKTtcbiAgICB9XG4gICAgc3RhdGljIGlzUGFyYW1UeXBlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhISh2YWx1ZSAhPSBudWxsICYmIHZhbHVlLl9pc1BhcmFtVHlwZSk7XG4gICAgfVxufVxuO1xuZnVuY3Rpb24gcGFyc2VQYXJhbXModmFsdWUsIGFsbG93SW5kZXgpIHtcbiAgICByZXR1cm4gc3BsaXROZXN0aW5nKHZhbHVlKS5tYXAoKHBhcmFtKSA9PiBQYXJhbVR5cGUuZnJvbVN0cmluZyhwYXJhbSwgYWxsb3dJbmRleCkpO1xufVxuZXhwb3J0IGNsYXNzIEZyYWdtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvckd1YXJkLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yR3VhcmQgIT09IF9jb25zdHJ1Y3Rvckd1YXJkKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVzZSBhIHN0YXRpYyBmcm9tIG1ldGhvZFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXcgRnJhZ21lbnQoKVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwb3B1bGF0ZSh0aGlzLCBwYXJhbXMpO1xuICAgICAgICB0aGlzLl9pc0ZyYWdtZW50ID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgaWYgKEZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU9iamVjdCh2YWx1ZSkge1xuICAgICAgICBpZiAoRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFwiY29uc3RydWN0b3JcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuICAgICAgICAgICAgY2FzZSBcImZhbGxiYWNrXCI6XG4gICAgICAgICAgICBjYXNlIFwicmVjZWl2ZVwiOlxuICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBTb21ldGhpbmc/IE1heWJlIHJldHVybiBhIEZ1bmN0aW9uRnJhZ21lbnQ/IEEgY3VzdG9tIERlZmF1bHRGdW5jdGlvbkZyYWdtZW50P1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmcmFnbWVudCBvYmplY3RcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgXCJyZXR1cm5zXCIgaXMgc3Vycm91bmRlZCBieSBhIHNwYWNlIGFuZCBhbGwgd2hpdGVzcGFjZSBpcyBleGFjdGx5IG9uZSBzcGFjZVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xccy9nLCBcIiBcIik7XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFwoL2csIFwiIChcIikucmVwbGFjZSgvXFwpL2csIFwiKSBcIikucmVwbGFjZSgvXFxzKy9nLCBcIiBcIik7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgICAgICBpZiAodmFsdWUuc3BsaXQoXCIgXCIpWzBdID09PSBcImV2ZW50XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUuc3Vic3RyaW5nKDUpLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUuc3BsaXQoXCIgXCIpWzBdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUuc3Vic3RyaW5nKDgpLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUuc3BsaXQoXCIoXCIpWzBdLnRyaW0oKSA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUuc3BsaXQoXCIgXCIpWzBdID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUuc3Vic3RyaW5nKDUpLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBmcmFnbWVudFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0ZyYWdtZW50KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRXZlbnRGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghZm9ybWF0KSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBGb3JtYXRUeXBlcy5zaWdoYXNoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghRm9ybWF0VHlwZXNbZm9ybWF0XSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZm9ybWF0IHR5cGVcIiwgXCJmb3JtYXRcIiwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBGb3JtYXRUeXBlcy5qc29uKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgICAgICAgICAgICAgICBhbm9ueW1vdXM6IHRoaXMuYW5vbnltb3VzLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaW5wdXQpID0+IEpTT04ucGFyc2UoaW5wdXQuZm9ybWF0KGZvcm1hdCkpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGlmIChmb3JtYXQgIT09IEZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcImV2ZW50IFwiO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSB0aGlzLm5hbWUgKyBcIihcIiArIHRoaXMuaW5wdXRzLm1hcCgoaW5wdXQpID0+IGlucHV0LmZvcm1hdChmb3JtYXQpKS5qb2luKChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLmZ1bGwpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpIFwiO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBGb3JtYXRUeXBlcy5zaWdoYXNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJhbm9ueW1vdXMgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC50cmltKCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIGlmIChFdmVudEZyYWdtZW50LmlzRXZlbnRGcmFnbWVudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJldmVudFwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBldmVudCBvYmplY3RcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgbmFtZTogdmVyaWZ5SWRlbnRpZmllcih2YWx1ZS5uYW1lKSxcbiAgICAgICAgICAgIGFub255bW91czogdmFsdWUuYW5vbnltb3VzLFxuICAgICAgICAgICAgaW5wdXRzOiAodmFsdWUuaW5wdXRzID8gdmFsdWUuaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbU9iamVjdCkgOiBbXSksXG4gICAgICAgICAgICB0eXBlOiBcImV2ZW50XCJcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudEZyYWdtZW50KF9jb25zdHJ1Y3Rvckd1YXJkLCBwYXJhbXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyh2YWx1ZSkge1xuICAgICAgICBsZXQgbWF0Y2ggPSB2YWx1ZS5tYXRjaChyZWdleFBhcmVuKTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZXZlbnQgc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhbm9ueW1vdXMgPSBmYWxzZTtcbiAgICAgICAgbWF0Y2hbM10uc3BsaXQoXCIgXCIpLmZvckVhY2goKG1vZGlmaWVyKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKG1vZGlmaWVyLnRyaW0oKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJhbm9ueW1vdXNcIjpcbiAgICAgICAgICAgICAgICAgICAgYW5vbnltb3VzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlwiOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcInVua25vd24gbW9kaWZpZXI6IFwiICsgbW9kaWZpZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbU9iamVjdCh7XG4gICAgICAgICAgICBuYW1lOiBtYXRjaFsxXS50cmltKCksXG4gICAgICAgICAgICBhbm9ueW1vdXM6IGFub255bW91cyxcbiAgICAgICAgICAgIGlucHV0czogcGFyc2VQYXJhbXMobWF0Y2hbMl0sIHRydWUpLFxuICAgICAgICAgICAgdHlwZTogXCJldmVudFwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgaXNFdmVudEZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWUuX2lzRnJhZ21lbnQgJiYgdmFsdWUudHlwZSA9PT0gXCJldmVudFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUdhcyh2YWx1ZSwgcGFyYW1zKSB7XG4gICAgcGFyYW1zLmdhcyA9IG51bGw7XG4gICAgbGV0IGNvbXBzID0gdmFsdWUuc3BsaXQoXCJAXCIpO1xuICAgIGlmIChjb21wcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGh1bWFuLXJlYWRhYmxlIEFCSSBzaWduYXR1cmVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb21wc1sxXS5tYXRjaCgvXlswLTldKyQvKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaHVtYW4tcmVhZGFibGUgQUJJIHNpZ25hdHVyZSBnYXNcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLmdhcyA9IEJpZ051bWJlci5mcm9tKGNvbXBzWzFdKTtcbiAgICAgICAgcmV0dXJuIGNvbXBzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyh2YWx1ZSwgcGFyYW1zKSB7XG4gICAgcGFyYW1zLmNvbnN0YW50ID0gZmFsc2U7XG4gICAgcGFyYW1zLnBheWFibGUgPSBmYWxzZTtcbiAgICBwYXJhbXMuc3RhdGVNdXRhYmlsaXR5ID0gXCJub25wYXlhYmxlXCI7XG4gICAgdmFsdWUuc3BsaXQoXCIgXCIpLmZvckVhY2goKG1vZGlmaWVyKSA9PiB7XG4gICAgICAgIHN3aXRjaCAobW9kaWZpZXIudHJpbSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwiY29uc3RhbnRcIjpcbiAgICAgICAgICAgICAgICBwYXJhbXMuY29uc3RhbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInBheWFibGVcIjpcbiAgICAgICAgICAgICAgICBwYXJhbXMucGF5YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnN0YXRlTXV0YWJpbGl0eSA9IFwicGF5YWJsZVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm5vbnBheWFibGVcIjpcbiAgICAgICAgICAgICAgICBwYXJhbXMucGF5YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5zdGF0ZU11dGFiaWxpdHkgPSBcIm5vbnBheWFibGVcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJwdXJlXCI6XG4gICAgICAgICAgICAgICAgcGFyYW1zLmNvbnN0YW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuc3RhdGVNdXRhYmlsaXR5ID0gXCJwdXJlXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidmlld1wiOlxuICAgICAgICAgICAgICAgIHBhcmFtcy5jb25zdGFudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnN0YXRlTXV0YWJpbGl0eSA9IFwidmlld1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImV4dGVybmFsXCI6XG4gICAgICAgICAgICBjYXNlIFwicHVibGljXCI6XG4gICAgICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidW5rbm93biBtb2RpZmllcjogXCIgKyBtb2RpZmllcik7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHZlcmlmeVN0YXRlKHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgY29uc3RhbnQ6IGZhbHNlLFxuICAgICAgICBwYXlhYmxlOiB0cnVlLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwicGF5YWJsZVwiXG4gICAgfTtcbiAgICBpZiAodmFsdWUuc3RhdGVNdXRhYmlsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9IHZhbHVlLnN0YXRlTXV0YWJpbGl0eTtcbiAgICAgICAgLy8gU2V0IChhbmQgY2hlY2sgdGhpbmdzIGFyZSBjb25zaXN0ZW50KSB0aGUgY29uc3RhbnQgcHJvcGVydHlcbiAgICAgICAgcmVzdWx0LmNvbnN0YW50ID0gKHJlc3VsdC5zdGF0ZU11dGFiaWxpdHkgPT09IFwidmlld1wiIHx8IHJlc3VsdC5zdGF0ZU11dGFiaWxpdHkgPT09IFwicHVyZVwiKTtcbiAgICAgICAgaWYgKHZhbHVlLmNvbnN0YW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICgoISF2YWx1ZS5jb25zdGFudCkgIT09IHJlc3VsdC5jb25zdGFudCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjYW5ub3QgaGF2ZSBjb25zdGFudCBmdW5jdGlvbiB3aXRoIG11dGFiaWxpdHkgXCIgKyByZXN1bHQuc3RhdGVNdXRhYmlsaXR5LCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgKGFuZCBjaGVjayB0aGluZ3MgYXJlIGNvbnNpc3RlbnQpIHRoZSBwYXlhYmxlIHByb3BlcnR5XG4gICAgICAgIHJlc3VsdC5wYXlhYmxlID0gKHJlc3VsdC5zdGF0ZU11dGFiaWxpdHkgPT09IFwicGF5YWJsZVwiKTtcbiAgICAgICAgaWYgKHZhbHVlLnBheWFibGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCghIXZhbHVlLnBheWFibGUpICE9PSByZXN1bHQucGF5YWJsZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjYW5ub3QgaGF2ZSBwYXlhYmxlIGZ1bmN0aW9uIHdpdGggbXV0YWJpbGl0eSBcIiArIHJlc3VsdC5zdGF0ZU11dGFiaWxpdHksIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlLnBheWFibGUgIT0gbnVsbCkge1xuICAgICAgICByZXN1bHQucGF5YWJsZSA9ICEhdmFsdWUucGF5YWJsZTtcbiAgICAgICAgLy8gSWYgcGF5YWJsZSB3ZSBjYW4gYXNzdW1lIG5vbi1jb25zdGFudDsgb3RoZXJ3aXNlIHdlIGNhbid0IGFzc3VtZVxuICAgICAgICBpZiAodmFsdWUuY29uc3RhbnQgPT0gbnVsbCAmJiAhcmVzdWx0LnBheWFibGUgJiYgdmFsdWUudHlwZSAhPT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5hYmxlIHRvIGRldGVybWluZSBzdGF0ZU11dGFiaWxpdHlcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LmNvbnN0YW50ID0gISF2YWx1ZS5jb25zdGFudDtcbiAgICAgICAgaWYgKHJlc3VsdC5jb25zdGFudCkge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9IFwidmlld1wiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9IChyZXN1bHQucGF5YWJsZSA/IFwicGF5YWJsZVwiIDogXCJub25wYXlhYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQucGF5YWJsZSAmJiByZXN1bHQuY29uc3RhbnQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjYW5ub3QgaGF2ZSBjb25zdGFudCBwYXlhYmxlIGZ1bmN0aW9uXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlLmNvbnN0YW50ICE9IG51bGwpIHtcbiAgICAgICAgcmVzdWx0LmNvbnN0YW50ID0gISF2YWx1ZS5jb25zdGFudDtcbiAgICAgICAgcmVzdWx0LnBheWFibGUgPSAhcmVzdWx0LmNvbnN0YW50O1xuICAgICAgICByZXN1bHQuc3RhdGVNdXRhYmlsaXR5ID0gKHJlc3VsdC5jb25zdGFudCA/IFwidmlld1wiIDogXCJwYXlhYmxlXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZS50eXBlICE9PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuYWJsZSB0byBkZXRlcm1pbmUgc3RhdGVNdXRhYmlsaXR5XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGNsYXNzIENvbnN0cnVjdG9yRnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoIWZvcm1hdCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gRm9ybWF0VHlwZXMuc2lnaGFzaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUZvcm1hdFR5cGVzW2Zvcm1hdF0pIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZvcm1hdCB0eXBlXCIsIFwiZm9ybWF0XCIsIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuanNvbikge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAoKHRoaXMuc3RhdGVNdXRhYmlsaXR5ICE9PSBcIm5vbnBheWFibGVcIikgPyB0aGlzLnN0YXRlTXV0YWJpbGl0eSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgcGF5YWJsZTogdGhpcy5wYXlhYmxlLFxuICAgICAgICAgICAgICAgIGdhczogKHRoaXMuZ2FzID8gdGhpcy5nYXMudG9OdW1iZXIoKSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGlucHV0KSA9PiBKU09OLnBhcnNlKGlucHV0LmZvcm1hdChmb3JtYXQpKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGZvcm1hdCBhIGNvbnN0cnVjdG9yIGZvciBzaWdoYXNoXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZvcm1hdChzaWdoYXNoKVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJjb25zdHJ1Y3RvcihcIiArIHRoaXMuaW5wdXRzLm1hcCgoaW5wdXQpID0+IGlucHV0LmZvcm1hdChmb3JtYXQpKS5qb2luKChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLmZ1bGwpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpIFwiO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZU11dGFiaWxpdHkgJiYgdGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5zdGF0ZU11dGFiaWxpdHkgKyBcIiBcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnRyaW0oKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21PYmplY3QodmFsdWUpIHtcbiAgICAgICAgaWYgKENvbnN0cnVjdG9yRnJhZ21lbnQuaXNDb25zdHJ1Y3RvckZyYWdtZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGNvbnN0cnVjdG9yIG9iamVjdFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdGUgPSB2ZXJpZnlTdGF0ZSh2YWx1ZSk7XG4gICAgICAgIGlmIChzdGF0ZS5jb25zdGFudCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjb25zdGFudFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICBuYW1lOiBudWxsLFxuICAgICAgICAgICAgdHlwZTogdmFsdWUudHlwZSxcbiAgICAgICAgICAgIGlucHV0czogKHZhbHVlLmlucHV0cyA/IHZhbHVlLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb21PYmplY3QpIDogW10pLFxuICAgICAgICAgICAgcGF5YWJsZTogc3RhdGUucGF5YWJsZSxcbiAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogc3RhdGUuc3RhdGVNdXRhYmlsaXR5LFxuICAgICAgICAgICAgZ2FzOiAodmFsdWUuZ2FzID8gQmlnTnVtYmVyLmZyb20odmFsdWUuZ2FzKSA6IG51bGwpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3JGcmFnbWVudChfY29uc3RydWN0b3JHdWFyZCwgcGFyYW1zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgbGV0IHBhcmFtcyA9IHsgdHlwZTogXCJjb25zdHJ1Y3RvclwiIH07XG4gICAgICAgIHZhbHVlID0gcGFyc2VHYXModmFsdWUsIHBhcmFtcyk7XG4gICAgICAgIGxldCBwYXJlbnMgPSB2YWx1ZS5tYXRjaChyZWdleFBhcmVuKTtcbiAgICAgICAgaWYgKCFwYXJlbnMgfHwgcGFyZW5zWzFdLnRyaW0oKSAhPT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjb25zdHJ1Y3RvciBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLmlucHV0cyA9IHBhcnNlUGFyYW1zKHBhcmVuc1syXS50cmltKCksIGZhbHNlKTtcbiAgICAgICAgcGFyc2VNb2RpZmllcnMocGFyZW5zWzNdLnRyaW0oKSwgcGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbU9iamVjdChwYXJhbXMpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNDb25zdHJ1Y3RvckZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWUuX2lzRnJhZ21lbnQgJiYgdmFsdWUudHlwZSA9PT0gXCJjb25zdHJ1Y3RvclwiKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRnVuY3Rpb25GcmFnbWVudCBleHRlbmRzIENvbnN0cnVjdG9yRnJhZ21lbnQge1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFmb3JtYXQpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IEZvcm1hdFR5cGVzLnNpZ2hhc2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFGb3JtYXRUeXBlc1tmb3JtYXRdKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmb3JtYXQgdHlwZVwiLCBcImZvcm1hdFwiLCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLmpzb24pIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBjb25zdGFudDogdGhpcy5jb25zdGFudCxcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICgodGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSA/IHRoaXMuc3RhdGVNdXRhYmlsaXR5IDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBwYXlhYmxlOiB0aGlzLnBheWFibGUsXG4gICAgICAgICAgICAgICAgZ2FzOiAodGhpcy5nYXMgPyB0aGlzLmdhcy50b051bWJlcigpIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaW5wdXQpID0+IEpTT04ucGFyc2UoaW5wdXQuZm9ybWF0KGZvcm1hdCkpKSxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiB0aGlzLm91dHB1dHMubWFwKChvdXRwdXQpID0+IEpTT04ucGFyc2Uob3V0cHV0LmZvcm1hdChmb3JtYXQpKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiZnVuY3Rpb24gXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IHRoaXMubmFtZSArIFwiKFwiICsgdGhpcy5pbnB1dHMubWFwKChpbnB1dCkgPT4gaW5wdXQuZm9ybWF0KGZvcm1hdCkpLmpvaW4oKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuZnVsbCkgPyBcIiwgXCIgOiBcIixcIikgKyBcIikgXCI7XG4gICAgICAgIGlmIChmb3JtYXQgIT09IEZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlTXV0YWJpbGl0eSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlTXV0YWJpbGl0eSAhPT0gXCJub25wYXlhYmxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICh0aGlzLnN0YXRlTXV0YWJpbGl0eSArIFwiIFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnN0YW50KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwidmlldyBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dHMgJiYgdGhpcy5vdXRwdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcInJldHVybnMgKFwiICsgdGhpcy5vdXRwdXRzLm1hcCgob3V0cHV0KSA9PiBvdXRwdXQuZm9ybWF0KGZvcm1hdCkpLmpvaW4oXCIsIFwiKSArIFwiKSBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiQFwiICsgdGhpcy5nYXMudG9TdHJpbmcoKSArIFwiIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQudHJpbSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU9iamVjdCh2YWx1ZSkge1xuICAgICAgICBpZiAoRnVuY3Rpb25GcmFnbWVudC5pc0Z1bmN0aW9uRnJhZ21lbnQodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZnVuY3Rpb24gb2JqZWN0XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0ZSA9IHZlcmlmeVN0YXRlKHZhbHVlKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgdHlwZTogdmFsdWUudHlwZSxcbiAgICAgICAgICAgIG5hbWU6IHZlcmlmeUlkZW50aWZpZXIodmFsdWUubmFtZSksXG4gICAgICAgICAgICBjb25zdGFudDogc3RhdGUuY29uc3RhbnQsXG4gICAgICAgICAgICBpbnB1dHM6ICh2YWx1ZS5pbnB1dHMgPyB2YWx1ZS5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tT2JqZWN0KSA6IFtdKSxcbiAgICAgICAgICAgIG91dHB1dHM6ICh2YWx1ZS5vdXRwdXRzID8gdmFsdWUub3V0cHV0cy5tYXAoUGFyYW1UeXBlLmZyb21PYmplY3QpIDogW10pLFxuICAgICAgICAgICAgcGF5YWJsZTogc3RhdGUucGF5YWJsZSxcbiAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogc3RhdGUuc3RhdGVNdXRhYmlsaXR5LFxuICAgICAgICAgICAgZ2FzOiAodmFsdWUuZ2FzID8gQmlnTnVtYmVyLmZyb20odmFsdWUuZ2FzKSA6IG51bGwpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25GcmFnbWVudChfY29uc3RydWN0b3JHdWFyZCwgcGFyYW1zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgbGV0IHBhcmFtcyA9IHsgdHlwZTogXCJmdW5jdGlvblwiIH07XG4gICAgICAgIHZhbHVlID0gcGFyc2VHYXModmFsdWUsIHBhcmFtcyk7XG4gICAgICAgIGxldCBjb21wcyA9IHZhbHVlLnNwbGl0KFwiIHJldHVybnMgXCIpO1xuICAgICAgICBpZiAoY29tcHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZnVuY3Rpb24gc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJlbnMgPSBjb21wc1swXS5tYXRjaChyZWdleFBhcmVuKTtcbiAgICAgICAgaWYgKCFwYXJlbnMpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZ1bmN0aW9uIHNpZ25hdHVyZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMubmFtZSA9IHBhcmVuc1sxXS50cmltKCk7XG4gICAgICAgIGlmIChwYXJhbXMubmFtZSkge1xuICAgICAgICAgICAgdmVyaWZ5SWRlbnRpZmllcihwYXJhbXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLmlucHV0cyA9IHBhcnNlUGFyYW1zKHBhcmVuc1syXSwgZmFsc2UpO1xuICAgICAgICBwYXJzZU1vZGlmaWVycyhwYXJlbnNbM10udHJpbSgpLCBwYXJhbXMpO1xuICAgICAgICAvLyBXZSBoYXZlIG91dHB1dHNcbiAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxldCByZXR1cm5zID0gY29tcHNbMV0ubWF0Y2gocmVnZXhQYXJlbik7XG4gICAgICAgICAgICBpZiAocmV0dXJuc1sxXS50cmltKCkgIT0gXCJcIiB8fCByZXR1cm5zWzNdLnRyaW0oKSAhPSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuZXhwZWN0ZWQgdG9rZW5zXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyYW1zLm91dHB1dHMgPSBwYXJzZVBhcmFtcyhyZXR1cm5zWzJdLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMub3V0cHV0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21PYmplY3QocGFyYW1zKTtcbiAgICB9XG4gICAgc3RhdGljIGlzRnVuY3Rpb25GcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlLl9pc0ZyYWdtZW50ICYmIHZhbHVlLnR5cGUgPT09IFwiZnVuY3Rpb25cIik7XG4gICAgfVxufVxuLy9leHBvcnQgY2xhc3MgU3RydWN0RnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XG4vL31cbmZ1bmN0aW9uIGNoZWNrRm9yYmlkZGVuKGZyYWdtZW50KSB7XG4gICAgY29uc3Qgc2lnID0gZnJhZ21lbnQuZm9ybWF0KCk7XG4gICAgaWYgKHNpZyA9PT0gXCJFcnJvcihzdHJpbmcpXCIgfHwgc2lnID09PSBcIlBhbmljKHVpbnQyNTYpXCIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgY2Fubm90IHNwZWNpZnkgdXNlciBkZWZpbmVkICR7c2lnfSBlcnJvcmAsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG59XG5leHBvcnQgY2xhc3MgRXJyb3JGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghZm9ybWF0KSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBGb3JtYXRUeXBlcy5zaWdoYXNoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghRm9ybWF0VHlwZXNbZm9ybWF0XSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZm9ybWF0IHR5cGVcIiwgXCJmb3JtYXRcIiwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBGb3JtYXRUeXBlcy5qc29uKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGlucHV0KSA9PiBKU09OLnBhcnNlKGlucHV0LmZvcm1hdChmb3JtYXQpKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiZXJyb3IgXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IHRoaXMubmFtZSArIFwiKFwiICsgdGhpcy5pbnB1dHMubWFwKChpbnB1dCkgPT4gaW5wdXQuZm9ybWF0KGZvcm1hdCkpLmpvaW4oKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuZnVsbCkgPyBcIiwgXCIgOiBcIixcIikgKyBcIikgXCI7XG4gICAgICAgIHJldHVybiByZXN1bHQudHJpbSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU9iamVjdCh2YWx1ZSkge1xuICAgICAgICBpZiAoRXJyb3JGcmFnbWVudC5pc0Vycm9yRnJhZ21lbnQodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZXJyb3Igb2JqZWN0XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgIHR5cGU6IHZhbHVlLnR5cGUsXG4gICAgICAgICAgICBuYW1lOiB2ZXJpZnlJZGVudGlmaWVyKHZhbHVlLm5hbWUpLFxuICAgICAgICAgICAgaW5wdXRzOiAodmFsdWUuaW5wdXRzID8gdmFsdWUuaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbU9iamVjdCkgOiBbXSlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNoZWNrRm9yYmlkZGVuKG5ldyBFcnJvckZyYWdtZW50KF9jb25zdHJ1Y3Rvckd1YXJkLCBwYXJhbXMpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgbGV0IHBhcmFtcyA9IHsgdHlwZTogXCJlcnJvclwiIH07XG4gICAgICAgIGxldCBwYXJlbnMgPSB2YWx1ZS5tYXRjaChyZWdleFBhcmVuKTtcbiAgICAgICAgaWYgKCFwYXJlbnMpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGVycm9yIHNpZ25hdHVyZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMubmFtZSA9IHBhcmVuc1sxXS50cmltKCk7XG4gICAgICAgIGlmIChwYXJhbXMubmFtZSkge1xuICAgICAgICAgICAgdmVyaWZ5SWRlbnRpZmllcihwYXJhbXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLmlucHV0cyA9IHBhcnNlUGFyYW1zKHBhcmVuc1syXSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gY2hlY2tGb3JiaWRkZW4oRXJyb3JGcmFnbWVudC5mcm9tT2JqZWN0KHBhcmFtcykpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNFcnJvckZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWUuX2lzRnJhZ21lbnQgJiYgdmFsdWUudHlwZSA9PT0gXCJlcnJvclwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2ZXJpZnlUeXBlKHR5cGUpIHtcbiAgICAvLyBUaGVzZSBuZWVkIHRvIGJlIHRyYW5zZm9ybWVkIHRvIHRoZWlyIGZ1bGwgZGVzY3JpcHRpb25cbiAgICBpZiAodHlwZS5tYXRjaCgvXnVpbnQoJHxbXjEtOV0pLykpIHtcbiAgICAgICAgdHlwZSA9IFwidWludDI1NlwiICsgdHlwZS5zdWJzdHJpbmcoNCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUubWF0Y2goL15pbnQoJHxbXjEtOV0pLykpIHtcbiAgICAgICAgdHlwZSA9IFwiaW50MjU2XCIgKyB0eXBlLnN1YnN0cmluZygzKTtcbiAgICB9XG4gICAgLy8gQFRPRE86IG1vcmUgdmVyaWZpY2F0aW9uXG4gICAgcmV0dXJuIHR5cGU7XG59XG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9zb2xpZGl0eS9ibG9iLzFmOGYxYTNkYjkzYTU0OGQwNTU1ZTNlMTRjZmM1NWExMGUyNWI2MGUvZG9jcy9ncmFtbWFyL1NvbGlkaXR5TGV4ZXIuZzQjTDIzNFxuY29uc3QgcmVnZXhJZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIl5bYS16QS1aJF9dW2EtekEtWjAtOSRfXSokXCIpO1xuZnVuY3Rpb24gdmVyaWZ5SWRlbnRpZmllcih2YWx1ZSkge1xuICAgIGlmICghdmFsdWUgfHwgIXZhbHVlLm1hdGNoKHJlZ2V4SWRlbnRpZmllcikpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCBpZGVudGlmaWVyIFwiJHt2YWx1ZX1cImAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCByZWdleFBhcmVuID0gbmV3IFJlZ0V4cChcIl4oW14pKF0qKVxcXFwoKC4qKVxcXFwpKFteKShdKikkXCIpO1xuZnVuY3Rpb24gc3BsaXROZXN0aW5nKHZhbHVlKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBhY2N1bSA9IFwiXCI7XG4gICAgbGV0IGRlcHRoID0gMDtcbiAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCB2YWx1ZS5sZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgICAgIGxldCBjID0gdmFsdWVbb2Zmc2V0XTtcbiAgICAgICAgaWYgKGMgPT09IFwiLFwiICYmIGRlcHRoID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChhY2N1bSk7XG4gICAgICAgICAgICBhY2N1bSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY2N1bSArPSBjO1xuICAgICAgICAgICAgaWYgKGMgPT09IFwiKFwiKSB7XG4gICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwiKVwiKSB7XG4gICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmJhbGFuY2VkIHBhcmVudGhlc2lzXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWNjdW0pIHtcbiAgICAgICAgcmVzdWx0LnB1c2goYWNjdW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJhZ21lbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJCaWdOdW1iZXIiLCJkZWZpbmVSZWFkT25seSIsIkxvZ2dlciIsInZlcnNpb24iLCJsb2dnZXIiLCJfY29uc3RydWN0b3JHdWFyZCIsIk1vZGlmaWVyc0J5dGVzIiwiY2FsbGRhdGEiLCJtZW1vcnkiLCJzdG9yYWdlIiwiTW9kaWZpZXJzTmVzdCIsImNoZWNrTW9kaWZpZXIiLCJ0eXBlIiwibmFtZSIsImluZGV4T2YiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJwYXJzZVBhcmFtVHlwZSIsInBhcmFtIiwiYWxsb3dJbmRleGVkIiwib3JpZ2luYWxQYXJhbSIsInRocm93RXJyb3IiLCJpIiwicmVwbGFjZSIsIm5ld05vZGUiLCJwYXJlbnQiLCJub2RlIiwic3RhdGUiLCJhbGxvd1R5cGUiLCJpbmRleGVkIiwibGVuZ3RoIiwiYyIsImFsbG93UGFyYW1zIiwidmVyaWZ5VHlwZSIsImNvbXBvbmVudHMiLCJjaGlsZCIsImFsbG93TmFtZSIsImFsbG93QXJyYXkiLCJzaWJsaW5nIiwicHVzaCIsInJlYWRBcnJheSIsInBvcHVsYXRlIiwib2JqZWN0IiwicGFyYW1zIiwia2V5IiwiRm9ybWF0VHlwZXMiLCJPYmplY3QiLCJmcmVlemUiLCJzaWdoYXNoIiwibWluaW1hbCIsImZ1bGwiLCJqc29uIiwicGFyYW1UeXBlQXJyYXkiLCJSZWdFeHAiLCJQYXJhbVR5cGUiLCJjb25zdHJ1Y3RvciIsImNvbnN0cnVjdG9yR3VhcmQiLCJlcnJvcnMiLCJVTlNVUFBPUlRFRF9PUEVSQVRJT04iLCJvcGVyYXRpb24iLCJtYXRjaCIsImFycmF5TGVuZ3RoIiwicGFyc2VJbnQiLCJhcnJheUNoaWxkcmVuIiwiZnJvbU9iamVjdCIsImJhc2VUeXBlIiwiX2lzUGFyYW1UeXBlIiwiZm9ybWF0IiwicmVzdWx0IiwidW5kZWZpbmVkIiwibWFwIiwiY29tcCIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsIlN0cmluZyIsImpvaW4iLCJmcm9tIiwidmFsdWUiLCJmcm9tU3RyaW5nIiwiaXNQYXJhbVR5cGUiLCJQYXJhbVR5cGlmeSIsInBhcnNlUGFyYW1zIiwiYWxsb3dJbmRleCIsInNwbGl0TmVzdGluZyIsIkZyYWdtZW50IiwiX2lzRnJhZ21lbnQiLCJpc0ZyYWdtZW50IiwiRnVuY3Rpb25GcmFnbWVudCIsIkV2ZW50RnJhZ21lbnQiLCJDb25zdHJ1Y3RvckZyYWdtZW50IiwiRXJyb3JGcmFnbWVudCIsInRyaW0iLCJzcGxpdCIsInN1YnN0cmluZyIsImFub255bW91cyIsImlucHV0cyIsImlucHV0IiwiaXNFdmVudEZyYWdtZW50IiwidmVyaWZ5SWRlbnRpZmllciIsInJlZ2V4UGFyZW4iLCJmb3JFYWNoIiwibW9kaWZpZXIiLCJ3YXJuIiwicGFyc2VHYXMiLCJnYXMiLCJjb21wcyIsInBhcnNlTW9kaWZpZXJzIiwiY29uc3RhbnQiLCJwYXlhYmxlIiwic3RhdGVNdXRhYmlsaXR5IiwiY29uc29sZSIsImxvZyIsInZlcmlmeVN0YXRlIiwidG9OdW1iZXIiLCJpc0NvbnN0cnVjdG9yRnJhZ21lbnQiLCJwYXJlbnMiLCJvdXRwdXRzIiwib3V0cHV0IiwidG9TdHJpbmciLCJpc0Z1bmN0aW9uRnJhZ21lbnQiLCJyZXR1cm5zIiwiY2hlY2tGb3JiaWRkZW4iLCJmcmFnbWVudCIsInNpZyIsImlzRXJyb3JGcmFnbWVudCIsInJlZ2V4SWRlbnRpZmllciIsImFjY3VtIiwiZGVwdGgiLCJvZmZzZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/fragments.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/interface.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/interface.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorDescription: () => (/* binding */ ErrorDescription),\n/* harmony export */   Indexed: () => (/* binding */ Indexed),\n/* harmony export */   Interface: () => (/* binding */ Interface),\n/* harmony export */   LogDescription: () => (/* binding */ LogDescription),\n/* harmony export */   TransactionDescription: () => (/* binding */ TransactionDescription),\n/* harmony export */   checkResultErrors: () => (/* reexport safe */ _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_2__.checkResultErrors)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/hash */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/id.js\");\n/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/keccak256/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _abi_coder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abi-coder */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/abi-coder.js\");\n/* harmony import */ var _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./coders/abstract-coder */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n/* harmony import */ var _fragments__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fragments */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/fragments.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/_version.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nclass LogDescription extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.Description {\n}\nclass TransactionDescription extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.Description {\n}\nclass ErrorDescription extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.Description {\n}\nclass Indexed extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.Description {\n    static isIndexed(value) {\n        return !!(value && value._isIndexed);\n    }\n}\nconst BuiltinErrors = {\n    \"0x08c379a0\": {\n        signature: \"Error(string)\",\n        name: \"Error\",\n        inputs: [\n            \"string\"\n        ],\n        reason: true\n    },\n    \"0x4e487b71\": {\n        signature: \"Panic(uint256)\",\n        name: \"Panic\",\n        inputs: [\n            \"uint256\"\n        ]\n    }\n};\nfunction wrapAccessError(property, error) {\n    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);\n    wrap.error = error;\n    return wrap;\n}\n/*\nfunction checkNames(fragment: Fragment, type: \"input\" | \"output\", params: Array<ParamType>): void {\n    params.reduce((accum, param) => {\n        if (param.name) {\n            if (accum[param.name]) {\n                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format(\"full\") }`, \"fragment\", fragment);\n            }\n            accum[param.name] = true;\n        }\n        return accum;\n    }, <{ [ name: string ]: boolean }>{ });\n}\n*/ class Interface {\n    constructor(fragments){\n        let abi = [];\n        if (typeof fragments === \"string\") {\n            abi = JSON.parse(fragments);\n        } else {\n            abi = fragments;\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"fragments\", abi.map((fragment)=>{\n            return _fragments__WEBPACK_IMPORTED_MODULE_4__.Fragment.from(fragment);\n        }).filter((fragment)=>fragment != null));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_abiCoder\", (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, \"getAbiCoder\")());\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"functions\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"errors\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"events\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"structs\", {});\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment)=>{\n            let bucket = null;\n            switch(fragment.type){\n                case \"constructor\":\n                    if (this.deploy) {\n                        logger.warn(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"deploy\", fragment);\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.functions;\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.events;\n                    break;\n                case \"error\":\n                    bucket = this.errors;\n                    break;\n                default:\n                    return;\n            }\n            let signature = fragment.format();\n            if (bucket[signature]) {\n                logger.warn(\"duplicate definition - \" + signature);\n                return;\n            }\n            bucket[signature] = fragment;\n        });\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"deploy\", _fragments__WEBPACK_IMPORTED_MODULE_4__.ConstructorFragment.from({\n                payable: false,\n                type: \"constructor\"\n            }));\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_isInterface\", true);\n    }\n    format(format) {\n        if (!format) {\n            format = _fragments__WEBPACK_IMPORTED_MODULE_4__.FormatTypes.full;\n        }\n        if (format === _fragments__WEBPACK_IMPORTED_MODULE_4__.FormatTypes.sighash) {\n            logger.throwArgumentError(\"interface does not support formatting sighash\", \"format\", format);\n        }\n        const abi = this.fragments.map((fragment)=>fragment.format(format));\n        // We need to re-bundle the JSON fragments a bit\n        if (format === _fragments__WEBPACK_IMPORTED_MODULE_4__.FormatTypes.json) {\n            return JSON.stringify(abi.map((j)=>JSON.parse(j)));\n        }\n        return abi;\n    }\n    // Sub-classes can override these to handle other blockchains\n    static getAbiCoder() {\n        return _abi_coder__WEBPACK_IMPORTED_MODULE_5__.defaultAbiCoder;\n    }\n    static getAddress(address) {\n        return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_6__.getAddress)(address);\n    }\n    static getSighash(fragment) {\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexDataSlice)((0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_8__.id)(fragment.format()), 0, 4);\n    }\n    static getEventTopic(eventFragment) {\n        return (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_8__.id)(eventFragment.format());\n    }\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getFunction(nameOrSignatureOrSighash) {\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.isHexString)(nameOrSignatureOrSighash)) {\n            for(const name in this.functions){\n                if (nameOrSignatureOrSighash === this.getSighash(name)) {\n                    return this.functions[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching function\", \"sighash\", nameOrSignatureOrSighash);\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.functions).filter((f)=>f.split(\"(\" /* fix:) */ )[0] === name);\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching function\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching functions\", \"name\", name);\n            }\n            return this.functions[matching[0]];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.functions[_fragments__WEBPACK_IMPORTED_MODULE_4__.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching function\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    getEvent(nameOrSignatureOrTopic) {\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.isHexString)(nameOrSignatureOrTopic)) {\n            const topichash = nameOrSignatureOrTopic.toLowerCase();\n            for(const name in this.events){\n                if (topichash === this.getEventTopic(name)) {\n                    return this.events[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching event\", \"topichash\", topichash);\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrTopic.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrTopic.trim();\n            const matching = Object.keys(this.events).filter((f)=>f.split(\"(\" /* fix:) */ )[0] === name);\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching event\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching events\", \"name\", name);\n            }\n            return this.events[matching[0]];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.events[_fragments__WEBPACK_IMPORTED_MODULE_4__.EventFragment.fromString(nameOrSignatureOrTopic).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching event\", \"signature\", nameOrSignatureOrTopic);\n        }\n        return result;\n    }\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getError(nameOrSignatureOrSighash) {\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.isHexString)(nameOrSignatureOrSighash)) {\n            const getSighash = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(this.constructor, \"getSighash\");\n            for(const name in this.errors){\n                const error = this.errors[name];\n                if (nameOrSignatureOrSighash === getSighash(error)) {\n                    return this.errors[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching error\", \"sighash\", nameOrSignatureOrSighash);\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.errors).filter((f)=>f.split(\"(\" /* fix:) */ )[0] === name);\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching error\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching errors\", \"name\", name);\n            }\n            return this.errors[matching[0]];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.errors[_fragments__WEBPACK_IMPORTED_MODULE_4__.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching error\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n    // Get the sighash (the bytes4 selector) used by Solidity to identify a function\n    getSighash(fragment) {\n        if (typeof fragment === \"string\") {\n            try {\n                fragment = this.getFunction(fragment);\n            } catch (error) {\n                try {\n                    fragment = this.getError(fragment);\n                } catch (_) {\n                    throw error;\n                }\n            }\n        }\n        return (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(this.constructor, \"getSighash\")(fragment);\n    }\n    // Get the topic (the bytes32 hash) used by Solidity to identify an event\n    getEventTopic(eventFragment) {\n        if (typeof eventFragment === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        return (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(this.constructor, \"getEventTopic\")(eventFragment);\n    }\n    _decodeParams(params, data) {\n        return this._abiCoder.decode(params, data);\n    }\n    _encodeParams(params, values) {\n        return this._abiCoder.encode(params, values);\n    }\n    encodeDeploy(values) {\n        return this._encodeParams(this.deploy.inputs, values || []);\n    }\n    decodeErrorResult(fragment, data) {\n        if (typeof fragment === \"string\") {\n            fragment = this.getError(fragment);\n        }\n        const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.arrayify)(data);\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(bytes.slice(0, 4)) !== this.getSighash(fragment)) {\n            logger.throwArgumentError(`data signature does not match error ${fragment.name}.`, \"data\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(bytes));\n        }\n        return this._decodeParams(fragment.inputs, bytes.slice(4));\n    }\n    encodeErrorResult(fragment, values) {\n        if (typeof fragment === \"string\") {\n            fragment = this.getError(fragment);\n        }\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.concat)([\n            this.getSighash(fragment),\n            this._encodeParams(fragment.inputs, values || [])\n        ]));\n    }\n    // Decode the data for a function call (e.g. tx.data)\n    decodeFunctionData(functionFragment, data) {\n        if (typeof functionFragment === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.arrayify)(data);\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {\n            logger.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, \"data\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(bytes));\n        }\n        return this._decodeParams(functionFragment.inputs, bytes.slice(4));\n    }\n    // Encode the data for a function call (e.g. tx.data)\n    encodeFunctionData(functionFragment, values) {\n        if (typeof functionFragment === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.concat)([\n            this.getSighash(functionFragment),\n            this._encodeParams(functionFragment.inputs, values || [])\n        ]));\n    }\n    // Decode the result from a function call (e.g. from eth_call)\n    decodeFunctionResult(functionFragment, data) {\n        if (typeof functionFragment === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        let bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.arrayify)(data);\n        let reason = null;\n        let message = \"\";\n        let errorArgs = null;\n        let errorName = null;\n        let errorSignature = null;\n        switch(bytes.length % this._abiCoder._getWordSize()){\n            case 0:\n                try {\n                    return this._abiCoder.decode(functionFragment.outputs, bytes);\n                } catch (error) {}\n                break;\n            case 4:\n                {\n                    const selector = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(bytes.slice(0, 4));\n                    const builtin = BuiltinErrors[selector];\n                    if (builtin) {\n                        errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));\n                        errorName = builtin.name;\n                        errorSignature = builtin.signature;\n                        if (builtin.reason) {\n                            reason = errorArgs[0];\n                        }\n                        if (errorName === \"Error\") {\n                            message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;\n                        } else if (errorName === \"Panic\") {\n                            message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;\n                        }\n                    } else {\n                        try {\n                            const error = this.getError(selector);\n                            errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));\n                            errorName = error.name;\n                            errorSignature = error.format();\n                        } catch (error) {}\n                    }\n                    break;\n                }\n        }\n        return logger.throwError(\"call revert exception\" + message, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.CALL_EXCEPTION, {\n            method: functionFragment.format(),\n            data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(data),\n            errorArgs,\n            errorName,\n            errorSignature,\n            reason\n        });\n    }\n    // Encode the result for a function call (e.g. for eth_call)\n    encodeFunctionResult(functionFragment, values) {\n        if (typeof functionFragment === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(this._abiCoder.encode(functionFragment.outputs, values || []));\n    }\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(eventFragment, values) {\n        if (typeof eventFragment === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        if (values.length > eventFragment.inputs.length) {\n            logger.throwError(\"too many arguments for \" + eventFragment.format(), _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNEXPECTED_ARGUMENT, {\n                argument: \"values\",\n                value: values\n            });\n        }\n        let topics = [];\n        if (!eventFragment.anonymous) {\n            topics.push(this.getEventTopic(eventFragment));\n        }\n        const encodeTopic = (param, value)=>{\n            if (param.type === \"string\") {\n                return (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_8__.id)(value);\n            } else if (param.type === \"bytes\") {\n                return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_9__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(value));\n            }\n            if (param.type === \"bool\" && typeof value === \"boolean\") {\n                value = value ? \"0x01\" : \"0x00\";\n            }\n            if (param.type.match(/^u?int/)) {\n                value = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_10__.BigNumber.from(value).toHexString();\n            }\n            // Check addresses are valid\n            if (param.type === \"address\") {\n                this._abiCoder.encode([\n                    \"address\"\n                ], [\n                    value\n                ]);\n            }\n            return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexZeroPad)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(value), 32);\n        };\n        values.forEach((value, index)=>{\n            let param = eventFragment.inputs[index];\n            if (!param.indexed) {\n                if (value != null) {\n                    logger.throwArgumentError(\"cannot filter non-indexed parameters; must be null\", \"contract.\" + param.name, value);\n                }\n                return;\n            }\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                logger.throwArgumentError(\"filtering with tuples or arrays not supported\", \"contract.\" + param.name, value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value)=>encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n        // Trim off trailing nulls\n        while(topics.length && topics[topics.length - 1] === null){\n            topics.pop();\n        }\n        return topics;\n    }\n    encodeEventLog(eventFragment, values) {\n        if (typeof eventFragment === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        const topics = [];\n        const dataTypes = [];\n        const dataValues = [];\n        if (!eventFragment.anonymous) {\n            topics.push(this.getEventTopic(eventFragment));\n        }\n        if (values.length !== eventFragment.inputs.length) {\n            logger.throwArgumentError(\"event arguments/values mismatch\", \"values\", values);\n        }\n        eventFragment.inputs.forEach((param, index)=>{\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push((0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_8__.id)(value));\n                } else if (param.type === \"bytes\") {\n                    topics.push((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_9__.keccak256)(value));\n                } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                } else {\n                    topics.push(this._abiCoder.encode([\n                        param.type\n                    ], [\n                        value\n                    ]));\n                }\n            } else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n        return {\n            data: this._abiCoder.encode(dataTypes, dataValues),\n            topics: topics\n        };\n    }\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(eventFragment, data, topics) {\n        if (typeof eventFragment === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        if (topics != null && !eventFragment.anonymous) {\n            let topicHash = this.getEventTopic(eventFragment);\n            if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.isHexString)(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {\n                logger.throwError(\"fragment/topic mismatch\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"topics[0]\",\n                    expected: topicHash,\n                    value: topics[0]\n                });\n            }\n            topics = topics.slice(1);\n        }\n        let indexed = [];\n        let nonIndexed = [];\n        let dynamic = [];\n        eventFragment.inputs.forEach((param, index)=>{\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(_fragments__WEBPACK_IMPORTED_MODULE_4__.ParamType.fromObject({\n                        type: \"bytes32\",\n                        name: param.name\n                    }));\n                    dynamic.push(true);\n                } else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            } else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n        let resultIndexed = topics != null ? this._abiCoder.decode(indexed, (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.concat)(topics)) : null;\n        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);\n        let result = [];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        eventFragment.inputs.forEach((param, index)=>{\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    result[index] = new Indexed({\n                        _isIndexed: true,\n                        hash: null\n                    });\n                } else if (dynamic[index]) {\n                    result[index] = new Indexed({\n                        _isIndexed: true,\n                        hash: resultIndexed[indexedIndex++]\n                    });\n                } else {\n                    try {\n                        result[index] = resultIndexed[indexedIndex++];\n                    } catch (error) {\n                        result[index] = error;\n                    }\n                }\n            } else {\n                try {\n                    result[index] = resultNonIndexed[nonIndexedIndex++];\n                } catch (error) {\n                    result[index] = error;\n                }\n            }\n            // Add the keyword argument if named and safe\n            if (param.name && result[param.name] == null) {\n                const value = result[index];\n                // Make error named values throw on access\n                if (value instanceof Error) {\n                    Object.defineProperty(result, param.name, {\n                        enumerable: true,\n                        get: ()=>{\n                            throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value);\n                        }\n                    });\n                } else {\n                    result[param.name] = value;\n                }\n            }\n        });\n        // Make all error indexed values throw on access\n        for(let i = 0; i < result.length; i++){\n            const value = result[i];\n            if (value instanceof Error) {\n                Object.defineProperty(result, i, {\n                    enumerable: true,\n                    get: ()=>{\n                        throw wrapAccessError(`index ${i}`, value);\n                    }\n                });\n            }\n        }\n        return Object.freeze(result);\n    }\n    // Given a transaction, find the matching function fragment (if any) and\n    // determine all its properties and call parameters\n    parseTransaction(tx) {\n        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());\n        if (!fragment) {\n            return null;\n        }\n        return new TransactionDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + tx.data.substring(10)),\n            functionFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n            value: _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_10__.BigNumber.from(tx.value || \"0\")\n        });\n    }\n    // @TODO\n    //parseCallResult(data: BytesLike): ??\n    // Given an event log, find the matching event fragment (if any) and\n    // determine all its properties and values\n    parseLog(log) {\n        let fragment = this.getEvent(log.topics[0]);\n        if (!fragment || fragment.anonymous) {\n            return null;\n        }\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n        return new LogDescription({\n            eventFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            topic: this.getEventTopic(fragment),\n            args: this.decodeEventLog(fragment, log.data, log.topics)\n        });\n    }\n    parseError(data) {\n        const hexData = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(data);\n        let fragment = this.getError(hexData.substring(0, 10).toLowerCase());\n        if (!fragment) {\n            return null;\n        }\n        return new ErrorDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + hexData.substring(10)),\n            errorFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment)\n        });\n    }\n    /*\n    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {\n        if (Interface.isInterface(value)) {\n            return value;\n        }\n        if (typeof(value) === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        return new Interface(value);\n    }\n    */ static isInterface(value) {\n        return !!(value && value._isInterface);\n    }\n} //# sourceMappingURL=interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBYTtBQUN1QztBQUNDO0FBQ21EO0FBQy9EO0FBQ1k7QUFDOEI7QUFDckM7QUFDYztBQUN5RDtBQUN0RTtBQUNWO0FBQ3JDLE1BQU11QixTQUFTLElBQUlGLHlEQUFNQSxDQUFDQyw2Q0FBT0E7QUFDSjtBQUN0QixNQUFNRSx1QkFBdUJiLGtFQUFXQTtBQUMvQztBQUNPLE1BQU1jLCtCQUErQmQsa0VBQVdBO0FBQ3ZEO0FBQ08sTUFBTWUseUJBQXlCZixrRUFBV0E7QUFDakQ7QUFDTyxNQUFNZ0IsZ0JBQWdCaEIsa0VBQVdBO0lBQ3BDLE9BQU9pQixVQUFVQyxLQUFLLEVBQUU7UUFDcEIsT0FBTyxDQUFDLENBQUVBLENBQUFBLFNBQVNBLE1BQU1DLFVBQVU7SUFDdkM7QUFDSjtBQUNBLE1BQU1DLGdCQUFnQjtJQUNsQixjQUFjO1FBQUVDLFdBQVc7UUFBaUJDLE1BQU07UUFBU0MsUUFBUTtZQUFDO1NBQVM7UUFBRUMsUUFBUTtJQUFLO0lBQzVGLGNBQWM7UUFBRUgsV0FBVztRQUFrQkMsTUFBTTtRQUFTQyxRQUFRO1lBQUM7U0FBVTtJQUFDO0FBQ3BGO0FBQ0EsU0FBU0UsZ0JBQWdCQyxRQUFRLEVBQUVDLEtBQUs7SUFDcEMsTUFBTUMsT0FBTyxJQUFJQyxNQUFNLENBQUMsdURBQXVELEVBQUVILFNBQVMsQ0FBQztJQUMzRkUsS0FBS0QsS0FBSyxHQUFHQTtJQUNiLE9BQU9DO0FBQ1g7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUEsR0FDTyxNQUFNRTtJQUNUQyxZQUFZQyxTQUFTLENBQUU7UUFDbkIsSUFBSUMsTUFBTSxFQUFFO1FBQ1osSUFBSSxPQUFRRCxjQUFlLFVBQVU7WUFDakNDLE1BQU1DLEtBQUtDLEtBQUssQ0FBQ0g7UUFDckIsT0FDSztZQUNEQyxNQUFNRDtRQUNWO1FBQ0FqQyx5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsYUFBYWtDLElBQUlHLEdBQUcsQ0FBQyxDQUFDQztZQUN2QyxPQUFPOUIsZ0RBQVFBLENBQUMrQixJQUFJLENBQUNEO1FBQ3pCLEdBQUdFLE1BQU0sQ0FBQyxDQUFDRixXQUFjQSxZQUFZO1FBQ3JDdEMseUVBQWNBLENBQUMsSUFBSSxFQUFFLGFBQWFFLG9FQUFTQSxDQUFDLFlBQVk7UUFDeERGLHlFQUFjQSxDQUFDLElBQUksRUFBRSxhQUFhLENBQUM7UUFDbkNBLHlFQUFjQSxDQUFDLElBQUksRUFBRSxVQUFVLENBQUM7UUFDaENBLHlFQUFjQSxDQUFDLElBQUksRUFBRSxVQUFVLENBQUM7UUFDaENBLHlFQUFjQSxDQUFDLElBQUksRUFBRSxXQUFXLENBQUM7UUFDakMsdUNBQXVDO1FBQ3ZDLElBQUksQ0FBQ2lDLFNBQVMsQ0FBQ1EsT0FBTyxDQUFDLENBQUNIO1lBQ3BCLElBQUlJLFNBQVM7WUFDYixPQUFRSixTQUFTSyxJQUFJO2dCQUNqQixLQUFLO29CQUNELElBQUksSUFBSSxDQUFDQyxNQUFNLEVBQUU7d0JBQ2IvQixPQUFPZ0MsSUFBSSxDQUFDO3dCQUNaO29CQUNKO29CQUNBLGlEQUFpRDtvQkFDakQ3Qyx5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsVUFBVXNDO29CQUMvQjtnQkFDSixLQUFLO29CQUNELGlEQUFpRDtvQkFDakQsdUVBQXVFO29CQUN2RUksU0FBUyxJQUFJLENBQUNJLFNBQVM7b0JBQ3ZCO2dCQUNKLEtBQUs7b0JBQ0QsaURBQWlEO29CQUNqREosU0FBUyxJQUFJLENBQUNLLE1BQU07b0JBQ3BCO2dCQUNKLEtBQUs7b0JBQ0RMLFNBQVMsSUFBSSxDQUFDTSxNQUFNO29CQUNwQjtnQkFDSjtvQkFDSTtZQUNSO1lBQ0EsSUFBSTFCLFlBQVlnQixTQUFTVyxNQUFNO1lBQy9CLElBQUlQLE1BQU0sQ0FBQ3BCLFVBQVUsRUFBRTtnQkFDbkJULE9BQU9nQyxJQUFJLENBQUMsNEJBQTRCdkI7Z0JBQ3hDO1lBQ0o7WUFDQW9CLE1BQU0sQ0FBQ3BCLFVBQVUsR0FBR2dCO1FBQ3hCO1FBQ0EsZ0RBQWdEO1FBQ2hELElBQUksQ0FBQyxJQUFJLENBQUNNLE1BQU0sRUFBRTtZQUNkNUMseUVBQWNBLENBQUMsSUFBSSxFQUFFLFVBQVVLLDJEQUFtQkEsQ0FBQ2tDLElBQUksQ0FBQztnQkFDcERXLFNBQVM7Z0JBQ1RQLE1BQU07WUFDVjtRQUNKO1FBQ0EzQyx5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsZ0JBQWdCO0lBQ3pDO0lBQ0FpRCxPQUFPQSxNQUFNLEVBQUU7UUFDWCxJQUFJLENBQUNBLFFBQVE7WUFDVEEsU0FBUzFDLG1EQUFXQSxDQUFDNEMsSUFBSTtRQUM3QjtRQUNBLElBQUlGLFdBQVcxQyxtREFBV0EsQ0FBQzZDLE9BQU8sRUFBRTtZQUNoQ3ZDLE9BQU93QyxrQkFBa0IsQ0FBQyxpREFBaUQsVUFBVUo7UUFDekY7UUFDQSxNQUFNZixNQUFNLElBQUksQ0FBQ0QsU0FBUyxDQUFDSSxHQUFHLENBQUMsQ0FBQ0MsV0FBYUEsU0FBU1csTUFBTSxDQUFDQTtRQUM3RCxnREFBZ0Q7UUFDaEQsSUFBSUEsV0FBVzFDLG1EQUFXQSxDQUFDK0MsSUFBSSxFQUFFO1lBQzdCLE9BQU9uQixLQUFLb0IsU0FBUyxDQUFDckIsSUFBSUcsR0FBRyxDQUFDLENBQUNtQixJQUFNckIsS0FBS0MsS0FBSyxDQUFDb0I7UUFDcEQ7UUFDQSxPQUFPdEI7SUFDWDtJQUNBLDZEQUE2RDtJQUM3RCxPQUFPdUIsY0FBYztRQUNqQixPQUFPdEQsdURBQWVBO0lBQzFCO0lBQ0EsT0FBT2IsV0FBV29FLE9BQU8sRUFBRTtRQUN2QixPQUFPcEUsa0VBQVVBLENBQUNvRTtJQUN0QjtJQUNBLE9BQU9DLFdBQVdyQixRQUFRLEVBQUU7UUFDeEIsT0FBTzVDLGtFQUFZQSxDQUFDSSx1REFBRUEsQ0FBQ3dDLFNBQVNXLE1BQU0sS0FBSyxHQUFHO0lBQ2xEO0lBQ0EsT0FBT1csY0FBY0MsYUFBYSxFQUFFO1FBQ2hDLE9BQU8vRCx1REFBRUEsQ0FBQytELGNBQWNaLE1BQU07SUFDbEM7SUFDQSw2RUFBNkU7SUFDN0VhLFlBQVlDLHdCQUF3QixFQUFFO1FBQ2xDLElBQUlsRSxpRUFBV0EsQ0FBQ2tFLDJCQUEyQjtZQUN2QyxJQUFLLE1BQU14QyxRQUFRLElBQUksQ0FBQ3VCLFNBQVMsQ0FBRTtnQkFDL0IsSUFBSWlCLDZCQUE2QixJQUFJLENBQUNKLFVBQVUsQ0FBQ3BDLE9BQU87b0JBQ3BELE9BQU8sSUFBSSxDQUFDdUIsU0FBUyxDQUFDdkIsS0FBSztnQkFDL0I7WUFDSjtZQUNBVixPQUFPd0Msa0JBQWtCLENBQUMsd0JBQXdCLFdBQVdVO1FBQ2pFO1FBQ0EsMEVBQTBFO1FBQzFFLElBQUlBLHlCQUF5QkMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHO1lBQzlDLE1BQU16QyxPQUFPd0MseUJBQXlCRSxJQUFJO1lBQzFDLE1BQU1DLFdBQVdDLE9BQU9DLElBQUksQ0FBQyxJQUFJLENBQUN0QixTQUFTLEVBQUVOLE1BQU0sQ0FBQyxDQUFDNkIsSUFBT0EsRUFBRUMsS0FBSyxDQUFDLElBQUksU0FBUyxJQUFHLENBQUMsRUFBRSxLQUFLL0M7WUFDNUYsSUFBSTJDLFNBQVNLLE1BQU0sS0FBSyxHQUFHO2dCQUN2QjFELE9BQU93QyxrQkFBa0IsQ0FBQyx3QkFBd0IsUUFBUTlCO1lBQzlELE9BQ0ssSUFBSTJDLFNBQVNLLE1BQU0sR0FBRyxHQUFHO2dCQUMxQjFELE9BQU93QyxrQkFBa0IsQ0FBQywrQkFBK0IsUUFBUTlCO1lBQ3JFO1lBQ0EsT0FBTyxJQUFJLENBQUN1QixTQUFTLENBQUNvQixRQUFRLENBQUMsRUFBRSxDQUFDO1FBQ3RDO1FBQ0Esa0RBQWtEO1FBQ2xELE1BQU1NLFNBQVMsSUFBSSxDQUFDMUIsU0FBUyxDQUFDckMsd0RBQWdCQSxDQUFDZ0UsVUFBVSxDQUFDViwwQkFBMEJkLE1BQU0sR0FBRztRQUM3RixJQUFJLENBQUN1QixRQUFRO1lBQ1QzRCxPQUFPd0Msa0JBQWtCLENBQUMsd0JBQXdCLGFBQWFVO1FBQ25FO1FBQ0EsT0FBT1M7SUFDWDtJQUNBLDJFQUEyRTtJQUMzRUUsU0FBU0Msc0JBQXNCLEVBQUU7UUFDN0IsSUFBSTlFLGlFQUFXQSxDQUFDOEUseUJBQXlCO1lBQ3JDLE1BQU1DLFlBQVlELHVCQUF1QkUsV0FBVztZQUNwRCxJQUFLLE1BQU10RCxRQUFRLElBQUksQ0FBQ3dCLE1BQU0sQ0FBRTtnQkFDNUIsSUFBSTZCLGNBQWMsSUFBSSxDQUFDaEIsYUFBYSxDQUFDckMsT0FBTztvQkFDeEMsT0FBTyxJQUFJLENBQUN3QixNQUFNLENBQUN4QixLQUFLO2dCQUM1QjtZQUNKO1lBQ0FWLE9BQU93QyxrQkFBa0IsQ0FBQyxxQkFBcUIsYUFBYXVCO1FBQ2hFO1FBQ0EsMEVBQTBFO1FBQzFFLElBQUlELHVCQUF1QlgsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHO1lBQzVDLE1BQU16QyxPQUFPb0QsdUJBQXVCVixJQUFJO1lBQ3hDLE1BQU1DLFdBQVdDLE9BQU9DLElBQUksQ0FBQyxJQUFJLENBQUNyQixNQUFNLEVBQUVQLE1BQU0sQ0FBQyxDQUFDNkIsSUFBT0EsRUFBRUMsS0FBSyxDQUFDLElBQUksU0FBUyxJQUFHLENBQUMsRUFBRSxLQUFLL0M7WUFDekYsSUFBSTJDLFNBQVNLLE1BQU0sS0FBSyxHQUFHO2dCQUN2QjFELE9BQU93QyxrQkFBa0IsQ0FBQyxxQkFBcUIsUUFBUTlCO1lBQzNELE9BQ0ssSUFBSTJDLFNBQVNLLE1BQU0sR0FBRyxHQUFHO2dCQUMxQjFELE9BQU93QyxrQkFBa0IsQ0FBQyw0QkFBNEIsUUFBUTlCO1lBQ2xFO1lBQ0EsT0FBTyxJQUFJLENBQUN3QixNQUFNLENBQUNtQixRQUFRLENBQUMsRUFBRSxDQUFDO1FBQ25DO1FBQ0Esa0RBQWtEO1FBQ2xELE1BQU1NLFNBQVMsSUFBSSxDQUFDekIsTUFBTSxDQUFDekMscURBQWFBLENBQUNtRSxVQUFVLENBQUNFLHdCQUF3QjFCLE1BQU0sR0FBRztRQUNyRixJQUFJLENBQUN1QixRQUFRO1lBQ1QzRCxPQUFPd0Msa0JBQWtCLENBQUMscUJBQXFCLGFBQWFzQjtRQUNoRTtRQUNBLE9BQU9IO0lBQ1g7SUFDQSw2RUFBNkU7SUFDN0VNLFNBQVNmLHdCQUF3QixFQUFFO1FBQy9CLElBQUlsRSxpRUFBV0EsQ0FBQ2tFLDJCQUEyQjtZQUN2QyxNQUFNSixhQUFhekQsb0VBQVNBLENBQUMsSUFBSSxDQUFDOEIsV0FBVyxFQUFFO1lBQy9DLElBQUssTUFBTVQsUUFBUSxJQUFJLENBQUN5QixNQUFNLENBQUU7Z0JBQzVCLE1BQU1wQixRQUFRLElBQUksQ0FBQ29CLE1BQU0sQ0FBQ3pCLEtBQUs7Z0JBQy9CLElBQUl3Qyw2QkFBNkJKLFdBQVcvQixRQUFRO29CQUNoRCxPQUFPLElBQUksQ0FBQ29CLE1BQU0sQ0FBQ3pCLEtBQUs7Z0JBQzVCO1lBQ0o7WUFDQVYsT0FBT3dDLGtCQUFrQixDQUFDLHFCQUFxQixXQUFXVTtRQUM5RDtRQUNBLDBFQUEwRTtRQUMxRSxJQUFJQSx5QkFBeUJDLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRztZQUM5QyxNQUFNekMsT0FBT3dDLHlCQUF5QkUsSUFBSTtZQUMxQyxNQUFNQyxXQUFXQyxPQUFPQyxJQUFJLENBQUMsSUFBSSxDQUFDcEIsTUFBTSxFQUFFUixNQUFNLENBQUMsQ0FBQzZCLElBQU9BLEVBQUVDLEtBQUssQ0FBQyxJQUFJLFNBQVMsSUFBRyxDQUFDLEVBQUUsS0FBSy9DO1lBQ3pGLElBQUkyQyxTQUFTSyxNQUFNLEtBQUssR0FBRztnQkFDdkIxRCxPQUFPd0Msa0JBQWtCLENBQUMscUJBQXFCLFFBQVE5QjtZQUMzRCxPQUNLLElBQUkyQyxTQUFTSyxNQUFNLEdBQUcsR0FBRztnQkFDMUIxRCxPQUFPd0Msa0JBQWtCLENBQUMsNEJBQTRCLFFBQVE5QjtZQUNsRTtZQUNBLE9BQU8sSUFBSSxDQUFDeUIsTUFBTSxDQUFDa0IsUUFBUSxDQUFDLEVBQUUsQ0FBQztRQUNuQztRQUNBLGtEQUFrRDtRQUNsRCxNQUFNTSxTQUFTLElBQUksQ0FBQ3hCLE1BQU0sQ0FBQ3ZDLHdEQUFnQkEsQ0FBQ2dFLFVBQVUsQ0FBQ1YsMEJBQTBCZCxNQUFNLEdBQUc7UUFDMUYsSUFBSSxDQUFDdUIsUUFBUTtZQUNUM0QsT0FBT3dDLGtCQUFrQixDQUFDLHFCQUFxQixhQUFhVTtRQUNoRTtRQUNBLE9BQU9TO0lBQ1g7SUFDQSxnRkFBZ0Y7SUFDaEZiLFdBQVdyQixRQUFRLEVBQUU7UUFDakIsSUFBSSxPQUFRQSxhQUFjLFVBQVU7WUFDaEMsSUFBSTtnQkFDQUEsV0FBVyxJQUFJLENBQUN3QixXQUFXLENBQUN4QjtZQUNoQyxFQUNBLE9BQU9WLE9BQU87Z0JBQ1YsSUFBSTtvQkFDQVUsV0FBVyxJQUFJLENBQUN3QyxRQUFRLENBQUN4QztnQkFDN0IsRUFDQSxPQUFPeUMsR0FBRztvQkFDTixNQUFNbkQ7Z0JBQ1Y7WUFDSjtRQUNKO1FBQ0EsT0FBTzFCLG9FQUFTQSxDQUFDLElBQUksQ0FBQzhCLFdBQVcsRUFBRSxjQUFjTTtJQUNyRDtJQUNBLHlFQUF5RTtJQUN6RXNCLGNBQWNDLGFBQWEsRUFBRTtRQUN6QixJQUFJLE9BQVFBLGtCQUFtQixVQUFVO1lBQ3JDQSxnQkFBZ0IsSUFBSSxDQUFDYSxRQUFRLENBQUNiO1FBQ2xDO1FBQ0EsT0FBTzNELG9FQUFTQSxDQUFDLElBQUksQ0FBQzhCLFdBQVcsRUFBRSxpQkFBaUI2QjtJQUN4RDtJQUNBbUIsY0FBY0MsTUFBTSxFQUFFQyxJQUFJLEVBQUU7UUFDeEIsT0FBTyxJQUFJLENBQUNDLFNBQVMsQ0FBQ0MsTUFBTSxDQUFDSCxRQUFRQztJQUN6QztJQUNBRyxjQUFjSixNQUFNLEVBQUVLLE1BQU0sRUFBRTtRQUMxQixPQUFPLElBQUksQ0FBQ0gsU0FBUyxDQUFDSSxNQUFNLENBQUNOLFFBQVFLO0lBQ3pDO0lBQ0FFLGFBQWFGLE1BQU0sRUFBRTtRQUNqQixPQUFPLElBQUksQ0FBQ0QsYUFBYSxDQUFDLElBQUksQ0FBQ3pDLE1BQU0sQ0FBQ3BCLE1BQU0sRUFBRThELFVBQVUsRUFBRTtJQUM5RDtJQUNBRyxrQkFBa0JuRCxRQUFRLEVBQUU0QyxJQUFJLEVBQUU7UUFDOUIsSUFBSSxPQUFRNUMsYUFBYyxVQUFVO1lBQ2hDQSxXQUFXLElBQUksQ0FBQ3dDLFFBQVEsQ0FBQ3hDO1FBQzdCO1FBQ0EsTUFBTW9ELFFBQVFsRyw4REFBUUEsQ0FBQzBGO1FBQ3ZCLElBQUl2Riw2REFBT0EsQ0FBQytGLE1BQU1DLEtBQUssQ0FBQyxHQUFHLFFBQVEsSUFBSSxDQUFDaEMsVUFBVSxDQUFDckIsV0FBVztZQUMxRHpCLE9BQU93QyxrQkFBa0IsQ0FBQyxDQUFDLG9DQUFvQyxFQUFFZixTQUFTZixJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsUUFBUTVCLDZEQUFPQSxDQUFDK0Y7UUFDdkc7UUFDQSxPQUFPLElBQUksQ0FBQ1YsYUFBYSxDQUFDMUMsU0FBU2QsTUFBTSxFQUFFa0UsTUFBTUMsS0FBSyxDQUFDO0lBQzNEO0lBQ0FDLGtCQUFrQnRELFFBQVEsRUFBRWdELE1BQU0sRUFBRTtRQUNoQyxJQUFJLE9BQVFoRCxhQUFjLFVBQVU7WUFDaENBLFdBQVcsSUFBSSxDQUFDd0MsUUFBUSxDQUFDeEM7UUFDN0I7UUFDQSxPQUFPM0MsNkRBQU9BLENBQUNGLDREQUFNQSxDQUFDO1lBQ2xCLElBQUksQ0FBQ2tFLFVBQVUsQ0FBQ3JCO1lBQ2hCLElBQUksQ0FBQytDLGFBQWEsQ0FBQy9DLFNBQVNkLE1BQU0sRUFBRThELFVBQVUsRUFBRTtTQUNuRDtJQUNMO0lBQ0EscURBQXFEO0lBQ3JETyxtQkFBbUJDLGdCQUFnQixFQUFFWixJQUFJLEVBQUU7UUFDdkMsSUFBSSxPQUFRWSxxQkFBc0IsVUFBVTtZQUN4Q0EsbUJBQW1CLElBQUksQ0FBQ2hDLFdBQVcsQ0FBQ2dDO1FBQ3hDO1FBQ0EsTUFBTUosUUFBUWxHLDhEQUFRQSxDQUFDMEY7UUFDdkIsSUFBSXZGLDZEQUFPQSxDQUFDK0YsTUFBTUMsS0FBSyxDQUFDLEdBQUcsUUFBUSxJQUFJLENBQUNoQyxVQUFVLENBQUNtQyxtQkFBbUI7WUFDbEVqRixPQUFPd0Msa0JBQWtCLENBQUMsQ0FBQyx1Q0FBdUMsRUFBRXlDLGlCQUFpQnZFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxRQUFRNUIsNkRBQU9BLENBQUMrRjtRQUNsSDtRQUNBLE9BQU8sSUFBSSxDQUFDVixhQUFhLENBQUNjLGlCQUFpQnRFLE1BQU0sRUFBRWtFLE1BQU1DLEtBQUssQ0FBQztJQUNuRTtJQUNBLHFEQUFxRDtJQUNyREksbUJBQW1CRCxnQkFBZ0IsRUFBRVIsTUFBTSxFQUFFO1FBQ3pDLElBQUksT0FBUVEscUJBQXNCLFVBQVU7WUFDeENBLG1CQUFtQixJQUFJLENBQUNoQyxXQUFXLENBQUNnQztRQUN4QztRQUNBLE9BQU9uRyw2REFBT0EsQ0FBQ0YsNERBQU1BLENBQUM7WUFDbEIsSUFBSSxDQUFDa0UsVUFBVSxDQUFDbUM7WUFDaEIsSUFBSSxDQUFDVCxhQUFhLENBQUNTLGlCQUFpQnRFLE1BQU0sRUFBRThELFVBQVUsRUFBRTtTQUMzRDtJQUNMO0lBQ0EsOERBQThEO0lBQzlEVSxxQkFBcUJGLGdCQUFnQixFQUFFWixJQUFJLEVBQUU7UUFDekMsSUFBSSxPQUFRWSxxQkFBc0IsVUFBVTtZQUN4Q0EsbUJBQW1CLElBQUksQ0FBQ2hDLFdBQVcsQ0FBQ2dDO1FBQ3hDO1FBQ0EsSUFBSUosUUFBUWxHLDhEQUFRQSxDQUFDMEY7UUFDckIsSUFBSXpELFNBQVM7UUFDYixJQUFJd0UsVUFBVTtRQUNkLElBQUlDLFlBQVk7UUFDaEIsSUFBSUMsWUFBWTtRQUNoQixJQUFJQyxpQkFBaUI7UUFDckIsT0FBUVYsTUFBTW5CLE1BQU0sR0FBRyxJQUFJLENBQUNZLFNBQVMsQ0FBQ2tCLFlBQVk7WUFDOUMsS0FBSztnQkFDRCxJQUFJO29CQUNBLE9BQU8sSUFBSSxDQUFDbEIsU0FBUyxDQUFDQyxNQUFNLENBQUNVLGlCQUFpQlEsT0FBTyxFQUFFWjtnQkFDM0QsRUFDQSxPQUFPOUQsT0FBTyxDQUFFO2dCQUNoQjtZQUNKLEtBQUs7Z0JBQUc7b0JBQ0osTUFBTTJFLFdBQVc1Ryw2REFBT0EsQ0FBQytGLE1BQU1DLEtBQUssQ0FBQyxHQUFHO29CQUN4QyxNQUFNYSxVQUFVbkYsYUFBYSxDQUFDa0YsU0FBUztvQkFDdkMsSUFBSUMsU0FBUzt3QkFDVE4sWUFBWSxJQUFJLENBQUNmLFNBQVMsQ0FBQ0MsTUFBTSxDQUFDb0IsUUFBUWhGLE1BQU0sRUFBRWtFLE1BQU1DLEtBQUssQ0FBQzt3QkFDOURRLFlBQVlLLFFBQVFqRixJQUFJO3dCQUN4QjZFLGlCQUFpQkksUUFBUWxGLFNBQVM7d0JBQ2xDLElBQUlrRixRQUFRL0UsTUFBTSxFQUFFOzRCQUNoQkEsU0FBU3lFLFNBQVMsQ0FBQyxFQUFFO3dCQUN6Qjt3QkFDQSxJQUFJQyxjQUFjLFNBQVM7NEJBQ3ZCRixVQUFVLENBQUMseUVBQXlFLEVBQUU5RCxLQUFLb0IsU0FBUyxDQUFDMkMsU0FBUyxDQUFDLEVBQUUsRUFBRSxDQUFDO3dCQUN4SCxPQUNLLElBQUlDLGNBQWMsU0FBUzs0QkFDNUJGLFVBQVUsQ0FBQyxzRUFBc0UsRUFBRUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDO3dCQUNyRztvQkFDSixPQUNLO3dCQUNELElBQUk7NEJBQ0EsTUFBTXRFLFFBQVEsSUFBSSxDQUFDa0QsUUFBUSxDQUFDeUI7NEJBQzVCTCxZQUFZLElBQUksQ0FBQ2YsU0FBUyxDQUFDQyxNQUFNLENBQUN4RCxNQUFNSixNQUFNLEVBQUVrRSxNQUFNQyxLQUFLLENBQUM7NEJBQzVEUSxZQUFZdkUsTUFBTUwsSUFBSTs0QkFDdEI2RSxpQkFBaUJ4RSxNQUFNcUIsTUFBTTt3QkFDakMsRUFDQSxPQUFPckIsT0FBTyxDQUFFO29CQUNwQjtvQkFDQTtnQkFDSjtRQUNKO1FBQ0EsT0FBT2YsT0FBTzRGLFVBQVUsQ0FBQywwQkFBMEJSLFNBQVN0Rix5REFBTUEsQ0FBQ3FDLE1BQU0sQ0FBQzBELGNBQWMsRUFBRTtZQUN0RkMsUUFBUWIsaUJBQWlCN0MsTUFBTTtZQUMvQmlDLE1BQU12Riw2REFBT0EsQ0FBQ3VGO1lBQU9nQjtZQUFXQztZQUFXQztZQUFnQjNFO1FBQy9EO0lBQ0o7SUFDQSw0REFBNEQ7SUFDNURtRixxQkFBcUJkLGdCQUFnQixFQUFFUixNQUFNLEVBQUU7UUFDM0MsSUFBSSxPQUFRUSxxQkFBc0IsVUFBVTtZQUN4Q0EsbUJBQW1CLElBQUksQ0FBQ2hDLFdBQVcsQ0FBQ2dDO1FBQ3hDO1FBQ0EsT0FBT25HLDZEQUFPQSxDQUFDLElBQUksQ0FBQ3dGLFNBQVMsQ0FBQ0ksTUFBTSxDQUFDTyxpQkFBaUJRLE9BQU8sRUFBRWhCLFVBQVUsRUFBRTtJQUMvRTtJQUNBLGdGQUFnRjtJQUNoRnVCLG1CQUFtQmhELGFBQWEsRUFBRXlCLE1BQU0sRUFBRTtRQUN0QyxJQUFJLE9BQVF6QixrQkFBbUIsVUFBVTtZQUNyQ0EsZ0JBQWdCLElBQUksQ0FBQ2EsUUFBUSxDQUFDYjtRQUNsQztRQUNBLElBQUl5QixPQUFPZixNQUFNLEdBQUdWLGNBQWNyQyxNQUFNLENBQUMrQyxNQUFNLEVBQUU7WUFDN0MxRCxPQUFPNEYsVUFBVSxDQUFDLDRCQUE0QjVDLGNBQWNaLE1BQU0sSUFBSXRDLHlEQUFNQSxDQUFDcUMsTUFBTSxDQUFDOEQsbUJBQW1CLEVBQUU7Z0JBQ3JHQyxVQUFVO2dCQUNWNUYsT0FBT21FO1lBQ1g7UUFDSjtRQUNBLElBQUkwQixTQUFTLEVBQUU7UUFDZixJQUFJLENBQUNuRCxjQUFjb0QsU0FBUyxFQUFFO1lBQzFCRCxPQUFPRSxJQUFJLENBQUMsSUFBSSxDQUFDdEQsYUFBYSxDQUFDQztRQUNuQztRQUNBLE1BQU1zRCxjQUFjLENBQUNDLE9BQU9qRztZQUN4QixJQUFJaUcsTUFBTXpFLElBQUksS0FBSyxVQUFVO2dCQUN6QixPQUFPN0MsdURBQUVBLENBQUNxQjtZQUNkLE9BQ0ssSUFBSWlHLE1BQU16RSxJQUFJLEtBQUssU0FBUztnQkFDN0IsT0FBTzVDLG1FQUFTQSxDQUFDSiw2REFBT0EsQ0FBQ3dCO1lBQzdCO1lBQ0EsSUFBSWlHLE1BQU16RSxJQUFJLEtBQUssVUFBVSxPQUFReEIsVUFBVyxXQUFXO2dCQUN2REEsUUFBU0EsUUFBUSxTQUFTO1lBQzlCO1lBQ0EsSUFBSWlHLE1BQU16RSxJQUFJLENBQUMwRSxLQUFLLENBQUMsV0FBVztnQkFDNUJsRyxRQUFRNUIsZ0VBQVNBLENBQUNnRCxJQUFJLENBQUNwQixPQUFPbUcsV0FBVztZQUM3QztZQUNBLDRCQUE0QjtZQUM1QixJQUFJRixNQUFNekUsSUFBSSxLQUFLLFdBQVc7Z0JBQzFCLElBQUksQ0FBQ3dDLFNBQVMsQ0FBQ0ksTUFBTSxDQUFDO29CQUFDO2lCQUFVLEVBQUU7b0JBQUNwRTtpQkFBTTtZQUM5QztZQUNBLE9BQU92QixnRUFBVUEsQ0FBQ0QsNkRBQU9BLENBQUN3QixRQUFRO1FBQ3RDO1FBQ0FtRSxPQUFPN0MsT0FBTyxDQUFDLENBQUN0QixPQUFPb0c7WUFDbkIsSUFBSUgsUUFBUXZELGNBQWNyQyxNQUFNLENBQUMrRixNQUFNO1lBQ3ZDLElBQUksQ0FBQ0gsTUFBTUksT0FBTyxFQUFFO2dCQUNoQixJQUFJckcsU0FBUyxNQUFNO29CQUNmTixPQUFPd0Msa0JBQWtCLENBQUMsc0RBQXVELGNBQWMrRCxNQUFNN0YsSUFBSSxFQUFHSjtnQkFDaEg7Z0JBQ0E7WUFDSjtZQUNBLElBQUlBLFNBQVMsTUFBTTtnQkFDZjZGLE9BQU9FLElBQUksQ0FBQztZQUNoQixPQUNLLElBQUlFLE1BQU1LLFFBQVEsS0FBSyxXQUFXTCxNQUFNSyxRQUFRLEtBQUssU0FBUztnQkFDL0Q1RyxPQUFPd0Msa0JBQWtCLENBQUMsaURBQWtELGNBQWMrRCxNQUFNN0YsSUFBSSxFQUFHSjtZQUMzRyxPQUNLLElBQUl1RyxNQUFNQyxPQUFPLENBQUN4RyxRQUFRO2dCQUMzQjZGLE9BQU9FLElBQUksQ0FBQy9GLE1BQU1rQixHQUFHLENBQUMsQ0FBQ2xCLFFBQVVnRyxZQUFZQyxPQUFPakc7WUFDeEQsT0FDSztnQkFDRDZGLE9BQU9FLElBQUksQ0FBQ0MsWUFBWUMsT0FBT2pHO1lBQ25DO1FBQ0o7UUFDQSwwQkFBMEI7UUFDMUIsTUFBTzZGLE9BQU96QyxNQUFNLElBQUl5QyxNQUFNLENBQUNBLE9BQU96QyxNQUFNLEdBQUcsRUFBRSxLQUFLLEtBQU07WUFDeER5QyxPQUFPWSxHQUFHO1FBQ2Q7UUFDQSxPQUFPWjtJQUNYO0lBQ0FhLGVBQWVoRSxhQUFhLEVBQUV5QixNQUFNLEVBQUU7UUFDbEMsSUFBSSxPQUFRekIsa0JBQW1CLFVBQVU7WUFDckNBLGdCQUFnQixJQUFJLENBQUNhLFFBQVEsQ0FBQ2I7UUFDbEM7UUFDQSxNQUFNbUQsU0FBUyxFQUFFO1FBQ2pCLE1BQU1jLFlBQVksRUFBRTtRQUNwQixNQUFNQyxhQUFhLEVBQUU7UUFDckIsSUFBSSxDQUFDbEUsY0FBY29ELFNBQVMsRUFBRTtZQUMxQkQsT0FBT0UsSUFBSSxDQUFDLElBQUksQ0FBQ3RELGFBQWEsQ0FBQ0M7UUFDbkM7UUFDQSxJQUFJeUIsT0FBT2YsTUFBTSxLQUFLVixjQUFjckMsTUFBTSxDQUFDK0MsTUFBTSxFQUFFO1lBQy9DMUQsT0FBT3dDLGtCQUFrQixDQUFDLG1DQUFtQyxVQUFVaUM7UUFDM0U7UUFDQXpCLGNBQWNyQyxNQUFNLENBQUNpQixPQUFPLENBQUMsQ0FBQzJFLE9BQU9HO1lBQ2pDLE1BQU1wRyxRQUFRbUUsTUFBTSxDQUFDaUMsTUFBTTtZQUMzQixJQUFJSCxNQUFNSSxPQUFPLEVBQUU7Z0JBQ2YsSUFBSUosTUFBTXpFLElBQUksS0FBSyxVQUFVO29CQUN6QnFFLE9BQU9FLElBQUksQ0FBQ3BILHVEQUFFQSxDQUFDcUI7Z0JBQ25CLE9BQ0ssSUFBSWlHLE1BQU16RSxJQUFJLEtBQUssU0FBUztvQkFDN0JxRSxPQUFPRSxJQUFJLENBQUNuSCxtRUFBU0EsQ0FBQ29CO2dCQUMxQixPQUNLLElBQUlpRyxNQUFNSyxRQUFRLEtBQUssV0FBV0wsTUFBTUssUUFBUSxLQUFLLFNBQVM7b0JBQy9ELFFBQVE7b0JBQ1IsTUFBTSxJQUFJM0YsTUFBTTtnQkFDcEIsT0FDSztvQkFDRGtGLE9BQU9FLElBQUksQ0FBQyxJQUFJLENBQUMvQixTQUFTLENBQUNJLE1BQU0sQ0FBQzt3QkFBQzZCLE1BQU16RSxJQUFJO3FCQUFDLEVBQUU7d0JBQUN4QjtxQkFBTTtnQkFDM0Q7WUFDSixPQUNLO2dCQUNEMkcsVUFBVVosSUFBSSxDQUFDRTtnQkFDZlcsV0FBV2IsSUFBSSxDQUFDL0Y7WUFDcEI7UUFDSjtRQUNBLE9BQU87WUFDSCtELE1BQU0sSUFBSSxDQUFDQyxTQUFTLENBQUNJLE1BQU0sQ0FBQ3VDLFdBQVdDO1lBQ3ZDZixRQUFRQTtRQUNaO0lBQ0o7SUFDQSx3REFBd0Q7SUFDeERnQixlQUFlbkUsYUFBYSxFQUFFcUIsSUFBSSxFQUFFOEIsTUFBTSxFQUFFO1FBQ3hDLElBQUksT0FBUW5ELGtCQUFtQixVQUFVO1lBQ3JDQSxnQkFBZ0IsSUFBSSxDQUFDYSxRQUFRLENBQUNiO1FBQ2xDO1FBQ0EsSUFBSW1ELFVBQVUsUUFBUSxDQUFDbkQsY0FBY29ELFNBQVMsRUFBRTtZQUM1QyxJQUFJZ0IsWUFBWSxJQUFJLENBQUNyRSxhQUFhLENBQUNDO1lBQ25DLElBQUksQ0FBQ2hFLGlFQUFXQSxDQUFDbUgsTUFBTSxDQUFDLEVBQUUsRUFBRSxPQUFPQSxNQUFNLENBQUMsRUFBRSxDQUFDbkMsV0FBVyxPQUFPb0QsV0FBVztnQkFDdEVwSCxPQUFPNEYsVUFBVSxDQUFDLDJCQUEyQjlGLHlEQUFNQSxDQUFDcUMsTUFBTSxDQUFDa0YsZ0JBQWdCLEVBQUU7b0JBQUVuQixVQUFVO29CQUFhb0IsVUFBVUY7b0JBQVc5RyxPQUFPNkYsTUFBTSxDQUFDLEVBQUU7Z0JBQUM7WUFDaEo7WUFDQUEsU0FBU0EsT0FBT3JCLEtBQUssQ0FBQztRQUMxQjtRQUNBLElBQUk2QixVQUFVLEVBQUU7UUFDaEIsSUFBSVksYUFBYSxFQUFFO1FBQ25CLElBQUlDLFVBQVUsRUFBRTtRQUNoQnhFLGNBQWNyQyxNQUFNLENBQUNpQixPQUFPLENBQUMsQ0FBQzJFLE9BQU9HO1lBQ2pDLElBQUlILE1BQU1JLE9BQU8sRUFBRTtnQkFDZixJQUFJSixNQUFNekUsSUFBSSxLQUFLLFlBQVl5RSxNQUFNekUsSUFBSSxLQUFLLFdBQVd5RSxNQUFNSyxRQUFRLEtBQUssV0FBV0wsTUFBTUssUUFBUSxLQUFLLFNBQVM7b0JBQy9HRCxRQUFRTixJQUFJLENBQUN4RyxpREFBU0EsQ0FBQzRILFVBQVUsQ0FBQzt3QkFBRTNGLE1BQU07d0JBQVdwQixNQUFNNkYsTUFBTTdGLElBQUk7b0JBQUM7b0JBQ3RFOEcsUUFBUW5CLElBQUksQ0FBQztnQkFDakIsT0FDSztvQkFDRE0sUUFBUU4sSUFBSSxDQUFDRTtvQkFDYmlCLFFBQVFuQixJQUFJLENBQUM7Z0JBQ2pCO1lBQ0osT0FDSztnQkFDRGtCLFdBQVdsQixJQUFJLENBQUNFO2dCQUNoQmlCLFFBQVFuQixJQUFJLENBQUM7WUFDakI7UUFDSjtRQUNBLElBQUlxQixnQkFBZ0IsVUFBVyxPQUFRLElBQUksQ0FBQ3BELFNBQVMsQ0FBQ0MsTUFBTSxDQUFDb0MsU0FBUy9ILDREQUFNQSxDQUFDdUgsV0FBVztRQUN4RixJQUFJd0IsbUJBQW1CLElBQUksQ0FBQ3JELFNBQVMsQ0FBQ0MsTUFBTSxDQUFDZ0QsWUFBWWxELE1BQU07UUFDL0QsSUFBSVYsU0FBUyxFQUFFO1FBQ2YsSUFBSWlFLGtCQUFrQixHQUFHQyxlQUFlO1FBQ3hDN0UsY0FBY3JDLE1BQU0sQ0FBQ2lCLE9BQU8sQ0FBQyxDQUFDMkUsT0FBT0c7WUFDakMsSUFBSUgsTUFBTUksT0FBTyxFQUFFO2dCQUNmLElBQUllLGlCQUFpQixNQUFNO29CQUN2Qi9ELE1BQU0sQ0FBQytDLE1BQU0sR0FBRyxJQUFJdEcsUUFBUTt3QkFBRUcsWUFBWTt3QkFBTXVILE1BQU07b0JBQUs7Z0JBQy9ELE9BQ0ssSUFBSU4sT0FBTyxDQUFDZCxNQUFNLEVBQUU7b0JBQ3JCL0MsTUFBTSxDQUFDK0MsTUFBTSxHQUFHLElBQUl0RyxRQUFRO3dCQUFFRyxZQUFZO3dCQUFNdUgsTUFBTUosYUFBYSxDQUFDRyxlQUFlO29CQUFDO2dCQUN4RixPQUNLO29CQUNELElBQUk7d0JBQ0FsRSxNQUFNLENBQUMrQyxNQUFNLEdBQUdnQixhQUFhLENBQUNHLGVBQWU7b0JBQ2pELEVBQ0EsT0FBTzlHLE9BQU87d0JBQ1Y0QyxNQUFNLENBQUMrQyxNQUFNLEdBQUczRjtvQkFDcEI7Z0JBQ0o7WUFDSixPQUNLO2dCQUNELElBQUk7b0JBQ0E0QyxNQUFNLENBQUMrQyxNQUFNLEdBQUdpQixnQkFBZ0IsQ0FBQ0Msa0JBQWtCO2dCQUN2RCxFQUNBLE9BQU83RyxPQUFPO29CQUNWNEMsTUFBTSxDQUFDK0MsTUFBTSxHQUFHM0Y7Z0JBQ3BCO1lBQ0o7WUFDQSw2Q0FBNkM7WUFDN0MsSUFBSXdGLE1BQU03RixJQUFJLElBQUlpRCxNQUFNLENBQUM0QyxNQUFNN0YsSUFBSSxDQUFDLElBQUksTUFBTTtnQkFDMUMsTUFBTUosUUFBUXFELE1BQU0sQ0FBQytDLE1BQU07Z0JBQzNCLDBDQUEwQztnQkFDMUMsSUFBSXBHLGlCQUFpQlcsT0FBTztvQkFDeEJxQyxPQUFPeUUsY0FBYyxDQUFDcEUsUUFBUTRDLE1BQU03RixJQUFJLEVBQUU7d0JBQ3RDc0gsWUFBWTt3QkFDWkMsS0FBSzs0QkFBUSxNQUFNcEgsZ0JBQWdCLENBQUMsU0FBUyxFQUFFUyxLQUFLb0IsU0FBUyxDQUFDNkQsTUFBTTdGLElBQUksRUFBRSxDQUFDLEVBQUVKO3dCQUFRO29CQUN6RjtnQkFDSixPQUNLO29CQUNEcUQsTUFBTSxDQUFDNEMsTUFBTTdGLElBQUksQ0FBQyxHQUFHSjtnQkFDekI7WUFDSjtRQUNKO1FBQ0EsZ0RBQWdEO1FBQ2hELElBQUssSUFBSTRILElBQUksR0FBR0EsSUFBSXZFLE9BQU9ELE1BQU0sRUFBRXdFLElBQUs7WUFDcEMsTUFBTTVILFFBQVFxRCxNQUFNLENBQUN1RSxFQUFFO1lBQ3ZCLElBQUk1SCxpQkFBaUJXLE9BQU87Z0JBQ3hCcUMsT0FBT3lFLGNBQWMsQ0FBQ3BFLFFBQVF1RSxHQUFHO29CQUM3QkYsWUFBWTtvQkFDWkMsS0FBSzt3QkFBUSxNQUFNcEgsZ0JBQWdCLENBQUMsTUFBTSxFQUFFcUgsRUFBRSxDQUFDLEVBQUU1SDtvQkFBUTtnQkFDN0Q7WUFDSjtRQUNKO1FBQ0EsT0FBT2dELE9BQU82RSxNQUFNLENBQUN4RTtJQUN6QjtJQUNBLHdFQUF3RTtJQUN4RSxtREFBbUQ7SUFDbkR5RSxpQkFBaUJDLEVBQUUsRUFBRTtRQUNqQixJQUFJNUcsV0FBVyxJQUFJLENBQUN3QixXQUFXLENBQUNvRixHQUFHaEUsSUFBSSxDQUFDaUUsU0FBUyxDQUFDLEdBQUcsSUFBSXRFLFdBQVc7UUFDcEUsSUFBSSxDQUFDdkMsVUFBVTtZQUNYLE9BQU87UUFDWDtRQUNBLE9BQU8sSUFBSXZCLHVCQUF1QjtZQUM5QnFJLE1BQU0sSUFBSSxDQUFDakUsU0FBUyxDQUFDQyxNQUFNLENBQUM5QyxTQUFTZCxNQUFNLEVBQUUsT0FBTzBILEdBQUdoRSxJQUFJLENBQUNpRSxTQUFTLENBQUM7WUFDdEVyRCxrQkFBa0J4RDtZQUNsQmYsTUFBTWUsU0FBU2YsSUFBSTtZQUNuQkQsV0FBV2dCLFNBQVNXLE1BQU07WUFDMUJHLFNBQVMsSUFBSSxDQUFDTyxVQUFVLENBQUNyQjtZQUN6Qm5CLE9BQU81QixnRUFBU0EsQ0FBQ2dELElBQUksQ0FBQzJHLEdBQUcvSCxLQUFLLElBQUk7UUFDdEM7SUFDSjtJQUNBLFFBQVE7SUFDUixzQ0FBc0M7SUFDdEMsb0VBQW9FO0lBQ3BFLDBDQUEwQztJQUMxQ2tJLFNBQVNDLEdBQUcsRUFBRTtRQUNWLElBQUloSCxXQUFXLElBQUksQ0FBQ29DLFFBQVEsQ0FBQzRFLElBQUl0QyxNQUFNLENBQUMsRUFBRTtRQUMxQyxJQUFJLENBQUMxRSxZQUFZQSxTQUFTMkUsU0FBUyxFQUFFO1lBQ2pDLE9BQU87UUFDWDtRQUNBLDBGQUEwRjtRQUMxRixpRkFBaUY7UUFDakYsK0RBQStEO1FBQy9ELE9BQU8sSUFBSW5HLGVBQWU7WUFDdEIrQyxlQUFldkI7WUFDZmYsTUFBTWUsU0FBU2YsSUFBSTtZQUNuQkQsV0FBV2dCLFNBQVNXLE1BQU07WUFDMUJzRyxPQUFPLElBQUksQ0FBQzNGLGFBQWEsQ0FBQ3RCO1lBQzFCOEcsTUFBTSxJQUFJLENBQUNwQixjQUFjLENBQUMxRixVQUFVZ0gsSUFBSXBFLElBQUksRUFBRW9FLElBQUl0QyxNQUFNO1FBQzVEO0lBQ0o7SUFDQXdDLFdBQVd0RSxJQUFJLEVBQUU7UUFDYixNQUFNdUUsVUFBVTlKLDZEQUFPQSxDQUFDdUY7UUFDeEIsSUFBSTVDLFdBQVcsSUFBSSxDQUFDd0MsUUFBUSxDQUFDMkUsUUFBUU4sU0FBUyxDQUFDLEdBQUcsSUFBSXRFLFdBQVc7UUFDakUsSUFBSSxDQUFDdkMsVUFBVTtZQUNYLE9BQU87UUFDWDtRQUNBLE9BQU8sSUFBSXRCLGlCQUFpQjtZQUN4Qm9JLE1BQU0sSUFBSSxDQUFDakUsU0FBUyxDQUFDQyxNQUFNLENBQUM5QyxTQUFTZCxNQUFNLEVBQUUsT0FBT2lJLFFBQVFOLFNBQVMsQ0FBQztZQUN0RU8sZUFBZXBIO1lBQ2ZmLE1BQU1lLFNBQVNmLElBQUk7WUFDbkJELFdBQVdnQixTQUFTVyxNQUFNO1lBQzFCRyxTQUFTLElBQUksQ0FBQ08sVUFBVSxDQUFDckI7UUFDN0I7SUFDSjtJQUNBOzs7Ozs7Ozs7O0lBVUEsR0FDQSxPQUFPcUgsWUFBWXhJLEtBQUssRUFBRTtRQUN0QixPQUFPLENBQUMsQ0FBRUEsQ0FBQUEsU0FBU0EsTUFBTXlJLFlBQVk7SUFDekM7QUFDSixFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NsaW1lLWJldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2ludGVyZmFjZS5qcz81Y2I1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hZGRyZXNzXCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgY29uY2F0LCBoZXhEYXRhU2xpY2UsIGhleGxpZnksIGhleFplcm9QYWQsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBpZCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9oYXNoXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qva2VjY2FrMjU2XCI7XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSwgRGVzY3JpcHRpb24sIGdldFN0YXRpYyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBkZWZhdWx0QWJpQ29kZXIgfSBmcm9tIFwiLi9hYmktY29kZXJcIjtcbmltcG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzIH0gZnJvbSBcIi4vY29kZXJzL2Fic3RyYWN0LWNvZGVyXCI7XG5pbXBvcnQgeyBDb25zdHJ1Y3RvckZyYWdtZW50LCBFdmVudEZyYWdtZW50LCBGb3JtYXRUeXBlcywgRnJhZ21lbnQsIEZ1bmN0aW9uRnJhZ21lbnQsIFBhcmFtVHlwZSB9IGZyb20gXCIuL2ZyYWdtZW50c1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuZXhwb3J0IHsgY2hlY2tSZXN1bHRFcnJvcnMgfTtcbmV4cG9ydCBjbGFzcyBMb2dEZXNjcmlwdGlvbiBleHRlbmRzIERlc2NyaXB0aW9uIHtcbn1cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uIGV4dGVuZHMgRGVzY3JpcHRpb24ge1xufVxuZXhwb3J0IGNsYXNzIEVycm9yRGVzY3JpcHRpb24gZXh0ZW5kcyBEZXNjcmlwdGlvbiB7XG59XG5leHBvcnQgY2xhc3MgSW5kZXhlZCBleHRlbmRzIERlc2NyaXB0aW9uIHtcbiAgICBzdGF0aWMgaXNJbmRleGVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNJbmRleGVkKTtcbiAgICB9XG59XG5jb25zdCBCdWlsdGluRXJyb3JzID0ge1xuICAgIFwiMHgwOGMzNzlhMFwiOiB7IHNpZ25hdHVyZTogXCJFcnJvcihzdHJpbmcpXCIsIG5hbWU6IFwiRXJyb3JcIiwgaW5wdXRzOiBbXCJzdHJpbmdcIl0sIHJlYXNvbjogdHJ1ZSB9LFxuICAgIFwiMHg0ZTQ4N2I3MVwiOiB7IHNpZ25hdHVyZTogXCJQYW5pYyh1aW50MjU2KVwiLCBuYW1lOiBcIlBhbmljXCIsIGlucHV0czogW1widWludDI1NlwiXSB9XG59O1xuZnVuY3Rpb24gd3JhcEFjY2Vzc0Vycm9yKHByb3BlcnR5LCBlcnJvcikge1xuICAgIGNvbnN0IHdyYXAgPSBuZXcgRXJyb3IoYGRlZmVycmVkIGVycm9yIGR1cmluZyBBQkkgZGVjb2RpbmcgdHJpZ2dlcmVkIGFjY2Vzc2luZyAke3Byb3BlcnR5fWApO1xuICAgIHdyYXAuZXJyb3IgPSBlcnJvcjtcbiAgICByZXR1cm4gd3JhcDtcbn1cbi8qXG5mdW5jdGlvbiBjaGVja05hbWVzKGZyYWdtZW50OiBGcmFnbWVudCwgdHlwZTogXCJpbnB1dFwiIHwgXCJvdXRwdXRcIiwgcGFyYW1zOiBBcnJheTxQYXJhbVR5cGU+KTogdm9pZCB7XG4gICAgcGFyYW1zLnJlZHVjZSgoYWNjdW0sIHBhcmFtKSA9PiB7XG4gICAgICAgIGlmIChwYXJhbS5uYW1lKSB7XG4gICAgICAgICAgICBpZiAoYWNjdW1bcGFyYW0ubmFtZV0pIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBkdXBsaWNhdGUgJHsgdHlwZSB9IHBhcmFtZXRlciAkeyBKU09OLnN0cmluZ2lmeShwYXJhbS5uYW1lKSB9IGluICR7IGZyYWdtZW50LmZvcm1hdChcImZ1bGxcIikgfWAsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWNjdW1bcGFyYW0ubmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2N1bTtcbiAgICB9LCA8eyBbIG5hbWU6IHN0cmluZyBdOiBib29sZWFuIH0+eyB9KTtcbn1cbiovXG5leHBvcnQgY2xhc3MgSW50ZXJmYWNlIHtcbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudHMpIHtcbiAgICAgICAgbGV0IGFiaSA9IFtdO1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudHMpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBhYmkgPSBKU09OLnBhcnNlKGZyYWdtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhYmkgPSBmcmFnbWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJmcmFnbWVudHNcIiwgYWJpLm1hcCgoZnJhZ21lbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tKGZyYWdtZW50KTtcbiAgICAgICAgfSkuZmlsdGVyKChmcmFnbWVudCkgPT4gKGZyYWdtZW50ICE9IG51bGwpKSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2FiaUNvZGVyXCIsIGdldFN0YXRpYyhuZXcudGFyZ2V0LCBcImdldEFiaUNvZGVyXCIpKCkpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImZ1bmN0aW9uc1wiLCB7fSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZXJyb3JzXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJldmVudHNcIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInN0cnVjdHNcIiwge30pO1xuICAgICAgICAvLyBBZGQgYWxsIGZyYWdtZW50cyBieSB0aGVpciBzaWduYXR1cmVcbiAgICAgICAgdGhpcy5mcmFnbWVudHMuZm9yRWFjaCgoZnJhZ21lbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBidWNrZXQgPSBudWxsO1xuICAgICAgICAgICAgc3dpdGNoIChmcmFnbWVudC50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbnN0cnVjdG9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlcGxveSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJkdXBsaWNhdGUgZGVmaW5pdGlvbiAtIGNvbnN0cnVjdG9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJpbnB1dFwiLCBmcmFnbWVudC5pbnB1dHMpO1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImRlcGxveVwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJvdXRwdXRcIiwgKDxGdW5jdGlvbkZyYWdtZW50PmZyYWdtZW50KS5vdXRwdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gdGhpcy5mdW5jdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwiaW5wdXRcIiwgZnJhZ21lbnQuaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gdGhpcy5ldmVudHM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgICAgICBidWNrZXQgPSB0aGlzLmVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICAgICAgaWYgKGJ1Y2tldFtzaWduYXR1cmVdKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJkdXBsaWNhdGUgZGVmaW5pdGlvbiAtIFwiICsgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWNrZXRbc2lnbmF0dXJlXSA9IGZyYWdtZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gSWYgd2UgZG8gbm90IGhhdmUgYSBjb25zdHJ1Y3RvciBhZGQgYSBkZWZhdWx0XG4gICAgICAgIGlmICghdGhpcy5kZXBsb3kpIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZGVwbG95XCIsIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbSh7XG4gICAgICAgICAgICAgICAgcGF5YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb25zdHJ1Y3RvclwiXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfaXNJbnRlcmZhY2VcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFmb3JtYXQpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IEZvcm1hdFR5cGVzLmZ1bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludGVyZmFjZSBkb2VzIG5vdCBzdXBwb3J0IGZvcm1hdHRpbmcgc2lnaGFzaFwiLCBcImZvcm1hdFwiLCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFiaSA9IHRoaXMuZnJhZ21lbnRzLm1hcCgoZnJhZ21lbnQpID0+IGZyYWdtZW50LmZvcm1hdChmb3JtYXQpKTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byByZS1idW5kbGUgdGhlIEpTT04gZnJhZ21lbnRzIGEgYml0XG4gICAgICAgIGlmIChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLmpzb24pIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhYmkubWFwKChqKSA9PiBKU09OLnBhcnNlKGopKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFiaTtcbiAgICB9XG4gICAgLy8gU3ViLWNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoZXNlIHRvIGhhbmRsZSBvdGhlciBibG9ja2NoYWluc1xuICAgIHN0YXRpYyBnZXRBYmlDb2RlcigpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRBYmlDb2RlcjtcbiAgICB9XG4gICAgc3RhdGljIGdldEFkZHJlc3MoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgICB9XG4gICAgc3RhdGljIGdldFNpZ2hhc2goZnJhZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIGhleERhdGFTbGljZShpZChmcmFnbWVudC5mb3JtYXQoKSksIDAsIDQpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0RXZlbnRUb3BpYyhldmVudEZyYWdtZW50KSB7XG4gICAgICAgIHJldHVybiBpZChldmVudEZyYWdtZW50LmZvcm1hdCgpKTtcbiAgICB9XG4gICAgLy8gRmluZCBhIGZ1bmN0aW9uIGRlZmluaXRpb24gYnkgYW55IG1lYW5zIG5lY2Vzc2FyeSAodW5sZXNzIGl0IGlzIGFtYmlndW91cylcbiAgICBnZXRGdW5jdGlvbihuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpIHtcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLmZ1bmN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2ggPT09IHRoaXMuZ2V0U2lnaGFzaChuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mdW5jdGlvbnNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGZ1bmN0aW9uXCIsIFwic2lnaGFzaFwiLCBuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2guaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoLnRyaW0oKTtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nID0gT2JqZWN0LmtleXModGhpcy5mdW5jdGlvbnMpLmZpbHRlcigoZikgPT4gKGYuc3BsaXQoXCIoXCIgLyogZml4OikgKi8pWzBdID09PSBuYW1lKSk7XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGZ1bmN0aW9uXCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoaW5nLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibXVsdGlwbGUgbWF0Y2hpbmcgZnVuY3Rpb25zXCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bmN0aW9uc1ttYXRjaGluZ1swXV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5mdW5jdGlvbnNbRnVuY3Rpb25GcmFnbWVudC5mcm9tU3RyaW5nKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCkuZm9ybWF0KCldO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGZ1bmN0aW9uXCIsIFwic2lnbmF0dXJlXCIsIG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRmluZCBhbiBldmVudCBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXG4gICAgZ2V0RXZlbnQobmFtZU9yU2lnbmF0dXJlT3JUb3BpYykge1xuICAgICAgICBpZiAoaXNIZXhTdHJpbmcobmFtZU9yU2lnbmF0dXJlT3JUb3BpYykpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvcGljaGFzaCA9IG5hbWVPclNpZ25hdHVyZU9yVG9waWMudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLmV2ZW50cykge1xuICAgICAgICAgICAgICAgIGlmICh0b3BpY2hhc2ggPT09IHRoaXMuZ2V0RXZlbnRUb3BpYyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudHNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGV2ZW50XCIsIFwidG9waWNoYXNoXCIsIHRvcGljaGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQgaXMgYSBiYXJlIG5hbWUsIGxvb2sgdXAgdGhlIGZ1bmN0aW9uICh3aWxsIHJldHVybiBudWxsIGlmIGFtYmlndW91cylcbiAgICAgICAgaWYgKG5hbWVPclNpZ25hdHVyZU9yVG9waWMuaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZU9yU2lnbmF0dXJlT3JUb3BpYy50cmltKCk7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IE9iamVjdC5rZXlzKHRoaXMuZXZlbnRzKS5maWx0ZXIoKGYpID0+IChmLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0gbmFtZSkpO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBldmVudFwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm11bHRpcGxlIG1hdGNoaW5nIGV2ZW50c1wiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudHNbbWF0Y2hpbmdbMF1dO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgc2lnbmF0dXJlIGFuZCBsb29rdXAgdGhlIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZXZlbnRzW0V2ZW50RnJhZ21lbnQuZnJvbVN0cmluZyhuYW1lT3JTaWduYXR1cmVPclRvcGljKS5mb3JtYXQoKV07XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibm8gbWF0Y2hpbmcgZXZlbnRcIiwgXCJzaWduYXR1cmVcIiwgbmFtZU9yU2lnbmF0dXJlT3JUb3BpYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRmluZCBhIGZ1bmN0aW9uIGRlZmluaXRpb24gYnkgYW55IG1lYW5zIG5lY2Vzc2FyeSAodW5sZXNzIGl0IGlzIGFtYmlndW91cylcbiAgICBnZXRFcnJvcihuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpIHtcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGdldFNpZ2hhc2ggPSBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJnZXRTaWdoYXNoXCIpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHRoaXMuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmVycm9yc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoID09PSBnZXRTaWdoYXNoKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcnNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGVycm9yXCIsIFwic2lnaGFzaFwiLCBuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2guaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoLnRyaW0oKTtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nID0gT2JqZWN0LmtleXModGhpcy5lcnJvcnMpLmZpbHRlcigoZikgPT4gKGYuc3BsaXQoXCIoXCIgLyogZml4OikgKi8pWzBdID09PSBuYW1lKSk7XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGVycm9yXCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoaW5nLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibXVsdGlwbGUgbWF0Y2hpbmcgZXJyb3JzXCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yc1ttYXRjaGluZ1swXV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5lcnJvcnNbRnVuY3Rpb25GcmFnbWVudC5mcm9tU3RyaW5nKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCkuZm9ybWF0KCldO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGVycm9yXCIsIFwic2lnbmF0dXJlXCIsIG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBzaWdoYXNoICh0aGUgYnl0ZXM0IHNlbGVjdG9yKSB1c2VkIGJ5IFNvbGlkaXR5IHRvIGlkZW50aWZ5IGEgZnVuY3Rpb25cbiAgICBnZXRTaWdoYXNoKGZyYWdtZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEVycm9yKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJnZXRTaWdoYXNoXCIpKGZyYWdtZW50KTtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSB0b3BpYyAodGhlIGJ5dGVzMzIgaGFzaCkgdXNlZCBieSBTb2xpZGl0eSB0byBpZGVudGlmeSBhbiBldmVudFxuICAgIGdldEV2ZW50VG9waWMoZXZlbnRGcmFnbWVudCkge1xuICAgICAgICBpZiAodHlwZW9mIChldmVudEZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZXZlbnRGcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQoZXZlbnRGcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldFN0YXRpYyh0aGlzLmNvbnN0cnVjdG9yLCBcImdldEV2ZW50VG9waWNcIikoZXZlbnRGcmFnbWVudCk7XG4gICAgfVxuICAgIF9kZWNvZGVQYXJhbXMocGFyYW1zLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hYmlDb2Rlci5kZWNvZGUocGFyYW1zLCBkYXRhKTtcbiAgICB9XG4gICAgX2VuY29kZVBhcmFtcyhwYXJhbXMsIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWJpQ29kZXIuZW5jb2RlKHBhcmFtcywgdmFsdWVzKTtcbiAgICB9XG4gICAgZW5jb2RlRGVwbG95KHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2RlUGFyYW1zKHRoaXMuZGVwbG95LmlucHV0cywgdmFsdWVzIHx8IFtdKTtcbiAgICB9XG4gICAgZGVjb2RlRXJyb3JSZXN1bHQoZnJhZ21lbnQsIGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2V0RXJyb3IoZnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gYXJyYXlpZnkoZGF0YSk7XG4gICAgICAgIGlmIChoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDQpKSAhPT0gdGhpcy5nZXRTaWdoYXNoKGZyYWdtZW50KSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgZGF0YSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZXJyb3IgJHtmcmFnbWVudC5uYW1lfS5gLCBcImRhdGFcIiwgaGV4bGlmeShieXRlcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCBieXRlcy5zbGljZSg0KSk7XG4gICAgfVxuICAgIGVuY29kZUVycm9yUmVzdWx0KGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2V0RXJyb3IoZnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KGNvbmNhdChbXG4gICAgICAgICAgICB0aGlzLmdldFNpZ2hhc2goZnJhZ21lbnQpLFxuICAgICAgICAgICAgdGhpcy5fZW5jb2RlUGFyYW1zKGZyYWdtZW50LmlucHV0cywgdmFsdWVzIHx8IFtdKVxuICAgICAgICBdKSk7XG4gICAgfVxuICAgIC8vIERlY29kZSB0aGUgZGF0YSBmb3IgYSBmdW5jdGlvbiBjYWxsIChlLmcuIHR4LmRhdGEpXG4gICAgZGVjb2RlRnVuY3Rpb25EYXRhKGZ1bmN0aW9uRnJhZ21lbnQsIGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnVuY3Rpb25GcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uRnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGZ1bmN0aW9uRnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gYXJyYXlpZnkoZGF0YSk7XG4gICAgICAgIGlmIChoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDQpKSAhPT0gdGhpcy5nZXRTaWdoYXNoKGZ1bmN0aW9uRnJhZ21lbnQpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBkYXRhIHNpZ25hdHVyZSBkb2VzIG5vdCBtYXRjaCBmdW5jdGlvbiAke2Z1bmN0aW9uRnJhZ21lbnQubmFtZX0uYCwgXCJkYXRhXCIsIGhleGxpZnkoYnl0ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlUGFyYW1zKGZ1bmN0aW9uRnJhZ21lbnQuaW5wdXRzLCBieXRlcy5zbGljZSg0KSk7XG4gICAgfVxuICAgIC8vIEVuY29kZSB0aGUgZGF0YSBmb3IgYSBmdW5jdGlvbiBjYWxsIChlLmcuIHR4LmRhdGEpXG4gICAgZW5jb2RlRnVuY3Rpb25EYXRhKGZ1bmN0aW9uRnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmdW5jdGlvbkZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZnVuY3Rpb25GcmFnbWVudCA9IHRoaXMuZ2V0RnVuY3Rpb24oZnVuY3Rpb25GcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleGxpZnkoY29uY2F0KFtcbiAgICAgICAgICAgIHRoaXMuZ2V0U2lnaGFzaChmdW5jdGlvbkZyYWdtZW50KSxcbiAgICAgICAgICAgIHRoaXMuX2VuY29kZVBhcmFtcyhmdW5jdGlvbkZyYWdtZW50LmlucHV0cywgdmFsdWVzIHx8IFtdKVxuICAgICAgICBdKSk7XG4gICAgfVxuICAgIC8vIERlY29kZSB0aGUgcmVzdWx0IGZyb20gYSBmdW5jdGlvbiBjYWxsIChlLmcuIGZyb20gZXRoX2NhbGwpXG4gICAgZGVjb2RlRnVuY3Rpb25SZXN1bHQoZnVuY3Rpb25GcmFnbWVudCwgZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIChmdW5jdGlvbkZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZnVuY3Rpb25GcmFnbWVudCA9IHRoaXMuZ2V0RnVuY3Rpb24oZnVuY3Rpb25GcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJ5dGVzID0gYXJyYXlpZnkoZGF0YSk7XG4gICAgICAgIGxldCByZWFzb24gPSBudWxsO1xuICAgICAgICBsZXQgbWVzc2FnZSA9IFwiXCI7XG4gICAgICAgIGxldCBlcnJvckFyZ3MgPSBudWxsO1xuICAgICAgICBsZXQgZXJyb3JOYW1lID0gbnVsbDtcbiAgICAgICAgbGV0IGVycm9yU2lnbmF0dXJlID0gbnVsbDtcbiAgICAgICAgc3dpdGNoIChieXRlcy5sZW5ndGggJSB0aGlzLl9hYmlDb2Rlci5fZ2V0V29yZFNpemUoKSkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hYmlDb2Rlci5kZWNvZGUoZnVuY3Rpb25GcmFnbWVudC5vdXRwdXRzLCBieXRlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgNCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1aWx0aW4gPSBCdWlsdGluRXJyb3JzW3NlbGVjdG9yXTtcbiAgICAgICAgICAgICAgICBpZiAoYnVpbHRpbikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckFyZ3MgPSB0aGlzLl9hYmlDb2Rlci5kZWNvZGUoYnVpbHRpbi5pbnB1dHMsIGJ5dGVzLnNsaWNlKDQpKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JOYW1lID0gYnVpbHRpbi5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBlcnJvclNpZ25hdHVyZSA9IGJ1aWx0aW4uc2lnbmF0dXJlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnVpbHRpbi5yZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbiA9IGVycm9yQXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JOYW1lID09PSBcIkVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgOyBWTSBFeGNlcHRpb24gd2hpbGUgcHJvY2Vzc2luZyB0cmFuc2FjdGlvbjogcmV2ZXJ0ZWQgd2l0aCByZWFzb24gc3RyaW5nICR7SlNPTi5zdHJpbmdpZnkoZXJyb3JBcmdzWzBdKX1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yTmFtZSA9PT0gXCJQYW5pY1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYDsgVk0gRXhjZXB0aW9uIHdoaWxlIHByb2Nlc3NpbmcgdHJhbnNhY3Rpb246IHJldmVydGVkIHdpdGggcGFuaWMgY29kZSAke2Vycm9yQXJnc1swXX1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmdldEVycm9yKHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQXJncyA9IHRoaXMuX2FiaUNvZGVyLmRlY29kZShlcnJvci5pbnB1dHMsIGJ5dGVzLnNsaWNlKDQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTmFtZSA9IGVycm9yLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclNpZ25hdHVyZSA9IGVycm9yLmZvcm1hdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImNhbGwgcmV2ZXJ0IGV4Y2VwdGlvblwiICsgbWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTiwge1xuICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbkZyYWdtZW50LmZvcm1hdCgpLFxuICAgICAgICAgICAgZGF0YTogaGV4bGlmeShkYXRhKSwgZXJyb3JBcmdzLCBlcnJvck5hbWUsIGVycm9yU2lnbmF0dXJlLCByZWFzb25cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEVuY29kZSB0aGUgcmVzdWx0IGZvciBhIGZ1bmN0aW9uIGNhbGwgKGUuZy4gZm9yIGV0aF9jYWxsKVxuICAgIGVuY29kZUZ1bmN0aW9uUmVzdWx0KGZ1bmN0aW9uRnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmdW5jdGlvbkZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZnVuY3Rpb25GcmFnbWVudCA9IHRoaXMuZ2V0RnVuY3Rpb24oZnVuY3Rpb25GcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleGxpZnkodGhpcy5fYWJpQ29kZXIuZW5jb2RlKGZ1bmN0aW9uRnJhZ21lbnQub3V0cHV0cywgdmFsdWVzIHx8IFtdKSk7XG4gICAgfVxuICAgIC8vIENyZWF0ZSB0aGUgZmlsdGVyIGZvciB0aGUgZXZlbnQgd2l0aCBzZWFyY2ggY3JpdGVyaWEgKGUuZy4gZm9yIGV0aF9maWx0ZXJMb2cpXG4gICAgZW5jb2RlRmlsdGVyVG9waWNzKGV2ZW50RnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChldmVudEZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZXZlbnRGcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQoZXZlbnRGcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPiBldmVudEZyYWdtZW50LmlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidG9vIG1hbnkgYXJndW1lbnRzIGZvciBcIiArIGV2ZW50RnJhZ21lbnQuZm9ybWF0KCksIExvZ2dlci5lcnJvcnMuVU5FWFBFQ1RFRF9BUkdVTUVOVCwge1xuICAgICAgICAgICAgICAgIGFyZ3VtZW50OiBcInZhbHVlc1wiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b3BpY3MgPSBbXTtcbiAgICAgICAgaWYgKCFldmVudEZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgdG9waWNzLnB1c2godGhpcy5nZXRFdmVudFRvcGljKGV2ZW50RnJhZ21lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmNvZGVUb3BpYyA9IChwYXJhbSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUgPT09IFwiYnl0ZXNcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBrZWNjYWsyNTYoaGV4bGlmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwiYm9vbFwiICYmIHR5cGVvZiAodmFsdWUpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlID8gXCIweDAxXCIgOiBcIjB4MDBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW0udHlwZS5tYXRjaCgvXnU/aW50LykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IEJpZ051bWJlci5mcm9tKHZhbHVlKS50b0hleFN0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgYWRkcmVzc2VzIGFyZSB2YWxpZFxuICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWJpQ29kZXIuZW5jb2RlKFtcImFkZHJlc3NcIl0sIFt2YWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhleFplcm9QYWQoaGV4bGlmeSh2YWx1ZSksIDMyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IHBhcmFtID0gZXZlbnRGcmFnbWVudC5pbnB1dHNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFwYXJhbS5pbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImNhbm5vdCBmaWx0ZXIgbm9uLWluZGV4ZWQgcGFyYW1ldGVyczsgbXVzdCBiZSBudWxsXCIsIChcImNvbnRyYWN0LlwiICsgcGFyYW0ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLmJhc2VUeXBlID09PSBcImFycmF5XCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJmaWx0ZXJpbmcgd2l0aCB0dXBsZXMgb3IgYXJyYXlzIG5vdCBzdXBwb3J0ZWRcIiwgKFwiY29udHJhY3QuXCIgKyBwYXJhbS5uYW1lKSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh2YWx1ZS5tYXAoKHZhbHVlKSA9PiBlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRyaW0gb2ZmIHRyYWlsaW5nIG51bGxzXG4gICAgICAgIHdoaWxlICh0b3BpY3MubGVuZ3RoICYmIHRvcGljc1t0b3BpY3MubGVuZ3RoIC0gMV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRvcGljcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9waWNzO1xuICAgIH1cbiAgICBlbmNvZGVFdmVudExvZyhldmVudEZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZXZlbnRGcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGV2ZW50RnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGV2ZW50RnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvcGljcyA9IFtdO1xuICAgICAgICBjb25zdCBkYXRhVHlwZXMgPSBbXTtcbiAgICAgICAgY29uc3QgZGF0YVZhbHVlcyA9IFtdO1xuICAgICAgICBpZiAoIWV2ZW50RnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICB0b3BpY3MucHVzaCh0aGlzLmdldEV2ZW50VG9waWMoZXZlbnRGcmFnbWVudCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoICE9PSBldmVudEZyYWdtZW50LmlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJldmVudCBhcmd1bWVudHMvdmFsdWVzIG1pc21hdGNoXCIsIFwidmFsdWVzXCIsIHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRGcmFnbWVudC5pbnB1dHMuZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgICAgICBpZiAocGFyYW0uaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKGlkKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUgPT09IFwiYnl0ZXNcIikge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChrZWNjYWsyNTYodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKHRoaXMuX2FiaUNvZGVyLmVuY29kZShbcGFyYW0udHlwZV0sIFt2YWx1ZV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhVHlwZXMucHVzaChwYXJhbSk7XG4gICAgICAgICAgICAgICAgZGF0YVZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiB0aGlzLl9hYmlDb2Rlci5lbmNvZGUoZGF0YVR5cGVzLCBkYXRhVmFsdWVzKSxcbiAgICAgICAgICAgIHRvcGljczogdG9waWNzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIERlY29kZSBhIGZpbHRlciBmb3IgdGhlIGV2ZW50IGFuZCB0aGUgc2VhcmNoIGNyaXRlcmlhXG4gICAgZGVjb2RlRXZlbnRMb2coZXZlbnRGcmFnbWVudCwgZGF0YSwgdG9waWNzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGV2ZW50RnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBldmVudEZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChldmVudEZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9waWNzICE9IG51bGwgJiYgIWV2ZW50RnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICBsZXQgdG9waWNIYXNoID0gdGhpcy5nZXRFdmVudFRvcGljKGV2ZW50RnJhZ21lbnQpO1xuICAgICAgICAgICAgaWYgKCFpc0hleFN0cmluZyh0b3BpY3NbMF0sIDMyKSB8fCB0b3BpY3NbMF0udG9Mb3dlckNhc2UoKSAhPT0gdG9waWNIYXNoKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJmcmFnbWVudC90b3BpYyBtaXNtYXRjaFwiLCBMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHsgYXJndW1lbnQ6IFwidG9waWNzWzBdXCIsIGV4cGVjdGVkOiB0b3BpY0hhc2gsIHZhbHVlOiB0b3BpY3NbMF0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b3BpY3MgPSB0b3BpY3Muc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluZGV4ZWQgPSBbXTtcbiAgICAgICAgbGV0IG5vbkluZGV4ZWQgPSBbXTtcbiAgICAgICAgbGV0IGR5bmFtaWMgPSBbXTtcbiAgICAgICAgZXZlbnRGcmFnbWVudC5pbnB1dHMuZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAocGFyYW0uaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcInN0cmluZ1wiIHx8IHBhcmFtLnR5cGUgPT09IFwiYnl0ZXNcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlZC5wdXNoKFBhcmFtVHlwZS5mcm9tT2JqZWN0KHsgdHlwZTogXCJieXRlczMyXCIsIG5hbWU6IHBhcmFtLm5hbWUgfSkpO1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljLnB1c2godHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRleGVkLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljLnB1c2goZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vbkluZGV4ZWQucHVzaChwYXJhbSk7XG4gICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxldCByZXN1bHRJbmRleGVkID0gKHRvcGljcyAhPSBudWxsKSA/IHRoaXMuX2FiaUNvZGVyLmRlY29kZShpbmRleGVkLCBjb25jYXQodG9waWNzKSkgOiBudWxsO1xuICAgICAgICBsZXQgcmVzdWx0Tm9uSW5kZXhlZCA9IHRoaXMuX2FiaUNvZGVyLmRlY29kZShub25JbmRleGVkLCBkYXRhLCB0cnVlKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgbm9uSW5kZXhlZEluZGV4ID0gMCwgaW5kZXhlZEluZGV4ID0gMDtcbiAgICAgICAgZXZlbnRGcmFnbWVudC5pbnB1dHMuZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAocGFyYW0uaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRJbmRleGVkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IG5ldyBJbmRleGVkKHsgX2lzSW5kZXhlZDogdHJ1ZSwgaGFzaDogbnVsbCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZHluYW1pY1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IG5ldyBJbmRleGVkKHsgX2lzSW5kZXhlZDogdHJ1ZSwgaGFzaDogcmVzdWx0SW5kZXhlZFtpbmRleGVkSW5kZXgrK10gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IHJlc3VsdEluZGV4ZWRbaW5kZXhlZEluZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IHJlc3VsdE5vbkluZGV4ZWRbbm9uSW5kZXhlZEluZGV4KytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0aGUga2V5d29yZCBhcmd1bWVudCBpZiBuYW1lZCBhbmQgc2FmZVxuICAgICAgICAgICAgaWYgKHBhcmFtLm5hbWUgJiYgcmVzdWx0W3BhcmFtLm5hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc3VsdFtpbmRleF07XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBlcnJvciBuYW1lZCB2YWx1ZXMgdGhyb3cgb24gYWNjZXNzXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgcGFyYW0ubmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogKCkgPT4geyB0aHJvdyB3cmFwQWNjZXNzRXJyb3IoYHByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkocGFyYW0ubmFtZSl9YCwgdmFsdWUpOyB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3BhcmFtLm5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gTWFrZSBhbGwgZXJyb3IgaW5kZXhlZCB2YWx1ZXMgdGhyb3cgb24gYWNjZXNzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc3VsdFtpXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgaSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHsgdGhyb3cgd3JhcEFjY2Vzc0Vycm9yKGBpbmRleCAke2l9YCwgdmFsdWUpOyB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUocmVzdWx0KTtcbiAgICB9XG4gICAgLy8gR2l2ZW4gYSB0cmFuc2FjdGlvbiwgZmluZCB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gZnJhZ21lbnQgKGlmIGFueSkgYW5kXG4gICAgLy8gZGV0ZXJtaW5lIGFsbCBpdHMgcHJvcGVydGllcyBhbmQgY2FsbCBwYXJhbWV0ZXJzXG4gICAgcGFyc2VUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICBsZXQgZnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKHR4LmRhdGEuc3Vic3RyaW5nKDAsIDEwKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgaWYgKCFmcmFnbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgICAgIGFyZ3M6IHRoaXMuX2FiaUNvZGVyLmRlY29kZShmcmFnbWVudC5pbnB1dHMsIFwiMHhcIiArIHR4LmRhdGEuc3Vic3RyaW5nKDEwKSksXG4gICAgICAgICAgICBmdW5jdGlvbkZyYWdtZW50OiBmcmFnbWVudCxcbiAgICAgICAgICAgIG5hbWU6IGZyYWdtZW50Lm5hbWUsXG4gICAgICAgICAgICBzaWduYXR1cmU6IGZyYWdtZW50LmZvcm1hdCgpLFxuICAgICAgICAgICAgc2lnaGFzaDogdGhpcy5nZXRTaWdoYXNoKGZyYWdtZW50KSxcbiAgICAgICAgICAgIHZhbHVlOiBCaWdOdW1iZXIuZnJvbSh0eC52YWx1ZSB8fCBcIjBcIiksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBAVE9ET1xuICAgIC8vcGFyc2VDYWxsUmVzdWx0KGRhdGE6IEJ5dGVzTGlrZSk6ID8/XG4gICAgLy8gR2l2ZW4gYW4gZXZlbnQgbG9nLCBmaW5kIHRoZSBtYXRjaGluZyBldmVudCBmcmFnbWVudCAoaWYgYW55KSBhbmRcbiAgICAvLyBkZXRlcm1pbmUgYWxsIGl0cyBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXNcbiAgICBwYXJzZUxvZyhsb2cpIHtcbiAgICAgICAgbGV0IGZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChsb2cudG9waWNzWzBdKTtcbiAgICAgICAgaWYgKCFmcmFnbWVudCB8fCBmcmFnbWVudC5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiBJZiBhbm9ueW1vdXMsIGFuZCB0aGUgb25seSBtZXRob2QsIGFuZCB0aGUgaW5wdXQgY291bnQgbWF0Y2hlcywgc2hvdWxkIHdlIHBhcnNlP1xuICAgICAgICAvLyAgICAgICAgUHJvYmFibHkgbm90LCBiZWNhdXNlIGp1c3QgYmVjYXVzZSBpdCBpcyB0aGUgb25seSBldmVudCBpbiB0aGUgQUJJIGRvZXNcbiAgICAgICAgLy8gICAgICAgIG5vdCBtZWFuIHdlIGhhdmUgdGhlIGZ1bGwgQUJJOyBtYXliZSBqdXN0IGEgZnJhZ21lbnQ/XG4gICAgICAgIHJldHVybiBuZXcgTG9nRGVzY3JpcHRpb24oe1xuICAgICAgICAgICAgZXZlbnRGcmFnbWVudDogZnJhZ21lbnQsXG4gICAgICAgICAgICBuYW1lOiBmcmFnbWVudC5uYW1lLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBmcmFnbWVudC5mb3JtYXQoKSxcbiAgICAgICAgICAgIHRvcGljOiB0aGlzLmdldEV2ZW50VG9waWMoZnJhZ21lbnQpLFxuICAgICAgICAgICAgYXJnczogdGhpcy5kZWNvZGVFdmVudExvZyhmcmFnbWVudCwgbG9nLmRhdGEsIGxvZy50b3BpY3MpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwYXJzZUVycm9yKGRhdGEpIHtcbiAgICAgICAgY29uc3QgaGV4RGF0YSA9IGhleGxpZnkoZGF0YSk7XG4gICAgICAgIGxldCBmcmFnbWVudCA9IHRoaXMuZ2V0RXJyb3IoaGV4RGF0YS5zdWJzdHJpbmcoMCwgMTApLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBpZiAoIWZyYWdtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVycm9yRGVzY3JpcHRpb24oe1xuICAgICAgICAgICAgYXJnczogdGhpcy5fYWJpQ29kZXIuZGVjb2RlKGZyYWdtZW50LmlucHV0cywgXCIweFwiICsgaGV4RGF0YS5zdWJzdHJpbmcoMTApKSxcbiAgICAgICAgICAgIGVycm9yRnJhZ21lbnQ6IGZyYWdtZW50LFxuICAgICAgICAgICAgbmFtZTogZnJhZ21lbnQubmFtZSxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogZnJhZ21lbnQuZm9ybWF0KCksXG4gICAgICAgICAgICBzaWdoYXNoOiB0aGlzLmdldFNpZ2hhc2goZnJhZ21lbnQpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLypcbiAgICBzdGF0aWMgZnJvbSh2YWx1ZTogQXJyYXk8RnJhZ21lbnQgfCBzdHJpbmcgfCBKc29uQWJpPiB8IHN0cmluZyB8IEludGVyZmFjZSkge1xuICAgICAgICBpZiAoSW50ZXJmYWNlLmlzSW50ZXJmYWNlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludGVyZmFjZShKU09OLnBhcnNlKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UodmFsdWUpO1xuICAgIH1cbiAgICAqL1xuICAgIHN0YXRpYyBpc0ludGVyZmFjZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzSW50ZXJmYWNlKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmZhY2UuanMubWFwIl0sIm5hbWVzIjpbImdldEFkZHJlc3MiLCJCaWdOdW1iZXIiLCJhcnJheWlmeSIsImNvbmNhdCIsImhleERhdGFTbGljZSIsImhleGxpZnkiLCJoZXhaZXJvUGFkIiwiaXNIZXhTdHJpbmciLCJpZCIsImtlY2NhazI1NiIsImRlZmluZVJlYWRPbmx5IiwiRGVzY3JpcHRpb24iLCJnZXRTdGF0aWMiLCJkZWZhdWx0QWJpQ29kZXIiLCJjaGVja1Jlc3VsdEVycm9ycyIsIkNvbnN0cnVjdG9yRnJhZ21lbnQiLCJFdmVudEZyYWdtZW50IiwiRm9ybWF0VHlwZXMiLCJGcmFnbWVudCIsIkZ1bmN0aW9uRnJhZ21lbnQiLCJQYXJhbVR5cGUiLCJMb2dnZXIiLCJ2ZXJzaW9uIiwibG9nZ2VyIiwiTG9nRGVzY3JpcHRpb24iLCJUcmFuc2FjdGlvbkRlc2NyaXB0aW9uIiwiRXJyb3JEZXNjcmlwdGlvbiIsIkluZGV4ZWQiLCJpc0luZGV4ZWQiLCJ2YWx1ZSIsIl9pc0luZGV4ZWQiLCJCdWlsdGluRXJyb3JzIiwic2lnbmF0dXJlIiwibmFtZSIsImlucHV0cyIsInJlYXNvbiIsIndyYXBBY2Nlc3NFcnJvciIsInByb3BlcnR5IiwiZXJyb3IiLCJ3cmFwIiwiRXJyb3IiLCJJbnRlcmZhY2UiLCJjb25zdHJ1Y3RvciIsImZyYWdtZW50cyIsImFiaSIsIkpTT04iLCJwYXJzZSIsIm1hcCIsImZyYWdtZW50IiwiZnJvbSIsImZpbHRlciIsImZvckVhY2giLCJidWNrZXQiLCJ0eXBlIiwiZGVwbG95Iiwid2FybiIsImZ1bmN0aW9ucyIsImV2ZW50cyIsImVycm9ycyIsImZvcm1hdCIsInBheWFibGUiLCJmdWxsIiwic2lnaGFzaCIsInRocm93QXJndW1lbnRFcnJvciIsImpzb24iLCJzdHJpbmdpZnkiLCJqIiwiZ2V0QWJpQ29kZXIiLCJhZGRyZXNzIiwiZ2V0U2lnaGFzaCIsImdldEV2ZW50VG9waWMiLCJldmVudEZyYWdtZW50IiwiZ2V0RnVuY3Rpb24iLCJuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2giLCJpbmRleE9mIiwidHJpbSIsIm1hdGNoaW5nIiwiT2JqZWN0Iiwia2V5cyIsImYiLCJzcGxpdCIsImxlbmd0aCIsInJlc3VsdCIsImZyb21TdHJpbmciLCJnZXRFdmVudCIsIm5hbWVPclNpZ25hdHVyZU9yVG9waWMiLCJ0b3BpY2hhc2giLCJ0b0xvd2VyQ2FzZSIsImdldEVycm9yIiwiXyIsIl9kZWNvZGVQYXJhbXMiLCJwYXJhbXMiLCJkYXRhIiwiX2FiaUNvZGVyIiwiZGVjb2RlIiwiX2VuY29kZVBhcmFtcyIsInZhbHVlcyIsImVuY29kZSIsImVuY29kZURlcGxveSIsImRlY29kZUVycm9yUmVzdWx0IiwiYnl0ZXMiLCJzbGljZSIsImVuY29kZUVycm9yUmVzdWx0IiwiZGVjb2RlRnVuY3Rpb25EYXRhIiwiZnVuY3Rpb25GcmFnbWVudCIsImVuY29kZUZ1bmN0aW9uRGF0YSIsImRlY29kZUZ1bmN0aW9uUmVzdWx0IiwibWVzc2FnZSIsImVycm9yQXJncyIsImVycm9yTmFtZSIsImVycm9yU2lnbmF0dXJlIiwiX2dldFdvcmRTaXplIiwib3V0cHV0cyIsInNlbGVjdG9yIiwiYnVpbHRpbiIsInRocm93RXJyb3IiLCJDQUxMX0VYQ0VQVElPTiIsIm1ldGhvZCIsImVuY29kZUZ1bmN0aW9uUmVzdWx0IiwiZW5jb2RlRmlsdGVyVG9waWNzIiwiVU5FWFBFQ1RFRF9BUkdVTUVOVCIsImFyZ3VtZW50IiwidG9waWNzIiwiYW5vbnltb3VzIiwicHVzaCIsImVuY29kZVRvcGljIiwicGFyYW0iLCJtYXRjaCIsInRvSGV4U3RyaW5nIiwiaW5kZXgiLCJpbmRleGVkIiwiYmFzZVR5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJwb3AiLCJlbmNvZGVFdmVudExvZyIsImRhdGFUeXBlcyIsImRhdGFWYWx1ZXMiLCJkZWNvZGVFdmVudExvZyIsInRvcGljSGFzaCIsIklOVkFMSURfQVJHVU1FTlQiLCJleHBlY3RlZCIsIm5vbkluZGV4ZWQiLCJkeW5hbWljIiwiZnJvbU9iamVjdCIsInJlc3VsdEluZGV4ZWQiLCJyZXN1bHROb25JbmRleGVkIiwibm9uSW5kZXhlZEluZGV4IiwiaW5kZXhlZEluZGV4IiwiaGFzaCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsImkiLCJmcmVlemUiLCJwYXJzZVRyYW5zYWN0aW9uIiwidHgiLCJzdWJzdHJpbmciLCJhcmdzIiwicGFyc2VMb2ciLCJsb2ciLCJ0b3BpYyIsInBhcnNlRXJyb3IiLCJoZXhEYXRhIiwiZXJyb3JGcmFnbWVudCIsImlzSW50ZXJmYWNlIiwiX2lzSW50ZXJmYWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/interface.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-provider/lib.esm/_version.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/abstract-provider/lib.esm/_version.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"abstract-provider/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlci9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxNQUFNQSxVQUFVLDBCQUEwQixDQUNqRCxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbGltZS1iZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlci9saWIuZXNtL192ZXJzaW9uLmpzPzE5ZTAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcImFic3RyYWN0LXByb3ZpZGVyLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-provider/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-provider/lib.esm/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/abstract-provider/lib.esm/index.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlockForkEvent: () => (/* binding */ BlockForkEvent),\n/* harmony export */   ForkEvent: () => (/* binding */ ForkEvent),\n/* harmony export */   Provider: () => (/* binding */ Provider),\n/* harmony export */   TransactionForkEvent: () => (/* binding */ TransactionForkEvent),\n/* harmony export */   TransactionOrderForkEvent: () => (/* binding */ TransactionOrderForkEvent)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-provider/lib.esm/_version.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n;\n;\n//export type CallTransactionable = {\n//    call(transaction: TransactionRequest): Promise<TransactionResponse>;\n//};\nclass ForkEvent extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.Description {\n    static isForkEvent(value) {\n        return !!(value && value._isForkEvent);\n    }\n}\nclass BlockForkEvent extends ForkEvent {\n    constructor(blockHash, expiry){\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(blockHash, 32)) {\n            logger.throwArgumentError(\"invalid blockHash\", \"blockHash\", blockHash);\n        }\n        super({\n            _isForkEvent: true,\n            _isBlockForkEvent: true,\n            expiry: expiry || 0,\n            blockHash: blockHash\n        });\n    }\n}\nclass TransactionForkEvent extends ForkEvent {\n    constructor(hash, expiry){\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(hash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"hash\", hash);\n        }\n        super({\n            _isForkEvent: true,\n            _isTransactionForkEvent: true,\n            expiry: expiry || 0,\n            hash: hash\n        });\n    }\n}\nclass TransactionOrderForkEvent extends ForkEvent {\n    constructor(beforeHash, afterHash, expiry){\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(beforeHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"beforeHash\", beforeHash);\n        }\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(afterHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"afterHash\", afterHash);\n        }\n        super({\n            _isForkEvent: true,\n            _isTransactionOrderForkEvent: true,\n            expiry: expiry || 0,\n            beforeHash: beforeHash,\n            afterHash: afterHash\n        });\n    }\n}\n///////////////////////////////\n// Exported Abstracts\nclass Provider {\n    constructor(){\n        logger.checkAbstract(new.target, Provider);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"_isProvider\", true);\n    }\n    getFeeData() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { block, gasPrice } = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)({\n                block: this.getBlock(\"latest\"),\n                gasPrice: this.getGasPrice().catch((error)=>{\n                    // @TODO: Why is this now failing on Calaveras?\n                    //console.log(error);\n                    return null;\n                })\n            });\n            let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;\n            if (block && block.baseFeePerGas) {\n                // We may want to compute this more accurately in the future,\n                // using the formula \"check if the base fee is correct\".\n                // See: https://eips.ethereum.org/EIPS/eip-1559\n                lastBaseFeePerGas = block.baseFeePerGas;\n                maxPriorityFeePerGas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(\"1500000000\");\n                maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);\n            }\n            return {\n                lastBaseFeePerGas,\n                maxFeePerGas,\n                maxPriorityFeePerGas,\n                gasPrice\n            };\n        });\n    }\n    // Alias for \"on\"\n    addListener(eventName, listener) {\n        return this.on(eventName, listener);\n    }\n    // Alias for \"off\"\n    removeListener(eventName, listener) {\n        return this.off(eventName, listener);\n    }\n    static isProvider(value) {\n        return !!(value && value._isProvider);\n    }\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlci9saWIuZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBYTtBQUNiLElBQUlBLFlBQVksU0FBSyxJQUFJLFNBQUksQ0FBQ0EsU0FBUyxJQUFLLFNBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDbkYsU0FBU0MsTUFBTUMsS0FBSztRQUFJLE9BQU9BLGlCQUFpQkgsSUFBSUcsUUFBUSxJQUFJSCxFQUFFLFNBQVVJLE9BQU87WUFBSUEsUUFBUUQ7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFBS0gsQ0FBQUEsS0FBTUEsQ0FBQUEsSUFBSUssT0FBTSxDQUFDLEVBQUcsU0FBVUQsT0FBTyxFQUFFRSxNQUFNO1FBQ3JELFNBQVNDLFVBQVVKLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxVQUFVUSxJQUFJLENBQUNOO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDMUYsU0FBU0MsU0FBU1IsS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFNBQVMsQ0FBQyxRQUFRLENBQUNFO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDN0YsU0FBU0YsS0FBS0ksTUFBTTtZQUFJQSxPQUFPQyxJQUFJLEdBQUdULFFBQVFRLE9BQU9ULEtBQUssSUFBSUQsTUFBTVUsT0FBT1QsS0FBSyxFQUFFVyxJQUFJLENBQUNQLFdBQVdJO1FBQVc7UUFDN0dILEtBQUssQ0FBQ1AsWUFBWUEsVUFBVWMsS0FBSyxDQUFDakIsU0FBU0MsY0FBYyxFQUFFLEdBQUdVLElBQUk7SUFDdEU7QUFDSjtBQUNxRDtBQUNGO0FBQ3dDO0FBQzVDO0FBQ1Y7QUFDckMsTUFBTWMsU0FBUyxJQUFJRix5REFBTUEsQ0FBQ0MsNkNBQU9BOzs7QUFHakMs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RCxLQUFLLEVBQUU7UUFDckIsT0FBTyxDQUFDLENBQUVBLENBQUFBLFNBQVNBLE1BQU00RCxXQUFXO0lBQ3hDO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbGltZS1iZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlci9saWIuZXNtL2luZGV4LmpzP2Q3M2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGlzSGV4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBEZXNjcmlwdGlvbiwgZGVmaW5lUmVhZE9ubHksIHJlc29sdmVQcm9wZXJ0aWVzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbjtcbjtcbi8vZXhwb3J0IHR5cGUgQ2FsbFRyYW5zYWN0aW9uYWJsZSA9IHtcbi8vICAgIGNhbGwodHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uUmVxdWVzdCk6IFByb21pc2U8VHJhbnNhY3Rpb25SZXNwb25zZT47XG4vL307XG5leHBvcnQgY2xhc3MgRm9ya0V2ZW50IGV4dGVuZHMgRGVzY3JpcHRpb24ge1xuICAgIHN0YXRpYyBpc0ZvcmtFdmVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzRm9ya0V2ZW50KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQmxvY2tGb3JrRXZlbnQgZXh0ZW5kcyBGb3JrRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrSGFzaCwgZXhwaXJ5KSB7XG4gICAgICAgIGlmICghaXNIZXhTdHJpbmcoYmxvY2tIYXNoLCAzMikpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGJsb2NrSGFzaFwiLCBcImJsb2NrSGFzaFwiLCBibG9ja0hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIF9pc0ZvcmtFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIF9pc0Jsb2NrRm9ya0V2ZW50OiB0cnVlLFxuICAgICAgICAgICAgZXhwaXJ5OiAoZXhwaXJ5IHx8IDApLFxuICAgICAgICAgICAgYmxvY2tIYXNoOiBibG9ja0hhc2hcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uRm9ya0V2ZW50IGV4dGVuZHMgRm9ya0V2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBleHBpcnkpIHtcbiAgICAgICAgaWYgKCFpc0hleFN0cmluZyhoYXNoLCAzMikpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uIGhhc2hcIiwgXCJoYXNoXCIsIGhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIF9pc0ZvcmtFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIF9pc1RyYW5zYWN0aW9uRm9ya0V2ZW50OiB0cnVlLFxuICAgICAgICAgICAgZXhwaXJ5OiAoZXhwaXJ5IHx8IDApLFxuICAgICAgICAgICAgaGFzaDogaGFzaFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25PcmRlckZvcmtFdmVudCBleHRlbmRzIEZvcmtFdmVudCB7XG4gICAgY29uc3RydWN0b3IoYmVmb3JlSGFzaCwgYWZ0ZXJIYXNoLCBleHBpcnkpIHtcbiAgICAgICAgaWYgKCFpc0hleFN0cmluZyhiZWZvcmVIYXNoLCAzMikpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uIGhhc2hcIiwgXCJiZWZvcmVIYXNoXCIsIGJlZm9yZUhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNIZXhTdHJpbmcoYWZ0ZXJIYXNoLCAzMikpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uIGhhc2hcIiwgXCJhZnRlckhhc2hcIiwgYWZ0ZXJIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBfaXNGb3JrRXZlbnQ6IHRydWUsXG4gICAgICAgICAgICBfaXNUcmFuc2FjdGlvbk9yZGVyRm9ya0V2ZW50OiB0cnVlLFxuICAgICAgICAgICAgZXhwaXJ5OiAoZXhwaXJ5IHx8IDApLFxuICAgICAgICAgICAgYmVmb3JlSGFzaDogYmVmb3JlSGFzaCxcbiAgICAgICAgICAgIGFmdGVySGFzaDogYWZ0ZXJIYXNoXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEV4cG9ydGVkIEFic3RyYWN0c1xuZXhwb3J0IGNsYXNzIFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgbG9nZ2VyLmNoZWNrQWJzdHJhY3QobmV3LnRhcmdldCwgUHJvdmlkZXIpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9pc1Byb3ZpZGVyXCIsIHRydWUpO1xuICAgIH1cbiAgICBnZXRGZWVEYXRhKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBibG9jaywgZ2FzUHJpY2UgfSA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBibG9jazogdGhpcy5nZXRCbG9jayhcImxhdGVzdFwiKSxcbiAgICAgICAgICAgICAgICBnYXNQcmljZTogdGhpcy5nZXRHYXNQcmljZSgpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogV2h5IGlzIHRoaXMgbm93IGZhaWxpbmcgb24gQ2FsYXZlcmFzP1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IGxhc3RCYXNlRmVlUGVyR2FzID0gbnVsbCwgbWF4RmVlUGVyR2FzID0gbnVsbCwgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGJsb2NrICYmIGJsb2NrLmJhc2VGZWVQZXJHYXMpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBtYXkgd2FudCB0byBjb21wdXRlIHRoaXMgbW9yZSBhY2N1cmF0ZWx5IGluIHRoZSBmdXR1cmUsXG4gICAgICAgICAgICAgICAgLy8gdXNpbmcgdGhlIGZvcm11bGEgXCJjaGVjayBpZiB0aGUgYmFzZSBmZWUgaXMgY29ycmVjdFwiLlxuICAgICAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xNTU5XG4gICAgICAgICAgICAgICAgbGFzdEJhc2VGZWVQZXJHYXMgPSBibG9jay5iYXNlRmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzID0gQmlnTnVtYmVyLmZyb20oXCIxNTAwMDAwMDAwXCIpO1xuICAgICAgICAgICAgICAgIG1heEZlZVBlckdhcyA9IGJsb2NrLmJhc2VGZWVQZXJHYXMubXVsKDIpLmFkZChtYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBsYXN0QmFzZUZlZVBlckdhcywgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcywgZ2FzUHJpY2UgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEFsaWFzIGZvciBcIm9uXCJcbiAgICBhZGRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvLyBBbGlhcyBmb3IgXCJvZmZcIlxuICAgIHJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNQcm92aWRlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzUHJvdmlkZXIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJCaWdOdW1iZXIiLCJpc0hleFN0cmluZyIsIkRlc2NyaXB0aW9uIiwiZGVmaW5lUmVhZE9ubHkiLCJyZXNvbHZlUHJvcGVydGllcyIsIkxvZ2dlciIsInZlcnNpb24iLCJsb2dnZXIiLCJGb3JrRXZlbnQiLCJpc0ZvcmtFdmVudCIsIl9pc0ZvcmtFdmVudCIsIkJsb2NrRm9ya0V2ZW50IiwiY29uc3RydWN0b3IiLCJibG9ja0hhc2giLCJleHBpcnkiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJfaXNCbG9ja0ZvcmtFdmVudCIsIlRyYW5zYWN0aW9uRm9ya0V2ZW50IiwiaGFzaCIsIl9pc1RyYW5zYWN0aW9uRm9ya0V2ZW50IiwiVHJhbnNhY3Rpb25PcmRlckZvcmtFdmVudCIsImJlZm9yZUhhc2giLCJhZnRlckhhc2giLCJfaXNUcmFuc2FjdGlvbk9yZGVyRm9ya0V2ZW50IiwiUHJvdmlkZXIiLCJjaGVja0Fic3RyYWN0IiwiZ2V0RmVlRGF0YSIsImJsb2NrIiwiZ2FzUHJpY2UiLCJnZXRCbG9jayIsImdldEdhc1ByaWNlIiwiY2F0Y2giLCJlcnJvciIsImxhc3RCYXNlRmVlUGVyR2FzIiwibWF4RmVlUGVyR2FzIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJiYXNlRmVlUGVyR2FzIiwiZnJvbSIsIm11bCIsImFkZCIsImFkZExpc3RlbmVyIiwiZXZlbnROYW1lIiwibGlzdGVuZXIiLCJvbiIsInJlbW92ZUxpc3RlbmVyIiwib2ZmIiwiaXNQcm92aWRlciIsIl9pc1Byb3ZpZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-provider/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-signer/lib.esm/_version.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/abstract-signer/lib.esm/_version.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"abstract-signer/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1zaWduZXIvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsVUFBVSx3QkFBd0IsQ0FDL0Msb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2xpbWUtYmV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJzdHJhY3Qtc2lnbmVyL2xpYi5lc20vX3ZlcnNpb24uanM/ZTkzMiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiYWJzdHJhY3Qtc2lnbmVyLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-signer/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-signer/lib.esm/index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/abstract-signer/lib.esm/index.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Signer: () => (/* binding */ Signer),\n/* harmony export */   VoidSigner: () => (/* binding */ VoidSigner)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-signer/lib.esm/_version.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nconst allowedTransactionKeys = [\n    \"accessList\",\n    \"ccipReadEnabled\",\n    \"chainId\",\n    \"customData\",\n    \"data\",\n    \"from\",\n    \"gasLimit\",\n    \"gasPrice\",\n    \"maxFeePerGas\",\n    \"maxPriorityFeePerGas\",\n    \"nonce\",\n    \"to\",\n    \"type\",\n    \"value\"\n];\nconst forwardErrors = [\n    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INSUFFICIENT_FUNDS,\n    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NONCE_EXPIRED,\n    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.REPLACEMENT_UNDERPRICED\n];\n;\n;\nclass Signer {\n    ///////////////////\n    // Sub-classes MUST call super\n    constructor(){\n        logger.checkAbstract(new.target, Signer);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"_isSigner\", true);\n    }\n    ///////////////////\n    // Sub-classes MAY override these\n    getBalance(blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this._checkProvider(\"getBalance\");\n            return yield this.provider.getBalance(this.getAddress(), blockTag);\n        });\n    }\n    getTransactionCount(blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this._checkProvider(\"getTransactionCount\");\n            return yield this.provider.getTransactionCount(this.getAddress(), blockTag);\n        });\n    }\n    // Populates \"from\" if unspecified, and estimates the gas for the transaction\n    estimateGas(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this._checkProvider(\"estimateGas\");\n            const tx = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)(this.checkTransaction(transaction));\n            return yield this.provider.estimateGas(tx);\n        });\n    }\n    // Populates \"from\" if unspecified, and calls with the transaction\n    call(transaction, blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this._checkProvider(\"call\");\n            const tx = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)(this.checkTransaction(transaction));\n            return yield this.provider.call(tx, blockTag);\n        });\n    }\n    // Populates all fields in a transaction, signs it and sends it to the network\n    sendTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this._checkProvider(\"sendTransaction\");\n            const tx = yield this.populateTransaction(transaction);\n            const signedTx = yield this.signTransaction(tx);\n            return yield this.provider.sendTransaction(signedTx);\n        });\n    }\n    getChainId() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this._checkProvider(\"getChainId\");\n            const network = yield this.provider.getNetwork();\n            return network.chainId;\n        });\n    }\n    getGasPrice() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this._checkProvider(\"getGasPrice\");\n            return yield this.provider.getGasPrice();\n        });\n    }\n    getFeeData() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this._checkProvider(\"getFeeData\");\n            return yield this.provider.getFeeData();\n        });\n    }\n    resolveName(name) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this._checkProvider(\"resolveName\");\n            return yield this.provider.resolveName(name);\n        });\n    }\n    // Checks a transaction does not contain invalid keys and if\n    // no \"from\" is provided, populates it.\n    // - does NOT require a provider\n    // - adds \"from\" is not present\n    // - returns a COPY (safe to mutate the result)\n    // By default called from: (overriding these prevents it)\n    //   - call\n    //   - estimateGas\n    //   - populateTransaction (and therefor sendTransaction)\n    checkTransaction(transaction) {\n        for(const key in transaction){\n            if (allowedTransactionKeys.indexOf(key) === -1) {\n                logger.throwArgumentError(\"invalid transaction key: \" + key, \"transaction\", transaction);\n            }\n        }\n        const tx = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.shallowCopy)(transaction);\n        if (tx.from == null) {\n            tx.from = this.getAddress();\n        } else {\n            // Make sure any provided address matches this signer\n            tx.from = Promise.all([\n                Promise.resolve(tx.from),\n                this.getAddress()\n            ]).then((result)=>{\n                if (result[0].toLowerCase() !== result[1].toLowerCase()) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n                return result[0];\n            });\n        }\n        return tx;\n    }\n    // Populates ALL keys for a transaction and checks that \"from\" matches\n    // this Signer. Should be used by sendTransaction but NOT by signTransaction.\n    // By default called from: (overriding these prevents it)\n    //   - sendTransaction\n    //\n    // Notes:\n    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas\n    populateTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const tx = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)(this.checkTransaction(transaction));\n            if (tx.to != null) {\n                tx.to = Promise.resolve(tx.to).then((to)=>__awaiter(this, void 0, void 0, function*() {\n                        if (to == null) {\n                            return null;\n                        }\n                        const address = yield this.resolveName(to);\n                        if (address == null) {\n                            logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                        }\n                        return address;\n                    }));\n                // Prevent this error from causing an UnhandledPromiseException\n                tx.to.catch((error)=>{});\n            }\n            // Do not allow mixing pre-eip-1559 and eip-1559 properties\n            const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;\n            if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {\n                logger.throwArgumentError(\"eip-1559 transaction do not support gasPrice\", \"transaction\", transaction);\n            } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {\n                logger.throwArgumentError(\"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"transaction\", transaction);\n            }\n            if ((tx.type === 2 || tx.type == null) && tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null) {\n                // Fully-formed EIP-1559 transaction (skip getFeeData)\n                tx.type = 2;\n            } else if (tx.type === 0 || tx.type === 1) {\n                // Explicit Legacy or EIP-2930 transaction\n                // Populate missing gasPrice\n                if (tx.gasPrice == null) {\n                    tx.gasPrice = this.getGasPrice();\n                }\n            } else {\n                // We need to get fee data to determine things\n                const feeData = yield this.getFeeData();\n                if (tx.type == null) {\n                    // We need to auto-detect the intended type of this transaction...\n                    if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                        // The network supports EIP-1559!\n                        // Upgrade transaction from null to eip-1559\n                        tx.type = 2;\n                        if (tx.gasPrice != null) {\n                            // Using legacy gasPrice property on an eip-1559 network,\n                            // so use gasPrice as both fee properties\n                            const gasPrice = tx.gasPrice;\n                            delete tx.gasPrice;\n                            tx.maxFeePerGas = gasPrice;\n                            tx.maxPriorityFeePerGas = gasPrice;\n                        } else {\n                            // Populate missing fee data\n                            if (tx.maxFeePerGas == null) {\n                                tx.maxFeePerGas = feeData.maxFeePerGas;\n                            }\n                            if (tx.maxPriorityFeePerGas == null) {\n                                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                            }\n                        }\n                    } else if (feeData.gasPrice != null) {\n                        // Network doesn't support EIP-1559...\n                        // ...but they are trying to use EIP-1559 properties\n                        if (hasEip1559) {\n                            logger.throwError(\"network does not support EIP-1559\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                                operation: \"populateTransaction\"\n                            });\n                        }\n                        // Populate missing fee data\n                        if (tx.gasPrice == null) {\n                            tx.gasPrice = feeData.gasPrice;\n                        }\n                        // Explicitly set untyped transaction to legacy\n                        tx.type = 0;\n                    } else {\n                        // getFeeData has failed us.\n                        logger.throwError(\"failed to get consistent fee data\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                            operation: \"signer.getFeeData\"\n                        });\n                    }\n                } else if (tx.type === 2) {\n                    // Explicitly using EIP-1559\n                    // Populate missing fee data\n                    if (tx.maxFeePerGas == null) {\n                        tx.maxFeePerGas = feeData.maxFeePerGas;\n                    }\n                    if (tx.maxPriorityFeePerGas == null) {\n                        tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                    }\n                }\n            }\n            if (tx.nonce == null) {\n                tx.nonce = this.getTransactionCount(\"pending\");\n            }\n            if (tx.gasLimit == null) {\n                tx.gasLimit = this.estimateGas(tx).catch((error)=>{\n                    if (forwardErrors.indexOf(error.code) >= 0) {\n                        throw error;\n                    }\n                    return logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                        error: error,\n                        tx: tx\n                    });\n                });\n            }\n            if (tx.chainId == null) {\n                tx.chainId = this.getChainId();\n            } else {\n                tx.chainId = Promise.all([\n                    Promise.resolve(tx.chainId),\n                    this.getChainId()\n                ]).then((results)=>{\n                    if (results[1] !== 0 && results[0] !== results[1]) {\n                        logger.throwArgumentError(\"chainId address mismatch\", \"transaction\", transaction);\n                    }\n                    return results[0];\n                });\n            }\n            return yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)(tx);\n        });\n    }\n    ///////////////////\n    // Sub-classes SHOULD leave these alone\n    _checkProvider(operation) {\n        if (!this.provider) {\n            logger.throwError(\"missing provider\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: operation || \"_checkProvider\"\n            });\n        }\n    }\n    static isSigner(value) {\n        return !!(value && value._isSigner);\n    }\n}\nclass VoidSigner extends Signer {\n    constructor(address, provider){\n        super();\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"address\", address);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"provider\", provider || null);\n    }\n    getAddress() {\n        return Promise.resolve(this.address);\n    }\n    _fail(message, operation) {\n        return Promise.resolve().then(()=>{\n            logger.throwError(message, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: operation\n            });\n        });\n    }\n    signMessage(message) {\n        return this._fail(\"VoidSigner cannot sign messages\", \"signMessage\");\n    }\n    signTransaction(transaction) {\n        return this._fail(\"VoidSigner cannot sign transactions\", \"signTransaction\");\n    }\n    _signTypedData(domain, types, value) {\n        return this._fail(\"VoidSigner cannot sign typed data\", \"signTypedData\");\n    }\n    connect(provider) {\n        return new VoidSigner(this.address, provider);\n    }\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1zaWduZXIvbGliLmVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFhO0FBQ2IsSUFBSUEsWUFBWSxTQUFLLElBQUksU0FBSSxDQUFDQSxTQUFTLElBQUssU0FBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNuRixTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBQzJGO0FBQzVDO0FBQ1Y7QUFDckMsTUFBTVksU0FBUyxJQUFJRix5REFBTUEsQ0FBQ0MsNkNBQU9BO0FBQ2pDLE1BQU1FLHlCQUF5QjtJQUMzQjtJ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b2R1bGVzL0BldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXNpZ25lci9saWIuZXNtL2luZGV4LmpzP2VhYzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IGRlZmluZVJlYWRPbmx5LCByZXNvbHZlUHJvcGVydGllcywgc2hhbGxvd0NvcHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuY29uc3QgYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyA9IFtcbiAgICBcImFjY2Vzc0xpc3RcIiwgXCJjY2lwUmVhZEVuYWJsZWRcIiwgXCJjaGFpbklkXCIsIFwiY3VzdG9tRGF0YVwiLCBcImRhdGFcIiwgXCJmcm9tXCIsIFwiZ2FzTGltaXRcIiwgXCJnYXNQcmljZVwiLCBcIm1heEZlZVBlckdhc1wiLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwibm9uY2VcIiwgXCJ0b1wiLCBcInR5cGVcIiwgXCJ2YWx1ZVwiXG5dO1xuY29uc3QgZm9yd2FyZEVycm9ycyA9IFtcbiAgICBMb2dnZXIuZXJyb3JzLklOU1VGRklDSUVOVF9GVU5EUyxcbiAgICBMb2dnZXIuZXJyb3JzLk5PTkNFX0VYUElSRUQsXG4gICAgTG9nZ2VyLmVycm9ycy5SRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCxcbl07XG47XG47XG5leHBvcnQgY2xhc3MgU2lnbmVyIHtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gU3ViLWNsYXNzZXMgTVVTVCBjYWxsIHN1cGVyXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGxvZ2dlci5jaGVja0Fic3RyYWN0KG5ldy50YXJnZXQsIFNpZ25lcik7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2lzU2lnbmVyXCIsIHRydWUpO1xuICAgIH1cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gU3ViLWNsYXNzZXMgTUFZIG92ZXJyaWRlIHRoZXNlXG4gICAgZ2V0QmFsYW5jZShibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcImdldEJhbGFuY2VcIik7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5nZXRCYWxhbmNlKHRoaXMuZ2V0QWRkcmVzcygpLCBibG9ja1RhZyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRUcmFuc2FjdGlvbkNvdW50KGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5nZXRBZGRyZXNzKCksIGJsb2NrVGFnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFBvcHVsYXRlcyBcImZyb21cIiBpZiB1bnNwZWNpZmllZCwgYW5kIGVzdGltYXRlcyB0aGUgZ2FzIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICBlc3RpbWF0ZUdhcyh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcImVzdGltYXRlR2FzXCIpO1xuICAgICAgICAgICAgY29uc3QgdHggPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh0aGlzLmNoZWNrVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLmVzdGltYXRlR2FzKHR4KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFBvcHVsYXRlcyBcImZyb21cIiBpZiB1bnNwZWNpZmllZCwgYW5kIGNhbGxzIHdpdGggdGhlIHRyYW5zYWN0aW9uXG4gICAgY2FsbCh0cmFuc2FjdGlvbiwgYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJjYWxsXCIpO1xuICAgICAgICAgICAgY29uc3QgdHggPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh0aGlzLmNoZWNrVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLmNhbGwodHgsIGJsb2NrVGFnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFBvcHVsYXRlcyBhbGwgZmllbGRzIGluIGEgdHJhbnNhY3Rpb24sIHNpZ25zIGl0IGFuZCBzZW5kcyBpdCB0byB0aGUgbmV0d29ya1xuICAgIHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcInNlbmRUcmFuc2FjdGlvblwiKTtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0geWllbGQgdGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lZFR4ID0geWllbGQgdGhpcy5zaWduVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uKHNpZ25lZFR4KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldENoYWluSWQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwiZ2V0Q2hhaW5JZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXR3b3JrLmNoYWluSWQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRHYXNQcmljZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJnZXRHYXNQcmljZVwiKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLmdldEdhc1ByaWNlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRGZWVEYXRhKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcImdldEZlZURhdGFcIik7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5nZXRGZWVEYXRhKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXNvbHZlTmFtZShuYW1lKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwicmVzb2x2ZU5hbWVcIik7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5yZXNvbHZlTmFtZShuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIENoZWNrcyBhIHRyYW5zYWN0aW9uIGRvZXMgbm90IGNvbnRhaW4gaW52YWxpZCBrZXlzIGFuZCBpZlxuICAgIC8vIG5vIFwiZnJvbVwiIGlzIHByb3ZpZGVkLCBwb3B1bGF0ZXMgaXQuXG4gICAgLy8gLSBkb2VzIE5PVCByZXF1aXJlIGEgcHJvdmlkZXJcbiAgICAvLyAtIGFkZHMgXCJmcm9tXCIgaXMgbm90IHByZXNlbnRcbiAgICAvLyAtIHJldHVybnMgYSBDT1BZIChzYWZlIHRvIG11dGF0ZSB0aGUgcmVzdWx0KVxuICAgIC8vIEJ5IGRlZmF1bHQgY2FsbGVkIGZyb206IChvdmVycmlkaW5nIHRoZXNlIHByZXZlbnRzIGl0KVxuICAgIC8vICAgLSBjYWxsXG4gICAgLy8gICAtIGVzdGltYXRlR2FzXG4gICAgLy8gICAtIHBvcHVsYXRlVHJhbnNhY3Rpb24gKGFuZCB0aGVyZWZvciBzZW5kVHJhbnNhY3Rpb24pXG4gICAgY2hlY2tUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgaWYgKGFsbG93ZWRUcmFuc2FjdGlvbktleXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uIGtleTogXCIgKyBrZXksIFwidHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR4ID0gc2hhbGxvd0NvcHkodHJhbnNhY3Rpb24pO1xuICAgICAgICBpZiAodHguZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0eC5mcm9tID0gdGhpcy5nZXRBZGRyZXNzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgYW55IHByb3ZpZGVkIGFkZHJlc3MgbWF0Y2hlcyB0aGlzIHNpZ25lclxuICAgICAgICAgICAgdHguZnJvbSA9IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUodHguZnJvbSksXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRBZGRyZXNzKClcbiAgICAgICAgICAgIF0pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbMF0udG9Mb3dlckNhc2UoKSAhPT0gcmVzdWx0WzFdLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgLy8gUG9wdWxhdGVzIEFMTCBrZXlzIGZvciBhIHRyYW5zYWN0aW9uIGFuZCBjaGVja3MgdGhhdCBcImZyb21cIiBtYXRjaGVzXG4gICAgLy8gdGhpcyBTaWduZXIuIFNob3VsZCBiZSB1c2VkIGJ5IHNlbmRUcmFuc2FjdGlvbiBidXQgTk9UIGJ5IHNpZ25UcmFuc2FjdGlvbi5cbiAgICAvLyBCeSBkZWZhdWx0IGNhbGxlZCBmcm9tOiAob3ZlcnJpZGluZyB0aGVzZSBwcmV2ZW50cyBpdClcbiAgICAvLyAgIC0gc2VuZFRyYW5zYWN0aW9uXG4gICAgLy9cbiAgICAvLyBOb3RlczpcbiAgICAvLyAgLSBXZSBhbGxvdyBnYXNQcmljZSBmb3IgRUlQLTE1NTkgYXMgbG9uZyBhcyBpdCBtYXRjaGVzIG1heEZlZVBlckdhc1xuICAgIHBvcHVsYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0geWllbGQgcmVzb2x2ZVByb3BlcnRpZXModGhpcy5jaGVja1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSk7XG4gICAgICAgICAgICBpZiAodHgudG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHR4LnRvID0gUHJvbWlzZS5yZXNvbHZlKHR4LnRvKS50aGVuKCh0bykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMucmVzb2x2ZU5hbWUodG8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwicHJvdmlkZWQgRU5TIG5hbWUgcmVzb2x2ZXMgdG8gbnVsbFwiLCBcInR4LnRvXCIsIHRvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCB0aGlzIGVycm9yIGZyb20gY2F1c2luZyBhbiBVbmhhbmRsZWRQcm9taXNlRXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgdHgudG8uY2F0Y2goKGVycm9yKSA9PiB7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG8gbm90IGFsbG93IG1peGluZyBwcmUtZWlwLTE1NTkgYW5kIGVpcC0xNTU5IHByb3BlcnRpZXNcbiAgICAgICAgICAgIGNvbnN0IGhhc0VpcDE1NTkgPSAodHgubWF4RmVlUGVyR2FzICE9IG51bGwgfHwgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCk7XG4gICAgICAgICAgICBpZiAodHguZ2FzUHJpY2UgIT0gbnVsbCAmJiAodHgudHlwZSA9PT0gMiB8fCBoYXNFaXAxNTU5KSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJlaXAtMTU1OSB0cmFuc2FjdGlvbiBkbyBub3Qgc3VwcG9ydCBnYXNQcmljZVwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCh0eC50eXBlID09PSAwIHx8IHR4LnR5cGUgPT09IDEpICYmIGhhc0VpcDE1NTkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwicHJlLWVpcC0xNTU5IHRyYW5zYWN0aW9uIGRvIG5vdCBzdXBwb3J0IG1heEZlZVBlckdhcy9tYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodHgudHlwZSA9PT0gMiB8fCB0eC50eXBlID09IG51bGwpICYmICh0eC5tYXhGZWVQZXJHYXMgIT0gbnVsbCAmJiB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSkge1xuICAgICAgICAgICAgICAgIC8vIEZ1bGx5LWZvcm1lZCBFSVAtMTU1OSB0cmFuc2FjdGlvbiAoc2tpcCBnZXRGZWVEYXRhKVxuICAgICAgICAgICAgICAgIHR4LnR5cGUgPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHgudHlwZSA9PT0gMCB8fCB0eC50eXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhwbGljaXQgTGVnYWN5IG9yIEVJUC0yOTMwIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBnYXNQcmljZVxuICAgICAgICAgICAgICAgIGlmICh0eC5nYXNQcmljZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHR4Lmdhc1ByaWNlID0gdGhpcy5nZXRHYXNQcmljZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZ2V0IGZlZSBkYXRhIHRvIGRldGVybWluZSB0aGluZ3NcbiAgICAgICAgICAgICAgICBjb25zdCBmZWVEYXRhID0geWllbGQgdGhpcy5nZXRGZWVEYXRhKCk7XG4gICAgICAgICAgICAgICAgaWYgKHR4LnR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGF1dG8tZGV0ZWN0IHRoZSBpbnRlbmRlZCB0eXBlIG9mIHRoaXMgdHJhbnNhY3Rpb24uLi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZlZURhdGEubWF4RmVlUGVyR2FzICE9IG51bGwgJiYgZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbmV0d29yayBzdXBwb3J0cyBFSVAtMTU1OSFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZ3JhZGUgdHJhbnNhY3Rpb24gZnJvbSBudWxsIHRvIGVpcC0xNTU5XG4gICAgICAgICAgICAgICAgICAgICAgICB0eC50eXBlID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNpbmcgbGVnYWN5IGdhc1ByaWNlIHByb3BlcnR5IG9uIGFuIGVpcC0xNTU5IG5ldHdvcmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gdXNlIGdhc1ByaWNlIGFzIGJvdGggZmVlIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0eC5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5tYXhGZWVQZXJHYXMgPSBnYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IGdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBmZWUgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5tYXhGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5tYXhGZWVQZXJHYXMgPSBmZWVEYXRhLm1heEZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmZWVEYXRhLmdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldHdvcmsgZG9lc24ndCBzdXBwb3J0IEVJUC0xNTU5Li4uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi5idXQgdGhleSBhcmUgdHJ5aW5nIHRvIHVzZSBFSVAtMTU1OSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzRWlwMTU1OSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibmV0d29yayBkb2VzIG5vdCBzdXBwb3J0IEVJUC0xNTU5XCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJwb3B1bGF0ZVRyYW5zYWN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5nYXNQcmljZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguZ2FzUHJpY2UgPSBmZWVEYXRhLmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSBzZXQgdW50eXBlZCB0cmFuc2FjdGlvbiB0byBsZWdhY3lcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4LnR5cGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0RmVlRGF0YSBoYXMgZmFpbGVkIHVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJmYWlsZWQgdG8gZ2V0IGNvbnNpc3RlbnQgZmVlIGRhdGFcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2lnbmVyLmdldEZlZURhdGFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHgudHlwZSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdGx5IHVzaW5nIEVJUC0xNTU5XG4gICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lm1heEZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eC5tYXhGZWVQZXJHYXMgPSBmZWVEYXRhLm1heEZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR4Lm5vbmNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0eC5ub25jZSA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25Db3VudChcInBlbmRpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHguZ2FzTGltaXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHR4Lmdhc0xpbWl0ID0gdGhpcy5lc3RpbWF0ZUdhcyh0eCkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3J3YXJkRXJyb3JzLmluZGV4T2YoZXJyb3IuY29kZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGVzdGltYXRlIGdhczsgdHJhbnNhY3Rpb24gbWF5IGZhaWwgb3IgbWF5IHJlcXVpcmUgbWFudWFsIGdhcyBsaW1pdFwiLCBMb2dnZXIuZXJyb3JzLlVOUFJFRElDVEFCTEVfR0FTX0xJTUlULCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eDogdHhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHguY2hhaW5JZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHguY2hhaW5JZCA9IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHguY2hhaW5JZCA9IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHR4LmNoYWluSWQpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldENoYWluSWQoKVxuICAgICAgICAgICAgICAgIF0pLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdHNbMV0gIT09IDAgJiYgcmVzdWx0c1swXSAhPT0gcmVzdWx0c1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImNoYWluSWQgYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0c1swXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh0eCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gU3ViLWNsYXNzZXMgU0hPVUxEIGxlYXZlIHRoZXNlIGFsb25lXG4gICAgX2NoZWNrUHJvdmlkZXIob3BlcmF0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJtaXNzaW5nIHByb3ZpZGVyXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiAob3BlcmF0aW9uIHx8IFwiX2NoZWNrUHJvdmlkZXJcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBpc1NpZ25lcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzU2lnbmVyKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVm9pZFNpZ25lciBleHRlbmRzIFNpZ25lciB7XG4gICAgY29uc3RydWN0b3IoYWRkcmVzcywgcHJvdmlkZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyIHx8IG51bGwpO1xuICAgIH1cbiAgICBnZXRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYWRkcmVzcyk7XG4gICAgfVxuICAgIF9mYWlsKG1lc3NhZ2UsIG9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyBvcGVyYXRpb246IG9wZXJhdGlvbiB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhaWwoXCJWb2lkU2lnbmVyIGNhbm5vdCBzaWduIG1lc3NhZ2VzXCIsIFwic2lnbk1lc3NhZ2VcIik7XG4gICAgfVxuICAgIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmFpbChcIlZvaWRTaWduZXIgY2Fubm90IHNpZ24gdHJhbnNhY3Rpb25zXCIsIFwic2lnblRyYW5zYWN0aW9uXCIpO1xuICAgIH1cbiAgICBfc2lnblR5cGVkRGF0YShkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmFpbChcIlZvaWRTaWduZXIgY2Fubm90IHNpZ24gdHlwZWQgZGF0YVwiLCBcInNpZ25UeXBlZERhdGFcIik7XG4gICAgfVxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWb2lkU2lnbmVyKHRoaXMuYWRkcmVzcywgcHJvdmlkZXIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJkZWZpbmVSZWFkT25seSIsInJlc29sdmVQcm9wZXJ0aWVzIiwic2hhbGxvd0NvcHkiLCJMb2dnZXIiLCJ2ZXJzaW9uIiwibG9nZ2VyIiwiYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyIsImZvcndhcmRFcnJvcnMiLCJlcnJvcnMiLCJJTlNVRkZJQ0lFTlRfRlVORFMiLCJOT05DRV9FWFBJUkVEIiwiUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQiLCJTaWduZXIiLCJjb25zdHJ1Y3RvciIsImNoZWNrQWJzdHJhY3QiLCJnZXRCYWxhbmNlIiwiYmxvY2tUYWciLCJfY2hlY2tQcm92aWRlciIsInByb3ZpZGVyIiwiZ2V0QWRkcmVzcyIsImdldFRyYW5zYWN0aW9uQ291bnQiLCJlc3RpbWF0ZUdhcyIsInRyYW5zYWN0aW9uIiwidHgiLCJjaGVja1RyYW5zYWN0aW9uIiwiY2FsbCIsInNlbmRUcmFuc2FjdGlvbiIsInBvcHVsYXRlVHJhbnNhY3Rpb24iLCJzaWduZWRUeCIsInNpZ25UcmFuc2FjdGlvbiIsImdldENoYWluSWQiLCJuZXR3b3JrIiwiZ2V0TmV0d29yayIsImNoYWluSWQiLCJnZXRHYXNQcmljZSIsImdldEZlZURhdGEiLCJyZXNvbHZlTmFtZSIsIm5hbWUiLCJrZXkiLCJpbmRleE9mIiwidGhyb3dBcmd1bWVudEVycm9yIiwiZnJvbSIsImFsbCIsInRvTG93ZXJDYXNlIiwidG8iLCJhZGRyZXNzIiwiY2F0Y2giLCJlcnJvciIsImhhc0VpcDE1NTkiLCJtYXhGZWVQZXJHYXMiLCJtYXhQcmlvcml0eUZlZVBlckdhcyIsImdhc1ByaWNlIiwidHlwZSIsImZlZURhdGEiLCJ0aHJvd0Vycm9yIiwiVU5TVVBQT1JURURfT1BFUkFUSU9OIiwib3BlcmF0aW9uIiwibm9uY2UiLCJnYXNMaW1pdCIsImNvZGUiLCJVTlBSRURJQ1RBQkxFX0dBU19MSU1JVCIsInJlc3VsdHMiLCJpc1NpZ25lciIsIl9pc1NpZ25lciIsIlZvaWRTaWduZXIiLCJfZmFpbCIsIm1lc3NhZ2UiLCJzaWduTWVzc2FnZSIsIl9zaWduVHlwZWREYXRhIiwiZG9tYWluIiwidHlwZXMiLCJjb25uZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-signer/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/address/lib.esm/_version.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/address/lib.esm/_version.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"address/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hZGRyZXNzL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLFVBQVUsZ0JBQWdCLENBQ3ZDLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NsaW1lLWJldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FkZHJlc3MvbGliLmVzbS9fdmVyc2lvbi5qcz84Y2UyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJhZGRyZXNzLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/address/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/address/lib.esm/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/address/lib.esm/index.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAddress: () => (/* binding */ getAddress),\n/* harmony export */   getContractAddress: () => (/* binding */ getContractAddress),\n/* harmony export */   getCreate2Address: () => (/* binding */ getCreate2Address),\n/* harmony export */   getIcapAddress: () => (/* binding */ getIcapAddress),\n/* harmony export */   isAddress: () => (/* binding */ isAddress)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/keccak256/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/rlp */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/rlp/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/address/lib.esm/_version.js\");\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nfunction getChecksumAddress(address) {\n    if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isHexString)(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    address = address.toLowerCase();\n    const chars = address.substring(2).split(\"\");\n    const expanded = new Uint8Array(40);\n    for(let i = 0; i < 40; i++){\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    const hashed = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__.keccak256)(expanded));\n    for(let i = 0; i < 40; i += 2){\n        if (hashed[i >> 1] >> 4 >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER = 0x1fffffffffffff;\nfunction log10(x) {\n    if (Math.log10) {\n        return Math.log10(x);\n    }\n    return Math.log(x) / Math.LN10;\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nconst ibanLookup = {};\nfor(let i = 0; i < 10; i++){\n    ibanLookup[String(i)] = String(i);\n}\nfor(let i = 0; i < 26; i++){\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    let expanded = address.split(\"\").map((c)=>{\n        return ibanLookup[c];\n    }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while(expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    let checksum = String(98 - parseInt(expanded, 10) % 97);\n    while(checksum.length < 2){\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nfunction getAddress(address) {\n    let result = null;\n    if (typeof address !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") {\n            address = \"0x\" + address;\n        }\n        result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n        result = (0,_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__._base36To16)(address.substring(4));\n        while(result.length < 40){\n            result = \"0\" + result;\n        }\n        result = getChecksumAddress(\"0x\" + result);\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    return result;\n}\nfunction isAddress(address) {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) {}\n    return false;\n}\nfunction getIcapAddress(address) {\n    let base36 = (0,_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__._base16To36)(getAddress(address).substring(2)).toUpperCase();\n    while(base36.length < 30){\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nfunction getContractAddress(transaction) {\n    let from = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n    const nonce = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.stripZeros)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction.nonce).toHexString()));\n    return getAddress((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexDataSlice)((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_ethersproject_rlp__WEBPACK_IMPORTED_MODULE_5__.encode)([\n        from,\n        nonce\n    ])), 12));\n}\nfunction getCreate2Address(from, salt, initCodeHash) {\n    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexDataLength)(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexDataLength)(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexDataSlice)((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.concat)([\n        \"0xff\",\n        getAddress(from),\n        salt,\n        initCodeHash\n    ])), 12));\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hZGRyZXNzL2xpYi5lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBYTtBQUNpRztBQUMvQjtBQUMxQjtBQUNUO0FBQ0c7QUFDVjtBQUNyQyxNQUFNYSxTQUFTLElBQUlGLHlEQUFNQSxDQUFDQyw2Q0FBT0E7QUFDakMsU0FBU0UsbUJBQW1CQyxPQUFPO0lBQy9CLElBQUksQ0FBQ1gsaUVBQVdBLENBQUNXLFNBQVMsS0FBSztRQUMzQkYsT0FBT0csa0JBQWtCLENBQUMsbUJBQW1CLFdBQVdEO0lBQzVEO0lBQ0FBLFVBQVVBLFFBQVFFLFdBQVc7SUFDN0IsTUFBTUMsUUFBUUgsUUFBUUksU0FBUyxDQUFDLEdBQUdDLEtBQUssQ0FBQztJQUN6QyxNQUFNQyxXQUFXLElBQUlDLFdBQVc7SUFDaEMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUksSUFBSUEsSUFBSztRQUN6QkYsUUFBUSxDQUFDRSxFQUFFLEdBQUdMLEtBQUssQ0FBQ0ssRUFBRSxDQUFDQyxVQUFVLENBQUM7SUFDdEM7SUFDQSxNQUFNQyxTQUFTekIsOERBQVFBLENBQUNTLG1FQUFTQSxDQUFDWTtJQUNsQyxJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSSxJQUFJQSxLQUFLLEVBQUc7UUFDNUIsSUFBSSxNQUFPLENBQUNBLEtBQUssRUFBRSxJQUFJLEtBQU0sR0FBRztZQUM1QkwsS0FBSyxDQUFDSyxFQUFFLEdBQUdMLEtBQUssQ0FBQ0ssRUFBRSxDQUFDRyxXQUFXO1FBQ25DO1FBQ0EsSUFBSSxDQUFDRCxNQUFNLENBQUNGLEtBQUssRUFBRSxHQUFHLElBQUcsS0FBTSxHQUFHO1lBQzlCTCxLQUFLLENBQUNLLElBQUksRUFBRSxHQUFHTCxLQUFLLENBQUNLLElBQUksRUFBRSxDQUFDRyxXQUFXO1FBQzNDO0lBQ0o7SUFDQSxPQUFPLE9BQU9SLE1BQU1TLElBQUksQ0FBQztB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b2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWRkcmVzcy9saWIuZXNtL2luZGV4LmpzPzcwMTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgY29uY2F0LCBoZXhEYXRhTGVuZ3RoLCBoZXhEYXRhU2xpY2UsIGlzSGV4U3RyaW5nLCBzdHJpcFplcm9zIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIsIF9iYXNlMTZUbzM2LCBfYmFzZTM2VG8xNiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9rZWNjYWsyNTZcIjtcbmltcG9ydCB7IGVuY29kZSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ybHBcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmZ1bmN0aW9uIGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgaWYgKCFpc0hleFN0cmluZyhhZGRyZXNzLCAyMCkpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgfVxuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgY2hhcnMgPSBhZGRyZXNzLnN1YnN0cmluZygyKS5zcGxpdChcIlwiKTtcbiAgICBjb25zdCBleHBhbmRlZCA9IG5ldyBVaW50OEFycmF5KDQwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpKyspIHtcbiAgICAgICAgZXhwYW5kZWRbaV0gPSBjaGFyc1tpXS5jaGFyQ29kZUF0KDApO1xuICAgIH1cbiAgICBjb25zdCBoYXNoZWQgPSBhcnJheWlmeShrZWNjYWsyNTYoZXhwYW5kZWQpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpICs9IDIpIHtcbiAgICAgICAgaWYgKChoYXNoZWRbaSA+PiAxXSA+PiA0KSA+PSA4KSB7XG4gICAgICAgICAgICBjaGFyc1tpXSA9IGNoYXJzW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoYXNoZWRbaSA+PiAxXSAmIDB4MGYpID49IDgpIHtcbiAgICAgICAgICAgIGNoYXJzW2kgKyAxXSA9IGNoYXJzW2kgKyAxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyBjaGFycy5qb2luKFwiXCIpO1xufVxuLy8gU2hpbXMgZm9yIGVudmlyb25tZW50cyB0aGF0IGFyZSBtaXNzaW5nIHNvbWUgcmVxdWlyZWQgY29uc3RhbnRzIGFuZCBmdW5jdGlvbnNcbmNvbnN0IE1BWF9TQUZFX0lOVEVHRVIgPSAweDFmZmZmZmZmZmZmZmZmO1xuZnVuY3Rpb24gbG9nMTAoeCkge1xuICAgIGlmIChNYXRoLmxvZzEwKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZzEwKHgpO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMTA7XG59XG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludGVybmF0aW9uYWxfQmFua19BY2NvdW50X051bWJlclxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZVxuY29uc3QgaWJhbkxvb2t1cCA9IHt9O1xuZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgaWJhbkxvb2t1cFtTdHJpbmcoaSldID0gU3RyaW5nKGkpO1xufVxuZm9yIChsZXQgaSA9IDA7IGkgPCAyNjsgaSsrKSB7XG4gICAgaWJhbkxvb2t1cFtTdHJpbmcuZnJvbUNoYXJDb2RlKDY1ICsgaSldID0gU3RyaW5nKDEwICsgaSk7XG59XG4vLyBIb3cgbWFueSBkZWNpbWFsIGRpZ2l0cyBjYW4gd2UgcHJvY2Vzcz8gKGZvciA2NC1iaXQgZmxvYXQsIHRoaXMgaXMgMTUpXG5jb25zdCBzYWZlRGlnaXRzID0gTWF0aC5mbG9vcihsb2cxMChNQVhfU0FGRV9JTlRFR0VSKSk7XG5mdW5jdGlvbiBpYmFuQ2hlY2tzdW0oYWRkcmVzcykge1xuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvVXBwZXJDYXNlKCk7XG4gICAgYWRkcmVzcyA9IGFkZHJlc3Muc3Vic3RyaW5nKDQpICsgYWRkcmVzcy5zdWJzdHJpbmcoMCwgMikgKyBcIjAwXCI7XG4gICAgbGV0IGV4cGFuZGVkID0gYWRkcmVzcy5zcGxpdChcIlwiKS5tYXAoKGMpID0+IHsgcmV0dXJuIGliYW5Mb29rdXBbY107IH0pLmpvaW4oXCJcIik7XG4gICAgLy8gSmF2YXNjcmlwdCBjYW4gaGFuZGxlIGludGVnZXJzIHNhZmVseSB1cCB0byAxNSAoZGVjaW1hbCkgZGlnaXRzXG4gICAgd2hpbGUgKGV4cGFuZGVkLmxlbmd0aCA+PSBzYWZlRGlnaXRzKSB7XG4gICAgICAgIGxldCBibG9jayA9IGV4cGFuZGVkLnN1YnN0cmluZygwLCBzYWZlRGlnaXRzKTtcbiAgICAgICAgZXhwYW5kZWQgPSBwYXJzZUludChibG9jaywgMTApICUgOTcgKyBleHBhbmRlZC5zdWJzdHJpbmcoYmxvY2subGVuZ3RoKTtcbiAgICB9XG4gICAgbGV0IGNoZWNrc3VtID0gU3RyaW5nKDk4IC0gKHBhcnNlSW50KGV4cGFuZGVkLCAxMCkgJSA5NykpO1xuICAgIHdoaWxlIChjaGVja3N1bS5sZW5ndGggPCAyKSB7XG4gICAgICAgIGNoZWNrc3VtID0gXCIwXCIgKyBjaGVja3N1bTtcbiAgICB9XG4gICAgcmV0dXJuIGNoZWNrc3VtO1xufVxuO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFkZHJlc3MoYWRkcmVzcykge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGlmICh0eXBlb2YgKGFkZHJlc3MpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgIH1cbiAgICBpZiAoYWRkcmVzcy5tYXRjaCgvXigweCk/WzAtOWEtZkEtRl17NDB9JC8pKSB7XG4gICAgICAgIC8vIE1pc3NpbmcgdGhlIDB4IHByZWZpeFxuICAgICAgICBpZiAoYWRkcmVzcy5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuICAgICAgICAgICAgYWRkcmVzcyA9IFwiMHhcIiArIGFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICAvLyBJdCBpcyBhIGNoZWNrc3VtbWVkIGFkZHJlc3Mgd2l0aCBhIGJhZCBjaGVja3N1bVxuICAgICAgICBpZiAoYWRkcmVzcy5tYXRjaCgvKFtBLUZdLipbYS1mXSl8KFthLWZdLipbQS1GXSkvKSAmJiByZXN1bHQgIT09IGFkZHJlc3MpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJiYWQgYWRkcmVzcyBjaGVja3N1bVwiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWF5YmUgSUNBUD8gKHdlIG9ubHkgc3VwcG9ydCBkaXJlY3QgbW9kZSlcbiAgICB9XG4gICAgZWxzZSBpZiAoYWRkcmVzcy5tYXRjaCgvXlhFWzAtOV17Mn1bMC05QS1aYS16XXszMCwzMX0kLykpIHtcbiAgICAgICAgLy8gSXQgaXMgYW4gSUNBUCBhZGRyZXNzIHdpdGggYSBiYWQgY2hlY2tzdW1cbiAgICAgICAgaWYgKGFkZHJlc3Muc3Vic3RyaW5nKDIsIDQpICE9PSBpYmFuQ2hlY2tzdW0oYWRkcmVzcykpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJiYWQgaWNhcCBjaGVja3N1bVwiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gX2Jhc2UzNlRvMTYoYWRkcmVzcy5zdWJzdHJpbmcoNCkpO1xuICAgICAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IDQwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBcIjBcIiArIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBnZXRDaGVja3N1bUFkZHJlc3MoXCIweFwiICsgcmVzdWx0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEljYXBBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICBsZXQgYmFzZTM2ID0gX2Jhc2UxNlRvMzYoZ2V0QWRkcmVzcyhhZGRyZXNzKS5zdWJzdHJpbmcoMikpLnRvVXBwZXJDYXNlKCk7XG4gICAgd2hpbGUgKGJhc2UzNi5sZW5ndGggPCAzMCkge1xuICAgICAgICBiYXNlMzYgPSBcIjBcIiArIGJhc2UzNjtcbiAgICB9XG4gICAgcmV0dXJuIFwiWEVcIiArIGliYW5DaGVja3N1bShcIlhFMDBcIiArIGJhc2UzNikgKyBiYXNlMzY7XG59XG4vLyBodHRwOi8vZXRoZXJldW0uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzc2MC9ob3ctaXMtdGhlLWFkZHJlc3Mtb2YtYW4tZXRoZXJldW0tY29udHJhY3QtY29tcHV0ZWRcbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250cmFjdEFkZHJlc3ModHJhbnNhY3Rpb24pIHtcbiAgICBsZXQgZnJvbSA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgICAgZnJvbSA9IGdldEFkZHJlc3ModHJhbnNhY3Rpb24uZnJvbSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibWlzc2luZyBmcm9tIGFkZHJlc3NcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IG5vbmNlID0gc3RyaXBaZXJvcyhhcnJheWlmeShCaWdOdW1iZXIuZnJvbSh0cmFuc2FjdGlvbi5ub25jZSkudG9IZXhTdHJpbmcoKSkpO1xuICAgIHJldHVybiBnZXRBZGRyZXNzKGhleERhdGFTbGljZShrZWNjYWsyNTYoZW5jb2RlKFtmcm9tLCBub25jZV0pKSwgMTIpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRDcmVhdGUyQWRkcmVzcyhmcm9tLCBzYWx0LCBpbml0Q29kZUhhc2gpIHtcbiAgICBpZiAoaGV4RGF0YUxlbmd0aChzYWx0KSAhPT0gMzIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNhbHQgbXVzdCBiZSAzMiBieXRlc1wiLCBcInNhbHRcIiwgc2FsdCk7XG4gICAgfVxuICAgIGlmIChoZXhEYXRhTGVuZ3RoKGluaXRDb2RlSGFzaCkgIT09IDMyKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbml0Q29kZUhhc2ggbXVzdCBiZSAzMiBieXRlc1wiLCBcImluaXRDb2RlSGFzaFwiLCBpbml0Q29kZUhhc2gpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhoZXhEYXRhU2xpY2Uoa2VjY2FrMjU2KGNvbmNhdChbXCIweGZmXCIsIGdldEFkZHJlc3MoZnJvbSksIHNhbHQsIGluaXRDb2RlSGFzaF0pKSwgMTIpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJhcnJheWlmeSIsImNvbmNhdCIsImhleERhdGFMZW5ndGgiLCJoZXhEYXRhU2xpY2UiLCJpc0hleFN0cmluZyIsInN0cmlwWmVyb3MiLCJCaWdOdW1iZXIiLCJfYmFzZTE2VG8zNiIsIl9iYXNlMzZUbzE2Iiwia2VjY2FrMjU2IiwiZW5jb2RlIiwiTG9nZ2VyIiwidmVyc2lvbiIsImxvZ2dlciIsImdldENoZWNrc3VtQWRkcmVzcyIsImFkZHJlc3MiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJ0b0xvd2VyQ2FzZSIsImNoYXJzIiwic3Vic3RyaW5nIiwic3BsaXQiLCJleHBhbmRlZCIsIlVpbnQ4QXJyYXkiLCJpIiwiY2hhckNvZGVBdCIsImhhc2hlZCIsInRvVXBwZXJDYXNlIiwiam9pbiIsIk1BWF9TQUZFX0lOVEVHRVIiLCJsb2cxMCIsIngiLCJNYXRoIiwibG9nIiwiTE4xMCIsImliYW5Mb29rdXAiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJzYWZlRGlnaXRzIiwiZmxvb3IiLCJpYmFuQ2hlY2tzdW0iLCJtYXAiLCJjIiwibGVuZ3RoIiwiYmxvY2siLCJwYXJzZUludCIsImNoZWNrc3VtIiwiZ2V0QWRkcmVzcyIsInJlc3VsdCIsIm1hdGNoIiwiaXNBZGRyZXNzIiwiZXJyb3IiLCJnZXRJY2FwQWRkcmVzcyIsImJhc2UzNiIsImdldENvbnRyYWN0QWRkcmVzcyIsInRyYW5zYWN0aW9uIiwiZnJvbSIsIm5vbmNlIiwidG9IZXhTdHJpbmciLCJnZXRDcmVhdGUyQWRkcmVzcyIsInNhbHQiLCJpbml0Q29kZUhhc2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/address/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/base64/lib.esm/base64.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/base64/lib.esm/base64.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n\n\nfunction decode(textData) {\n    textData = atob(textData);\n    const data = [];\n    for(let i = 0; i < textData.length; i++){\n        data.push(textData.charCodeAt(i));\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.arrayify)(data);\n}\nfunction encode(data) {\n    data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.arrayify)(data);\n    let textData = \"\";\n    for(let i = 0; i < data.length; i++){\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n} //# sourceMappingURL=base64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9iYXNlNjQvbGliLmVzbS9iYXNlNjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWE7QUFDbUM7QUFDekMsU0FBU0MsT0FBT0MsUUFBUTtJQUMzQkEsV0FBV0MsS0FBS0Q7SUFDaEIsTUFBTUUsT0FBTyxFQUFFO0lBQ2YsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILFNBQVNJLE1BQU0sRUFBRUQsSUFBSztRQUN0Q0QsS0FBS0csSUFBSSxDQUFDTCxTQUFTTSxVQUFVLENBQUNIO0lBQ2xDO0lBQ0EsT0FBT0wsOERBQVFBLENBQUNJO0FBQ3BCO0FBQ08sU0FBU0ssT0FBT0wsSUFBSTtJQUN2QkEsT0FBT0osOERBQVFBLENBQUNJO0lBQ2hCLElBQUlGLFdBQVc7SUFDZixJQUFLLElBQUlHLElBQUksR0FBR0EsSUFBSUQsS0FBS0UsTUFBTSxFQUFFRCxJQUFLO1FBQ2xDSCxZQUFZUSxPQUFPQyxZQUFZLENBQUNQLElBQUksQ0FBQ0MsRUFBRTtJQUMzQztJQUNBLE9BQU9PLEtBQUtWO0FBQ2hCLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2xpbWUtYmV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYmFzZTY0L2xpYi5lc20vYmFzZTY0LmpzPzUzZTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBhcnJheWlmeSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZSh0ZXh0RGF0YSkge1xuICAgIHRleHREYXRhID0gYXRvYih0ZXh0RGF0YSk7XG4gICAgY29uc3QgZGF0YSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YS5wdXNoKHRleHREYXRhLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlpZnkoZGF0YSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgICBkYXRhID0gYXJyYXlpZnkoZGF0YSk7XG4gICAgbGV0IHRleHREYXRhID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGV4dERhdGEgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ0b2EodGV4dERhdGEpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTY0LmpzLm1hcCJdLCJuYW1lcyI6WyJhcnJheWlmeSIsImRlY29kZSIsInRleHREYXRhIiwiYXRvYiIsImRhdGEiLCJpIiwibGVuZ3RoIiwicHVzaCIsImNoYXJDb2RlQXQiLCJlbmNvZGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJidG9hIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/base64/lib.esm/base64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/basex/lib.esm/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/basex/lib.esm/index.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Base32: () => (/* binding */ Base32),\n/* harmony export */   Base58: () => (/* binding */ Base58),\n/* harmony export */   BaseX: () => (/* binding */ BaseX)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/**\n * var basex = require(\"base-x\");\n *\n * This implementation is heavily based on base-x. The main reason to\n * deviate was to prevent the dependency of Buffer.\n *\n * Contributors:\n *\n * base-x encoding\n * Forked from https://github.com/cryptocoinjs/bs58\n * Originally written by Mike Hearn for BitcoinJ\n * Copyright (c) 2011 Google Inc\n * Ported to JavaScript by Stefan Thomas\n * Merged Buffer refactorings from base58-native by Stephen Pair\n * Copyright (c) 2013 BitPay Inc\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */ \n\nclass BaseX {\n    constructor(alphabet){\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__.defineReadOnly)(this, \"alphabet\", alphabet);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__.defineReadOnly)(this, \"base\", alphabet.length);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__.defineReadOnly)(this, \"_alphabetMap\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__.defineReadOnly)(this, \"_leader\", alphabet.charAt(0));\n        // pre-compute lookup table\n        for(let i = 0; i < alphabet.length; i++){\n            this._alphabetMap[alphabet.charAt(i)] = i;\n        }\n    }\n    encode(value) {\n        let source = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(value);\n        if (source.length === 0) {\n            return \"\";\n        }\n        let digits = [\n            0\n        ];\n        for(let i = 0; i < source.length; ++i){\n            let carry = source[i];\n            for(let j = 0; j < digits.length; ++j){\n                carry += digits[j] << 8;\n                digits[j] = carry % this.base;\n                carry = carry / this.base | 0;\n            }\n            while(carry > 0){\n                digits.push(carry % this.base);\n                carry = carry / this.base | 0;\n            }\n        }\n        let string = \"\";\n        // deal with leading zeros\n        for(let k = 0; source[k] === 0 && k < source.length - 1; ++k){\n            string += this._leader;\n        }\n        // convert digits to a string\n        for(let q = digits.length - 1; q >= 0; --q){\n            string += this.alphabet[digits[q]];\n        }\n        return string;\n    }\n    decode(value) {\n        if (typeof value !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n        let bytes = [];\n        if (value.length === 0) {\n            return new Uint8Array(bytes);\n        }\n        bytes.push(0);\n        for(let i = 0; i < value.length; i++){\n            let byte = this._alphabetMap[value[i]];\n            if (byte === undefined) {\n                throw new Error(\"Non-base\" + this.base + \" character\");\n            }\n            let carry = byte;\n            for(let j = 0; j < bytes.length; ++j){\n                carry += bytes[j] * this.base;\n                bytes[j] = carry & 0xff;\n                carry >>= 8;\n            }\n            while(carry > 0){\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n        // deal with leading zeros\n        for(let k = 0; value[k] === this._leader && k < value.length - 1; ++k){\n            bytes.push(0);\n        }\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(new Uint8Array(bytes.reverse()));\n    }\n}\nconst Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\nconst Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\n //console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n //console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9iYXNleC9saWIuZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0NDLEdBQytDO0FBQ1c7QUFDcEQsTUFBTUU7SUFDVEMsWUFBWUMsUUFBUSxDQUFFO1FBQ2xCSCx5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsWUFBWUc7UUFDakNILHlFQUFjQSxDQUFDLElBQUksRUFBRSxRQUFRRyxTQUFTQyxNQUFNO1FBQzVDSix5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsZ0JBQWdCLENBQUM7UUFDdENBLHlFQUFjQSxDQUFDLElBQUksRUFBRSxXQUFXRyxTQUFTRSxNQUFNLENBQUM7UUFDaEQsMkJBQTJCO1FBQzNCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSCxTQUFTQyxNQUFNLEVBQUVFLElBQUs7WUFDdEMsSUFBSSxDQUFDQyxZQUFZLENBQUNKLFNBQVNFLE1BQU0sQ0FBQ0MsR0FBRyxHQUFHQTtRQUM1QztJQUNKO0lBQ0FFLE9BQU9DLEtBQUssRUFBRTtRQUNWLElBQUlDLFNBQVNYLDhEQUFRQSxDQUFDVTtRQUN0QixJQUFJQyxPQUFPTixNQUFNLEtBQUssR0FBRztZQUNyQixPQUFPO1FBQ1g7UUFDQSxJQUFJTyxTQUFTO1lBQUM7U0FBRTtRQUNoQixJQUFLLElBQUlMLElBQUksR0FBR0EsSUFBSUksT0FBT04sTUFBTSxFQUFFLEVBQUVFLEVBQUc7WUFDcEMsSUFBSU0sUUFBUUYsTUFBTSxDQUFDSixFQUFFO1lBQ3JCLElBQUssSUFBSU8sSUFBSSxHQUFHQSxJQUFJRixPQUFPUCxNQUFNLEVBQUUsRUFBRVMsRUFBRztnQkFDcENELFNBQVNELE1BQU0sQ0FBQ0UsRUFBRSxJQUFJO2dCQUN0QkYsTUFBTSxDQUFDRSxFQUFFLEdBQUdELFFBQVEsSUFBSSxDQUFDRSxJQUFJO2dCQUM3QkYsUUFBUSxRQUFTLElBQUksQ0FBQ0UsSUFBSSxHQUFJO1lBQ2xDO1lBQ0EsTUFBT0YsUUFBUSxFQUFHO2dCQUNkRCxPQUFPSSxJQUFJLENBQUNILFFBQVEsSUFBSSxDQUFDRSxJQUFJO2dCQUM3QkYsUUFBUSxRQUFTLElBQUksQ0FBQ0UsSUFBSSxHQUFJO1lBQ2xDO1FBQ0o7UUFDQSxJQUFJRSxTQUFTO1FBQ2IsMEJBQTBCO1FBQzFCLElBQUssSUFBSUMsSUFBSSxHQUFHUCxNQUFNLENBQUNPLEVBQUUsS0FBSyxLQUFLQSxJQUFJUCxPQUFPTixNQUFNLEdBQUcsR0FBRyxFQUFFYSxFQUFHO1lBQzNERCxVQUFVLElBQUksQ0FBQ0UsT0FBTztRQUMxQjtRQUNBLDZCQUE2QjtRQUM3QixJQUFLLElBQUlDLElBQUlSLE9BQU9QLE1BQU0sR0FBRyxHQUFHZSxLQUFLLEdBQUcsRUFBRUEsRUFBRztZQUN6Q0gsVUFBVSxJQUFJLENBQUNiLFFBQVEsQ0FBQ1EsTUFBTSxDQUFDUSxFQUFFLENBQUM7UUFDdEM7UUFDQSxPQUFPSDtJQUNYO0lBQ0FJLE9BQU9YLEtBQUssRUFBRTtRQUNWLElBQUksT0FBUUEsVUFBVyxVQUFVO1lBQzdCLE1BQU0sSUFBSVksVUFBVTtRQUN4QjtRQUNBLElBQUlDLFFBQVEsRUFBRTtRQUNkLElBQUliLE1BQU1MLE1BQU0sS0FBSyxHQUFHO1lBQ3BCLE9BQU8sSUFBSW1CLFdBQVdEO1FBQzFCO1FBQ0FBLE1BQU1QLElBQUksQ0FBQztRQUNYLElBQUssSUFBSVQsSUFBSSxHQUFHQSxJQUFJRyxNQUFNTCxNQUFNLEVBQUVFLElBQUs7WUFDbkMsSUFBSWtCLE9BQU8sSUFBSSxDQUFDakIsWUFBWSxDQUFDRSxLQUFLLENBQUNILEVBQUUsQ0FBQztZQUN0QyxJQUFJa0IsU0FBU0MsV0FBVztnQkFDcEIsTUFBTSxJQUFJQyxNQUFNLGFBQWEsSUFBSSxDQUFDWixJQUFJLEdBQUc7WUFDN0M7WUFDQSxJQUFJRixRQUFRWTtZQUNaLElBQUssSUFBSVgsSUFBSSxHQUFHQSxJQUFJUyxNQUFNbEIsTUFBTSxFQUFFLEVBQUVTLEVBQUc7Z0JBQ25DRCxTQUFTVSxLQUFLLENBQUNULEVBQUUsR0FBRyxJQUFJLENBQUNDLElBQUk7Z0JBQzdCUSxLQUFLLENBQUNULEVBQUUsR0FBR0QsUUFBUTtnQkFDbkJBLFVBQVU7WUFDZDtZQUNBLE1BQU9BLFFBQVEsRUFBRztnQkFDZFUsTUFBTVAsSUFBSSxDQUFDSCxRQUFRO2dCQUNuQkEsVUFBVTtZQUNkO1FBQ0o7UUFDQSwwQkFBMEI7UUFDMUIsSUFBSyxJQUFJSyxJQUFJLEdBQUdSLEtBQUssQ0FBQ1EsRUFBRSxLQUFLLElBQUksQ0FBQ0MsT0FBTyxJQUFJRCxJQUFJUixNQUFNTCxNQUFNLEdBQUcsR0FBRyxFQUFFYSxFQUFHO1lBQ3BFSyxNQUFNUCxJQUFJLENBQUM7UUFDZjtRQUNBLE9BQU9oQiw4REFBUUEsQ0FBQyxJQUFJd0IsV0FBV0QsTUFBTUssT0FBTztJQUNoRDtBQUNKO0FBQ0EsTUFBTUMsU0FBUyxJQUFJM0IsTUFBTTtBQUN6QixNQUFNNEIsU0FBUyxJQUFJNUIsTUFBTTtBQUNDLENBQzFCLDhFQUE4RTtDQUM5RSw2RkFBNkY7Q0FDN0YsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2xpbWUtYmV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYmFzZXgvbGliLmVzbS9pbmRleC5qcz85YTYxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogdmFyIGJhc2V4ID0gcmVxdWlyZShcImJhc2UteFwiKTtcbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGhlYXZpbHkgYmFzZWQgb24gYmFzZS14LiBUaGUgbWFpbiByZWFzb24gdG9cbiAqIGRldmlhdGUgd2FzIHRvIHByZXZlbnQgdGhlIGRlcGVuZGVuY3kgb2YgQnVmZmVyLlxuICpcbiAqIENvbnRyaWJ1dG9yczpcbiAqXG4gKiBiYXNlLXggZW5jb2RpbmdcbiAqIEZvcmtlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvYnM1OFxuICogT3JpZ2luYWxseSB3cml0dGVuIGJ5IE1pa2UgSGVhcm4gZm9yIEJpdGNvaW5KXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEgR29vZ2xlIEluY1xuICogUG9ydGVkIHRvIEphdmFTY3JpcHQgYnkgU3RlZmFuIFRob21hc1xuICogTWVyZ2VkIEJ1ZmZlciByZWZhY3RvcmluZ3MgZnJvbSBiYXNlNTgtbmF0aXZlIGJ5IFN0ZXBoZW4gUGFpclxuICogQ29weXJpZ2h0IChjKSAyMDEzIEJpdFBheSBJbmNcbiAqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgYmFzZS14IGNvbnRyaWJ1dG9ycyAoYykgMjAxNlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HU1xuICogSU4gVEhFIFNPRlRXQVJFLlxuICpcbiAqL1xuaW1wb3J0IHsgYXJyYXlpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IGRlZmluZVJlYWRPbmx5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmV4cG9ydCBjbGFzcyBCYXNlWCB7XG4gICAgY29uc3RydWN0b3IoYWxwaGFiZXQpIHtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhbHBoYWJldFwiLCBhbHBoYWJldCk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYmFzZVwiLCBhbHBoYWJldC5sZW5ndGgpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9hbHBoYWJldE1hcFwiLCB7fSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2xlYWRlclwiLCBhbHBoYWJldC5jaGFyQXQoMCkpO1xuICAgICAgICAvLyBwcmUtY29tcHV0ZSBsb29rdXAgdGFibGVcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbHBoYWJldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fYWxwaGFiZXRNYXBbYWxwaGFiZXQuY2hhckF0KGkpXSA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5jb2RlKHZhbHVlKSB7XG4gICAgICAgIGxldCBzb3VyY2UgPSBhcnJheWlmeSh2YWx1ZSk7XG4gICAgICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGlnaXRzID0gWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IGNhcnJ5ID0gc291cmNlW2ldO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBkaWdpdHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBjYXJyeSArPSBkaWdpdHNbal0gPDwgODtcbiAgICAgICAgICAgICAgICBkaWdpdHNbal0gPSBjYXJyeSAlIHRoaXMuYmFzZTtcbiAgICAgICAgICAgICAgICBjYXJyeSA9IChjYXJyeSAvIHRoaXMuYmFzZSkgfCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNhcnJ5ID4gMCkge1xuICAgICAgICAgICAgICAgIGRpZ2l0cy5wdXNoKGNhcnJ5ICUgdGhpcy5iYXNlKTtcbiAgICAgICAgICAgICAgICBjYXJyeSA9IChjYXJyeSAvIHRoaXMuYmFzZSkgfCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBzdHJpbmcgPSBcIlwiO1xuICAgICAgICAvLyBkZWFsIHdpdGggbGVhZGluZyB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgc291cmNlW2tdID09PSAwICYmIGsgPCBzb3VyY2UubGVuZ3RoIC0gMTsgKytrKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gdGhpcy5fbGVhZGVyO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnZlcnQgZGlnaXRzIHRvIGEgc3RyaW5nXG4gICAgICAgIGZvciAobGV0IHEgPSBkaWdpdHMubGVuZ3RoIC0gMTsgcSA+PSAwOyAtLXEpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSB0aGlzLmFscGhhYmV0W2RpZ2l0c1txXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG4gICAgZGVjb2RlKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYnl0ZXMgPSBbXTtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBieXRlcy5wdXNoKDApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYnl0ZSA9IHRoaXMuX2FscGhhYmV0TWFwW3ZhbHVlW2ldXTtcbiAgICAgICAgICAgIGlmIChieXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb24tYmFzZVwiICsgdGhpcy5iYXNlICsgXCIgY2hhcmFjdGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNhcnJ5ID0gYnl0ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYnl0ZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBjYXJyeSArPSBieXRlc1tqXSAqIHRoaXMuYmFzZTtcbiAgICAgICAgICAgICAgICBieXRlc1tqXSA9IGNhcnJ5ICYgMHhmZjtcbiAgICAgICAgICAgICAgICBjYXJyeSA+Pj0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjYXJyeSA+IDApIHtcbiAgICAgICAgICAgICAgICBieXRlcy5wdXNoKGNhcnJ5ICYgMHhmZik7XG4gICAgICAgICAgICAgICAgY2FycnkgPj49IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IHZhbHVlW2tdID09PSB0aGlzLl9sZWFkZXIgJiYgayA8IHZhbHVlLmxlbmd0aCAtIDE7ICsraykge1xuICAgICAgICAgICAgYnl0ZXMucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXlpZnkobmV3IFVpbnQ4QXJyYXkoYnl0ZXMucmV2ZXJzZSgpKSk7XG4gICAgfVxufVxuY29uc3QgQmFzZTMyID0gbmV3IEJhc2VYKFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1NjdcIik7XG5jb25zdCBCYXNlNTggPSBuZXcgQmFzZVgoXCIxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6XCIpO1xuZXhwb3J0IHsgQmFzZTMyLCBCYXNlNTggfTtcbi8vY29uc29sZS5sb2coQmFzZTU4LmRlY29kZShcIlFtZDJWNzc3bzVYdkpiWU1lTWI4azJuVTVmOGQzY2lVUTVZcFl1V2h6djhpRGpcIikpXG4vL2NvbnNvbGUubG9nKEJhc2U1OC5lbmNvZGUoQmFzZTU4LmRlY29kZShcIlFtZDJWNzc3bzVYdkpiWU1lTWI4azJuVTVmOGQzY2lVUTVZcFl1V2h6djhpRGpcIikpKVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbImFycmF5aWZ5IiwiZGVmaW5lUmVhZE9ubHkiLCJCYXNlWCIsImNvbnN0cnVjdG9yIiwiYWxwaGFiZXQiLCJsZW5ndGgiLCJjaGFyQXQiLCJpIiwiX2FscGhhYmV0TWFwIiwiZW5jb2RlIiwidmFsdWUiLCJzb3VyY2UiLCJkaWdpdHMiLCJjYXJyeSIsImoiLCJiYXNlIiwicHVzaCIsInN0cmluZyIsImsiLCJfbGVhZGVyIiwicSIsImRlY29kZSIsIlR5cGVFcnJvciIsImJ5dGVzIiwiVWludDhBcnJheSIsImJ5dGUiLCJ1bmRlZmluZWQiLCJFcnJvciIsInJldmVyc2UiLCJCYXNlMzIiLCJCYXNlNTgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/basex/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/_version.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/_version.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"bignumber/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9iaWdudW1iZXIvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsVUFBVSxrQkFBa0IsQ0FDekMsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2xpbWUtYmV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyL2xpYi5lc20vX3ZlcnNpb24uanM/YWE5MiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiYmlnbnVtYmVyLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BigNumber: () => (/* binding */ BigNumber),\n/* harmony export */   _base16To36: () => (/* binding */ _base16To36),\n/* harmony export */   _base36To16: () => (/* binding */ _base36To16),\n/* harmony export */   isBigNumberish: () => (/* binding */ isBigNumberish)\n/* harmony export */ });\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/_version.js\");\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */ \nvar BN = (bn_js__WEBPACK_IMPORTED_MODULE_0___default().BN);\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger(_version__WEBPACK_IMPORTED_MODULE_2__.version);\nconst _constructorGuard = {};\nconst MAX_SAFE = 0x1fffffffffffff;\nfunction isBigNumberish(value) {\n    return value != null && (BigNumber.isBigNumber(value) || typeof value === \"number\" && value % 1 === 0 || typeof value === \"string\" && !!value.match(/^-?[0-9]+$/) || (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(value) || typeof value === \"bigint\" || (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isBytes)(value));\n}\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\nclass BigNumber {\n    constructor(constructorGuard, hex){\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n        this._hex = hex;\n        this._isBigNumber = true;\n        Object.freeze(this);\n    }\n    fromTwos(value) {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n    toTwos(value) {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n    abs() {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n    add(other) {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n    sub(other) {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n    div(other) {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n    mul(other) {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n    mod(other) {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n    pow(other) {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n    and(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n    or(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n    xor(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n    mask(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n    shl(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n    shr(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n    eq(other) {\n        return toBN(this).eq(toBN(other));\n    }\n    lt(other) {\n        return toBN(this).lt(toBN(other));\n    }\n    lte(other) {\n        return toBN(this).lte(toBN(other));\n    }\n    gt(other) {\n        return toBN(this).gt(toBN(other));\n    }\n    gte(other) {\n        return toBN(this).gte(toBN(other));\n    }\n    isNegative() {\n        return this._hex[0] === \"-\";\n    }\n    isZero() {\n        return toBN(this).isZero();\n    }\n    toNumber() {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n    toBigInt() {\n        try {\n            return BigInt(this.toString());\n        } catch (e) {}\n        return logger.throwError(\"this platform does not support BigInt\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n    toString() {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNEXPECTED_ARGUMENT, {});\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNEXPECTED_ARGUMENT, {});\n            }\n        }\n        return toBN(this).toString(10);\n    }\n    toHexString() {\n        return this._hex;\n    }\n    toJSON(key) {\n        return {\n            type: \"BigNumber\",\n            hex: this.toHexString()\n        };\n    }\n    static from(value) {\n        if (value instanceof BigNumber) {\n            return value;\n        }\n        if (typeof value === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n        if (typeof value === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n            return BigNumber.from(String(value));\n        }\n        const anyValue = value;\n        if (typeof anyValue === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isBytes)(anyValue)) {\n            return BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(anyValue));\n        }\n        if (anyValue) {\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof hex === \"string\") {\n                    return BigNumber.from(hex);\n                }\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n                if (typeof hex === \"string\") {\n                    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(hex) || hex[0] === \"-\" && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(hex.substring(1))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n    static isBigNumber(value) {\n        return !!(value && value._isBigNumber);\n    }\n}\n// Normalize the hex string\nfunction toHex(value) {\n    // For BN, call on the hex string\n    if (typeof value !== \"string\") {\n        return toHex(value.toString(16));\n    }\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") {\n            logger.throwArgumentError(\"invalid hex\", \"value\", value);\n        }\n        // Call toHex on the positive component\n        value = toHex(value);\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") {\n            return value;\n        }\n        // Negate the value\n        return \"-\" + value;\n    }\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    // Normalize zero\n    if (value === \"0x\") {\n        return \"0x00\";\n    }\n    // Make the string even length\n    if (value.length % 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n    // Trim to smallest even-length string\n    while(value.length > 4 && value.substring(0, 4) === \"0x00\"){\n        value = \"0x\" + value.substring(4);\n    }\n    return value;\n}\nfunction toBigNumber(value) {\n    return BigNumber.from(toHex(value));\n}\nfunction toBN(value) {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return new BN(\"-\" + hex.substring(3), 16);\n    }\n    return new BN(hex.substring(2), 16);\n}\nfunction throwFault(fault, operation, value) {\n    const params = {\n        fault: fault,\n        operation: operation\n    };\n    if (value != null) {\n        params.value = value;\n    }\n    return logger.throwError(fault, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NUMERIC_FAULT, params);\n}\n// value should have no prefix\nfunction _base36To16(value) {\n    return new BN(value, 36).toString(16);\n}\n// value should have no prefix\nfunction _base16To36(value) {\n    return new BN(value, 16).toString(36);\n} //# sourceMappingURL=bignumber.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9iaWdudW1iZXIvbGliLmVzbS9iaWdudW1iZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQWE7QUFDYjs7Ozs7O0NBTUMsR0FDdUI7QUFDeEIsSUFBSUMsS0FBS0QsaURBQU07QUFDc0Q7QUFDdEI7QUFDVjtBQUNyQyxNQUFNTyxTQUFTLElBQUlGLHlEQUFNQSxDQUFDQyw2Q0FBT0E7QUFDakMsTUFBTUUsb0JBQW9CLENBQUM7QUFDM0IsTUFBTUMsV0FBVztBQUNWLFNBQVNDLGVBQWVDLEtBQUs7SUFDaEMsT0FBTyxTQUFVLFFBQVVDLENBQUFBLFVBQVVDLFdBQVcsQ0FBQ0YsVUFDNUMsT0FBUUEsVUFBVyxZQUFZLFFBQVMsTUFBTyxLQUMvQyxPQUFRQSxVQUFXLFlBQVksQ0FBQyxDQUFDQSxNQUFNRyxLQUFLLENBQUMsaUJBQzlDVixpRUFBV0EsQ0FBQ08sVUFDWCxPQUFRQSxVQUFXLFlBQ3BCUiw2REFBT0EsQ0FBQ1EsTUFBSztBQUNyQjtBQUNBLDZDQUE2QztBQUM3QyxJQUFJSSx1QkFBdUI7QUFDcEIsTUFBTUg7SUFDVEksWUFBWUMsZ0JBQWdCLEVBQUVDLEdBQUcsQ0FBRTtRQUMvQixJQUFJRCxxQkFBcUJULG1CQUFtQjtZQUN4Q0QsT0FBT1ksVUFBVSxDQUFDLHdEQUF3RGQseURBQU1BLENBQUNlLE1BQU0sQ0FBQ0MscUJBQXFCLEVBQUU7Z0JBQzNHQyxXQUFXO1lBQ2Y7UUFDSjtRQUNBLElBQUksQ0FBQ0MsSUFBSSxHQUFHTDtRQUNaLElBQUksQ0FBQ00sWUFBWSxHQUFHO1FBQ3BCQyxPQUFPQyxNQUFNLENBQUMsSUFBSTtJQUN0QjtJQUNBQyxTQUFTaEIsS0FBSyxFQUFFO1FBQ1osT0FBT2lCLFlBQVlDLEtBQUssSUFBSSxFQUFFRixRQUFRLENBQUNoQjtJQUMzQztJQUNBbUIsT0FBT25CLEtBQUssRUFBRTtRQUNWLE9BQU9pQixZQUFZQyxL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SztJQUNmLE1BQU1PLE1BQU1OLFVBQVVvQixJQUFJLENBQUNyQixPQUFPNEQsV0FBVztJQUM3QyxJQUFJckQsR0FBRyxDQUFDLEVBQUUsS0FBSyxLQUFLO1FBQ2hCLE9BQVEsSUFBSWpCLEdBQUcsTUFBTWlCLElBQUllLFNBQVMsQ0FBQyxJQUFJO0lBQzNDO0lBQ0EsT0FBTyxJQUFJaEMsR0FBR2lCLElBQUllLFNBQVMsQ0FBQyxJQUFJO0FBQ3BDO0FBQ0EsU0FBU08sV0FBV3VDLEtBQUssRUFBRXpELFNBQVMsRUFBRVgsS0FBSztJQUN2QyxNQUFNcUUsU0FBUztRQUFFRCxPQUFPQTtRQUFPekQsV0FBV0E7SUFBVTtJQUNwRCxJQUFJWCxTQUFTLE1BQU07UUFDZnFFLE9BQU9yRSxLQUFLLEdBQUdBO0lBQ25CO0lBQ0EsT0FBT0osT0FBT1ksVUFBVSxDQUFDNEQsT0FBTzFFLHlEQUFNQSxDQUFDZSxNQUFNLENBQUM2RCxhQUFhLEVBQUVEO0FBQ2pFO0FBQ0EsOEJBQThCO0FBQ3ZCLFNBQVNFLFlBQVl2RSxLQUFLO0lBQzdCLE9BQU8sSUFBS1YsR0FBR1UsT0FBTyxJQUFLb0QsUUFBUSxDQUFDO0FBQ3hDO0FBQ0EsOEJBQThCO0FBQ3ZCLFNBQVNvQixZQUFZeEUsS0FBSztJQUM3QixPQUFPLElBQUtWLEdBQUdVLE9BQU8sSUFBS29ELFFBQVEsQ0FBQztBQUN4QyxFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NsaW1lLWJldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2JpZ251bWJlci9saWIuZXNtL2JpZ251bWJlci5qcz85ZWEzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgQmlnTnVtYmVyXG4gKlxuICogIEEgd3JhcHBlciBhcm91bmQgdGhlIEJOLmpzIG9iamVjdC4gV2UgdXNlIHRoZSBCTi5qcyBsaWJyYXJ5XG4gKiAgYmVjYXVzZSBpdCBpcyB1c2VkIGJ5IGVsbGlwdGljLCBzbyBpdCBpcyByZXF1aXJlZCByZWdhcmRsZXNzLlxuICpcbiAqL1xuaW1wb3J0IF9CTiBmcm9tIFwiYm4uanNcIjtcbnZhciBCTiA9IF9CTi5CTjtcbmltcG9ydCB7IGhleGxpZnksIGlzQnl0ZXMsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5jb25zdCBfY29uc3RydWN0b3JHdWFyZCA9IHt9O1xuY29uc3QgTUFYX1NBRkUgPSAweDFmZmZmZmZmZmZmZmZmO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQmlnTnVtYmVyaXNoKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAhPSBudWxsKSAmJiAoQmlnTnVtYmVyLmlzQmlnTnVtYmVyKHZhbHVlKSB8fFxuICAgICAgICAodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIgJiYgKHZhbHVlICUgMSkgPT09IDApIHx8XG4gICAgICAgICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiAhIXZhbHVlLm1hdGNoKC9eLT9bMC05XSskLykpIHx8XG4gICAgICAgIGlzSGV4U3RyaW5nKHZhbHVlKSB8fFxuICAgICAgICAodHlwZW9mICh2YWx1ZSkgPT09IFwiYmlnaW50XCIpIHx8XG4gICAgICAgIGlzQnl0ZXModmFsdWUpKTtcbn1cbi8vIE9ubHkgd2FybiBhYm91dCBwYXNzaW5nIDEwIGludG8gcmFkaXggb25jZVxubGV0IF93YXJuZWRUb1N0cmluZ1JhZGl4ID0gZmFsc2U7XG5leHBvcnQgY2xhc3MgQmlnTnVtYmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvckd1YXJkLCBoZXgpIHtcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yR3VhcmQgIT09IF9jb25zdHJ1Y3Rvckd1YXJkKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBjYWxsIGNvbnN0cnVjdG9yIGRpcmVjdGx5OyB1c2UgQmlnTnVtYmVyLmZyb21cIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IChCaWdOdW1iZXIpXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hleCA9IGhleDtcbiAgICAgICAgdGhpcy5faXNCaWdOdW1iZXIgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICBmcm9tVHdvcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5mcm9tVHdvcyh2YWx1ZSkpO1xuICAgIH1cbiAgICB0b1R3b3ModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykudG9Ud29zKHZhbHVlKSk7XG4gICAgfVxuICAgIGFicygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hleFswXSA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbSh0aGlzLl9oZXguc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLmFkZCh0b0JOKG90aGVyKSkpO1xuICAgIH1cbiAgICBzdWIob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuc3ViKHRvQk4ob3RoZXIpKSk7XG4gICAgfVxuICAgIGRpdihvdGhlcikge1xuICAgICAgICBjb25zdCBvID0gQmlnTnVtYmVyLmZyb20ob3RoZXIpO1xuICAgICAgICBpZiAoby5pc1plcm8oKSkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcImRpdmlzaW9uLWJ5LXplcm9cIiwgXCJkaXZcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuZGl2KHRvQk4ob3RoZXIpKSk7XG4gICAgfVxuICAgIG11bChvdGhlcikge1xuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5tdWwodG9CTihvdGhlcikpKTtcbiAgICB9XG4gICAgbW9kKG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdG9CTihvdGhlcik7XG4gICAgICAgIGlmICh2YWx1ZS5pc05lZygpKSB7XG4gICAgICAgICAgICB0aHJvd0ZhdWx0KFwiZGl2aXNpb24tYnktemVyb1wiLCBcIm1vZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS51bW9kKHZhbHVlKSk7XG4gICAgfVxuICAgIHBvdyhvdGhlcikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRvQk4ob3RoZXIpO1xuICAgICAgICBpZiAodmFsdWUuaXNOZWcoKSkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcIm5lZ2F0aXZlLXBvd2VyXCIsIFwicG93XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnBvdyh2YWx1ZSkpO1xuICAgIH1cbiAgICBhbmQob3RoZXIpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0b0JOKG90aGVyKTtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlLmlzTmVnKCkpIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJ1bmJvdW5kLWJpdHdpc2UtcmVzdWx0XCIsIFwiYW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLmFuZCh2YWx1ZSkpO1xuICAgIH1cbiAgICBvcihvdGhlcikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRvQk4ob3RoZXIpO1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUuaXNOZWcoKSkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcInVuYm91bmQtYml0d2lzZS1yZXN1bHRcIiwgXCJvclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5vcih2YWx1ZSkpO1xuICAgIH1cbiAgICB4b3Iob3RoZXIpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0b0JOKG90aGVyKTtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlLmlzTmVnKCkpIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJ1bmJvdW5kLWJpdHdpc2UtcmVzdWx0XCIsIFwieG9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnhvcih2YWx1ZSkpO1xuICAgIH1cbiAgICBtYXNrKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJuZWdhdGl2ZS13aWR0aFwiLCBcIm1hc2tcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykubWFza24odmFsdWUpKTtcbiAgICB9XG4gICAgc2hsKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJuZWdhdGl2ZS13aWR0aFwiLCBcInNobFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5zaGxuKHZhbHVlKSk7XG4gICAgfVxuICAgIHNocih2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgICAgICB0aHJvd0ZhdWx0KFwibmVnYXRpdmUtd2lkdGhcIiwgXCJzaHJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuc2hybih2YWx1ZSkpO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdG9CTih0aGlzKS5lcSh0b0JOKG90aGVyKSk7XG4gICAgfVxuICAgIGx0KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0b0JOKHRoaXMpLmx0KHRvQk4ob3RoZXIpKTtcbiAgICB9XG4gICAgbHRlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0b0JOKHRoaXMpLmx0ZSh0b0JOKG90aGVyKSk7XG4gICAgfVxuICAgIGd0KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0b0JOKHRoaXMpLmd0KHRvQk4ob3RoZXIpKTtcbiAgICB9XG4gICAgZ3RlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0b0JOKHRoaXMpLmd0ZSh0b0JOKG90aGVyKSk7XG4gICAgfVxuICAgIGlzTmVnYXRpdmUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5faGV4WzBdID09PSBcIi1cIik7XG4gICAgfVxuICAgIGlzWmVybygpIHtcbiAgICAgICAgcmV0dXJuIHRvQk4odGhpcykuaXNaZXJvKCk7XG4gICAgfVxuICAgIHRvTnVtYmVyKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRvQk4odGhpcykudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJvdmVyZmxvd1wiLCBcInRvTnVtYmVyXCIsIHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRvQmlnSW50KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh0aGlzLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwidGhpcyBwbGF0Zm9ybSBkb2VzIG5vdCBzdXBwb3J0IEJpZ0ludFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMudG9TdHJpbmcoKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIC8vIExvdHMgb2YgcGVvcGxlIGV4cGVjdCB0aGlzLCB3aGljaCB3ZSBkbyBub3Qgc3VwcG9ydCwgc28gY2hlY2sgKFNlZTogIzg4OSlcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzWzBdID09PSAxMCkge1xuICAgICAgICAgICAgICAgIGlmICghX3dhcm5lZFRvU3RyaW5nUmFkaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3dhcm5lZFRvU3RyaW5nUmFkaXggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIkJpZ051bWJlci50b1N0cmluZyBkb2VzIG5vdCBhY2NlcHQgYW55IHBhcmFtZXRlcnM7IGJhc2UtMTAgaXMgYXNzdW1lZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcmd1bWVudHNbMF0gPT09IDE2KSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJCaWdOdW1iZXIudG9TdHJpbmcgZG9lcyBub3QgYWNjZXB0IGFueSBwYXJhbWV0ZXJzOyB1c2UgYmlnTnVtYmVyLnRvSGV4U3RyaW5nKClcIiwgTG9nZ2VyLmVycm9ycy5VTkVYUEVDVEVEX0FSR1VNRU5ULCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkJpZ051bWJlci50b1N0cmluZyBkb2VzIG5vdCBhY2NlcHQgcGFyYW1ldGVyc1wiLCBMb2dnZXIuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9CTih0aGlzKS50b1N0cmluZygxMCk7XG4gICAgfVxuICAgIHRvSGV4U3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGV4O1xuICAgIH1cbiAgICB0b0pTT04oa2V5KSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiQmlnTnVtYmVyXCIsIGhleDogdGhpcy50b0hleFN0cmluZygpIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKHZhbHVlLm1hdGNoKC9eLT8weFswLTlhLWZdKyQvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihfY29uc3RydWN0b3JHdWFyZCwgdG9IZXgodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS5tYXRjaCgvXi0/WzAtOV0rJC8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoX2NvbnN0cnVjdG9yR3VhcmQsIHRvSGV4KG5ldyBCTih2YWx1ZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBCaWdOdW1iZXIgc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgaWYgKHZhbHVlICUgMSkge1xuICAgICAgICAgICAgICAgIHRocm93RmF1bHQoXCJ1bmRlcmZsb3dcIiwgXCJCaWdOdW1iZXIuZnJvbVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gTUFYX1NBRkUgfHwgdmFsdWUgPD0gLU1BWF9TQUZFKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dGYXVsdChcIm92ZXJmbG93XCIsIFwiQmlnTnVtYmVyLmZyb21cIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFueVZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgKGFueVZhbHVlKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKGFueVZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0J5dGVzKGFueVZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKGhleGxpZnkoYW55VmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW55VmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEhleGFibGUgaW50ZXJmYWNlICh0YWtlcyBwcmlvcml0eSlcbiAgICAgICAgICAgIGlmIChhbnlWYWx1ZS50b0hleFN0cmluZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhleCA9IGFueVZhbHVlLnRvSGV4U3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoaGV4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20oaGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGb3Igbm93LCBoYW5kbGUgbGVnYWN5IEpTT04taWZpZWQgdmFsdWVzIChnb2VzIGF3YXkgaW4gdjYpXG4gICAgICAgICAgICAgICAgbGV0IGhleCA9IGFueVZhbHVlLl9oZXg7XG4gICAgICAgICAgICAgICAgLy8gTmV3LWZvcm0gSlNPTlxuICAgICAgICAgICAgICAgIGlmIChoZXggPT0gbnVsbCAmJiBhbnlWYWx1ZS50eXBlID09PSBcIkJpZ051bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGhleCA9IGFueVZhbHVlLmhleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoaGV4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoaGV4KSB8fCAoaGV4WzBdID09PSBcIi1cIiAmJiBpc0hleFN0cmluZyhoZXguc3Vic3RyaW5nKDEpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShoZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBCaWdOdW1iZXIgdmFsdWVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0JpZ051bWJlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzQmlnTnVtYmVyKTtcbiAgICB9XG59XG4vLyBOb3JtYWxpemUgdGhlIGhleCBzdHJpbmdcbmZ1bmN0aW9uIHRvSGV4KHZhbHVlKSB7XG4gICAgLy8gRm9yIEJOLCBjYWxsIG9uIHRoZSBoZXggc3RyaW5nXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB0b0hleCh2YWx1ZS50b1N0cmluZygxNikpO1xuICAgIH1cbiAgICAvLyBJZiBuZWdhdGl2ZSwgcHJlcGVuZCB0aGUgbmVnYXRpdmUgc2lnbiB0byB0aGUgbm9ybWFsaXplZCBwb3NpdGl2ZSB2YWx1ZVxuICAgIGlmICh2YWx1ZVswXSA9PT0gXCItXCIpIHtcbiAgICAgICAgLy8gU3RyaXAgb2ZmIHRoZSBuZWdhdGl2ZSBzaWduXG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAvLyBDYW5ub3QgaGF2ZSBtdWx0aXBsZSBuZWdhdGl2ZSBzaWducyAoZS5nLiBcIi0tMHgwNFwiKVxuICAgICAgICBpZiAodmFsdWVbMF0gPT09IFwiLVwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXhcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsbCB0b0hleCBvbiB0aGUgcG9zaXRpdmUgY29tcG9uZW50XG4gICAgICAgIHZhbHVlID0gdG9IZXgodmFsdWUpO1xuICAgICAgICAvLyBEbyBub3QgYWxsb3cgXCItMHgwMFwiXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gXCIweDAwXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOZWdhdGUgdGhlIHZhbHVlXG4gICAgICAgIHJldHVybiBcIi1cIiArIHZhbHVlO1xuICAgIH1cbiAgICAvLyBBZGQgYSBcIjB4XCIgcHJlZml4IGlmIG1pc3NpbmdcbiAgICBpZiAodmFsdWUuc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcbiAgICAgICAgdmFsdWUgPSBcIjB4XCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIHplcm9cbiAgICBpZiAodmFsdWUgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gXCIweDAwXCI7XG4gICAgfVxuICAgIC8vIE1ha2UgdGhlIHN0cmluZyBldmVuIGxlbmd0aFxuICAgIGlmICh2YWx1ZS5sZW5ndGggJSAyKSB7XG4gICAgICAgIHZhbHVlID0gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgLy8gVHJpbSB0byBzbWFsbGVzdCBldmVuLWxlbmd0aCBzdHJpbmdcbiAgICB3aGlsZSAodmFsdWUubGVuZ3RoID4gNCAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgNCkgPT09IFwiMHgwMFwiKSB7XG4gICAgICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWUuc3Vic3RyaW5nKDQpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiB0b0JpZ051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbSh0b0hleCh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gdG9CTih2YWx1ZSkge1xuICAgIGNvbnN0IGhleCA9IEJpZ051bWJlci5mcm9tKHZhbHVlKS50b0hleFN0cmluZygpO1xuICAgIGlmIChoZXhbMF0gPT09IFwiLVwiKSB7XG4gICAgICAgIHJldHVybiAobmV3IEJOKFwiLVwiICsgaGV4LnN1YnN0cmluZygzKSwgMTYpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCTihoZXguc3Vic3RyaW5nKDIpLCAxNik7XG59XG5mdW5jdGlvbiB0aHJvd0ZhdWx0KGZhdWx0LCBvcGVyYXRpb24sIHZhbHVlKSB7XG4gICAgY29uc3QgcGFyYW1zID0geyBmYXVsdDogZmF1bHQsIG9wZXJhdGlvbjogb3BlcmF0aW9uIH07XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcGFyYW1zLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihmYXVsdCwgTG9nZ2VyLmVycm9ycy5OVU1FUklDX0ZBVUxULCBwYXJhbXMpO1xufVxuLy8gdmFsdWUgc2hvdWxkIGhhdmUgbm8gcHJlZml4XG5leHBvcnQgZnVuY3Rpb24gX2Jhc2UzNlRvMTYodmFsdWUpIHtcbiAgICByZXR1cm4gKG5ldyBCTih2YWx1ZSwgMzYpKS50b1N0cmluZygxNik7XG59XG4vLyB2YWx1ZSBzaG91bGQgaGF2ZSBubyBwcmVmaXhcbmV4cG9ydCBmdW5jdGlvbiBfYmFzZTE2VG8zNih2YWx1ZSkge1xuICAgIHJldHVybiAobmV3IEJOKHZhbHVlLCAxNikpLnRvU3RyaW5nKDM2KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpZ251bWJlci5qcy5tYXAiXSwibmFtZXMiOlsiX0JOIiwiQk4iLCJoZXhsaWZ5IiwiaXNCeXRlcyIsImlzSGV4U3RyaW5nIiwiTG9nZ2VyIiwidmVyc2lvbiIsImxvZ2dlciIsIl9jb25zdHJ1Y3Rvckd1YXJkIiwiTUFYX1NBRkUiLCJpc0JpZ051bWJlcmlzaCIsInZhbHVlIiwiQmlnTnVtYmVyIiwiaXNCaWdOdW1iZXIiLCJtYXRjaCIsIl93YXJuZWRUb1N0cmluZ1JhZGl4IiwiY29uc3RydWN0b3IiLCJjb25zdHJ1Y3Rvckd1YXJkIiwiaGV4IiwidGhyb3dFcnJvciIsImVycm9ycyIsIlVOU1VQUE9SVEVEX09QRVJBVElPTiIsIm9wZXJhdGlvbiIsIl9oZXgiLCJfaXNCaWdOdW1iZXIiLCJPYmplY3QiLCJmcmVlemUiLCJmcm9tVHdvcyIsInRvQmlnTnVtYmVyIiwidG9CTiIsInRvVHdvcyIsImFicyIsImZyb20iLCJzdWJzdHJpbmciLCJhZGQiLCJvdGhlciIsInN1YiIsImRpdiIsIm8iLCJpc1plcm8iLCJ0aHJvd0ZhdWx0IiwibXVsIiwibW9kIiwiaXNOZWciLCJ1bW9kIiwicG93IiwiYW5kIiwiaXNOZWdhdGl2ZSIsIm9yIiwieG9yIiwibWFzayIsIm1hc2tuIiwic2hsIiwic2hsbiIsInNociIsInNocm4iLCJlcSIsImx0IiwibHRlIiwiZ3QiLCJndGUiLCJ0b051bWJlciIsImVycm9yIiwidG9TdHJpbmciLCJ0b0JpZ0ludCIsIkJpZ0ludCIsImUiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ3YXJuIiwiVU5FWFBFQ1RFRF9BUkdVTUVOVCIsInRvSGV4U3RyaW5nIiwidG9KU09OIiwia2V5IiwidHlwZSIsInRvSGV4IiwidGhyb3dBcmd1bWVudEVycm9yIiwiU3RyaW5nIiwiYW55VmFsdWUiLCJmYXVsdCIsInBhcmFtcyIsIk5VTUVSSUNfRkFVTFQiLCJfYmFzZTM2VG8xNiIsIl9iYXNlMTZUbzM2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedFormat: () => (/* binding */ FixedFormat),\n/* harmony export */   FixedNumber: () => (/* binding */ FixedNumber),\n/* harmony export */   formatFixed: () => (/* binding */ formatFixed),\n/* harmony export */   parseFixed: () => (/* binding */ parseFixed)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/_version.js\");\n/* harmony import */ var _bignumber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nconst _constructorGuard = {};\nconst Zero = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(0);\nconst NegativeOne = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(-1);\nfunction throwFault(message, fault, operation, value) {\n    const params = {\n        fault: fault,\n        operation: operation\n    };\n    if (value !== undefined) {\n        params.value = value;\n    }\n    return logger.throwError(message, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NUMERIC_FAULT, params);\n}\n// Constant to pull zeros from for multipliers\nlet zeros = \"0\";\nwhile(zeros.length < 256){\n    zeros += zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getMultiplier(decimals) {\n    if (typeof decimals !== \"number\") {\n        try {\n            decimals = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(decimals).toNumber();\n        } catch (e) {}\n    }\n    if (typeof decimals === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n        return \"1\" + zeros.substring(0, decimals);\n    }\n    return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n}\nfunction formatFixed(value, decimals) {\n    if (decimals == null) {\n        decimals = 0;\n    }\n    const multiplier = getMultiplier(decimals);\n    // Make sure wei is a big number (convert as necessary)\n    value = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(value);\n    const negative = value.lt(Zero);\n    if (negative) {\n        value = value.mul(NegativeOne);\n    }\n    let fraction = value.mod(multiplier).toString();\n    while(fraction.length < multiplier.length - 1){\n        fraction = \"0\" + fraction;\n    }\n    // Strip training 0\n    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n    const whole = value.div(multiplier).toString();\n    if (multiplier.length === 1) {\n        value = whole;\n    } else {\n        value = whole + \".\" + fraction;\n    }\n    if (negative) {\n        value = \"-\" + value;\n    }\n    return value;\n}\nfunction parseFixed(value, decimals) {\n    if (decimals == null) {\n        decimals = 0;\n    }\n    const multiplier = getMultiplier(decimals);\n    if (typeof value !== \"string\" || !value.match(/^-?[0-9.]+$/)) {\n        logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n    }\n    // Is it negative?\n    const negative = value.substring(0, 1) === \"-\";\n    if (negative) {\n        value = value.substring(1);\n    }\n    if (value === \".\") {\n        logger.throwArgumentError(\"missing value\", \"value\", value);\n    }\n    // Split it into a whole and fractional part\n    const comps = value.split(\".\");\n    if (comps.length > 2) {\n        logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n    }\n    let whole = comps[0], fraction = comps[1];\n    if (!whole) {\n        whole = \"0\";\n    }\n    if (!fraction) {\n        fraction = \"0\";\n    }\n    // Trim trailing zeros\n    while(fraction[fraction.length - 1] === \"0\"){\n        fraction = fraction.substring(0, fraction.length - 1);\n    }\n    // Check the fraction doesn't exceed our decimals size\n    if (fraction.length > multiplier.length - 1) {\n        throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n    }\n    // If decimals is 0, we have an empty string for fraction\n    if (fraction === \"\") {\n        fraction = \"0\";\n    }\n    // Fully pad the string with zeros to get to wei\n    while(fraction.length < multiplier.length - 1){\n        fraction += \"0\";\n    }\n    const wholeValue = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(whole);\n    const fractionValue = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(fraction);\n    let wei = wholeValue.mul(multiplier).add(fractionValue);\n    if (negative) {\n        wei = wei.mul(NegativeOne);\n    }\n    return wei;\n}\nclass FixedFormat {\n    constructor(constructorGuard, signed, width, decimals){\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n        this.signed = signed;\n        this.width = width;\n        this.decimals = decimals;\n        this.name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n        this._multiplier = getMultiplier(decimals);\n        Object.freeze(this);\n    }\n    static from(value) {\n        if (value instanceof FixedFormat) {\n            return value;\n        }\n        if (typeof value === \"number\") {\n            value = `fixed128x${value}`;\n        }\n        let signed = true;\n        let width = 128;\n        let decimals = 18;\n        if (typeof value === \"string\") {\n            if (value === \"fixed\") {\n            // defaults...\n            } else if (value === \"ufixed\") {\n                signed = false;\n            } else {\n                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n                if (!match) {\n                    logger.throwArgumentError(\"invalid fixed format\", \"format\", value);\n                }\n                signed = match[1] !== \"u\";\n                width = parseInt(match[2]);\n                decimals = parseInt(match[3]);\n            }\n        } else if (value) {\n            const check = (key, type, defaultValue)=>{\n                if (value[key] == null) {\n                    return defaultValue;\n                }\n                if (typeof value[key] !== type) {\n                    logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, value[key]);\n                }\n                return value[key];\n            };\n            signed = check(\"signed\", \"boolean\", signed);\n            width = check(\"width\", \"number\", width);\n            decimals = check(\"decimals\", \"number\", decimals);\n        }\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n        }\n        if (decimals > 80) {\n            logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n        }\n        return new FixedFormat(_constructorGuard, signed, width, decimals);\n    }\n}\nclass FixedNumber {\n    constructor(constructorGuard, hex, value, format){\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n        this.format = format;\n        this._hex = hex;\n        this._value = value;\n        this._isFixedNumber = true;\n        Object.freeze(this);\n    }\n    _checkFormat(other) {\n        if (this.format.name !== other.format.name) {\n            logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n        }\n    }\n    addUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n    }\n    subUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n    }\n    mulUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n    }\n    divUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n    }\n    floor() {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        let result = FixedNumber.from(comps[0], this.format);\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (this.isNegative() && hasFraction) {\n            result = result.subUnsafe(ONE.toFormat(result.format));\n        }\n        return result;\n    }\n    ceiling() {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        let result = FixedNumber.from(comps[0], this.format);\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (!this.isNegative() && hasFraction) {\n            result = result.addUnsafe(ONE.toFormat(result.format));\n        }\n        return result;\n    }\n    // @TODO: Support other rounding algorithms\n    round(decimals) {\n        if (decimals == null) {\n            decimals = 0;\n        }\n        // If we are already in range, we're done\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        if (decimals < 0 || decimals > 80 || decimals % 1) {\n            logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n        }\n        if (comps[1].length <= decimals) {\n            return this;\n        }\n        const factor = FixedNumber.from(\"1\" + zeros.substring(0, decimals), this.format);\n        const bump = BUMP.toFormat(this.format);\n        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);\n    }\n    isZero() {\n        return this._value === \"0.0\" || this._value === \"0\";\n    }\n    isNegative() {\n        return this._value[0] === \"-\";\n    }\n    toString() {\n        return this._value;\n    }\n    toHexString(width) {\n        if (width == null) {\n            return this._hex;\n        }\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid byte width\", \"width\", width);\n        }\n        const hex = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(hex, width / 8);\n    }\n    toUnsafeFloat() {\n        return parseFloat(this.toString());\n    }\n    toFormat(format) {\n        return FixedNumber.fromString(this._value, format);\n    }\n    static fromValue(value, decimals, format) {\n        // If decimals looks more like a format, and there is no format, shift the parameters\n        if (format == null && decimals != null && !(0,_bignumber__WEBPACK_IMPORTED_MODULE_2__.isBigNumberish)(decimals)) {\n            format = decimals;\n            decimals = null;\n        }\n        if (decimals == null) {\n            decimals = 0;\n        }\n        if (format == null) {\n            format = \"fixed\";\n        }\n        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n    }\n    static fromString(value, format) {\n        if (format == null) {\n            format = \"fixed\";\n        }\n        const fixedFormat = FixedFormat.from(format);\n        const numeric = parseFixed(value, fixedFormat.decimals);\n        if (!fixedFormat.signed && numeric.lt(Zero)) {\n            throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n        }\n        let hex = null;\n        if (fixedFormat.signed) {\n            hex = numeric.toTwos(fixedFormat.width).toHexString();\n        } else {\n            hex = numeric.toHexString();\n            hex = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(hex, fixedFormat.width / 8);\n        }\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n    static fromBytes(value, format) {\n        if (format == null) {\n            format = \"fixed\";\n        }\n        const fixedFormat = FixedFormat.from(format);\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value).length > fixedFormat.width / 8) {\n            throw new Error(\"overflow\");\n        }\n        let numeric = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(value);\n        if (fixedFormat.signed) {\n            numeric = numeric.fromTwos(fixedFormat.width);\n        }\n        const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n    static from(value, format) {\n        if (typeof value === \"string\") {\n            return FixedNumber.fromString(value, format);\n        }\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isBytes)(value)) {\n            return FixedNumber.fromBytes(value, format);\n        }\n        try {\n            return FixedNumber.fromValue(value, 0, format);\n        } catch (error) {\n            // Allow NUMERIC_FAULT to bubble up\n            if (error.code !== _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT) {\n                throw error;\n            }\n        }\n        return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n    }\n    static isFixedNumber(value) {\n        return !!(value && value._isFixedNumber);\n    }\n}\nconst ONE = FixedNumber.from(1);\nconst BUMP = FixedNumber.from(\"0.5\"); //# sourceMappingURL=fixednumber.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9iaWdudW1iZXIvbGliLmVzbS9maXhlZG51bWJlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFhO0FBQ3dEO0FBQ3RCO0FBQ1Y7QUFDckMsTUFBTUssU0FBUyxJQUFJRix5REFBTUEsQ0FBQ0MsNkNBQU9BO0FBQ3VCO0FBQ3hELE1BQU1JLG9CQUFvQixDQUFDO0FBQzNCLE1BQU1DLE9BQU9ILGlEQUFTQSxDQUFDSSxJQUFJLENBQUM7QUFDNUIsTUFBTUMsY0FBY0wsaURBQVNBLENBQUNJLElBQUksQ0FBQyxDQUFDO0FBQ3BDLFNBQVNFLFdBQVdDLE9BQU8sRUFBRUMsS0FBSyxFQUFFQyxTQUFTLEVBQUVDLEtBQUs7SUFDaEQsTUFBTUMsU0FBUztRQUFFSCxPQUFPQTtRQUFPQyxXQUFXQTtJQUFVO0lBQ3BELElBQUlDLFVBQVVFLFdBQVc7UUFDckJELE9BQU9ELEtBQUssR0FBR0E7SUFDbkI7SUFDQSxPQUFPWCxPQUFPYyxVQUFVLENBQUNOLFNBQVNWLHlEQUFNQSxDQUFDaUIsTUFBTSxDQUFDQyxhQUFhLEVBQUVKO0FBQ25FO0FBQ0EsOENBQThDO0FBQzlDLElBQUlLLFFBQVE7QUFDWixNQUFPQSxNQUFNQyxNQUFNLEdBQUcsSUFBSztJQUN2QkQsU0FBU0E7QUFDYjtBQUNBLGdEQUFnRDtBQUNoRCxTQUFTRSxjQUFjQyxRQUFRO0lBQzNCLElBQUksT0FBUUEsYUFBYyxVQUFVO1FBQ2hDLElBQUk7WUFDQUEsV0FBV25CLGlEQUFTQSxDQUFDSSxJQUFJLENBQUNlLFVBQVVDLFFBQVE7UUFDaEQsRUFDQSxPQUFPQyxHQUFHLENBQUU7SUFDaEI7SUFDQSxJQUFJLE9BQVFGLGFBQWMsWUFBWUEsWUFBWSxLQUFLQSxZQUFZLE9BQU8sQ0FBRUEsQ0FBQUEsV0FBVyxJQUFJO1FBQ3ZGLE9BQVEsTUFBTUgsTUFBTU0sU0FBUyxDQUFDLEdBQUdIO0lBQ3JDO0lBQ0Es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QUFNcUQsY0FBYztJQUMzQztBQUNKO0FBQ0EsTUFBTWdCLE1BQU1yQixZQUFZdEQsSUFBSSxDQUFDO0FBQzdCLE1BQU1pRixPQUFPM0IsWUFBWXRELElBQUksQ0FBQyxRQUM5Qix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbGltZS1iZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9iaWdudW1iZXIvbGliLmVzbS9maXhlZG51bWJlci5qcz83MmFiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGhleFplcm9QYWQsIGlzQnl0ZXMgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IEJpZ051bWJlciwgaXNCaWdOdW1iZXJpc2ggfSBmcm9tIFwiLi9iaWdudW1iZXJcIjtcbmNvbnN0IF9jb25zdHJ1Y3Rvckd1YXJkID0ge307XG5jb25zdCBaZXJvID0gQmlnTnVtYmVyLmZyb20oMCk7XG5jb25zdCBOZWdhdGl2ZU9uZSA9IEJpZ051bWJlci5mcm9tKC0xKTtcbmZ1bmN0aW9uIHRocm93RmF1bHQobWVzc2FnZSwgZmF1bHQsIG9wZXJhdGlvbiwgdmFsdWUpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7IGZhdWx0OiBmYXVsdCwgb3BlcmF0aW9uOiBvcGVyYXRpb24gfTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJhbXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuTlVNRVJJQ19GQVVMVCwgcGFyYW1zKTtcbn1cbi8vIENvbnN0YW50IHRvIHB1bGwgemVyb3MgZnJvbSBmb3IgbXVsdGlwbGllcnNcbmxldCB6ZXJvcyA9IFwiMFwiO1xud2hpbGUgKHplcm9zLmxlbmd0aCA8IDI1Nikge1xuICAgIHplcm9zICs9IHplcm9zO1xufVxuLy8gUmV0dXJucyBhIHN0cmluZyBcIjFcIiBmb2xsb3dlZCBieSBkZWNpbWFsIFwiMFwic1xuZnVuY3Rpb24gZ2V0TXVsdGlwbGllcihkZWNpbWFscykge1xuICAgIGlmICh0eXBlb2YgKGRlY2ltYWxzKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVjaW1hbHMgPSBCaWdOdW1iZXIuZnJvbShkZWNpbWFscykudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKGRlY2ltYWxzKSA9PT0gXCJudW1iZXJcIiAmJiBkZWNpbWFscyA+PSAwICYmIGRlY2ltYWxzIDw9IDI1NiAmJiAhKGRlY2ltYWxzICUgMSkpIHtcbiAgICAgICAgcmV0dXJuIChcIjFcIiArIHplcm9zLnN1YnN0cmluZygwLCBkZWNpbWFscykpO1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZGVjaW1hbCBzaXplXCIsIFwiZGVjaW1hbHNcIiwgZGVjaW1hbHMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEZpeGVkKHZhbHVlLCBkZWNpbWFscykge1xuICAgIGlmIChkZWNpbWFscyA9PSBudWxsKSB7XG4gICAgICAgIGRlY2ltYWxzID0gMDtcbiAgICB9XG4gICAgY29uc3QgbXVsdGlwbGllciA9IGdldE11bHRpcGxpZXIoZGVjaW1hbHMpO1xuICAgIC8vIE1ha2Ugc3VyZSB3ZWkgaXMgYSBiaWcgbnVtYmVyIChjb252ZXJ0IGFzIG5lY2Vzc2FyeSlcbiAgICB2YWx1ZSA9IEJpZ051bWJlci5mcm9tKHZhbHVlKTtcbiAgICBjb25zdCBuZWdhdGl2ZSA9IHZhbHVlLmx0KFplcm8pO1xuICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLm11bChOZWdhdGl2ZU9uZSk7XG4gICAgfVxuICAgIGxldCBmcmFjdGlvbiA9IHZhbHVlLm1vZChtdWx0aXBsaWVyKS50b1N0cmluZygpO1xuICAgIHdoaWxlIChmcmFjdGlvbi5sZW5ndGggPCBtdWx0aXBsaWVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgZnJhY3Rpb24gPSBcIjBcIiArIGZyYWN0aW9uO1xuICAgIH1cbiAgICAvLyBTdHJpcCB0cmFpbmluZyAwXG4gICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5tYXRjaCgvXihbMC05XSpbMS05XXwwKSgwKikvKVsxXTtcbiAgICBjb25zdCB3aG9sZSA9IHZhbHVlLmRpdihtdWx0aXBsaWVyKS50b1N0cmluZygpO1xuICAgIGlmIChtdWx0aXBsaWVyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YWx1ZSA9IHdob2xlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSB3aG9sZSArIFwiLlwiICsgZnJhY3Rpb247XG4gICAgfVxuICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICB2YWx1ZSA9IFwiLVwiICsgdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZpeGVkKHZhbHVlLCBkZWNpbWFscykge1xuICAgIGlmIChkZWNpbWFscyA9PSBudWxsKSB7XG4gICAgICAgIGRlY2ltYWxzID0gMDtcbiAgICB9XG4gICAgY29uc3QgbXVsdGlwbGllciA9IGdldE11bHRpcGxpZXIoZGVjaW1hbHMpO1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIiB8fCAhdmFsdWUubWF0Y2goL14tP1swLTkuXSskLykpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZGVjaW1hbCB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gSXMgaXQgbmVnYXRpdmU/XG4gICAgY29uc3QgbmVnYXRpdmUgPSAodmFsdWUuc3Vic3RyaW5nKDAsIDEpID09PSBcIi1cIik7XG4gICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IFwiLlwiKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBTcGxpdCBpdCBpbnRvIGEgd2hvbGUgYW5kIGZyYWN0aW9uYWwgcGFydFxuICAgIGNvbnN0IGNvbXBzID0gdmFsdWUuc3BsaXQoXCIuXCIpO1xuICAgIGlmIChjb21wcy5sZW5ndGggPiAyKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0b28gbWFueSBkZWNpbWFsIHBvaW50c1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgbGV0IHdob2xlID0gY29tcHNbMF0sIGZyYWN0aW9uID0gY29tcHNbMV07XG4gICAgaWYgKCF3aG9sZSkge1xuICAgICAgICB3aG9sZSA9IFwiMFwiO1xuICAgIH1cbiAgICBpZiAoIWZyYWN0aW9uKSB7XG4gICAgICAgIGZyYWN0aW9uID0gXCIwXCI7XG4gICAgfVxuICAgIC8vIFRyaW0gdHJhaWxpbmcgemVyb3NcbiAgICB3aGlsZSAoZnJhY3Rpb25bZnJhY3Rpb24ubGVuZ3RoIC0gMV0gPT09IFwiMFwiKSB7XG4gICAgICAgIGZyYWN0aW9uID0gZnJhY3Rpb24uc3Vic3RyaW5nKDAsIGZyYWN0aW9uLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICAvLyBDaGVjayB0aGUgZnJhY3Rpb24gZG9lc24ndCBleGNlZWQgb3VyIGRlY2ltYWxzIHNpemVcbiAgICBpZiAoZnJhY3Rpb24ubGVuZ3RoID4gbXVsdGlwbGllci5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRocm93RmF1bHQoXCJmcmFjdGlvbmFsIGNvbXBvbmVudCBleGNlZWRzIGRlY2ltYWxzXCIsIFwidW5kZXJmbG93XCIsIFwicGFyc2VGaXhlZFwiKTtcbiAgICB9XG4gICAgLy8gSWYgZGVjaW1hbHMgaXMgMCwgd2UgaGF2ZSBhbiBlbXB0eSBzdHJpbmcgZm9yIGZyYWN0aW9uXG4gICAgaWYgKGZyYWN0aW9uID09PSBcIlwiKSB7XG4gICAgICAgIGZyYWN0aW9uID0gXCIwXCI7XG4gICAgfVxuICAgIC8vIEZ1bGx5IHBhZCB0aGUgc3RyaW5nIHdpdGggemVyb3MgdG8gZ2V0IHRvIHdlaVxuICAgIHdoaWxlIChmcmFjdGlvbi5sZW5ndGggPCBtdWx0aXBsaWVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgZnJhY3Rpb24gKz0gXCIwXCI7XG4gICAgfVxuICAgIGNvbnN0IHdob2xlVmFsdWUgPSBCaWdOdW1iZXIuZnJvbSh3aG9sZSk7XG4gICAgY29uc3QgZnJhY3Rpb25WYWx1ZSA9IEJpZ051bWJlci5mcm9tKGZyYWN0aW9uKTtcbiAgICBsZXQgd2VpID0gKHdob2xlVmFsdWUubXVsKG11bHRpcGxpZXIpKS5hZGQoZnJhY3Rpb25WYWx1ZSk7XG4gICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIHdlaSA9IHdlaS5tdWwoTmVnYXRpdmVPbmUpO1xuICAgIH1cbiAgICByZXR1cm4gd2VpO1xufVxuZXhwb3J0IGNsYXNzIEZpeGVkRm9ybWF0IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvckd1YXJkLCBzaWduZWQsIHdpZHRoLCBkZWNpbWFscykge1xuICAgICAgICBpZiAoY29uc3RydWN0b3JHdWFyZCAhPT0gX2NvbnN0cnVjdG9yR3VhcmQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IHVzZSBGaXhlZEZvcm1hdCBjb25zdHJ1Y3RvcjsgdXNlIEZpeGVkRm9ybWF0LmZyb21cIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IEZpeGVkRm9ybWF0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2lnbmVkID0gc2lnbmVkO1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuZGVjaW1hbHMgPSBkZWNpbWFscztcbiAgICAgICAgdGhpcy5uYW1lID0gKHNpZ25lZCA/IFwiXCIgOiBcInVcIikgKyBcImZpeGVkXCIgKyBTdHJpbmcod2lkdGgpICsgXCJ4XCIgKyBTdHJpbmcoZGVjaW1hbHMpO1xuICAgICAgICB0aGlzLl9tdWx0aXBsaWVyID0gZ2V0TXVsdGlwbGllcihkZWNpbWFscyk7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZpeGVkRm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGBmaXhlZDEyOHgke3ZhbHVlfWA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNpZ25lZCA9IHRydWU7XG4gICAgICAgIGxldCB3aWR0aCA9IDEyODtcbiAgICAgICAgbGV0IGRlY2ltYWxzID0gMTg7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcImZpeGVkXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0cy4uLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IFwidWZpeGVkXCIpIHtcbiAgICAgICAgICAgICAgICBzaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdmFsdWUubWF0Y2goL14odT8pZml4ZWQoWzAtOV0rKXgoWzAtOV0rKSQvKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZpeGVkIGZvcm1hdFwiLCBcImZvcm1hdFwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNpZ25lZCA9IChtYXRjaFsxXSAhPT0gXCJ1XCIpO1xuICAgICAgICAgICAgICAgIHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgICAgICAgICAgIGRlY2ltYWxzID0gcGFyc2VJbnQobWF0Y2hbM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGVjayA9IChrZXksIHR5cGUsIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWVba2V5XSkgIT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZml4ZWQgZm9ybWF0IChcIiArIGtleSArIFwiIG5vdCBcIiArIHR5cGUgKyBcIilcIiwgXCJmb3JtYXQuXCIgKyBrZXksIHZhbHVlW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVba2V5XTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzaWduZWQgPSBjaGVjayhcInNpZ25lZFwiLCBcImJvb2xlYW5cIiwgc2lnbmVkKTtcbiAgICAgICAgICAgIHdpZHRoID0gY2hlY2soXCJ3aWR0aFwiLCBcIm51bWJlclwiLCB3aWR0aCk7XG4gICAgICAgICAgICBkZWNpbWFscyA9IGNoZWNrKFwiZGVjaW1hbHNcIiwgXCJudW1iZXJcIiwgZGVjaW1hbHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aWR0aCAlIDgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZpeGVkIGZvcm1hdCB3aWR0aCAobm90IGJ5dGUgYWxpZ25lZClcIiwgXCJmb3JtYXQud2lkdGhcIiwgd2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWNpbWFscyA+IDgwKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmaXhlZCBmb3JtYXQgKGRlY2ltYWxzIHRvbyBsYXJnZSlcIiwgXCJmb3JtYXQuZGVjaW1hbHNcIiwgZGVjaW1hbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWRGb3JtYXQoX2NvbnN0cnVjdG9yR3VhcmQsIHNpZ25lZCwgd2lkdGgsIGRlY2ltYWxzKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRml4ZWROdW1iZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnN0cnVjdG9yR3VhcmQsIGhleCwgdmFsdWUsIGZvcm1hdCkge1xuICAgICAgICBpZiAoY29uc3RydWN0b3JHdWFyZCAhPT0gX2NvbnN0cnVjdG9yR3VhcmQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IHVzZSBGaXhlZE51bWJlciBjb25zdHJ1Y3RvcjsgdXNlIEZpeGVkTnVtYmVyLmZyb21cIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IEZpeGVkRm9ybWF0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICB0aGlzLl9oZXggPSBoZXg7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2lzRml4ZWROdW1iZXIgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICBfY2hlY2tGb3JtYXQob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9ybWF0Lm5hbWUgIT09IG90aGVyLmZvcm1hdC5uYW1lKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW5jb21wYXRpYmxlIGZvcm1hdDsgdXNlIGZpeGVkTnVtYmVyLnRvRm9ybWF0XCIsIFwib3RoZXJcIiwgb3RoZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFVuc2FmZShvdGhlcikge1xuICAgICAgICB0aGlzLl9jaGVja0Zvcm1hdChvdGhlcik7XG4gICAgICAgIGNvbnN0IGEgPSBwYXJzZUZpeGVkKHRoaXMuX3ZhbHVlLCB0aGlzLmZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIGNvbnN0IGIgPSBwYXJzZUZpeGVkKG90aGVyLl92YWx1ZSwgb3RoZXIuZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZShhLmFkZChiKSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMsIHRoaXMuZm9ybWF0KTtcbiAgICB9XG4gICAgc3ViVW5zYWZlKG90aGVyKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrRm9ybWF0KG90aGVyKTtcbiAgICAgICAgY29uc3QgYSA9IHBhcnNlRml4ZWQodGhpcy5fdmFsdWUsIHRoaXMuZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgY29uc3QgYiA9IHBhcnNlRml4ZWQob3RoZXIuX3ZhbHVlLCBvdGhlci5mb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVZhbHVlKGEuc3ViKGIpLCB0aGlzLmZvcm1hdC5kZWNpbWFscywgdGhpcy5mb3JtYXQpO1xuICAgIH1cbiAgICBtdWxVbnNhZmUob3RoZXIpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tGb3JtYXQob3RoZXIpO1xuICAgICAgICBjb25zdCBhID0gcGFyc2VGaXhlZCh0aGlzLl92YWx1ZSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICBjb25zdCBiID0gcGFyc2VGaXhlZChvdGhlci5fdmFsdWUsIG90aGVyLmZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tVmFsdWUoYS5tdWwoYikuZGl2KHRoaXMuZm9ybWF0Ll9tdWx0aXBsaWVyKSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMsIHRoaXMuZm9ybWF0KTtcbiAgICB9XG4gICAgZGl2VW5zYWZlKG90aGVyKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrRm9ybWF0KG90aGVyKTtcbiAgICAgICAgY29uc3QgYSA9IHBhcnNlRml4ZWQodGhpcy5fdmFsdWUsIHRoaXMuZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgY29uc3QgYiA9IHBhcnNlRml4ZWQob3RoZXIuX3ZhbHVlLCBvdGhlci5mb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVZhbHVlKGEubXVsKHRoaXMuZm9ybWF0Ll9tdWx0aXBsaWVyKS5kaXYoYiksIHRoaXMuZm9ybWF0LmRlY2ltYWxzLCB0aGlzLmZvcm1hdCk7XG4gICAgfVxuICAgIGZsb29yKCkge1xuICAgICAgICBjb25zdCBjb21wcyA9IHRoaXMudG9TdHJpbmcoKS5zcGxpdChcIi5cIik7XG4gICAgICAgIGlmIChjb21wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbXBzLnB1c2goXCIwXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBGaXhlZE51bWJlci5mcm9tKGNvbXBzWzBdLCB0aGlzLmZvcm1hdCk7XG4gICAgICAgIGNvbnN0IGhhc0ZyYWN0aW9uID0gIWNvbXBzWzFdLm1hdGNoKC9eKDAqKSQvKTtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpICYmIGhhc0ZyYWN0aW9uKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc3ViVW5zYWZlKE9ORS50b0Zvcm1hdChyZXN1bHQuZm9ybWF0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY2VpbGluZygpIHtcbiAgICAgICAgY29uc3QgY29tcHMgPSB0aGlzLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpO1xuICAgICAgICBpZiAoY29tcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBjb21wcy5wdXNoKFwiMFwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gRml4ZWROdW1iZXIuZnJvbShjb21wc1swXSwgdGhpcy5mb3JtYXQpO1xuICAgICAgICBjb25zdCBoYXNGcmFjdGlvbiA9ICFjb21wc1sxXS5tYXRjaCgvXigwKikkLyk7XG4gICAgICAgIGlmICghdGhpcy5pc05lZ2F0aXZlKCkgJiYgaGFzRnJhY3Rpb24pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGRVbnNhZmUoT05FLnRvRm9ybWF0KHJlc3VsdC5mb3JtYXQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBAVE9ETzogU3VwcG9ydCBvdGhlciByb3VuZGluZyBhbGdvcml0aG1zXG4gICAgcm91bmQoZGVjaW1hbHMpIHtcbiAgICAgICAgaWYgKGRlY2ltYWxzID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlY2ltYWxzID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBhcmUgYWxyZWFkeSBpbiByYW5nZSwgd2UncmUgZG9uZVxuICAgICAgICBjb25zdCBjb21wcyA9IHRoaXMudG9TdHJpbmcoKS5zcGxpdChcIi5cIik7XG4gICAgICAgIGlmIChjb21wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbXBzLnB1c2goXCIwXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWNpbWFscyA8IDAgfHwgZGVjaW1hbHMgPiA4MCB8fCAoZGVjaW1hbHMgJSAxKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZGVjaW1hbCBjb3VudFwiLCBcImRlY2ltYWxzXCIsIGRlY2ltYWxzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHNbMV0ubGVuZ3RoIDw9IGRlY2ltYWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmYWN0b3IgPSBGaXhlZE51bWJlci5mcm9tKFwiMVwiICsgemVyb3Muc3Vic3RyaW5nKDAsIGRlY2ltYWxzKSwgdGhpcy5mb3JtYXQpO1xuICAgICAgICBjb25zdCBidW1wID0gQlVNUC50b0Zvcm1hdCh0aGlzLmZvcm1hdCk7XG4gICAgICAgIHJldHVybiB0aGlzLm11bFVuc2FmZShmYWN0b3IpLmFkZFVuc2FmZShidW1wKS5mbG9vcigpLmRpdlVuc2FmZShmYWN0b3IpO1xuICAgIH1cbiAgICBpc1plcm8oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fdmFsdWUgPT09IFwiMC4wXCIgfHwgdGhpcy5fdmFsdWUgPT09IFwiMFwiKTtcbiAgICB9XG4gICAgaXNOZWdhdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl92YWx1ZVswXSA9PT0gXCItXCIpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9XG4gICAgdG9IZXhTdHJpbmcod2lkdGgpIHtcbiAgICAgICAgaWYgKHdpZHRoID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpZHRoICUgOCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYnl0ZSB3aWR0aFwiLCBcIndpZHRoXCIsIHdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZXggPSBCaWdOdW1iZXIuZnJvbSh0aGlzLl9oZXgpLmZyb21Ud29zKHRoaXMuZm9ybWF0LndpZHRoKS50b1R3b3Mod2lkdGgpLnRvSGV4U3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBoZXhaZXJvUGFkKGhleCwgd2lkdGggLyA4KTtcbiAgICB9XG4gICAgdG9VbnNhZmVGbG9hdCgpIHsgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy50b1N0cmluZygpKTsgfVxuICAgIHRvRm9ybWF0KGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVN0cmluZyh0aGlzLl92YWx1ZSwgZm9ybWF0KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21WYWx1ZSh2YWx1ZSwgZGVjaW1hbHMsIGZvcm1hdCkge1xuICAgICAgICAvLyBJZiBkZWNpbWFscyBsb29rcyBtb3JlIGxpa2UgYSBmb3JtYXQsIGFuZCB0aGVyZSBpcyBubyBmb3JtYXQsIHNoaWZ0IHRoZSBwYXJhbWV0ZXJzXG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCAmJiBkZWNpbWFscyAhPSBudWxsICYmICFpc0JpZ051bWJlcmlzaChkZWNpbWFscykpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGRlY2ltYWxzO1xuICAgICAgICAgICAgZGVjaW1hbHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWNpbWFscyA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWNpbWFscyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcImZpeGVkXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21TdHJpbmcoZm9ybWF0Rml4ZWQodmFsdWUsIGRlY2ltYWxzKSwgRml4ZWRGb3JtYXQuZnJvbShmb3JtYXQpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmcodmFsdWUsIGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwiZml4ZWRcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXhlZEZvcm1hdCA9IEZpeGVkRm9ybWF0LmZyb20oZm9ybWF0KTtcbiAgICAgICAgY29uc3QgbnVtZXJpYyA9IHBhcnNlRml4ZWQodmFsdWUsIGZpeGVkRm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgaWYgKCFmaXhlZEZvcm1hdC5zaWduZWQgJiYgbnVtZXJpYy5sdChaZXJvKSkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcInVuc2lnbmVkIHZhbHVlIGNhbm5vdCBiZSBuZWdhdGl2ZVwiLCBcIm92ZXJmbG93XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBoZXggPSBudWxsO1xuICAgICAgICBpZiAoZml4ZWRGb3JtYXQuc2lnbmVkKSB7XG4gICAgICAgICAgICBoZXggPSBudW1lcmljLnRvVHdvcyhmaXhlZEZvcm1hdC53aWR0aCkudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhleCA9IG51bWVyaWMudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgICAgIGhleCA9IGhleFplcm9QYWQoaGV4LCBmaXhlZEZvcm1hdC53aWR0aCAvIDgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlY2ltYWwgPSBmb3JtYXRGaXhlZChudW1lcmljLCBmaXhlZEZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2NvbnN0cnVjdG9yR3VhcmQsIGhleCwgZGVjaW1hbCwgZml4ZWRGb3JtYXQpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJ5dGVzKHZhbHVlLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcImZpeGVkXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZml4ZWRGb3JtYXQgPSBGaXhlZEZvcm1hdC5mcm9tKGZvcm1hdCk7XG4gICAgICAgIGlmIChhcnJheWlmeSh2YWx1ZSkubGVuZ3RoID4gZml4ZWRGb3JtYXQud2lkdGggLyA4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvdmVyZmxvd1wiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbnVtZXJpYyA9IEJpZ051bWJlci5mcm9tKHZhbHVlKTtcbiAgICAgICAgaWYgKGZpeGVkRm9ybWF0LnNpZ25lZCkge1xuICAgICAgICAgICAgbnVtZXJpYyA9IG51bWVyaWMuZnJvbVR3b3MoZml4ZWRGb3JtYXQud2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhleCA9IG51bWVyaWMudG9Ud29zKChmaXhlZEZvcm1hdC5zaWduZWQgPyAwIDogMSkgKyBmaXhlZEZvcm1hdC53aWR0aCkudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgY29uc3QgZGVjaW1hbCA9IGZvcm1hdEZpeGVkKG51bWVyaWMsIGZpeGVkRm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfY29uc3RydWN0b3JHdWFyZCwgaGV4LCBkZWNpbWFsLCBmaXhlZEZvcm1hdCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHZhbHVlLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVN0cmluZyh2YWx1ZSwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNCeXRlcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tQnl0ZXModmFsdWUsIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tVmFsdWUodmFsdWUsIDAsIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBBbGxvdyBOVU1FUklDX0ZBVUxUIHRvIGJ1YmJsZSB1cFxuICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgIT09IExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBGaXhlZE51bWJlciB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGlzRml4ZWROdW1iZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0ZpeGVkTnVtYmVyKTtcbiAgICB9XG59XG5jb25zdCBPTkUgPSBGaXhlZE51bWJlci5mcm9tKDEpO1xuY29uc3QgQlVNUCA9IEZpeGVkTnVtYmVyLmZyb20oXCIwLjVcIik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maXhlZG51bWJlci5qcy5tYXAiXSwibmFtZXMiOlsiYXJyYXlpZnkiLCJoZXhaZXJvUGFkIiwiaXNCeXRlcyIsIkxvZ2dlciIsInZlcnNpb24iLCJsb2dnZXIiLCJCaWdOdW1iZXIiLCJpc0JpZ051bWJlcmlzaCIsIl9jb25zdHJ1Y3Rvckd1YXJkIiwiWmVybyIsImZyb20iLCJOZWdhdGl2ZU9uZSIsInRocm93RmF1bHQiLCJtZXNzYWdlIiwiZmF1bHQiLCJvcGVyYXRpb24iLCJ2YWx1ZSIsInBhcmFtcyIsInVuZGVmaW5lZCIsInRocm93RXJyb3IiLCJlcnJvcnMiLCJOVU1FUklDX0ZBVUxUIiwiemVyb3MiLCJsZW5ndGgiLCJnZXRNdWx0aXBsaWVyIiwiZGVjaW1hbHMiLCJ0b051bWJlciIsImUiLCJzdWJzdHJpbmciLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJmb3JtYXRGaXhlZCIsIm11bHRpcGxpZXIiLCJuZWdhdGl2ZSIsImx0IiwibXVsIiwiZnJhY3Rpb24iLCJtb2QiLCJ0b1N0cmluZyIsIm1hdGNoIiwid2hvbGUiLCJkaXYiLCJwYXJzZUZpeGVkIiwiY29tcHMiLCJzcGxpdCIsIndob2xlVmFsdWUiLCJmcmFjdGlvblZhbHVlIiwid2VpIiwiYWRkIiwiRml4ZWRGb3JtYXQiLCJjb25zdHJ1Y3RvciIsImNvbnN0cnVjdG9yR3VhcmQiLCJzaWduZWQiLCJ3aWR0aCIsIlVOU1VQUE9SVEVEX09QRVJBVElPTiIsIm5hbWUiLCJTdHJpbmciLCJfbXVsdGlwbGllciIsIk9iamVjdCIsImZyZWV6ZSIsInBhcnNlSW50IiwiY2hlY2siLCJrZXkiLCJ0eXBlIiwiZGVmYXVsdFZhbHVlIiwiRml4ZWROdW1iZXIiLCJoZXgiLCJmb3JtYXQiLCJfaGV4IiwiX3ZhbHVlIiwiX2lzRml4ZWROdW1iZXIiLCJfY2hlY2tGb3JtYXQiLCJvdGhlciIsImFkZFVuc2FmZSIsImEiLCJiIiwiZnJvbVZhbHVlIiwic3ViVW5zYWZlIiwic3ViIiwibXVsVW5zYWZlIiwiZGl2VW5zYWZlIiwiZmxvb3IiLCJwdXNoIiwicmVzdWx0IiwiaGFzRnJhY3Rpb24iLCJpc05lZ2F0aXZlIiwiT05FIiwidG9Gb3JtYXQiLCJjZWlsaW5nIiwicm91bmQiLCJmYWN0b3IiLCJidW1wIiwiQlVNUCIsImlzWmVybyIsInRvSGV4U3RyaW5nIiwiZnJvbVR3b3MiLCJ0b1R3b3MiLCJ0b1Vuc2FmZUZsb2F0IiwicGFyc2VGbG9hdCIsImZyb21TdHJpbmciLCJmaXhlZEZvcm1hdCIsIm51bWVyaWMiLCJkZWNpbWFsIiwiZnJvbUJ5dGVzIiwiRXJyb3IiLCJlcnJvciIsImNvZGUiLCJJTlZBTElEX0FSR1VNRU5UIiwiaXNGaXhlZE51bWJlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/_version.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/_version.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"bytes/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9ieXRlcy9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxNQUFNQSxVQUFVLGNBQWMsQ0FDckMsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2xpbWUtYmV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYnl0ZXMvbGliLmVzbS9fdmVyc2lvbi5qcz9iZjAzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJieXRlcy81LjcuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrayify: () => (/* binding */ arrayify),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   hexConcat: () => (/* binding */ hexConcat),\n/* harmony export */   hexDataLength: () => (/* binding */ hexDataLength),\n/* harmony export */   hexDataSlice: () => (/* binding */ hexDataSlice),\n/* harmony export */   hexStripZeros: () => (/* binding */ hexStripZeros),\n/* harmony export */   hexValue: () => (/* binding */ hexValue),\n/* harmony export */   hexZeroPad: () => (/* binding */ hexZeroPad),\n/* harmony export */   hexlify: () => (/* binding */ hexlify),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isBytesLike: () => (/* binding */ isBytesLike),\n/* harmony export */   isHexString: () => (/* binding */ isHexString),\n/* harmony export */   joinSignature: () => (/* binding */ joinSignature),\n/* harmony export */   splitSignature: () => (/* binding */ splitSignature),\n/* harmony export */   stripZeros: () => (/* binding */ stripZeros),\n/* harmony export */   zeroPad: () => (/* binding */ zeroPad)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/_version.js\");\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n///////////////////////////////\nfunction isHexable(value) {\n    return !!value.toHexString;\n}\nfunction addSlice(array) {\n    if (array.slice) {\n        return array;\n    }\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    };\n    return array;\n}\nfunction isBytesLike(value) {\n    return isHexString(value) && !(value.length % 2) || isBytes(value);\n}\nfunction isInteger(value) {\n    return typeof value === \"number\" && value == value && value % 1 === 0;\n}\nfunction isBytes(value) {\n    if (value == null) {\n        return false;\n    }\n    if (value.constructor === Uint8Array) {\n        return true;\n    }\n    if (typeof value === \"string\") {\n        return false;\n    }\n    if (!isInteger(value.length) || value.length < 0) {\n        return false;\n    }\n    for(let i = 0; i < value.length; i++){\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction arrayify(value, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof value === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n        const result = [];\n        while(value){\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) {\n            result.push(0);\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (options.allowMissingPrefix && typeof value === \"string\" && value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    if (isHexable(value)) {\n        value = value.toHexString();\n    }\n    if (isHexString(value)) {\n        let hex = value.substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        const result = [];\n        for(let i = 0; i < hex.length; i += 2){\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\nfunction concat(items) {\n    const objects = items.map((item)=>arrayify(item));\n    const length = objects.reduce((accum, item)=>accum + item.length, 0);\n    const result = new Uint8Array(length);\n    objects.reduce((offset, object)=>{\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n    return addSlice(result);\n}\nfunction stripZeros(value) {\n    let result = arrayify(value);\n    if (result.length === 0) {\n        return result;\n    }\n    // Find the first non-zero entry\n    let start = 0;\n    while(start < result.length && result[start] === 0){\n        start++;\n    }\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n    return result;\n}\nfunction zeroPad(value, length) {\n    value = arrayify(value);\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\nfunction isHexString(value, length) {\n    if (typeof value !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (length && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    return true;\n}\nconst HexCharacters = \"0123456789abcdef\";\nfunction hexlify(value, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof value === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n        let hex = \"\";\n        while(value){\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n        if (hex.length) {\n            if (hex.length % 2) {\n                hex = \"0\" + hex;\n            }\n            return \"0x\" + hex;\n        }\n        return \"0x00\";\n    }\n    if (typeof value === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) {\n            return \"0x0\" + value;\n        }\n        return \"0x\" + value;\n    }\n    if (options.allowMissingPrefix && typeof value === \"string\" && value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    if (isHexable(value)) {\n        return value.toHexString();\n    }\n    if (isHexString(value)) {\n        if (value.length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + value.substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return value.toLowerCase();\n    }\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for(let i = 0; i < value.length; i++){\n            let v = value[i];\n            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/ function hexDataLength(data) {\n    if (typeof data !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || data.length % 2) {\n        return null;\n    }\n    return (data.length - 2) / 2;\n}\nfunction hexDataSlice(data, offset, endOffset) {\n    if (typeof data !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || data.length % 2) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data);\n    }\n    offset = 2 + 2 * offset;\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n    return \"0x\" + data.substring(offset);\n}\nfunction hexConcat(items) {\n    let result = \"0x\";\n    items.forEach((item)=>{\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\nfunction hexValue(value) {\n    const trimmed = hexStripZeros(hexlify(value, {\n        hexPad: \"left\"\n    }));\n    if (trimmed === \"0x\") {\n        return \"0x0\";\n    }\n    return trimmed;\n}\nfunction hexStripZeros(value) {\n    if (typeof value !== \"string\") {\n        value = hexlify(value);\n    }\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while(offset < value.length && value[offset] === \"0\"){\n        offset++;\n    }\n    return \"0x\" + value.substring(offset);\n}\nfunction hexZeroPad(value, length) {\n    if (typeof value !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n    while(value.length < 2 * length + 2){\n        value = \"0x0\" + value.substring(2);\n    }\n    return value;\n}\nfunction splitSignature(signature) {\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n    if (isBytesLike(signature)) {\n        let bytes = arrayify(signature);\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - result.v % 2;\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) {\n            bytes[32] |= 0x80;\n        }\n        result._vs = hexlify(bytes.slice(32, 64));\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n            // Set or check the recid\n            const recoveryParam = vs[0] >= 128 ? 1 : 0;\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - result.v % 2;\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) {\n            vs[0] |= 0x80;\n        }\n        const _vs = hexlify(vs);\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n    return result;\n}\nfunction joinSignature(signature) {\n    signature = splitSignature(signature);\n    return hexlify(concat([\n        signature.r,\n        signature.s,\n        signature.recoveryParam ? \"0x1c\" : \"0x1b\"\n    ]));\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9ieXRlcy9saWIuZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFhO0FBQ2tDO0FBQ1Y7QUFDckMsTUFBTUUsU0FBUyxJQUFJRix5REFBTUEsQ0FBQ0MsNkNBQU9BO0FBQ2pDLCtCQUErQjtBQUMvQixTQUFTRSxVQUFVQyxLQUFLO0lBQ3BCLE9BQU8sQ0FBQyxDQUFFQSxNQUFNQyxXQUFXO0FBQy9CO0FBQ0EsU0FBU0MsU0FBU0MsS0FBSztJQUNuQixJQUFJQSxNQUFNQyxLQUFLLEVBQUU7UUFDYixPQUFPRDtJQUNYO0lBQ0FBLE1BQU1DLEtBQUssR0FBRztRQUNWLE1BQU1DLE9BQU9DLE1BQU1DLFNBQVMsQ0FBQ0gsS0FBSyxDQUFDSSxJQUFJLENBQUNDO1FBQ3hDLE9BQU9QLFNBQVMsSUFBSVEsV0FBV0osTUFBTUMsU0FBUyxDQUFDSCxLQUFLLENBQUNPLEtBQUssQ0FBQ1IsT0FBT0U7SUFDdEU7SUFDQSxPQUFPRjtBQUNYO0FBQ08sU0FBU1MsWUFBWVosS0FBSztJQUM3QixPQUFRLFlBQWFBLFVBQVUsQ0FBRUEsQ0FBQUEsTUFBTWMsTUFBTSxHQUFHLE1BQU9DLFFBQVFmO0FBQ25FO0FBQ0EsU0FBU2dCLFVBQVVoQixLQUFLO0lBQ3BCLE9BQVEsT0FBUUEsVUFBVyxZQUFZQSxTQUFTQSxTQUFTLFFBQVMsTUFBTztBQUM3RTtBQUNPLFNBQVNlLFFBQVFmLEtBQUs7SUFDekIsSUFBSUEsU0FBUyxNQUFNO1FBQ2YsT0FBTztJQUNYO0lBQ0EsSUFBSUEsTUFBTWlCLFdBQVcsS0FBS1AsWUFBWTtRQUNsQyxPQUFPO0lBQ1g7SUFDQSxJQUFJLE9BQVFWLFVBQVcsVUFBVTtRQUM3QixPQUFPO0lBQ1g7SUFDQSxJQUFJLENBQUNnQixVQUFVaEIsTUFBTWMsTUFBTSxLQUFLZCxNQUFNYyxNQUFNLEdBQUcsR0FBRztRQUM5QyxPQUFP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LEdBQUdMLFdBQVd2QyxPQUFPNEMsR0FBRyxFQUFFO1FBQ3hDO1FBQ0EsdUJBQXVCO1FBQ3ZCLElBQUk1QyxPQUFPNEMsR0FBRyxJQUFJLE1BQU07WUFDcEI1QyxPQUFPNEMsR0FBRyxHQUFHQTtRQUNqQixPQUNLLElBQUk1QyxPQUFPNEMsR0FBRyxLQUFLQSxLQUFLO1lBQ3pCckUsT0FBT2tDLGtCQUFrQixDQUFDLGtDQUFrQyxhQUFhZ0M7UUFDN0U7SUFDSjtJQUNBekMsT0FBTzhDLFdBQVcsR0FBRzlDLE9BQU80QyxHQUFHO0lBQy9CNUMsT0FBTytDLE9BQU8sR0FBRy9DLE9BQU8wQyxDQUFDLEdBQUcxQyxPQUFPOEMsV0FBVyxDQUFDeEMsU0FBUyxDQUFDO0lBQ3pELE9BQU9OO0FBQ1g7QUFDTyxTQUFTbUQsY0FBY1YsU0FBUztJQUNuQ0EsWUFBWUQsZUFBZUM7SUFDM0IsT0FBT2hCLFFBQVFmLE9BQU87UUFDbEIrQixVQUFVQyxDQUFDO1FBQ1hELFVBQVVFLENBQUM7UUFDVkYsVUFBVUksYUFBYSxHQUFHLFNBQVM7S0FDdkM7QUFDTCxFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NsaW1lLWJldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2J5dGVzL2xpYi5lc20vaW5kZXguanM/OWFhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZ1bmN0aW9uIGlzSGV4YWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiAhISh2YWx1ZS50b0hleFN0cmluZyk7XG59XG5mdW5jdGlvbiBhZGRTbGljZShhcnJheSkge1xuICAgIGlmIChhcnJheS5zbGljZSkge1xuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIGFycmF5LnNsaWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGFkZFNsaWNlKG5ldyBVaW50OEFycmF5KEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcnJheSwgYXJncykpKTtcbiAgICB9O1xuICAgIHJldHVybiBhcnJheTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzTGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiAoKGlzSGV4U3RyaW5nKHZhbHVlKSAmJiAhKHZhbHVlLmxlbmd0aCAlIDIpKSB8fCBpc0J5dGVzKHZhbHVlKSk7XG59XG5mdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiICYmIHZhbHVlID09IHZhbHVlICYmICh2YWx1ZSAlIDEpID09PSAwKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodmFsdWUuY29uc3RydWN0b3IgPT09IFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghaXNJbnRlZ2VyKHZhbHVlLmxlbmd0aCkgfHwgdmFsdWUubGVuZ3RoIDwgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdiA9IHZhbHVlW2ldO1xuICAgICAgICBpZiAoIWlzSW50ZWdlcih2KSB8fCB2IDwgMCB8fCB2ID49IDI1Nikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5aWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGxvZ2dlci5jaGVja1NhZmVVaW50NTModmFsdWUsIFwiaW52YWxpZCBhcnJheWlmeSB2YWx1ZVwiKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlICh2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0LnVuc2hpZnQodmFsdWUgJiAweGZmKTtcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoU3RyaW5nKHZhbHVlIC8gMjU2KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheShyZXN1bHQpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYWxsb3dNaXNzaW5nUHJlZml4ICYmIHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLnN1YnN0cmluZygwLCAyKSAhPT0gXCIweFwiKSB7XG4gICAgICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWU7XG4gICAgfVxuICAgIGlmIChpc0hleGFibGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9IZXhTdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKGlzSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgICAgICBsZXQgaGV4ID0gdmFsdWUuc3Vic3RyaW5nKDIpO1xuICAgICAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhleFBhZCA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgICAgICAgICBoZXggPSBcIjBcIiArIGhleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuaGV4UGFkID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICAgICAgICBoZXggKz0gXCIwXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaGV4IGRhdGEgaXMgb2RkLWxlbmd0aFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZXgubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KGhleC5zdWJzdHJpbmcoaSwgaSArIDIpLCAxNikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheShyZXN1bHQpKTtcbiAgICB9XG4gICAgaWYgKGlzQnl0ZXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheSh2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYXJyYXlpZnkgdmFsdWVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29uY2F0KGl0ZW1zKSB7XG4gICAgY29uc3Qgb2JqZWN0cyA9IGl0ZW1zLm1hcChpdGVtID0+IGFycmF5aWZ5KGl0ZW0pKTtcbiAgICBjb25zdCBsZW5ndGggPSBvYmplY3RzLnJlZHVjZSgoYWNjdW0sIGl0ZW0pID0+IChhY2N1bSArIGl0ZW0ubGVuZ3RoKSwgMCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBvYmplY3RzLnJlZHVjZSgob2Zmc2V0LCBvYmplY3QpID0+IHtcbiAgICAgICAgcmVzdWx0LnNldChvYmplY3QsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgKyBvYmplY3QubGVuZ3RoO1xuICAgIH0sIDApO1xuICAgIHJldHVybiBhZGRTbGljZShyZXN1bHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwWmVyb3ModmFsdWUpIHtcbiAgICBsZXQgcmVzdWx0ID0gYXJyYXlpZnkodmFsdWUpO1xuICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIGZpcnN0IG5vbi16ZXJvIGVudHJ5XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICB3aGlsZSAoc3RhcnQgPCByZXN1bHQubGVuZ3RoICYmIHJlc3VsdFtzdGFydF0gPT09IDApIHtcbiAgICAgICAgc3RhcnQrKztcbiAgICB9XG4gICAgLy8gSWYgd2Ugc3RhcnRlZCB3aXRoIHplcm9zLCBzdHJpcCB0aGVtXG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZShzdGFydCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gemVyb1BhZCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgdmFsdWUgPSBhcnJheWlmeSh2YWx1ZSk7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA+IGxlbmd0aCkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidmFsdWUgb3V0IG9mIHJhbmdlXCIsIFwidmFsdWVcIiwgYXJndW1lbnRzWzBdKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICByZXN1bHQuc2V0KHZhbHVlLCBsZW5ndGggLSB2YWx1ZS5sZW5ndGgpO1xuICAgIHJldHVybiBhZGRTbGljZShyZXN1bHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIgfHwgIXZhbHVlLm1hdGNoKC9eMHhbMC05QS1GYS1mXSokLykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoICYmIHZhbHVlLmxlbmd0aCAhPT0gMiArIDIgKiBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IEhleENoYXJhY3RlcnMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbmV4cG9ydCBmdW5jdGlvbiBoZXhsaWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGxvZ2dlci5jaGVja1NhZmVVaW50NTModmFsdWUsIFwiaW52YWxpZCBoZXhsaWZ5IHZhbHVlXCIpO1xuICAgICAgICBsZXQgaGV4ID0gXCJcIjtcbiAgICAgICAgd2hpbGUgKHZhbHVlKSB7XG4gICAgICAgICAgICBoZXggPSBIZXhDaGFyYWN0ZXJzW3ZhbHVlICYgMHhmXSArIGhleDtcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSAvIDE2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGV4Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhleC5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICAgICAgaGV4ID0gXCIwXCIgKyBoZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCIweFwiICsgaGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIjB4MDBcIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICUgMikge1xuICAgICAgICAgICAgcmV0dXJuIChcIjB4MFwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYWxsb3dNaXNzaW5nUHJlZml4ICYmIHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLnN1YnN0cmluZygwLCAyKSAhPT0gXCIweFwiKSB7XG4gICAgICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWU7XG4gICAgfVxuICAgIGlmIChpc0hleGFibGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0hleFN0cmluZygpO1xuICAgIH1cbiAgICBpZiAoaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oZXhQYWQgPT09IFwibGVmdFwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBcIjB4MFwiICsgdmFsdWUuc3Vic3RyaW5nKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5oZXhQYWQgPT09IFwicmlnaHRcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IFwiMFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImhleCBkYXRhIGlzIG9kZC1sZW5ndGhcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGlmIChpc0J5dGVzKHZhbHVlKSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdiA9IHZhbHVlW2ldO1xuICAgICAgICAgICAgcmVzdWx0ICs9IEhleENoYXJhY3RlcnNbKHYgJiAweGYwKSA+PiA0XSArIEhleENoYXJhY3RlcnNbdiAmIDB4MGZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXhsaWZ5IHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xufVxuLypcbmZ1bmN0aW9uIHVub2RkaWZ5KHZhbHVlOiBCeXRlc0xpa2UgfCBIZXhhYmxlIHwgbnVtYmVyKTogQnl0ZXNMaWtlIHwgSGV4YWJsZSB8IG51bWJlciB7XG4gICAgaWYgKHR5cGVvZih2YWx1ZSkgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUubGVuZ3RoICUgMiAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgMikgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhEYXRhTGVuZ3RoKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIChkYXRhKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkYXRhID0gaGV4bGlmeShkYXRhKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWlzSGV4U3RyaW5nKGRhdGEpIHx8IChkYXRhLmxlbmd0aCAlIDIpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGRhdGEubGVuZ3RoIC0gMikgLyAyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleERhdGFTbGljZShkYXRhLCBvZmZzZXQsIGVuZE9mZnNldCkge1xuICAgIGlmICh0eXBlb2YgKGRhdGEpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGRhdGEgPSBoZXhsaWZ5KGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXNIZXhTdHJpbmcoZGF0YSkgfHwgKGRhdGEubGVuZ3RoICUgMikpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGV4RGF0YVwiLCBcInZhbHVlXCIsIGRhdGEpO1xuICAgIH1cbiAgICBvZmZzZXQgPSAyICsgMiAqIG9mZnNldDtcbiAgICBpZiAoZW5kT2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwiMHhcIiArIGRhdGEuc3Vic3RyaW5nKG9mZnNldCwgMiArIDIgKiBlbmRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgZGF0YS5zdWJzdHJpbmcob2Zmc2V0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhDb25jYXQoaXRlbXMpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgcmVzdWx0ICs9IGhleGxpZnkoaXRlbSkuc3Vic3RyaW5nKDIpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gaGV4VmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCB0cmltbWVkID0gaGV4U3RyaXBaZXJvcyhoZXhsaWZ5KHZhbHVlLCB7IGhleFBhZDogXCJsZWZ0XCIgfSkpO1xuICAgIGlmICh0cmltbWVkID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIFwiMHgwXCI7XG4gICAgfVxuICAgIHJldHVybiB0cmltbWVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFN0cmlwWmVyb3ModmFsdWUpIHtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsdWUgPSBoZXhsaWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKCFpc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGV4IHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMik7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgd2hpbGUgKG9mZnNldCA8IHZhbHVlLmxlbmd0aCAmJiB2YWx1ZVtvZmZzZXRdID09PSBcIjBcIikge1xuICAgICAgICBvZmZzZXQrKztcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIHZhbHVlLnN1YnN0cmluZyhvZmZzZXQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFplcm9QYWQodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YWx1ZSA9IGhleGxpZnkodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleCBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5sZW5ndGggPiAyICogbGVuZ3RoICsgMikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidmFsdWUgb3V0IG9mIHJhbmdlXCIsIFwidmFsdWVcIiwgYXJndW1lbnRzWzFdKTtcbiAgICB9XG4gICAgd2hpbGUgKHZhbHVlLmxlbmd0aCA8IDIgKiBsZW5ndGggKyAyKSB7XG4gICAgICAgIHZhbHVlID0gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgcjogXCIweFwiLFxuICAgICAgICBzOiBcIjB4XCIsXG4gICAgICAgIF92czogXCIweFwiLFxuICAgICAgICByZWNvdmVyeVBhcmFtOiAwLFxuICAgICAgICB2OiAwLFxuICAgICAgICB5UGFyaXR5QW5kUzogXCIweFwiLFxuICAgICAgICBjb21wYWN0OiBcIjB4XCJcbiAgICB9O1xuICAgIGlmIChpc0J5dGVzTGlrZShzaWduYXR1cmUpKSB7XG4gICAgICAgIGxldCBieXRlcyA9IGFycmF5aWZ5KHNpZ25hdHVyZSk7XG4gICAgICAgIC8vIEdldCB0aGUgciwgcyBhbmQgdlxuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAgICAgLy8gRUlQLTIwOTg7IHB1bGwgdGhlIHYgZnJvbSB0aGUgdG9wIGJpdCBvZiBzIGFuZCBjbGVhciBpdFxuICAgICAgICAgICAgcmVzdWx0LnYgPSAyNyArIChieXRlc1szMl0gPj4gNyk7XG4gICAgICAgICAgICBieXRlc1szMl0gJj0gMHg3ZjtcbiAgICAgICAgICAgIHJlc3VsdC5yID0gaGV4bGlmeShieXRlcy5zbGljZSgwLCAzMikpO1xuICAgICAgICAgICAgcmVzdWx0LnMgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDMyLCA2NCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gNjUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5yID0gaGV4bGlmeShieXRlcy5zbGljZSgwLCAzMikpO1xuICAgICAgICAgICAgcmVzdWx0LnMgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDMyLCA2NCkpO1xuICAgICAgICAgICAgcmVzdWx0LnYgPSBieXRlc1s2NF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBzaWduYXR1cmUgc3RyaW5nXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWxsb3cgYSByZWNpZCB0byBiZSB1c2VkIGFzIHRoZSB2XG4gICAgICAgIGlmIChyZXN1bHQudiA8IDI3KSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnYgPT09IDAgfHwgcmVzdWx0LnYgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudiArPSAyNztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgaW52YWxpZCB2IGJ5dGVcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHJlY292ZXJ5UGFyYW0gZnJvbSB2XG4gICAgICAgIHJlc3VsdC5yZWNvdmVyeVBhcmFtID0gMSAtIChyZXN1bHQudiAlIDIpO1xuICAgICAgICAvLyBDb21wdXRlIF92cyBmcm9tIHJlY292ZXJ5UGFyYW0gYW5kIHNcbiAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyeVBhcmFtKSB7XG4gICAgICAgICAgICBieXRlc1szMl0gfD0gMHg4MDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuX3ZzID0gaGV4bGlmeShieXRlcy5zbGljZSgzMiwgNjQpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5yID0gc2lnbmF0dXJlLnI7XG4gICAgICAgIHJlc3VsdC5zID0gc2lnbmF0dXJlLnM7XG4gICAgICAgIHJlc3VsdC52ID0gc2lnbmF0dXJlLnY7XG4gICAgICAgIHJlc3VsdC5yZWNvdmVyeVBhcmFtID0gc2lnbmF0dXJlLnJlY292ZXJ5UGFyYW07XG4gICAgICAgIHJlc3VsdC5fdnMgPSBzaWduYXR1cmUuX3ZzO1xuICAgICAgICAvLyBJZiB0aGUgX3ZzIGlzIGF2YWlsYWJsZSwgdXNlIGl0IHRvIHBvcHVsYXRlIG1pc3NpbmcgcywgdiBhbmQgcmVjb3ZlcnlQYXJhbVxuICAgICAgICAvLyBhbmQgdmVyaWZ5IG5vbi1taXNzaW5nIHMsIHYgYW5kIHJlY292ZXJ5UGFyYW1cbiAgICAgICAgaWYgKHJlc3VsdC5fdnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdnMgPSB6ZXJvUGFkKGFycmF5aWZ5KHJlc3VsdC5fdnMpLCAzMik7XG4gICAgICAgICAgICByZXN1bHQuX3ZzID0gaGV4bGlmeSh2cyk7XG4gICAgICAgICAgICAvLyBTZXQgb3IgY2hlY2sgdGhlIHJlY2lkXG4gICAgICAgICAgICBjb25zdCByZWNvdmVyeVBhcmFtID0gKCh2c1swXSA+PSAxMjgpID8gMSA6IDApO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyeVBhcmFtID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVjb3ZlcnlQYXJhbSA9IHJlY292ZXJ5UGFyYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSAhPT0gcmVjb3ZlcnlQYXJhbSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgcmVjb3ZlcnlQYXJhbSBtaXNtYXRjaCBfdnNcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCBvciBjaGVjayB0aGUgc1xuICAgICAgICAgICAgdnNbMF0gJj0gMHg3ZjtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBoZXhsaWZ5KHZzKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnMgPSBzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnMgIT09IHMpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHYgbWlzbWF0Y2ggX3ZzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIHJlY2lkIGFuZCB2IHRvIHBvcHVsYXRlIGVhY2ggb3RoZXJcbiAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyeVBhcmFtID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBtaXNzaW5nIHYgYW5kIHJlY292ZXJ5UGFyYW1cIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC52ID09PSAwIHx8IHJlc3VsdC52ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlY292ZXJ5UGFyYW0gPSByZXN1bHQudjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5yZWNvdmVyeVBhcmFtID0gMSAtIChyZXN1bHQudiAlIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC52ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudiA9IDI3ICsgcmVzdWx0LnJlY292ZXJ5UGFyYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWNJZCA9IChyZXN1bHQudiA9PT0gMCB8fCByZXN1bHQudiA9PT0gMSkgPyByZXN1bHQudiA6ICgxIC0gKHJlc3VsdC52ICUgMikpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSAhPT0gcmVjSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSByZWNvdmVyeVBhcmFtIG1pc21hdGNoIHZcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5yID09IG51bGwgfHwgIWlzSGV4U3RyaW5nKHJlc3VsdC5yKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBtaXNzaW5nIG9yIGludmFsaWQgclwiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnIgPSBoZXhaZXJvUGFkKHJlc3VsdC5yLCAzMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5zID09IG51bGwgfHwgIWlzSGV4U3RyaW5nKHJlc3VsdC5zKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBtaXNzaW5nIG9yIGludmFsaWQgc1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnMgPSBoZXhaZXJvUGFkKHJlc3VsdC5zLCAzMik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdnMgPSBhcnJheWlmeShyZXN1bHQucyk7XG4gICAgICAgIGlmICh2c1swXSA+PSAxMjgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgcyBvdXQgb2YgcmFuZ2VcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LnJlY292ZXJ5UGFyYW0pIHtcbiAgICAgICAgICAgIHZzWzBdIHw9IDB4ODA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX3ZzID0gaGV4bGlmeSh2cyk7XG4gICAgICAgIGlmIChyZXN1bHQuX3ZzKSB7XG4gICAgICAgICAgICBpZiAoIWlzSGV4U3RyaW5nKHJlc3VsdC5fdnMpKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBpbnZhbGlkIF92c1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0Ll92cyA9IGhleFplcm9QYWQocmVzdWx0Ll92cywgMzIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBvciBjaGVjayB0aGUgX3ZzXG4gICAgICAgIGlmIChyZXN1bHQuX3ZzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5fdnMgPSBfdnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0Ll92cyAhPT0gX3ZzKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIF92cyBtaXNtYXRjaCB2IGFuZCBzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnlQYXJpdHlBbmRTID0gcmVzdWx0Ll92cztcbiAgICByZXN1bHQuY29tcGFjdCA9IHJlc3VsdC5yICsgcmVzdWx0LnlQYXJpdHlBbmRTLnN1YnN0cmluZygyKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGpvaW5TaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgc2lnbmF0dXJlID0gc3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICByZXR1cm4gaGV4bGlmeShjb25jYXQoW1xuICAgICAgICBzaWduYXR1cmUucixcbiAgICAgICAgc2lnbmF0dXJlLnMsXG4gICAgICAgIChzaWduYXR1cmUucmVjb3ZlcnlQYXJhbSA/IFwiMHgxY1wiIDogXCIweDFiXCIpXG4gICAgXSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIkxvZ2dlciIsInZlcnNpb24iLCJsb2dnZXIiLCJpc0hleGFibGUiLCJ2YWx1ZSIsInRvSGV4U3RyaW5nIiwiYWRkU2xpY2UiLCJhcnJheSIsInNsaWNlIiwiYXJncyIsIkFycmF5IiwicHJvdG90eXBlIiwiY2FsbCIsImFyZ3VtZW50cyIsIlVpbnQ4QXJyYXkiLCJhcHBseSIsImlzQnl0ZXNMaWtlIiwiaXNIZXhTdHJpbmciLCJsZW5ndGgiLCJpc0J5dGVzIiwiaXNJbnRlZ2VyIiwiY29uc3RydWN0b3IiLCJpIiwidiIsImFycmF5aWZ5Iiwib3B0aW9ucyIsImNoZWNrU2FmZVVpbnQ1MyIsInJlc3VsdCIsInVuc2hpZnQiLCJwYXJzZUludCIsIlN0cmluZyIsInB1c2giLCJhbGxvd01pc3NpbmdQcmVmaXgiLCJzdWJzdHJpbmciLCJoZXgiLCJoZXhQYWQiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJjb25jYXQiLCJpdGVtcyIsIm9iamVjdHMiLCJtYXAiLCJpdGVtIiwicmVkdWNlIiwiYWNjdW0iLCJvZmZzZXQiLCJvYmplY3QiLCJzZXQiLCJzdHJpcFplcm9zIiwic3RhcnQiLCJ6ZXJvUGFkIiwibWF0Y2giLCJIZXhDaGFyYWN0ZXJzIiwiaGV4bGlmeSIsIk1hdGgiLCJmbG9vciIsInRvU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJoZXhEYXRhTGVuZ3RoIiwiZGF0YSIsImhleERhdGFTbGljZSIsImVuZE9mZnNldCIsImhleENvbmNhdCIsImZvckVhY2giLCJoZXhWYWx1ZSIsInRyaW1tZWQiLCJoZXhTdHJpcFplcm9zIiwiaGV4WmVyb1BhZCIsInNwbGl0U2lnbmF0dXJlIiwic2lnbmF0dXJlIiwiciIsInMiLCJfdnMiLCJyZWNvdmVyeVBhcmFtIiwieVBhcml0eUFuZFMiLCJjb21wYWN0IiwiYnl0ZXMiLCJ2cyIsInJlY0lkIiwiam9pblNpZ25hdHVyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib.esm/addresses.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/constants/lib.esm/addresses.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressZero: () => (/* binding */ AddressZero)\n/* harmony export */ });\nconst AddressZero = \"0x0000000000000000000000000000000000000000\"; //# sourceMappingURL=addresses.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9jb25zdGFudHMvbGliLmVzbS9hZGRyZXNzZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLGNBQWMsNkNBQTZDLENBQ3hFLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NsaW1lLWJldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2NvbnN0YW50cy9saWIuZXNtL2FkZHJlc3Nlcy5qcz8xZTBmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBBZGRyZXNzWmVybyA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzZXMuanMubWFwIl0sIm5hbWVzIjpbIkFkZHJlc3NaZXJvIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib.esm/addresses.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib.esm/bignumbers.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/constants/lib.esm/bignumbers.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MaxInt256: () => (/* binding */ MaxInt256),\n/* harmony export */   MaxUint256: () => (/* binding */ MaxUint256),\n/* harmony export */   MinInt256: () => (/* binding */ MinInt256),\n/* harmony export */   NegativeOne: () => (/* binding */ NegativeOne),\n/* harmony export */   One: () => (/* binding */ One),\n/* harmony export */   Two: () => (/* binding */ Two),\n/* harmony export */   WeiPerEther: () => (/* binding */ WeiPerEther),\n/* harmony export */   Zero: () => (/* binding */ Zero)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n\nconst NegativeOne = /*#__PURE__*/ _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(-1);\nconst Zero = /*#__PURE__*/ _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(0);\nconst One = /*#__PURE__*/ _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(1);\nconst Two = /*#__PURE__*/ _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(2);\nconst WeiPerEther = /*#__PURE__*/ _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(\"1000000000000000000\");\nconst MaxUint256 = /*#__PURE__*/ _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nconst MinInt256 = /*#__PURE__*/ _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(\"-0x8000000000000000000000000000000000000000000000000000000000000000\");\nconst MaxInt256 = /*#__PURE__*/ _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n //# sourceMappingURL=bignumbers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9jb25zdGFudHMvbGliLmVzbS9iaWdudW1iZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFxRDtBQUNyRCxNQUFNQyxjQUFnQixXQUFXLEdBQUVELCtEQUFTQSxDQUFDRSxJQUFJLENBQUMsQ0FBQztBQUNuRCxNQUFNQyxPQUFTLFdBQVcsR0FBRUgsK0RBQVNBLENBQUNFLElBQUksQ0FBQztBQUMzQyxNQUFNRSxNQUFRLFdBQVcsR0FBRUosK0RBQVNBLENBQUNFLElBQUksQ0FBQztBQUMxQyxNQUFNRyxNQUFRLFdBQVcsR0FBRUwsK0RBQVNBLENBQUNFLElBQUksQ0FBQztBQUMxQyxNQUFNSSxjQUFnQixXQUFXLEdBQUVOLCtEQUFTQSxDQUFDRSxJQUFJLENBQUM7QUFDbEQsTUFBTUssYUFBZSxXQUFXLEdBQUVQLCtEQUFTQSxDQUFDRSxJQUFJLENBQUM7QUFDakQsTUFBTU0sWUFBYyxXQUFXLEdBQUVSLCtEQUFTQSxDQUFDRSxJQUFJLENBQUM7QUFDaEQsTUFBTU8sWUFBYyxXQUFXLEdBQUVULCtEQUFTQSxDQUFDRSxJQUFJLENBQUM7QUFDdUMsQ0FDdkYsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2xpbWUtYmV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvY29uc3RhbnRzL2xpYi5lc20vYmlnbnVtYmVycy5qcz9jYjExIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmNvbnN0IE5lZ2F0aXZlT25lID0gKCAvKiNfX1BVUkVfXyovQmlnTnVtYmVyLmZyb20oLTEpKTtcbmNvbnN0IFplcm8gPSAoIC8qI19fUFVSRV9fKi9CaWdOdW1iZXIuZnJvbSgwKSk7XG5jb25zdCBPbmUgPSAoIC8qI19fUFVSRV9fKi9CaWdOdW1iZXIuZnJvbSgxKSk7XG5jb25zdCBUd28gPSAoIC8qI19fUFVSRV9fKi9CaWdOdW1iZXIuZnJvbSgyKSk7XG5jb25zdCBXZWlQZXJFdGhlciA9ICggLyojX19QVVJFX18qL0JpZ051bWJlci5mcm9tKFwiMTAwMDAwMDAwMDAwMDAwMDAwMFwiKSk7XG5jb25zdCBNYXhVaW50MjU2ID0gKCAvKiNfX1BVUkVfXyovQmlnTnVtYmVyLmZyb20oXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIikpO1xuY29uc3QgTWluSW50MjU2ID0gKCAvKiNfX1BVUkVfXyovQmlnTnVtYmVyLmZyb20oXCItMHg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpKTtcbmNvbnN0IE1heEludDI1NiA9ICggLyojX19QVVJFX18qL0JpZ051bWJlci5mcm9tKFwiMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpKTtcbmV4cG9ydCB7IE5lZ2F0aXZlT25lLCBaZXJvLCBPbmUsIFR3bywgV2VpUGVyRXRoZXIsIE1heFVpbnQyNTYsIE1pbkludDI1NiwgTWF4SW50MjU2LCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmlnbnVtYmVycy5qcy5tYXAiXSwibmFtZXMiOlsiQmlnTnVtYmVyIiwiTmVnYXRpdmVPbmUiLCJmcm9tIiwiWmVybyIsIk9uZSIsIlR3byIsIldlaVBlckV0aGVyIiwiTWF4VWludDI1NiIsIk1pbkludDI1NiIsIk1heEludDI1NiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib.esm/bignumbers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib.esm/hashes.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/constants/lib.esm/hashes.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HashZero: () => (/* binding */ HashZero)\n/* harmony export */ });\nconst HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\"; //# sourceMappingURL=hashes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9jb25zdGFudHMvbGliLmVzbS9oYXNoZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLFdBQVcscUVBQXFFLENBQzdGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NsaW1lLWJldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2NvbnN0YW50cy9saWIuZXNtL2hhc2hlcy5qcz9mYmVhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBIYXNoWmVybyA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoZXMuanMubWFwIl0sIm5hbWVzIjpbIkhhc2haZXJvIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib.esm/hashes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/contracts/lib.esm/_version.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/contracts/lib.esm/_version.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"contracts/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9jb250cmFjdHMvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsVUFBVSxrQkFBa0IsQ0FDekMsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2xpbWUtYmV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvY29udHJhY3RzL2xpYi5lc20vX3ZlcnNpb24uanM/ZTE2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiY29udHJhY3RzLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/contracts/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/contracts/lib.esm/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/contracts/lib.esm/index.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseContract: () => (/* binding */ BaseContract),\n/* harmony export */   Contract: () => (/* binding */ Contract),\n/* harmony export */   ContractFactory: () => (/* binding */ ContractFactory)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_abi__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/abi */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\");\n/* harmony import */ var _ethersproject_abi__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/abi */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/interface.js\");\n/* harmony import */ var _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-provider/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/abstract-signer */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-signer/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/transactions */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/transactions/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/contracts/lib.esm/_version.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n;\n;\n///////////////////////////////\nconst allowedTransactionKeys = {\n    chainId: true,\n    data: true,\n    from: true,\n    gasLimit: true,\n    gasPrice: true,\n    nonce: true,\n    to: true,\n    value: true,\n    type: true,\n    accessList: true,\n    maxFeePerGas: true,\n    maxPriorityFeePerGas: true,\n    customData: true,\n    ccipReadEnabled: true\n};\nfunction resolveName(resolver, nameOrPromise) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const name = yield nameOrPromise;\n        if (typeof name !== \"string\") {\n            logger.throwArgumentError(\"invalid address or ENS name\", \"name\", name);\n        }\n        // If it is already an address, just use it (after adding checksum)\n        try {\n            return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(name);\n        } catch (error) {}\n        if (!resolver) {\n            logger.throwError(\"a provider or signer is needed to resolve ENS names\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"resolveName\"\n            });\n        }\n        const address = yield resolver.resolveName(name);\n        if (address == null) {\n            logger.throwArgumentError(\"resolver or addr is not configured for ENS name\", \"name\", name);\n        }\n        return address;\n    });\n}\n// Recursively replaces ENS names with promises to resolve the name and resolves all properties\nfunction resolveAddresses(resolver, value, paramType) {\n    return __awaiter(this, void 0, void 0, function*() {\n        if (Array.isArray(paramType)) {\n            return yield Promise.all(paramType.map((paramType, index)=>{\n                return resolveAddresses(resolver, Array.isArray(value) ? value[index] : value[paramType.name], paramType);\n            }));\n        }\n        if (paramType.type === \"address\") {\n            return yield resolveName(resolver, value);\n        }\n        if (paramType.type === \"tuple\") {\n            return yield resolveAddresses(resolver, value, paramType.components);\n        }\n        if (paramType.baseType === \"array\") {\n            if (!Array.isArray(value)) {\n                return Promise.reject(logger.makeError(\"invalid value for array\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"value\",\n                    value\n                }));\n            }\n            return yield Promise.all(value.map((v)=>resolveAddresses(resolver, v, paramType.arrayChildren)));\n        }\n        return value;\n    });\n}\nfunction populateTransaction(contract, fragment, args) {\n    return __awaiter(this, void 0, void 0, function*() {\n        // If an extra argument is given, it is overrides\n        let overrides = {};\n        if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === \"object\") {\n            overrides = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(args.pop());\n        }\n        // Make sure the parameter count matches\n        logger.checkArgumentCount(args.length, fragment.inputs.length, \"passed to contract\");\n        // Populate \"from\" override (allow promises)\n        if (contract.signer) {\n            if (overrides.from) {\n                // Contracts with a Signer are from the Signer's frame-of-reference;\n                // but we allow overriding \"from\" if it matches the signer\n                overrides.from = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)({\n                    override: resolveName(contract.signer, overrides.from),\n                    signer: contract.signer.getAddress()\n                }).then((check)=>__awaiter(this, void 0, void 0, function*() {\n                        if ((0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(check.signer) !== check.override) {\n                            logger.throwError(\"Contract with a Signer cannot override from\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                                operation: \"overrides.from\"\n                            });\n                        }\n                        return check.override;\n                    }));\n            } else {\n                overrides.from = contract.signer.getAddress();\n            }\n        } else if (overrides.from) {\n            overrides.from = resolveName(contract.provider, overrides.from);\n        //} else {\n        // Contracts without a signer can override \"from\", and if\n        // unspecified the zero address is used\n        //overrides.from = AddressZero;\n        }\n        // Wait for all dependencies to be resolved (prefer the signer over the provider)\n        const resolved = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)({\n            args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),\n            address: contract.resolvedAddress,\n            overrides: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)(overrides) || {}\n        });\n        // The ABI coded transaction\n        const data = contract.interface.encodeFunctionData(fragment, resolved.args);\n        const tx = {\n            data: data,\n            to: resolved.address\n        };\n        // Resolved Overrides\n        const ro = resolved.overrides;\n        // Populate simple overrides\n        if (ro.nonce != null) {\n            tx.nonce = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.nonce).toNumber();\n        }\n        if (ro.gasLimit != null) {\n            tx.gasLimit = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.gasLimit);\n        }\n        if (ro.gasPrice != null) {\n            tx.gasPrice = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.gasPrice);\n        }\n        if (ro.maxFeePerGas != null) {\n            tx.maxFeePerGas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.maxFeePerGas);\n        }\n        if (ro.maxPriorityFeePerGas != null) {\n            tx.maxPriorityFeePerGas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.maxPriorityFeePerGas);\n        }\n        if (ro.from != null) {\n            tx.from = ro.from;\n        }\n        if (ro.type != null) {\n            tx.type = ro.type;\n        }\n        if (ro.accessList != null) {\n            tx.accessList = (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_5__.accessListify)(ro.accessList);\n        }\n        // If there was no \"gasLimit\" override, but the ABI specifies a default, use it\n        if (tx.gasLimit == null && fragment.gas != null) {\n            // Compute the intrinsic gas cost for this transaction\n            // @TODO: This is based on the yellow paper as of Petersburg; this is something\n            // we may wish to parameterize in v6 as part of the Network object. Since this\n            // is always a non-nil to address, we can ignore G_create, but may wish to add\n            // similar logic to the ContractFactory.\n            let intrinsic = 21000;\n            const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(data);\n            for(let i = 0; i < bytes.length; i++){\n                intrinsic += 4;\n                if (bytes[i]) {\n                    intrinsic += 64;\n                }\n            }\n            tx.gasLimit = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(fragment.gas).add(intrinsic);\n        }\n        // Populate \"value\" override\n        if (ro.value) {\n            const roValue = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.value);\n            if (!roValue.isZero() && !fragment.payable) {\n                logger.throwError(\"non-payable method cannot override value\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"overrides.value\",\n                    value: overrides.value\n                });\n            }\n            tx.value = roValue;\n        }\n        if (ro.customData) {\n            tx.customData = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(ro.customData);\n        }\n        if (ro.ccipReadEnabled) {\n            tx.ccipReadEnabled = !!ro.ccipReadEnabled;\n        }\n        // Remove the overrides\n        delete overrides.nonce;\n        delete overrides.gasLimit;\n        delete overrides.gasPrice;\n        delete overrides.from;\n        delete overrides.value;\n        delete overrides.type;\n        delete overrides.accessList;\n        delete overrides.maxFeePerGas;\n        delete overrides.maxPriorityFeePerGas;\n        delete overrides.customData;\n        delete overrides.ccipReadEnabled;\n        // Make sure there are no stray overrides, which may indicate a\n        // typo or using an unsupported key.\n        const leftovers = Object.keys(overrides).filter((key)=>overrides[key] != null);\n        if (leftovers.length) {\n            logger.throwError(`cannot override ${leftovers.map((l)=>JSON.stringify(l)).join(\",\")}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"overrides\",\n                overrides: leftovers\n            });\n        }\n        return tx;\n    });\n}\nfunction buildPopulate(contract, fragment) {\n    return function(...args) {\n        return populateTransaction(contract, fragment, args);\n    };\n}\nfunction buildEstimate(contract, fragment) {\n    const signerOrProvider = contract.signer || contract.provider;\n    return function(...args) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!signerOrProvider) {\n                logger.throwError(\"estimate require a provider or signer\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"estimateGas\"\n                });\n            }\n            const tx = yield populateTransaction(contract, fragment, args);\n            return yield signerOrProvider.estimateGas(tx);\n        });\n    };\n}\nfunction addContractWait(contract, tx) {\n    const wait = tx.wait.bind(tx);\n    tx.wait = (confirmations)=>{\n        return wait(confirmations).then((receipt)=>{\n            receipt.events = receipt.logs.map((log)=>{\n                let event = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.deepCopy)(log);\n                let parsed = null;\n                try {\n                    parsed = contract.interface.parseLog(log);\n                } catch (e) {}\n                // Successfully parsed the event log; include it\n                if (parsed) {\n                    event.args = parsed.args;\n                    event.decode = (data, topics)=>{\n                        return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);\n                    };\n                    event.event = parsed.name;\n                    event.eventSignature = parsed.signature;\n                }\n                // Useful operations\n                event.removeListener = ()=>{\n                    return contract.provider;\n                };\n                event.getBlock = ()=>{\n                    return contract.provider.getBlock(receipt.blockHash);\n                };\n                event.getTransaction = ()=>{\n                    return contract.provider.getTransaction(receipt.transactionHash);\n                };\n                event.getTransactionReceipt = ()=>{\n                    return Promise.resolve(receipt);\n                };\n                return event;\n            });\n            return receipt;\n        });\n    };\n}\nfunction buildCall(contract, fragment, collapseSimple) {\n    const signerOrProvider = contract.signer || contract.provider;\n    return function(...args) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // Extract the \"blockTag\" override if present\n            let blockTag = undefined;\n            if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === \"object\") {\n                const overrides = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(args.pop());\n                if (overrides.blockTag != null) {\n                    blockTag = yield overrides.blockTag;\n                }\n                delete overrides.blockTag;\n                args.push(overrides);\n            }\n            // If the contract was just deployed, wait until it is mined\n            if (contract.deployTransaction != null) {\n                yield contract._deployed(blockTag);\n            }\n            // Call a node and get the result\n            const tx = yield populateTransaction(contract, fragment, args);\n            const result = yield signerOrProvider.call(tx, blockTag);\n            try {\n                let value = contract.interface.decodeFunctionResult(fragment, result);\n                if (collapseSimple && fragment.outputs.length === 1) {\n                    value = value[0];\n                }\n                return value;\n            } catch (error) {\n                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.CALL_EXCEPTION) {\n                    error.address = contract.address;\n                    error.args = args;\n                    error.transaction = tx;\n                }\n                throw error;\n            }\n        });\n    };\n}\nfunction buildSend(contract, fragment) {\n    return function(...args) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!contract.signer) {\n                logger.throwError(\"sending a transaction requires a signer\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"sendTransaction\"\n                });\n            }\n            // If the contract was just deployed, wait until it is mined\n            if (contract.deployTransaction != null) {\n                yield contract._deployed();\n            }\n            const txRequest = yield populateTransaction(contract, fragment, args);\n            const tx = yield contract.signer.sendTransaction(txRequest);\n            // Tweak the tx.wait so the receipt has extra properties\n            addContractWait(contract, tx);\n            return tx;\n        });\n    };\n}\nfunction buildDefault(contract, fragment, collapseSimple) {\n    if (fragment.constant) {\n        return buildCall(contract, fragment, collapseSimple);\n    }\n    return buildSend(contract, fragment);\n}\nfunction getEventTag(filter) {\n    if (filter.address && (filter.topics == null || filter.topics.length === 0)) {\n        return \"*\";\n    }\n    return (filter.address || \"*\") + \"@\" + (filter.topics ? filter.topics.map((topic)=>{\n        if (Array.isArray(topic)) {\n            return topic.join(\"|\");\n        }\n        return topic;\n    }).join(\":\") : \"\");\n}\nclass RunningEvent {\n    constructor(tag, filter){\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"tag\", tag);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"filter\", filter);\n        this._listeners = [];\n    }\n    addListener(listener, once) {\n        this._listeners.push({\n            listener: listener,\n            once: once\n        });\n    }\n    removeListener(listener) {\n        let done = false;\n        this._listeners = this._listeners.filter((item)=>{\n            if (done || item.listener !== listener) {\n                return true;\n            }\n            done = true;\n            return false;\n        });\n    }\n    removeAllListeners() {\n        this._listeners = [];\n    }\n    listeners() {\n        return this._listeners.map((i)=>i.listener);\n    }\n    listenerCount() {\n        return this._listeners.length;\n    }\n    run(args) {\n        const listenerCount = this.listenerCount();\n        this._listeners = this._listeners.filter((item)=>{\n            const argsCopy = args.slice();\n            // Call the callback in the next event loop\n            setTimeout(()=>{\n                item.listener.apply(this, argsCopy);\n            }, 0);\n            // Reschedule it if it not \"once\"\n            return !item.once;\n        });\n        return listenerCount;\n    }\n    prepareEvent(event) {}\n    // Returns the array that will be applied to an emit\n    getEmit(event) {\n        return [\n            event\n        ];\n    }\n}\nclass ErrorRunningEvent extends RunningEvent {\n    constructor(){\n        super(\"error\", null);\n    }\n}\n// @TODO Fragment should inherit Wildcard? and just override getEmit?\n//       or have a common abstract super class, with enough constructor\n//       options to configure both.\n// A Fragment Event will populate all the properties that Wildcard\n// will, and additionally dereference the arguments when emitting\nclass FragmentRunningEvent extends RunningEvent {\n    constructor(address, contractInterface, fragment, topics){\n        const filter = {\n            address: address\n        };\n        let topic = contractInterface.getEventTopic(fragment);\n        if (topics) {\n            if (topic !== topics[0]) {\n                logger.throwArgumentError(\"topic mismatch\", \"topics\", topics);\n            }\n            filter.topics = topics.slice();\n        } else {\n            filter.topics = [\n                topic\n            ];\n        }\n        super(getEventTag(filter), filter);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"address\", address);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"interface\", contractInterface);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"fragment\", fragment);\n    }\n    prepareEvent(event) {\n        super.prepareEvent(event);\n        event.event = this.fragment.name;\n        event.eventSignature = this.fragment.format();\n        event.decode = (data, topics)=>{\n            return this.interface.decodeEventLog(this.fragment, data, topics);\n        };\n        try {\n            event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);\n        } catch (error) {\n            event.args = null;\n            event.decodeError = error;\n        }\n    }\n    getEmit(event) {\n        const errors = (0,_ethersproject_abi__WEBPACK_IMPORTED_MODULE_7__.checkResultErrors)(event.args);\n        if (errors.length) {\n            throw errors[0].error;\n        }\n        const args = (event.args || []).slice();\n        args.push(event);\n        return args;\n    }\n}\n// A Wildcard Event will attempt to populate:\n//  - event            The name of the event name\n//  - eventSignature   The full signature of the event\n//  - decode           A function to decode data and topics\n//  - args             The decoded data and topics\nclass WildcardRunningEvent extends RunningEvent {\n    constructor(address, contractInterface){\n        super(\"*\", {\n            address: address\n        });\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"address\", address);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"interface\", contractInterface);\n    }\n    prepareEvent(event) {\n        super.prepareEvent(event);\n        try {\n            const parsed = this.interface.parseLog(event);\n            event.event = parsed.name;\n            event.eventSignature = parsed.signature;\n            event.decode = (data, topics)=>{\n                return this.interface.decodeEventLog(parsed.eventFragment, data, topics);\n            };\n            event.args = parsed.args;\n        } catch (error) {\n        // No matching event\n        }\n    }\n}\nclass BaseContract {\n    constructor(addressOrName, contractInterface, signerOrProvider){\n        // @TODO: Maybe still check the addressOrName looks like a valid address or name?\n        //address = getAddress(address);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"interface\", (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, \"getInterface\")(contractInterface));\n        if (signerOrProvider == null) {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"provider\", null);\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"signer\", null);\n        } else if (_ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_8__.Signer.isSigner(signerOrProvider)) {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"provider\", signerOrProvider.provider || null);\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"signer\", signerOrProvider);\n        } else if (_ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_9__.Provider.isProvider(signerOrProvider)) {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"provider\", signerOrProvider);\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"signer\", null);\n        } else {\n            logger.throwArgumentError(\"invalid signer or provider\", \"signerOrProvider\", signerOrProvider);\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"callStatic\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"estimateGas\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"functions\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"populateTransaction\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"filters\", {});\n        {\n            const uniqueFilters = {};\n            Object.keys(this.interface.events).forEach((eventSignature)=>{\n                const event = this.interface.events[eventSignature];\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.filters, eventSignature, (...args)=>{\n                    return {\n                        address: this.address,\n                        topics: this.interface.encodeFilterTopics(event, args)\n                    };\n                });\n                if (!uniqueFilters[event.name]) {\n                    uniqueFilters[event.name] = [];\n                }\n                uniqueFilters[event.name].push(eventSignature);\n            });\n            Object.keys(uniqueFilters).forEach((name)=>{\n                const filters = uniqueFilters[name];\n                if (filters.length === 1) {\n                    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.filters, name, this.filters[filters[0]]);\n                } else {\n                    logger.warn(`Duplicate definition of ${name} (${filters.join(\", \")})`);\n                }\n            });\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_runningEvents\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_wrappedEmits\", {});\n        if (addressOrName == null) {\n            logger.throwArgumentError(\"invalid contract address or ENS name\", \"addressOrName\", addressOrName);\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"address\", addressOrName);\n        if (this.provider) {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"resolvedAddress\", resolveName(this.provider, addressOrName));\n        } else {\n            try {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"resolvedAddress\", Promise.resolve((0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(addressOrName)));\n            } catch (error) {\n                // Without a provider, we cannot use ENS names\n                logger.throwError(\"provider is required to use ENS name as contract address\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"new Contract\"\n                });\n            }\n        }\n        // Swallow bad ENS names to prevent Unhandled Exceptions\n        this.resolvedAddress.catch((e)=>{});\n        const uniqueNames = {};\n        const uniqueSignatures = {};\n        Object.keys(this.interface.functions).forEach((signature)=>{\n            const fragment = this.interface.functions[signature];\n            // Check that the signature is unique; if not the ABI generation has\n            // not been cleaned or may be incorrectly generated\n            if (uniqueSignatures[signature]) {\n                logger.warn(`Duplicate ABI entry for ${JSON.stringify(signature)}`);\n                return;\n            }\n            uniqueSignatures[signature] = true;\n            // Track unique names; we only expose bare named functions if they\n            // are ambiguous\n            {\n                const name = fragment.name;\n                if (!uniqueNames[`%${name}`]) {\n                    uniqueNames[`%${name}`] = [];\n                }\n                uniqueNames[`%${name}`].push(signature);\n            }\n            if (this[signature] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, signature, buildDefault(this, fragment, true));\n            }\n            // We do not collapse simple calls on this bucket, which allows\n            // frameworks to safely use this without introspection as well as\n            // allows decoding error recovery.\n            if (this.functions[signature] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.functions, signature, buildDefault(this, fragment, false));\n            }\n            if (this.callStatic[signature] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.callStatic, signature, buildCall(this, fragment, true));\n            }\n            if (this.populateTransaction[signature] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.populateTransaction, signature, buildPopulate(this, fragment));\n            }\n            if (this.estimateGas[signature] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.estimateGas, signature, buildEstimate(this, fragment));\n            }\n        });\n        Object.keys(uniqueNames).forEach((name)=>{\n            // Ambiguous names to not get attached as bare names\n            const signatures = uniqueNames[name];\n            if (signatures.length > 1) {\n                return;\n            }\n            // Strip off the leading \"%\" used for prototype protection\n            name = name.substring(1);\n            const signature = signatures[0];\n            // If overwriting a member property that is null, swallow the error\n            try {\n                if (this[name] == null) {\n                    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, name, this[signature]);\n                }\n            } catch (e) {}\n            if (this.functions[name] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.functions, name, this.functions[signature]);\n            }\n            if (this.callStatic[name] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.callStatic, name, this.callStatic[signature]);\n            }\n            if (this.populateTransaction[name] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.populateTransaction, name, this.populateTransaction[signature]);\n            }\n            if (this.estimateGas[name] == null) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.estimateGas, name, this.estimateGas[signature]);\n            }\n        });\n    }\n    static getContractAddress(transaction) {\n        return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getContractAddress)(transaction);\n    }\n    static getInterface(contractInterface) {\n        if (_ethersproject_abi__WEBPACK_IMPORTED_MODULE_10__.Interface.isInterface(contractInterface)) {\n            return contractInterface;\n        }\n        return new _ethersproject_abi__WEBPACK_IMPORTED_MODULE_10__.Interface(contractInterface);\n    }\n    // @TODO: Allow timeout?\n    deployed() {\n        return this._deployed();\n    }\n    _deployed(blockTag) {\n        if (!this._deployedPromise) {\n            // If we were just deployed, we know the transaction we should occur in\n            if (this.deployTransaction) {\n                this._deployedPromise = this.deployTransaction.wait().then(()=>{\n                    return this;\n                });\n            } else {\n                // @TODO: Once we allow a timeout to be passed in, we will wait\n                // up to that many blocks for getCode\n                // Otherwise, poll for our code to be deployed\n                this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code)=>{\n                    if (code === \"0x\") {\n                        logger.throwError(\"contract not deployed\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                            contractAddress: this.address,\n                            operation: \"getDeployed\"\n                        });\n                    }\n                    return this;\n                });\n            }\n        }\n        return this._deployedPromise;\n    }\n    // @TODO:\n    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>\n    // @TODO:\n    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>\n    fallback(overrides) {\n        if (!this.signer) {\n            logger.throwError(\"sending a transactions require a signer\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"sendTransaction(fallback)\"\n            });\n        }\n        const tx = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(overrides || {});\n        [\n            \"from\",\n            \"to\"\n        ].forEach(function(key) {\n            if (tx[key] == null) {\n                return;\n            }\n            logger.throwError(\"cannot override \" + key, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: key\n            });\n        });\n        tx.to = this.resolvedAddress;\n        return this.deployed().then(()=>{\n            return this.signer.sendTransaction(tx);\n        });\n    }\n    // Reconnect to a different signer or provider\n    connect(signerOrProvider) {\n        if (typeof signerOrProvider === \"string\") {\n            signerOrProvider = new _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_8__.VoidSigner(signerOrProvider, this.provider);\n        }\n        const contract = new this.constructor(this.address, this.interface, signerOrProvider);\n        if (this.deployTransaction) {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(contract, \"deployTransaction\", this.deployTransaction);\n        }\n        return contract;\n    }\n    // Re-attach to a different on-chain instance of this contract\n    attach(addressOrName) {\n        return new this.constructor(addressOrName, this.interface, this.signer || this.provider);\n    }\n    static isIndexed(value) {\n        return _ethersproject_abi__WEBPACK_IMPORTED_MODULE_10__.Indexed.isIndexed(value);\n    }\n    _normalizeRunningEvent(runningEvent) {\n        // Already have an instance of this event running; we can re-use it\n        if (this._runningEvents[runningEvent.tag]) {\n            return this._runningEvents[runningEvent.tag];\n        }\n        return runningEvent;\n    }\n    _getRunningEvent(eventName) {\n        if (typeof eventName === \"string\") {\n            // Listen for \"error\" events (if your contract has an error event, include\n            // the full signature to bypass this special event keyword)\n            if (eventName === \"error\") {\n                return this._normalizeRunningEvent(new ErrorRunningEvent());\n            }\n            // Listen for any event that is registered\n            if (eventName === \"event\") {\n                return this._normalizeRunningEvent(new RunningEvent(\"event\", null));\n            }\n            // Listen for any event\n            if (eventName === \"*\") {\n                return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n            }\n            // Get the event Fragment (throws if ambiguous/unknown event)\n            const fragment = this.interface.getEvent(eventName);\n            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));\n        }\n        // We have topics to filter by...\n        if (eventName.topics && eventName.topics.length > 0) {\n            // Is it a known topichash? (throws if no matching topichash)\n            try {\n                const topic = eventName.topics[0];\n                if (typeof topic !== \"string\") {\n                    throw new Error(\"invalid topic\"); // @TODO: May happen for anonymous events\n                }\n                const fragment = this.interface.getEvent(topic);\n                return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));\n            } catch (error) {}\n            // Filter by the unknown topichash\n            const filter = {\n                address: this.address,\n                topics: eventName.topics\n            };\n            return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));\n        }\n        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n    }\n    _checkRunningEvents(runningEvent) {\n        if (runningEvent.listenerCount() === 0) {\n            delete this._runningEvents[runningEvent.tag];\n            // If we have a poller for this, remove it\n            const emit = this._wrappedEmits[runningEvent.tag];\n            if (emit && runningEvent.filter) {\n                this.provider.off(runningEvent.filter, emit);\n                delete this._wrappedEmits[runningEvent.tag];\n            }\n        }\n    }\n    // Subclasses can override this to gracefully recover\n    // from parse errors if they wish\n    _wrapEvent(runningEvent, log, listener) {\n        const event = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.deepCopy)(log);\n        event.removeListener = ()=>{\n            if (!listener) {\n                return;\n            }\n            runningEvent.removeListener(listener);\n            this._checkRunningEvents(runningEvent);\n        };\n        event.getBlock = ()=>{\n            return this.provider.getBlock(log.blockHash);\n        };\n        event.getTransaction = ()=>{\n            return this.provider.getTransaction(log.transactionHash);\n        };\n        event.getTransactionReceipt = ()=>{\n            return this.provider.getTransactionReceipt(log.transactionHash);\n        };\n        // This may throw if the topics and data mismatch the signature\n        runningEvent.prepareEvent(event);\n        return event;\n    }\n    _addEventListener(runningEvent, listener, once) {\n        if (!this.provider) {\n            logger.throwError(\"events require a provider or a signer with a provider\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"once\"\n            });\n        }\n        runningEvent.addListener(listener, once);\n        // Track this running event and its listeners (may already be there; but no hard in updating)\n        this._runningEvents[runningEvent.tag] = runningEvent;\n        // If we are not polling the provider, start polling\n        if (!this._wrappedEmits[runningEvent.tag]) {\n            const wrappedEmit = (log)=>{\n                let event = this._wrapEvent(runningEvent, log, listener);\n                // Try to emit the result for the parameterized event...\n                if (event.decodeError == null) {\n                    try {\n                        const args = runningEvent.getEmit(event);\n                        this.emit(runningEvent.filter, ...args);\n                    } catch (error) {\n                        event.decodeError = error.error;\n                    }\n                }\n                // Always emit \"event\" for fragment-base events\n                if (runningEvent.filter != null) {\n                    this.emit(\"event\", event);\n                }\n                // Emit \"error\" if there was an error\n                if (event.decodeError != null) {\n                    this.emit(\"error\", event.decodeError, event);\n                }\n            };\n            this._wrappedEmits[runningEvent.tag] = wrappedEmit;\n            // Special events, like \"error\" do not have a filter\n            if (runningEvent.filter != null) {\n                this.provider.on(runningEvent.filter, wrappedEmit);\n            }\n        }\n    }\n    queryFilter(event, fromBlockOrBlockhash, toBlock) {\n        const runningEvent = this._getRunningEvent(event);\n        const filter = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(runningEvent.filter);\n        if (typeof fromBlockOrBlockhash === \"string\" && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.isHexString)(fromBlockOrBlockhash, 32)) {\n            if (toBlock != null) {\n                logger.throwArgumentError(\"cannot specify toBlock with blockhash\", \"toBlock\", toBlock);\n            }\n            filter.blockHash = fromBlockOrBlockhash;\n        } else {\n            filter.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;\n            filter.toBlock = toBlock != null ? toBlock : \"latest\";\n        }\n        return this.provider.getLogs(filter).then((logs)=>{\n            return logs.map((log)=>this._wrapEvent(runningEvent, log, null));\n        });\n    }\n    on(event, listener) {\n        this._addEventListener(this._getRunningEvent(event), listener, false);\n        return this;\n    }\n    once(event, listener) {\n        this._addEventListener(this._getRunningEvent(event), listener, true);\n        return this;\n    }\n    emit(eventName, ...args) {\n        if (!this.provider) {\n            return false;\n        }\n        const runningEvent = this._getRunningEvent(eventName);\n        const result = runningEvent.run(args) > 0;\n        // May have drained all the \"once\" events; check for living events\n        this._checkRunningEvents(runningEvent);\n        return result;\n    }\n    listenerCount(eventName) {\n        if (!this.provider) {\n            return 0;\n        }\n        if (eventName == null) {\n            return Object.keys(this._runningEvents).reduce((accum, key)=>{\n                return accum + this._runningEvents[key].listenerCount();\n            }, 0);\n        }\n        return this._getRunningEvent(eventName).listenerCount();\n    }\n    listeners(eventName) {\n        if (!this.provider) {\n            return [];\n        }\n        if (eventName == null) {\n            const result = [];\n            for(let tag in this._runningEvents){\n                this._runningEvents[tag].listeners().forEach((listener)=>{\n                    result.push(listener);\n                });\n            }\n            return result;\n        }\n        return this._getRunningEvent(eventName).listeners();\n    }\n    removeAllListeners(eventName) {\n        if (!this.provider) {\n            return this;\n        }\n        if (eventName == null) {\n            for(const tag in this._runningEvents){\n                const runningEvent = this._runningEvents[tag];\n                runningEvent.removeAllListeners();\n                this._checkRunningEvents(runningEvent);\n            }\n            return this;\n        }\n        // Delete any listeners\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeAllListeners();\n        this._checkRunningEvents(runningEvent);\n        return this;\n    }\n    off(eventName, listener) {\n        if (!this.provider) {\n            return this;\n        }\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeListener(listener);\n        this._checkRunningEvents(runningEvent);\n        return this;\n    }\n    removeListener(eventName, listener) {\n        return this.off(eventName, listener);\n    }\n}\nclass Contract extends BaseContract {\n}\nclass ContractFactory {\n    constructor(contractInterface, bytecode, signer){\n        let bytecodeHex = null;\n        if (typeof bytecode === \"string\") {\n            bytecodeHex = bytecode;\n        } else if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.isBytes)(bytecode)) {\n            bytecodeHex = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(bytecode);\n        } else if (bytecode && typeof bytecode.object === \"string\") {\n            // Allow the bytecode object from the Solidity compiler\n            bytecodeHex = bytecode.object;\n        } else {\n            // Crash in the next verification step\n            bytecodeHex = \"!\";\n        }\n        // Make sure it is 0x prefixed\n        if (bytecodeHex.substring(0, 2) !== \"0x\") {\n            bytecodeHex = \"0x\" + bytecodeHex;\n        }\n        // Make sure the final result is valid bytecode\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.isHexString)(bytecodeHex) || bytecodeHex.length % 2) {\n            logger.throwArgumentError(\"invalid bytecode\", \"bytecode\", bytecode);\n        }\n        // If we have a signer, make sure it is valid\n        if (signer && !_ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_8__.Signer.isSigner(signer)) {\n            logger.throwArgumentError(\"invalid signer\", \"signer\", signer);\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"bytecode\", bytecodeHex);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"interface\", (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, \"getInterface\")(contractInterface));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"signer\", signer || null);\n    }\n    // @TODO: Future; rename to populateTransaction?\n    getDeployTransaction(...args) {\n        let tx = {};\n        // If we have 1 additional argument, we allow transaction overrides\n        if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === \"object\") {\n            tx = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(args.pop());\n            for(const key in tx){\n                if (!allowedTransactionKeys[key]) {\n                    throw new Error(\"unknown transaction override \" + key);\n                }\n            }\n        }\n        // Do not allow these to be overridden in a deployment transaction\n        [\n            \"data\",\n            \"from\",\n            \"to\"\n        ].forEach((key)=>{\n            if (tx[key] == null) {\n                return;\n            }\n            logger.throwError(\"cannot override \" + key, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: key\n            });\n        });\n        if (tx.value) {\n            const value = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(tx.value);\n            if (!value.isZero() && !this.interface.deploy.payable) {\n                logger.throwError(\"non-payable constructor cannot override value\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"overrides.value\",\n                    value: tx.value\n                });\n            }\n        }\n        // Make sure the call matches the constructor signature\n        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n        // Set the data to the bytecode + the encoded constructor arguments\n        tx.data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.concat)([\n            this.bytecode,\n            this.interface.encodeDeploy(args)\n        ]));\n        return tx;\n    }\n    deploy(...args) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let overrides = {};\n            // If 1 extra parameter was passed in, it contains overrides\n            if (args.length === this.interface.deploy.inputs.length + 1) {\n                overrides = args.pop();\n            }\n            // Make sure the call matches the constructor signature\n            logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n            // Resolve ENS names and promises in the arguments\n            const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);\n            params.push(overrides);\n            // Get the deployment transaction (with optional overrides)\n            const unsignedTx = this.getDeployTransaction(...params);\n            // Send the deployment transaction\n            const tx = yield this.signer.sendTransaction(unsignedTx);\n            const address = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(this.constructor, \"getContractAddress\")(tx);\n            const contract = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(this.constructor, \"getContract\")(address, this.interface, this.signer);\n            // Add the modified wait that wraps events\n            addContractWait(contract, tx);\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(contract, \"deployTransaction\", tx);\n            return contract;\n        });\n    }\n    attach(address) {\n        return this.constructor.getContract(address, this.interface, this.signer);\n    }\n    connect(signer) {\n        return new this.constructor(this.interface, this.bytecode, signer);\n    }\n    static fromSolidity(compilerOutput, signer) {\n        if (compilerOutput == null) {\n            logger.throwError(\"missing compiler output\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.MISSING_ARGUMENT, {\n                argument: \"compilerOutput\"\n            });\n        }\n        if (typeof compilerOutput === \"string\") {\n            compilerOutput = JSON.parse(compilerOutput);\n        }\n        const abi = compilerOutput.abi;\n        let bytecode = null;\n        if (compilerOutput.bytecode) {\n            bytecode = compilerOutput.bytecode;\n        } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {\n            bytecode = compilerOutput.evm.bytecode;\n        }\n        return new this(abi, bytecode, signer);\n    }\n    static getInterface(contractInterface) {\n        return Contract.getInterface(contractInterface);\n    }\n    static getContractAddress(tx) {\n        return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getContractAddress)(tx);\n    }\n    static getContract(address, contractInterface, signer) {\n        return new Contract(address, contractInterface, signer);\n    }\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9jb250cmFjdHMvbGliLmVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFhO0FBQ2IsSUFBSUEsWUFBWSxTQUFLLElBQUksU0FBSSxDQUFDQSxTQUFTLElBQUssU0FBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNuRixTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBQzJFO0FBQ2Y7QUFDUTtBQUNJO0FBQ25CO0FBQ2tDO0FBQ3lCO0FBQ3BEO0FBQ2I7QUFDVjtBQUNyQyxNQUFNNkIsU0FBUyxJQUFJRix5REFB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QUFDK0ksUUFBUSxFQUFFcko7SUFDakU7SUFDQSxPQUFPOEosYUFBYUMsY0FBYyxFQUFFL0osTUFBTSxFQUFFO1FBQ3hDLElBQUkrSixrQkFBa0IsTUFBTTtZQUN4QmhOLE9BQU9xQixVQUFVLENBQUMsMkJBQTJCdkIseURBQU1BLENBQUN3QixNQUFNLENBQUMyTCxnQkFBZ0IsRUFBRTtnQkFBRTVLLFVBQVU7WUFBaUI7UUFDOUc7UUFDQSxJQUFJLE9BQVEySyxtQkFBb0IsVUFBVTtZQUN0Q0EsaUJBQWlCdEksS0FBS3dJLEtBQUssQ0FBQ0Y7UUFDaEM7UUFDQSxNQUFNRyxNQUFNSCxlQUFlRyxHQUFHO1FBQzlCLElBQUliLFdBQVc7UUFDZixJQUFJVSxlQUFlVixRQUFRLEVBQUU7WUFDekJBLFdBQVdVLGVBQWVWLFFBQVE7UUFDdEMsT0FDSyxJQUFJVSxlQUFlSSxHQUFHLElBQUlKLGVBQWVJLEdBQUcsQ0FBQ2QsUUFBUSxFQUFFO1lBQ3hEQSxXQUFXVSxlQUFlSSxHQUFHLENBQUNkLFFBQVE7UUFDMUM7UUFDQSxPQUFPLElBQUksSUFBSSxDQUFDYSxLQUFLYixVQUFVcko7SUFDbkM7SUFDQSxPQUFPbUgsYUFBYXJCLGlCQUFpQixFQUFFO1FBQ25DLE9BQU9xRCxTQUFTaEMsWUFBWSxDQUFDckI7SUFDakM7SUFDQSxPQUFPOUosbUJBQW1Cd0UsRUFBRSxFQUFFO1FBQzFCLE9BQU94RSwwRUFBa0JBLENBQUN3RTtJQUM5QjtJQUNBLE9BQU9xSixZQUFZckwsT0FBTyxFQUFFc0gsaUJBQWlCLEVBQUU5RixNQUFNLEVBQUU7UUFDbkQsT0FBTyxJQUFJbUosU0FBUzNLLFNBQVNzSCxtQkFBbUI5RjtJQUNwRDtBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2xpbWUtYmV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvY29udHJhY3RzL2xpYi5lc20vaW5kZXguanM/NWZmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgY2hlY2tSZXN1bHRFcnJvcnMsIEluZGV4ZWQsIEludGVyZmFjZSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hYmlcIjtcbmltcG9ydCB7IFByb3ZpZGVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBTaWduZXIsIFZvaWRTaWduZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWJzdHJhY3Qtc2lnbmVyXCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzLCBnZXRDb250cmFjdEFkZHJlc3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWRkcmVzc1wiO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGNvbmNhdCwgaGV4bGlmeSwgaXNCeXRlcywgaXNIZXhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IGRlZmluZVJlYWRPbmx5LCBkZWVwQ29weSwgZ2V0U3RhdGljLCByZXNvbHZlUHJvcGVydGllcywgc2hhbGxvd0NvcHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC90cmFuc2FjdGlvbnNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbjtcbjtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmNvbnN0IGFsbG93ZWRUcmFuc2FjdGlvbktleXMgPSB7XG4gICAgY2hhaW5JZDogdHJ1ZSwgZGF0YTogdHJ1ZSwgZnJvbTogdHJ1ZSwgZ2FzTGltaXQ6IHRydWUsIGdhc1ByaWNlOiB0cnVlLCBub25jZTogdHJ1ZSwgdG86IHRydWUsIHZhbHVlOiB0cnVlLFxuICAgIHR5cGU6IHRydWUsIGFjY2Vzc0xpc3Q6IHRydWUsXG4gICAgbWF4RmVlUGVyR2FzOiB0cnVlLCBtYXhQcmlvcml0eUZlZVBlckdhczogdHJ1ZSxcbiAgICBjdXN0b21EYXRhOiB0cnVlLFxuICAgIGNjaXBSZWFkRW5hYmxlZDogdHJ1ZVxufTtcbmZ1bmN0aW9uIHJlc29sdmVOYW1lKHJlc29sdmVyLCBuYW1lT3JQcm9taXNlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHlpZWxkIG5hbWVPclByb21pc2U7XG4gICAgICAgIGlmICh0eXBlb2YgKG5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzIG9yIEVOUyBuYW1lXCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBpdCBpcyBhbHJlYWR5IGFuIGFkZHJlc3MsIGp1c3QgdXNlIGl0IChhZnRlciBhZGRpbmcgY2hlY2tzdW0pXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyhuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICBpZiAoIXJlc29sdmVyKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImEgcHJvdmlkZXIgb3Igc2lnbmVyIGlzIG5lZWRlZCB0byByZXNvbHZlIEVOUyBuYW1lc1wiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXNvbHZlTmFtZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzID0geWllbGQgcmVzb2x2ZXIucmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJyZXNvbHZlciBvciBhZGRyIGlzIG5vdCBjb25maWd1cmVkIGZvciBFTlMgbmFtZVwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgfSk7XG59XG4vLyBSZWN1cnNpdmVseSByZXBsYWNlcyBFTlMgbmFtZXMgd2l0aCBwcm9taXNlcyB0byByZXNvbHZlIHRoZSBuYW1lIGFuZCByZXNvbHZlcyBhbGwgcHJvcGVydGllc1xuZnVuY3Rpb24gcmVzb2x2ZUFkZHJlc3NlcyhyZXNvbHZlciwgdmFsdWUsIHBhcmFtVHlwZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtVHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCBQcm9taXNlLmFsbChwYXJhbVR5cGUubWFwKChwYXJhbVR5cGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVBZGRyZXNzZXMocmVzb2x2ZXIsICgoQXJyYXkuaXNBcnJheSh2YWx1ZSkpID8gdmFsdWVbaW5kZXhdIDogdmFsdWVbcGFyYW1UeXBlLm5hbWVdKSwgcGFyYW1UeXBlKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1UeXBlLnR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzb2x2ZU5hbWUocmVzb2x2ZXIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1UeXBlLnR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc29sdmVBZGRyZXNzZXMocmVzb2x2ZXIsIHZhbHVlLCBwYXJhbVR5cGUuY29tcG9uZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtVHlwZS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGxvZ2dlci5tYWtlRXJyb3IoXCJpbnZhbGlkIHZhbHVlIGZvciBhcnJheVwiLCBMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWllbGQgUHJvbWlzZS5hbGwodmFsdWUubWFwKCh2KSA9PiByZXNvbHZlQWRkcmVzc2VzKHJlc29sdmVyLCB2LCBwYXJhbVR5cGUuYXJyYXlDaGlsZHJlbikpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBwb3B1bGF0ZVRyYW5zYWN0aW9uKGNvbnRyYWN0LCBmcmFnbWVudCwgYXJncykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIC8vIElmIGFuIGV4dHJhIGFyZ3VtZW50IGlzIGdpdmVuLCBpdCBpcyBvdmVycmlkZXNcbiAgICAgICAgbGV0IG92ZXJyaWRlcyA9IHt9O1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IGZyYWdtZW50LmlucHV0cy5sZW5ndGggKyAxICYmIHR5cGVvZiAoYXJnc1thcmdzLmxlbmd0aCAtIDFdKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgb3ZlcnJpZGVzID0gc2hhbGxvd0NvcHkoYXJncy5wb3AoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBwYXJhbWV0ZXIgY291bnQgbWF0Y2hlc1xuICAgICAgICBsb2dnZXIuY2hlY2tBcmd1bWVudENvdW50KGFyZ3MubGVuZ3RoLCBmcmFnbWVudC5pbnB1dHMubGVuZ3RoLCBcInBhc3NlZCB0byBjb250cmFjdFwiKTtcbiAgICAgICAgLy8gUG9wdWxhdGUgXCJmcm9tXCIgb3ZlcnJpZGUgKGFsbG93IHByb21pc2VzKVxuICAgICAgICBpZiAoY29udHJhY3Quc2lnbmVyKSB7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGVzLmZyb20pIHtcbiAgICAgICAgICAgICAgICAvLyBDb250cmFjdHMgd2l0aCBhIFNpZ25lciBhcmUgZnJvbSB0aGUgU2lnbmVyJ3MgZnJhbWUtb2YtcmVmZXJlbmNlO1xuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBhbGxvdyBvdmVycmlkaW5nIFwiZnJvbVwiIGlmIGl0IG1hdGNoZXMgdGhlIHNpZ25lclxuICAgICAgICAgICAgICAgIG92ZXJyaWRlcy5mcm9tID0gcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgICAgICBvdmVycmlkZTogcmVzb2x2ZU5hbWUoY29udHJhY3Quc2lnbmVyLCBvdmVycmlkZXMuZnJvbSksXG4gICAgICAgICAgICAgICAgICAgIHNpZ25lcjogY29udHJhY3Quc2lnbmVyLmdldEFkZHJlc3MoKVxuICAgICAgICAgICAgICAgIH0pLnRoZW4oKGNoZWNrKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXRBZGRyZXNzKGNoZWNrLnNpZ25lcikgIT09IGNoZWNrLm92ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkNvbnRyYWN0IHdpdGggYSBTaWduZXIgY2Fubm90IG92ZXJyaWRlIGZyb21cIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwib3ZlcnJpZGVzLmZyb21cIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrLm92ZXJyaWRlO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG92ZXJyaWRlcy5mcm9tID0gY29udHJhY3Quc2lnbmVyLmdldEFkZHJlc3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdmVycmlkZXMuZnJvbSkge1xuICAgICAgICAgICAgb3ZlcnJpZGVzLmZyb20gPSByZXNvbHZlTmFtZShjb250cmFjdC5wcm92aWRlciwgb3ZlcnJpZGVzLmZyb20pO1xuICAgICAgICAgICAgLy99IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ29udHJhY3RzIHdpdGhvdXQgYSBzaWduZXIgY2FuIG92ZXJyaWRlIFwiZnJvbVwiLCBhbmQgaWZcbiAgICAgICAgICAgIC8vIHVuc3BlY2lmaWVkIHRoZSB6ZXJvIGFkZHJlc3MgaXMgdXNlZFxuICAgICAgICAgICAgLy9vdmVycmlkZXMuZnJvbSA9IEFkZHJlc3NaZXJvO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdhaXQgZm9yIGFsbCBkZXBlbmRlbmNpZXMgdG8gYmUgcmVzb2x2ZWQgKHByZWZlciB0aGUgc2lnbmVyIG92ZXIgdGhlIHByb3ZpZGVyKVxuICAgICAgICBjb25zdCByZXNvbHZlZCA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIGFyZ3M6IHJlc29sdmVBZGRyZXNzZXMoY29udHJhY3Quc2lnbmVyIHx8IGNvbnRyYWN0LnByb3ZpZGVyLCBhcmdzLCBmcmFnbWVudC5pbnB1dHMpLFxuICAgICAgICAgICAgYWRkcmVzczogY29udHJhY3QucmVzb2x2ZWRBZGRyZXNzLFxuICAgICAgICAgICAgb3ZlcnJpZGVzOiAocmVzb2x2ZVByb3BlcnRpZXMob3ZlcnJpZGVzKSB8fCB7fSlcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoZSBBQkkgY29kZWQgdHJhbnNhY3Rpb25cbiAgICAgICAgY29uc3QgZGF0YSA9IGNvbnRyYWN0LmludGVyZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQsIHJlc29sdmVkLmFyZ3MpO1xuICAgICAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICB0bzogcmVzb2x2ZWQuYWRkcmVzc1xuICAgICAgICB9O1xuICAgICAgICAvLyBSZXNvbHZlZCBPdmVycmlkZXNcbiAgICAgICAgY29uc3Qgcm8gPSByZXNvbHZlZC5vdmVycmlkZXM7XG4gICAgICAgIC8vIFBvcHVsYXRlIHNpbXBsZSBvdmVycmlkZXNcbiAgICAgICAgaWYgKHJvLm5vbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4Lm5vbmNlID0gQmlnTnVtYmVyLmZyb20ocm8ubm9uY2UpLnRvTnVtYmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvLmdhc0xpbWl0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4Lmdhc0xpbWl0ID0gQmlnTnVtYmVyLmZyb20ocm8uZ2FzTGltaXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyby5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC5nYXNQcmljZSA9IEJpZ051bWJlci5mcm9tKHJvLmdhc1ByaWNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm8ubWF4RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4Lm1heEZlZVBlckdhcyA9IEJpZ051bWJlci5mcm9tKHJvLm1heEZlZVBlckdhcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvLm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID0gQmlnTnVtYmVyLmZyb20ocm8ubWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyby5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4LmZyb20gPSByby5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyby50eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4LnR5cGUgPSByby50eXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyby5hY2Nlc3NMaXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4LmFjY2Vzc0xpc3QgPSBhY2Nlc3NMaXN0aWZ5KHJvLmFjY2Vzc0xpc3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBubyBcImdhc0xpbWl0XCIgb3ZlcnJpZGUsIGJ1dCB0aGUgQUJJIHNwZWNpZmllcyBhIGRlZmF1bHQsIHVzZSBpdFxuICAgICAgICBpZiAodHguZ2FzTGltaXQgPT0gbnVsbCAmJiBmcmFnbWVudC5nYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgaW50cmluc2ljIGdhcyBjb3N0IGZvciB0aGlzIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAvLyBAVE9ETzogVGhpcyBpcyBiYXNlZCBvbiB0aGUgeWVsbG93IHBhcGVyIGFzIG9mIFBldGVyc2J1cmc7IHRoaXMgaXMgc29tZXRoaW5nXG4gICAgICAgICAgICAvLyB3ZSBtYXkgd2lzaCB0byBwYXJhbWV0ZXJpemUgaW4gdjYgYXMgcGFydCBvZiB0aGUgTmV0d29yayBvYmplY3QuIFNpbmNlIHRoaXNcbiAgICAgICAgICAgIC8vIGlzIGFsd2F5cyBhIG5vbi1uaWwgdG8gYWRkcmVzcywgd2UgY2FuIGlnbm9yZSBHX2NyZWF0ZSwgYnV0IG1heSB3aXNoIHRvIGFkZFxuICAgICAgICAgICAgLy8gc2ltaWxhciBsb2dpYyB0byB0aGUgQ29udHJhY3RGYWN0b3J5LlxuICAgICAgICAgICAgbGV0IGludHJpbnNpYyA9IDIxMDAwO1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBhcnJheWlmeShkYXRhKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpbnRyaW5zaWMgKz0gNDtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW50cmluc2ljICs9IDY0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR4Lmdhc0xpbWl0ID0gQmlnTnVtYmVyLmZyb20oZnJhZ21lbnQuZ2FzKS5hZGQoaW50cmluc2ljKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3B1bGF0ZSBcInZhbHVlXCIgb3ZlcnJpZGVcbiAgICAgICAgaWYgKHJvLnZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCByb1ZhbHVlID0gQmlnTnVtYmVyLmZyb20ocm8udmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFyb1ZhbHVlLmlzWmVybygpICYmICFmcmFnbWVudC5wYXlhYmxlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJub24tcGF5YWJsZSBtZXRob2QgY2Fubm90IG92ZXJyaWRlIHZhbHVlXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJvdmVycmlkZXMudmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG92ZXJyaWRlcy52YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHgudmFsdWUgPSByb1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyby5jdXN0b21EYXRhKSB7XG4gICAgICAgICAgICB0eC5jdXN0b21EYXRhID0gc2hhbGxvd0NvcHkocm8uY3VzdG9tRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvLmNjaXBSZWFkRW5hYmxlZCkge1xuICAgICAgICAgICAgdHguY2NpcFJlYWRFbmFibGVkID0gISFyby5jY2lwUmVhZEVuYWJsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBvdmVycmlkZXNcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5ub25jZTtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5nYXNMaW1pdDtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5nYXNQcmljZTtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5mcm9tO1xuICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLnZhbHVlO1xuICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLnR5cGU7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuYWNjZXNzTGlzdDtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5tYXhGZWVQZXJHYXM7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuY3VzdG9tRGF0YTtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5jY2lwUmVhZEVuYWJsZWQ7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSBhcmUgbm8gc3RyYXkgb3ZlcnJpZGVzLCB3aGljaCBtYXkgaW5kaWNhdGUgYVxuICAgICAgICAvLyB0eXBvIG9yIHVzaW5nIGFuIHVuc3VwcG9ydGVkIGtleS5cbiAgICAgICAgY29uc3QgbGVmdG92ZXJzID0gT2JqZWN0LmtleXMob3ZlcnJpZGVzKS5maWx0ZXIoKGtleSkgPT4gKG92ZXJyaWRlc1trZXldICE9IG51bGwpKTtcbiAgICAgICAgaWYgKGxlZnRvdmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKGBjYW5ub3Qgb3ZlcnJpZGUgJHtsZWZ0b3ZlcnMubWFwKChsKSA9PiBKU09OLnN0cmluZ2lmeShsKSkuam9pbihcIixcIil9YCwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwib3ZlcnJpZGVzXCIsXG4gICAgICAgICAgICAgICAgb3ZlcnJpZGVzOiBsZWZ0b3ZlcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUG9wdWxhdGUoY29udHJhY3QsIGZyYWdtZW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBwb3B1bGF0ZVRyYW5zYWN0aW9uKGNvbnRyYWN0LCBmcmFnbWVudCwgYXJncyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXN0aW1hdGUoY29udHJhY3QsIGZyYWdtZW50KSB7XG4gICAgY29uc3Qgc2lnbmVyT3JQcm92aWRlciA9IChjb250cmFjdC5zaWduZXIgfHwgY29udHJhY3QucHJvdmlkZXIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCFzaWduZXJPclByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJlc3RpbWF0ZSByZXF1aXJlIGEgcHJvdmlkZXIgb3Igc2lnbmVyXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJlc3RpbWF0ZUdhc1wiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eCA9IHlpZWxkIHBvcHVsYXRlVHJhbnNhY3Rpb24oY29udHJhY3QsIGZyYWdtZW50LCBhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCBzaWduZXJPclByb3ZpZGVyLmVzdGltYXRlR2FzKHR4KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFkZENvbnRyYWN0V2FpdChjb250cmFjdCwgdHgpIHtcbiAgICBjb25zdCB3YWl0ID0gdHgud2FpdC5iaW5kKHR4KTtcbiAgICB0eC53YWl0ID0gKGNvbmZpcm1hdGlvbnMpID0+IHtcbiAgICAgICAgcmV0dXJuIHdhaXQoY29uZmlybWF0aW9ucykudGhlbigocmVjZWlwdCkgPT4ge1xuICAgICAgICAgICAgcmVjZWlwdC5ldmVudHMgPSByZWNlaXB0LmxvZ3MubWFwKChsb2cpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnQgPSBkZWVwQ29weShsb2cpO1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IGNvbnRyYWN0LmludGVyZmFjZS5wYXJzZUxvZyhsb2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICAgICAgLy8gU3VjY2Vzc2Z1bGx5IHBhcnNlZCB0aGUgZXZlbnQgbG9nOyBpbmNsdWRlIGl0XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5hcmdzID0gcGFyc2VkLmFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmRlY29kZSA9IChkYXRhLCB0b3BpY3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250cmFjdC5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2cocGFyc2VkLmV2ZW50RnJhZ21lbnQsIGRhdGEsIHRvcGljcyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmV2ZW50ID0gcGFyc2VkLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmV2ZW50U2lnbmF0dXJlID0gcGFyc2VkLnNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVXNlZnVsIG9wZXJhdGlvbnNcbiAgICAgICAgICAgICAgICBldmVudC5yZW1vdmVMaXN0ZW5lciA9ICgpID0+IHsgcmV0dXJuIGNvbnRyYWN0LnByb3ZpZGVyOyB9O1xuICAgICAgICAgICAgICAgIGV2ZW50LmdldEJsb2NrID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udHJhY3QucHJvdmlkZXIuZ2V0QmxvY2socmVjZWlwdC5ibG9ja0hhc2gpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZXZlbnQuZ2V0VHJhbnNhY3Rpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250cmFjdC5wcm92aWRlci5nZXRUcmFuc2FjdGlvbihyZWNlaXB0LnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBldmVudC5nZXRUcmFuc2FjdGlvblJlY2VpcHQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZWNlaXB0O1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRDYWxsKGNvbnRyYWN0LCBmcmFnbWVudCwgY29sbGFwc2VTaW1wbGUpIHtcbiAgICBjb25zdCBzaWduZXJPclByb3ZpZGVyID0gKGNvbnRyYWN0LnNpZ25lciB8fCBjb250cmFjdC5wcm92aWRlcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBcImJsb2NrVGFnXCIgb3ZlcnJpZGUgaWYgcHJlc2VudFxuICAgICAgICAgICAgbGV0IGJsb2NrVGFnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSBmcmFnbWVudC5pbnB1dHMubGVuZ3RoICsgMSAmJiB0eXBlb2YgKGFyZ3NbYXJncy5sZW5ndGggLSAxXSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdmVycmlkZXMgPSBzaGFsbG93Q29weShhcmdzLnBvcCgpKTtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGVzLmJsb2NrVGFnICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tUYWcgPSB5aWVsZCBvdmVycmlkZXMuYmxvY2tUYWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuYmxvY2tUYWc7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKG92ZXJyaWRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgY29udHJhY3Qgd2FzIGp1c3QgZGVwbG95ZWQsIHdhaXQgdW50aWwgaXQgaXMgbWluZWRcbiAgICAgICAgICAgIGlmIChjb250cmFjdC5kZXBsb3lUcmFuc2FjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgY29udHJhY3QuX2RlcGxveWVkKGJsb2NrVGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENhbGwgYSBub2RlIGFuZCBnZXQgdGhlIHJlc3VsdFxuICAgICAgICAgICAgY29uc3QgdHggPSB5aWVsZCBwb3B1bGF0ZVRyYW5zYWN0aW9uKGNvbnRyYWN0LCBmcmFnbWVudCwgYXJncyk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBzaWduZXJPclByb3ZpZGVyLmNhbGwodHgsIGJsb2NrVGFnKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmIChjb2xsYXBzZVNpbXBsZSAmJiBmcmFnbWVudC5vdXRwdXRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5hZGRyZXNzID0gY29udHJhY3QuYWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuYXJncyA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLnRyYW5zYWN0aW9uID0gdHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRTZW5kKGNvbnRyYWN0LCBmcmFnbWVudCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCFjb250cmFjdC5zaWduZXIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInNlbmRpbmcgYSB0cmFuc2FjdGlvbiByZXF1aXJlcyBhIHNpZ25lclwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2VuZFRyYW5zYWN0aW9uXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBjb250cmFjdCB3YXMganVzdCBkZXBsb3llZCwgd2FpdCB1bnRpbCBpdCBpcyBtaW5lZFxuICAgICAgICAgICAgaWYgKGNvbnRyYWN0LmRlcGxveVRyYW5zYWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBjb250cmFjdC5fZGVwbG95ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR4UmVxdWVzdCA9IHlpZWxkIHBvcHVsYXRlVHJhbnNhY3Rpb24oY29udHJhY3QsIGZyYWdtZW50LCBhcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0geWllbGQgY29udHJhY3Quc2lnbmVyLnNlbmRUcmFuc2FjdGlvbih0eFJlcXVlc3QpO1xuICAgICAgICAgICAgLy8gVHdlYWsgdGhlIHR4LndhaXQgc28gdGhlIHJlY2VpcHQgaGFzIGV4dHJhIHByb3BlcnRpZXNcbiAgICAgICAgICAgIGFkZENvbnRyYWN0V2FpdChjb250cmFjdCwgdHgpO1xuICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGREZWZhdWx0KGNvbnRyYWN0LCBmcmFnbWVudCwgY29sbGFwc2VTaW1wbGUpIHtcbiAgICBpZiAoZnJhZ21lbnQuY29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIGJ1aWxkQ2FsbChjb250cmFjdCwgZnJhZ21lbnQsIGNvbGxhcHNlU2ltcGxlKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWxkU2VuZChjb250cmFjdCwgZnJhZ21lbnQpO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRUYWcoZmlsdGVyKSB7XG4gICAgaWYgKGZpbHRlci5hZGRyZXNzICYmIChmaWx0ZXIudG9waWNzID09IG51bGwgfHwgZmlsdGVyLnRvcGljcy5sZW5ndGggPT09IDApKSB7XG4gICAgICAgIHJldHVybiBcIipcIjtcbiAgICB9XG4gICAgcmV0dXJuIChmaWx0ZXIuYWRkcmVzcyB8fCBcIipcIikgKyBcIkBcIiArIChmaWx0ZXIudG9waWNzID8gZmlsdGVyLnRvcGljcy5tYXAoKHRvcGljKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRvcGljKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvcGljLmpvaW4oXCJ8XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3BpYztcbiAgICB9KS5qb2luKFwiOlwiKSA6IFwiXCIpO1xufVxuY2xhc3MgUnVubmluZ0V2ZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih0YWcsIGZpbHRlcikge1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInRhZ1wiLCB0YWcpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImZpbHRlclwiLCBmaWx0ZXIpO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgICB9XG4gICAgYWRkTGlzdGVuZXIobGlzdGVuZXIsIG9uY2UpIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lcjogbGlzdGVuZXIsIG9uY2U6IG9uY2UgfSk7XG4gICAgfVxuICAgIHJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycy5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChkb25lIHx8IGl0ZW0ubGlzdGVuZXIgIT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgfVxuICAgIGxpc3RlbmVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3RlbmVycy5tYXAoKGkpID0+IGkubGlzdGVuZXIpO1xuICAgIH1cbiAgICBsaXN0ZW5lckNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGlzdGVuZXJzLmxlbmd0aDtcbiAgICB9XG4gICAgcnVuKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJDb3VudCA9IHRoaXMubGlzdGVuZXJDb3VudCgpO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhcmdzQ29weSA9IGFyZ3Muc2xpY2UoKTtcbiAgICAgICAgICAgIC8vIENhbGwgdGhlIGNhbGxiYWNrIGluIHRoZSBuZXh0IGV2ZW50IGxvb3BcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGl0ZW0ubGlzdGVuZXIuYXBwbHkodGhpcywgYXJnc0NvcHkpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAvLyBSZXNjaGVkdWxlIGl0IGlmIGl0IG5vdCBcIm9uY2VcIlxuICAgICAgICAgICAgcmV0dXJuICEoaXRlbS5vbmNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lckNvdW50O1xuICAgIH1cbiAgICBwcmVwYXJlRXZlbnQoZXZlbnQpIHtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgYXJyYXkgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gYW4gZW1pdFxuICAgIGdldEVtaXQoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIFtldmVudF07XG4gICAgfVxufVxuY2xhc3MgRXJyb3JSdW5uaW5nRXZlbnQgZXh0ZW5kcyBSdW5uaW5nRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcImVycm9yXCIsIG51bGwpO1xuICAgIH1cbn1cbi8vIEBUT0RPIEZyYWdtZW50IHNob3VsZCBpbmhlcml0IFdpbGRjYXJkPyBhbmQganVzdCBvdmVycmlkZSBnZXRFbWl0P1xuLy8gICAgICAgb3IgaGF2ZSBhIGNvbW1vbiBhYnN0cmFjdCBzdXBlciBjbGFzcywgd2l0aCBlbm91Z2ggY29uc3RydWN0b3Jcbi8vICAgICAgIG9wdGlvbnMgdG8gY29uZmlndXJlIGJvdGguXG4vLyBBIEZyYWdtZW50IEV2ZW50IHdpbGwgcG9wdWxhdGUgYWxsIHRoZSBwcm9wZXJ0aWVzIHRoYXQgV2lsZGNhcmRcbi8vIHdpbGwsIGFuZCBhZGRpdGlvbmFsbHkgZGVyZWZlcmVuY2UgdGhlIGFyZ3VtZW50cyB3aGVuIGVtaXR0aW5nXG5jbGFzcyBGcmFnbWVudFJ1bm5pbmdFdmVudCBleHRlbmRzIFJ1bm5pbmdFdmVudCB7XG4gICAgY29uc3RydWN0b3IoYWRkcmVzcywgY29udHJhY3RJbnRlcmZhY2UsIGZyYWdtZW50LCB0b3BpY3MpIHtcbiAgICAgICAgY29uc3QgZmlsdGVyID0ge1xuICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzc1xuICAgICAgICB9O1xuICAgICAgICBsZXQgdG9waWMgPSBjb250cmFjdEludGVyZmFjZS5nZXRFdmVudFRvcGljKGZyYWdtZW50KTtcbiAgICAgICAgaWYgKHRvcGljcykge1xuICAgICAgICAgICAgaWYgKHRvcGljICE9PSB0b3BpY3NbMF0pIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidG9waWMgbWlzbWF0Y2hcIiwgXCJ0b3BpY3NcIiwgdG9waWNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbHRlci50b3BpY3MgPSB0b3BpY3Muc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpbHRlci50b3BpY3MgPSBbdG9waWNdO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGdldEV2ZW50VGFnKGZpbHRlciksIGZpbHRlcik7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJpbnRlcmZhY2VcIiwgY29udHJhY3RJbnRlcmZhY2UpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICB9XG4gICAgcHJlcGFyZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHN1cGVyLnByZXBhcmVFdmVudChldmVudCk7XG4gICAgICAgIGV2ZW50LmV2ZW50ID0gdGhpcy5mcmFnbWVudC5uYW1lO1xuICAgICAgICBldmVudC5ldmVudFNpZ25hdHVyZSA9IHRoaXMuZnJhZ21lbnQuZm9ybWF0KCk7XG4gICAgICAgIGV2ZW50LmRlY29kZSA9IChkYXRhLCB0b3BpY3MpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVyZmFjZS5kZWNvZGVFdmVudExvZyh0aGlzLmZyYWdtZW50LCBkYXRhLCB0b3BpY3MpO1xuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZXZlbnQuYXJncyA9IHRoaXMuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKHRoaXMuZnJhZ21lbnQsIGV2ZW50LmRhdGEsIGV2ZW50LnRvcGljcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBldmVudC5hcmdzID0gbnVsbDtcbiAgICAgICAgICAgIGV2ZW50LmRlY29kZUVycm9yID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RW1pdChldmVudCkge1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBjaGVja1Jlc3VsdEVycm9ycyhldmVudC5hcmdzKTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yc1swXS5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmdzID0gKGV2ZW50LmFyZ3MgfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIGFyZ3MucHVzaChldmVudCk7XG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgIH1cbn1cbi8vIEEgV2lsZGNhcmQgRXZlbnQgd2lsbCBhdHRlbXB0IHRvIHBvcHVsYXRlOlxuLy8gIC0gZXZlbnQgICAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgbmFtZVxuLy8gIC0gZXZlbnRTaWduYXR1cmUgICBUaGUgZnVsbCBzaWduYXR1cmUgb2YgdGhlIGV2ZW50XG4vLyAgLSBkZWNvZGUgICAgICAgICAgIEEgZnVuY3Rpb24gdG8gZGVjb2RlIGRhdGEgYW5kIHRvcGljc1xuLy8gIC0gYXJncyAgICAgICAgICAgICBUaGUgZGVjb2RlZCBkYXRhIGFuZCB0b3BpY3NcbmNsYXNzIFdpbGRjYXJkUnVubmluZ0V2ZW50IGV4dGVuZHMgUnVubmluZ0V2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBjb250cmFjdEludGVyZmFjZSkge1xuICAgICAgICBzdXBlcihcIipcIiwgeyBhZGRyZXNzOiBhZGRyZXNzIH0pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiaW50ZXJmYWNlXCIsIGNvbnRyYWN0SW50ZXJmYWNlKTtcbiAgICB9XG4gICAgcHJlcGFyZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHN1cGVyLnByZXBhcmVFdmVudChldmVudCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmludGVyZmFjZS5wYXJzZUxvZyhldmVudCk7XG4gICAgICAgICAgICBldmVudC5ldmVudCA9IHBhcnNlZC5uYW1lO1xuICAgICAgICAgICAgZXZlbnQuZXZlbnRTaWduYXR1cmUgPSBwYXJzZWQuc2lnbmF0dXJlO1xuICAgICAgICAgICAgZXZlbnQuZGVjb2RlID0gKGRhdGEsIHRvcGljcykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVyZmFjZS5kZWNvZGVFdmVudExvZyhwYXJzZWQuZXZlbnRGcmFnbWVudCwgZGF0YSwgdG9waWNzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBldmVudC5hcmdzID0gcGFyc2VkLmFyZ3M7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBObyBtYXRjaGluZyBldmVudFxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJhc2VDb250cmFjdCB7XG4gICAgY29uc3RydWN0b3IoYWRkcmVzc09yTmFtZSwgY29udHJhY3RJbnRlcmZhY2UsIHNpZ25lck9yUHJvdmlkZXIpIHtcbiAgICAgICAgLy8gQFRPRE86IE1heWJlIHN0aWxsIGNoZWNrIHRoZSBhZGRyZXNzT3JOYW1lIGxvb2tzIGxpa2UgYSB2YWxpZCBhZGRyZXNzIG9yIG5hbWU/XG4gICAgICAgIC8vYWRkcmVzcyA9IGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiaW50ZXJmYWNlXCIsIGdldFN0YXRpYyhuZXcudGFyZ2V0LCBcImdldEludGVyZmFjZVwiKShjb250cmFjdEludGVyZmFjZSkpO1xuICAgICAgICBpZiAoc2lnbmVyT3JQcm92aWRlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInByb3ZpZGVyXCIsIG51bGwpO1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJzaWduZXJcIiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoU2lnbmVyLmlzU2lnbmVyKHNpZ25lck9yUHJvdmlkZXIpKSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInByb3ZpZGVyXCIsIHNpZ25lck9yUHJvdmlkZXIucHJvdmlkZXIgfHwgbnVsbCk7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInNpZ25lclwiLCBzaWduZXJPclByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChQcm92aWRlci5pc1Byb3ZpZGVyKHNpZ25lck9yUHJvdmlkZXIpKSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInByb3ZpZGVyXCIsIHNpZ25lck9yUHJvdmlkZXIpO1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJzaWduZXJcIiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBzaWduZXIgb3IgcHJvdmlkZXJcIiwgXCJzaWduZXJPclByb3ZpZGVyXCIsIHNpZ25lck9yUHJvdmlkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiY2FsbFN0YXRpY1wiLCB7fSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZXN0aW1hdGVHYXNcIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImZ1bmN0aW9uc1wiLCB7fSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicG9wdWxhdGVUcmFuc2FjdGlvblwiLCB7fSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZmlsdGVyc1wiLCB7fSk7XG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZUZpbHRlcnMgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuaW50ZXJmYWNlLmV2ZW50cykuZm9yRWFjaCgoZXZlbnRTaWduYXR1cmUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IHRoaXMuaW50ZXJmYWNlLmV2ZW50c1tldmVudFNpZ25hdHVyZV07XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcy5maWx0ZXJzLCBldmVudFNpZ25hdHVyZSwgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljczogdGhpcy5pbnRlcmZhY2UuZW5jb2RlRmlsdGVyVG9waWNzKGV2ZW50LCBhcmdzKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghdW5pcXVlRmlsdGVyc1tldmVudC5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB1bmlxdWVGaWx0ZXJzW2V2ZW50Lm5hbWVdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVuaXF1ZUZpbHRlcnNbZXZlbnQubmFtZV0ucHVzaChldmVudFNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHVuaXF1ZUZpbHRlcnMpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJzID0gdW5pcXVlRmlsdGVyc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcy5maWx0ZXJzLCBuYW1lLCB0aGlzLmZpbHRlcnNbZmlsdGVyc1swXV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYER1cGxpY2F0ZSBkZWZpbml0aW9uIG9mICR7bmFtZX0gKCR7ZmlsdGVycy5qb2luKFwiLCBcIil9KWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX3J1bm5pbmdFdmVudHNcIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl93cmFwcGVkRW1pdHNcIiwge30pO1xuICAgICAgICBpZiAoYWRkcmVzc09yTmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjb250cmFjdCBhZGRyZXNzIG9yIEVOUyBuYW1lXCIsIFwiYWRkcmVzc09yTmFtZVwiLCBhZGRyZXNzT3JOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImFkZHJlc3NcIiwgYWRkcmVzc09yTmFtZSk7XG4gICAgICAgIGlmICh0aGlzLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInJlc29sdmVkQWRkcmVzc1wiLCByZXNvbHZlTmFtZSh0aGlzLnByb3ZpZGVyLCBhZGRyZXNzT3JOYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicmVzb2x2ZWRBZGRyZXNzXCIsIFByb21pc2UucmVzb2x2ZShnZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBXaXRob3V0IGEgcHJvdmlkZXIsIHdlIGNhbm5vdCB1c2UgRU5TIG5hbWVzXG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJwcm92aWRlciBpcyByZXF1aXJlZCB0byB1c2UgRU5TIG5hbWUgYXMgY29udHJhY3QgYWRkcmVzc1wiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IENvbnRyYWN0XCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTd2FsbG93IGJhZCBFTlMgbmFtZXMgdG8gcHJldmVudCBVbmhhbmRsZWQgRXhjZXB0aW9uc1xuICAgICAgICB0aGlzLnJlc29sdmVkQWRkcmVzcy5jYXRjaCgoZSkgPT4geyB9KTtcbiAgICAgICAgY29uc3QgdW5pcXVlTmFtZXMgPSB7fTtcbiAgICAgICAgY29uc3QgdW5pcXVlU2lnbmF0dXJlcyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmludGVyZmFjZS5mdW5jdGlvbnMpLmZvckVhY2goKHNpZ25hdHVyZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmludGVyZmFjZS5mdW5jdGlvbnNbc2lnbmF0dXJlXTtcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIHNpZ25hdHVyZSBpcyB1bmlxdWU7IGlmIG5vdCB0aGUgQUJJIGdlbmVyYXRpb24gaGFzXG4gICAgICAgICAgICAvLyBub3QgYmVlbiBjbGVhbmVkIG9yIG1heSBiZSBpbmNvcnJlY3RseSBnZW5lcmF0ZWRcbiAgICAgICAgICAgIGlmICh1bmlxdWVTaWduYXR1cmVzW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgRHVwbGljYXRlIEFCSSBlbnRyeSBmb3IgJHtKU09OLnN0cmluZ2lmeShzaWduYXR1cmUpfWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVuaXF1ZVNpZ25hdHVyZXNbc2lnbmF0dXJlXSA9IHRydWU7XG4gICAgICAgICAgICAvLyBUcmFjayB1bmlxdWUgbmFtZXM7IHdlIG9ubHkgZXhwb3NlIGJhcmUgbmFtZWQgZnVuY3Rpb25zIGlmIHRoZXlcbiAgICAgICAgICAgIC8vIGFyZSBhbWJpZ3VvdXNcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZnJhZ21lbnQubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoIXVuaXF1ZU5hbWVzW2AlJHtuYW1lfWBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZU5hbWVzW2AlJHtuYW1lfWBdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVuaXF1ZU5hbWVzW2AlJHtuYW1lfWBdLnB1c2goc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzW3NpZ25hdHVyZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIHNpZ25hdHVyZSwgYnVpbGREZWZhdWx0KHRoaXMsIGZyYWdtZW50LCB0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBkbyBub3QgY29sbGFwc2Ugc2ltcGxlIGNhbGxzIG9uIHRoaXMgYnVja2V0LCB3aGljaCBhbGxvd3NcbiAgICAgICAgICAgIC8vIGZyYW1ld29ya3MgdG8gc2FmZWx5IHVzZSB0aGlzIHdpdGhvdXQgaW50cm9zcGVjdGlvbiBhcyB3ZWxsIGFzXG4gICAgICAgICAgICAvLyBhbGxvd3MgZGVjb2RpbmcgZXJyb3IgcmVjb3ZlcnkuXG4gICAgICAgICAgICBpZiAodGhpcy5mdW5jdGlvbnNbc2lnbmF0dXJlXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcy5mdW5jdGlvbnMsIHNpZ25hdHVyZSwgYnVpbGREZWZhdWx0KHRoaXMsIGZyYWdtZW50LCBmYWxzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY2FsbFN0YXRpY1tzaWduYXR1cmVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLmNhbGxTdGF0aWMsIHNpZ25hdHVyZSwgYnVpbGRDYWxsKHRoaXMsIGZyYWdtZW50LCB0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uW3NpZ25hdHVyZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbiwgc2lnbmF0dXJlLCBidWlsZFBvcHVsYXRlKHRoaXMsIGZyYWdtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5lc3RpbWF0ZUdhc1tzaWduYXR1cmVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLmVzdGltYXRlR2FzLCBzaWduYXR1cmUsIGJ1aWxkRXN0aW1hdGUodGhpcywgZnJhZ21lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5rZXlzKHVuaXF1ZU5hbWVzKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAvLyBBbWJpZ3VvdXMgbmFtZXMgdG8gbm90IGdldCBhdHRhY2hlZCBhcyBiYXJlIG5hbWVzXG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmVzID0gdW5pcXVlTmFtZXNbbmFtZV07XG4gICAgICAgICAgICBpZiAoc2lnbmF0dXJlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RyaXAgb2ZmIHRoZSBsZWFkaW5nIFwiJVwiIHVzZWQgZm9yIHByb3RvdHlwZSBwcm90ZWN0aW9uXG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBzaWduYXR1cmVzWzBdO1xuICAgICAgICAgICAgLy8gSWYgb3ZlcndyaXRpbmcgYSBtZW1iZXIgcHJvcGVydHkgdGhhdCBpcyBudWxsLCBzd2FsbG93IHRoZSBlcnJvclxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIG5hbWUsIHRoaXNbc2lnbmF0dXJlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZnVuY3Rpb25zW25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLmZ1bmN0aW9ucywgbmFtZSwgdGhpcy5mdW5jdGlvbnNbc2lnbmF0dXJlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jYWxsU3RhdGljW25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLmNhbGxTdGF0aWMsIG5hbWUsIHRoaXMuY2FsbFN0YXRpY1tzaWduYXR1cmVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb25bbmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbiwgbmFtZSwgdGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uW3NpZ25hdHVyZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZXN0aW1hdGVHYXNbbmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMuZXN0aW1hdGVHYXMsIG5hbWUsIHRoaXMuZXN0aW1hdGVHYXNbc2lnbmF0dXJlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0Q29udHJhY3RBZGRyZXNzKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBnZXRDb250cmFjdEFkZHJlc3ModHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0SW50ZXJmYWNlKGNvbnRyYWN0SW50ZXJmYWNlKSB7XG4gICAgICAgIGlmIChJbnRlcmZhY2UuaXNJbnRlcmZhY2UoY29udHJhY3RJbnRlcmZhY2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udHJhY3RJbnRlcmZhY2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UoY29udHJhY3RJbnRlcmZhY2UpO1xuICAgIH1cbiAgICAvLyBAVE9ETzogQWxsb3cgdGltZW91dD9cbiAgICBkZXBsb3llZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlcGxveWVkKCk7XG4gICAgfVxuICAgIF9kZXBsb3llZChibG9ja1RhZykge1xuICAgICAgICBpZiAoIXRoaXMuX2RlcGxveWVkUHJvbWlzZSkge1xuICAgICAgICAgICAgLy8gSWYgd2Ugd2VyZSBqdXN0IGRlcGxveWVkLCB3ZSBrbm93IHRoZSB0cmFuc2FjdGlvbiB3ZSBzaG91bGQgb2NjdXIgaW5cbiAgICAgICAgICAgIGlmICh0aGlzLmRlcGxveVRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVwbG95ZWRQcm9taXNlID0gdGhpcy5kZXBsb3lUcmFuc2FjdGlvbi53YWl0KCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQFRPRE86IE9uY2Ugd2UgYWxsb3cgYSB0aW1lb3V0IHRvIGJlIHBhc3NlZCBpbiwgd2Ugd2lsbCB3YWl0XG4gICAgICAgICAgICAgICAgLy8gdXAgdG8gdGhhdCBtYW55IGJsb2NrcyBmb3IgZ2V0Q29kZVxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgcG9sbCBmb3Igb3VyIGNvZGUgdG8gYmUgZGVwbG95ZWRcbiAgICAgICAgICAgICAgICB0aGlzLl9kZXBsb3llZFByb21pc2UgPSB0aGlzLnByb3ZpZGVyLmdldENvZGUodGhpcy5hZGRyZXNzLCBibG9ja1RhZykudGhlbigoY29kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNvbnRyYWN0IG5vdCBkZXBsb3llZFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXREZXBsb3llZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVwbG95ZWRQcm9taXNlO1xuICAgIH1cbiAgICAvLyBAVE9ETzpcbiAgICAvLyBlc3RpbWF0ZUZhbGxiYWNrKG92ZXJyaWRlcz86IFRyYW5zYWN0aW9uUmVxdWVzdCk6IFByb21pc2U8QmlnTnVtYmVyPlxuICAgIC8vIEBUT0RPOlxuICAgIC8vIGVzdGltYXRlRGVwbG95KGJ5dGVjb2RlOiBzdHJpbmcsIC4uLmFyZ3MpOiBQcm9taXNlPEJpZ051bWJlcj5cbiAgICBmYWxsYmFjayhvdmVycmlkZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNpZ25lcikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJzZW5kaW5nIGEgdHJhbnNhY3Rpb25zIHJlcXVpcmUgYSBzaWduZXJcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgb3BlcmF0aW9uOiBcInNlbmRUcmFuc2FjdGlvbihmYWxsYmFjaylcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eCA9IHNoYWxsb3dDb3B5KG92ZXJyaWRlcyB8fCB7fSk7XG4gICAgICAgIFtcImZyb21cIiwgXCJ0b1wiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0eFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBvdmVycmlkZSBcIiArIGtleSwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgb3BlcmF0aW9uOiBrZXkgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0eC50byA9IHRoaXMucmVzb2x2ZWRBZGRyZXNzO1xuICAgICAgICByZXR1cm4gdGhpcy5kZXBsb3llZCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmVyLnNlbmRUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBSZWNvbm5lY3QgdG8gYSBkaWZmZXJlbnQgc2lnbmVyIG9yIHByb3ZpZGVyXG4gICAgY29ubmVjdChzaWduZXJPclByb3ZpZGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHNpZ25lck9yUHJvdmlkZXIpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBzaWduZXJPclByb3ZpZGVyID0gbmV3IFZvaWRTaWduZXIoc2lnbmVyT3JQcm92aWRlciwgdGhpcy5wcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udHJhY3QgPSBuZXcgKHRoaXMuY29uc3RydWN0b3IpKHRoaXMuYWRkcmVzcywgdGhpcy5pbnRlcmZhY2UsIHNpZ25lck9yUHJvdmlkZXIpO1xuICAgICAgICBpZiAodGhpcy5kZXBsb3lUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkoY29udHJhY3QsIFwiZGVwbG95VHJhbnNhY3Rpb25cIiwgdGhpcy5kZXBsb3lUcmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0O1xuICAgIH1cbiAgICAvLyBSZS1hdHRhY2ggdG8gYSBkaWZmZXJlbnQgb24tY2hhaW4gaW5zdGFuY2Ugb2YgdGhpcyBjb250cmFjdFxuICAgIGF0dGFjaChhZGRyZXNzT3JOYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgKHRoaXMuY29uc3RydWN0b3IpKGFkZHJlc3NPck5hbWUsIHRoaXMuaW50ZXJmYWNlLCB0aGlzLnNpZ25lciB8fCB0aGlzLnByb3ZpZGVyKTtcbiAgICB9XG4gICAgc3RhdGljIGlzSW5kZXhlZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gSW5kZXhlZC5pc0luZGV4ZWQodmFsdWUpO1xuICAgIH1cbiAgICBfbm9ybWFsaXplUnVubmluZ0V2ZW50KHJ1bm5pbmdFdmVudCkge1xuICAgICAgICAvLyBBbHJlYWR5IGhhdmUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBldmVudCBydW5uaW5nOyB3ZSBjYW4gcmUtdXNlIGl0XG4gICAgICAgIGlmICh0aGlzLl9ydW5uaW5nRXZlbnRzW3J1bm5pbmdFdmVudC50YWddKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcnVubmluZ0V2ZW50c1tydW5uaW5nRXZlbnQudGFnXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVubmluZ0V2ZW50O1xuICAgIH1cbiAgICBfZ2V0UnVubmluZ0V2ZW50KGV2ZW50TmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIChldmVudE5hbWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBMaXN0ZW4gZm9yIFwiZXJyb3JcIiBldmVudHMgKGlmIHlvdXIgY29udHJhY3QgaGFzIGFuIGVycm9yIGV2ZW50LCBpbmNsdWRlXG4gICAgICAgICAgICAvLyB0aGUgZnVsbCBzaWduYXR1cmUgdG8gYnlwYXNzIHRoaXMgc3BlY2lhbCBldmVudCBrZXl3b3JkKVxuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZVJ1bm5pbmdFdmVudChuZXcgRXJyb3JSdW5uaW5nRXZlbnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMaXN0ZW4gZm9yIGFueSBldmVudCB0aGF0IGlzIHJlZ2lzdGVyZWRcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiZXZlbnRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IFJ1bm5pbmdFdmVudChcImV2ZW50XCIsIG51bGwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExpc3RlbiBmb3IgYW55IGV2ZW50XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IFdpbGRjYXJkUnVubmluZ0V2ZW50KHRoaXMuYWRkcmVzcywgdGhpcy5pbnRlcmZhY2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCB0aGUgZXZlbnQgRnJhZ21lbnQgKHRocm93cyBpZiBhbWJpZ3VvdXMvdW5rbm93biBldmVudClcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5pbnRlcmZhY2UuZ2V0RXZlbnQoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IEZyYWdtZW50UnVubmluZ0V2ZW50KHRoaXMuYWRkcmVzcywgdGhpcy5pbnRlcmZhY2UsIGZyYWdtZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGF2ZSB0b3BpY3MgdG8gZmlsdGVyIGJ5Li4uXG4gICAgICAgIGlmIChldmVudE5hbWUudG9waWNzICYmIGV2ZW50TmFtZS50b3BpY3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gSXMgaXQgYSBrbm93biB0b3BpY2hhc2g/ICh0aHJvd3MgaWYgbm8gbWF0Y2hpbmcgdG9waWNoYXNoKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3BpYyA9IGV2ZW50TmFtZS50b3BpY3NbMF07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodG9waWMpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdG9waWNcIik7IC8vIEBUT0RPOiBNYXkgaGFwcGVuIGZvciBhbm9ueW1vdXMgZXZlbnRzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5pbnRlcmZhY2UuZ2V0RXZlbnQodG9waWMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IEZyYWdtZW50UnVubmluZ0V2ZW50KHRoaXMuYWRkcmVzcywgdGhpcy5pbnRlcmZhY2UsIGZyYWdtZW50LCBldmVudE5hbWUudG9waWNzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgLy8gRmlsdGVyIGJ5IHRoZSB1bmtub3duIHRvcGljaGFzaFxuICAgICAgICAgICAgY29uc3QgZmlsdGVyID0ge1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICB0b3BpY3M6IGV2ZW50TmFtZS50b3BpY3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBSdW5uaW5nRXZlbnQoZ2V0RXZlbnRUYWcoZmlsdGVyKSwgZmlsdGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZVJ1bm5pbmdFdmVudChuZXcgV2lsZGNhcmRSdW5uaW5nRXZlbnQodGhpcy5hZGRyZXNzLCB0aGlzLmludGVyZmFjZSkpO1xuICAgIH1cbiAgICBfY2hlY2tSdW5uaW5nRXZlbnRzKHJ1bm5pbmdFdmVudCkge1xuICAgICAgICBpZiAocnVubmluZ0V2ZW50Lmxpc3RlbmVyQ291bnQoKSA9PT0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3J1bm5pbmdFdmVudHNbcnVubmluZ0V2ZW50LnRhZ107XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9sbGVyIGZvciB0aGlzLCByZW1vdmUgaXRcbiAgICAgICAgICAgIGNvbnN0IGVtaXQgPSB0aGlzLl93cmFwcGVkRW1pdHNbcnVubmluZ0V2ZW50LnRhZ107XG4gICAgICAgICAgICBpZiAoZW1pdCAmJiBydW5uaW5nRXZlbnQuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vZmYocnVubmluZ0V2ZW50LmZpbHRlciwgZW1pdCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3dyYXBwZWRFbWl0c1tydW5uaW5nRXZlbnQudGFnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTdWJjbGFzc2VzIGNhbiBvdmVycmlkZSB0aGlzIHRvIGdyYWNlZnVsbHkgcmVjb3ZlclxuICAgIC8vIGZyb20gcGFyc2UgZXJyb3JzIGlmIHRoZXkgd2lzaFxuICAgIF93cmFwRXZlbnQocnVubmluZ0V2ZW50LCBsb2csIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gZGVlcENvcHkobG9nKTtcbiAgICAgICAgZXZlbnQucmVtb3ZlTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVubmluZ0V2ZW50LnJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUnVubmluZ0V2ZW50cyhydW5uaW5nRXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICBldmVudC5nZXRCbG9jayA9ICgpID0+IHsgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0QmxvY2sobG9nLmJsb2NrSGFzaCk7IH07XG4gICAgICAgIGV2ZW50LmdldFRyYW5zYWN0aW9uID0gKCkgPT4geyByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbihsb2cudHJhbnNhY3Rpb25IYXNoKTsgfTtcbiAgICAgICAgZXZlbnQuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0ID0gKCkgPT4geyByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQobG9nLnRyYW5zYWN0aW9uSGFzaCk7IH07XG4gICAgICAgIC8vIFRoaXMgbWF5IHRocm93IGlmIHRoZSB0b3BpY3MgYW5kIGRhdGEgbWlzbWF0Y2ggdGhlIHNpZ25hdHVyZVxuICAgICAgICBydW5uaW5nRXZlbnQucHJlcGFyZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cbiAgICBfYWRkRXZlbnRMaXN0ZW5lcihydW5uaW5nRXZlbnQsIGxpc3RlbmVyLCBvbmNlKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJldmVudHMgcmVxdWlyZSBhIHByb3ZpZGVyIG9yIGEgc2lnbmVyIHdpdGggYSBwcm92aWRlclwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyBvcGVyYXRpb246IFwib25jZVwiIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJ1bm5pbmdFdmVudC5hZGRMaXN0ZW5lcihsaXN0ZW5lciwgb25jZSk7XG4gICAgICAgIC8vIFRyYWNrIHRoaXMgcnVubmluZyBldmVudCBhbmQgaXRzIGxpc3RlbmVycyAobWF5IGFscmVhZHkgYmUgdGhlcmU7IGJ1dCBubyBoYXJkIGluIHVwZGF0aW5nKVxuICAgICAgICB0aGlzLl9ydW5uaW5nRXZlbnRzW3J1bm5pbmdFdmVudC50YWddID0gcnVubmluZ0V2ZW50O1xuICAgICAgICAvLyBJZiB3ZSBhcmUgbm90IHBvbGxpbmcgdGhlIHByb3ZpZGVyLCBzdGFydCBwb2xsaW5nXG4gICAgICAgIGlmICghdGhpcy5fd3JhcHBlZEVtaXRzW3J1bm5pbmdFdmVudC50YWddKSB7XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVkRW1pdCA9IChsb2cpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnQgPSB0aGlzLl93cmFwRXZlbnQocnVubmluZ0V2ZW50LCBsb2csIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZW1pdCB0aGUgcmVzdWx0IGZvciB0aGUgcGFyYW1ldGVyaXplZCBldmVudC4uLlxuICAgICAgICAgICAgICAgIGlmIChldmVudC5kZWNvZGVFcnJvciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gcnVubmluZ0V2ZW50LmdldEVtaXQoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHJ1bm5pbmdFdmVudC5maWx0ZXIsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGVjb2RlRXJyb3IgPSBlcnJvci5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBbHdheXMgZW1pdCBcImV2ZW50XCIgZm9yIGZyYWdtZW50LWJhc2UgZXZlbnRzXG4gICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmdFdmVudC5maWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJldmVudFwiLCBldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVtaXQgXCJlcnJvclwiIGlmIHRoZXJlIHdhcyBhbiBlcnJvclxuICAgICAgICAgICAgICAgIGlmIChldmVudC5kZWNvZGVFcnJvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGV2ZW50LmRlY29kZUVycm9yLCBldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX3dyYXBwZWRFbWl0c1tydW5uaW5nRXZlbnQudGFnXSA9IHdyYXBwZWRFbWl0O1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBldmVudHMsIGxpa2UgXCJlcnJvclwiIGRvIG5vdCBoYXZlIGEgZmlsdGVyXG4gICAgICAgICAgICBpZiAocnVubmluZ0V2ZW50LmZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbihydW5uaW5nRXZlbnQuZmlsdGVyLCB3cmFwcGVkRW1pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVlcnlGaWx0ZXIoZXZlbnQsIGZyb21CbG9ja09yQmxvY2toYXNoLCB0b0Jsb2NrKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5pbmdFdmVudCA9IHRoaXMuX2dldFJ1bm5pbmdFdmVudChldmVudCk7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHNoYWxsb3dDb3B5KHJ1bm5pbmdFdmVudC5maWx0ZXIpO1xuICAgICAgICBpZiAodHlwZW9mIChmcm9tQmxvY2tPckJsb2NraGFzaCkgPT09IFwic3RyaW5nXCIgJiYgaXNIZXhTdHJpbmcoZnJvbUJsb2NrT3JCbG9ja2hhc2gsIDMyKSkge1xuICAgICAgICAgICAgaWYgKHRvQmxvY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjYW5ub3Qgc3BlY2lmeSB0b0Jsb2NrIHdpdGggYmxvY2toYXNoXCIsIFwidG9CbG9ja1wiLCB0b0Jsb2NrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbHRlci5ibG9ja0hhc2ggPSBmcm9tQmxvY2tPckJsb2NraGFzaDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpbHRlci5mcm9tQmxvY2sgPSAoKGZyb21CbG9ja09yQmxvY2toYXNoICE9IG51bGwpID8gZnJvbUJsb2NrT3JCbG9ja2hhc2ggOiAwKTtcbiAgICAgICAgICAgIGZpbHRlci50b0Jsb2NrID0gKCh0b0Jsb2NrICE9IG51bGwpID8gdG9CbG9jayA6IFwibGF0ZXN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldExvZ3MoZmlsdGVyKS50aGVuKChsb2dzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbG9ncy5tYXAoKGxvZykgPT4gdGhpcy5fd3JhcEV2ZW50KHJ1bm5pbmdFdmVudCwgbG9nLCBudWxsKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnQpLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb25jZShldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnQpLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBlbWl0KGV2ZW50TmFtZSwgLi4uYXJncykge1xuICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW5uaW5nRXZlbnQgPSB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnROYW1lKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gKHJ1bm5pbmdFdmVudC5ydW4oYXJncykgPiAwKTtcbiAgICAgICAgLy8gTWF5IGhhdmUgZHJhaW5lZCBhbGwgdGhlIFwib25jZVwiIGV2ZW50czsgY2hlY2sgZm9yIGxpdmluZyBldmVudHNcbiAgICAgICAgdGhpcy5fY2hlY2tSdW5uaW5nRXZlbnRzKHJ1bm5pbmdFdmVudCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGxpc3RlbmVyQ291bnQoZXZlbnROYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fcnVubmluZ0V2ZW50cykucmVkdWNlKChhY2N1bSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtICsgdGhpcy5fcnVubmluZ0V2ZW50c1trZXldLmxpc3RlbmVyQ291bnQoKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnROYW1lKS5saXN0ZW5lckNvdW50KCk7XG4gICAgfVxuICAgIGxpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHRhZyBpbiB0aGlzLl9ydW5uaW5nRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcnVubmluZ0V2ZW50c1t0YWddLmxpc3RlbmVycygpLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFJ1bm5pbmdFdmVudChldmVudE5hbWUpLmxpc3RlbmVycygpO1xuICAgIH1cbiAgICByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhZyBpbiB0aGlzLl9ydW5uaW5nRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcnVubmluZ0V2ZW50ID0gdGhpcy5fcnVubmluZ0V2ZW50c1t0YWddO1xuICAgICAgICAgICAgICAgIHJ1bm5pbmdFdmVudC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1J1bm5pbmdFdmVudHMocnVubmluZ0V2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlbGV0ZSBhbnkgbGlzdGVuZXJzXG4gICAgICAgIGNvbnN0IHJ1bm5pbmdFdmVudCA9IHRoaXMuX2dldFJ1bm5pbmdFdmVudChldmVudE5hbWUpO1xuICAgICAgICBydW5uaW5nRXZlbnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuX2NoZWNrUnVubmluZ0V2ZW50cyhydW5uaW5nRXZlbnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW5uaW5nRXZlbnQgPSB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnROYW1lKTtcbiAgICAgICAgcnVubmluZ0V2ZW50LnJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5fY2hlY2tSdW5uaW5nRXZlbnRzKHJ1bm5pbmdFdmVudCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ29udHJhY3QgZXh0ZW5kcyBCYXNlQ29udHJhY3Qge1xufVxuZXhwb3J0IGNsYXNzIENvbnRyYWN0RmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3IoY29udHJhY3RJbnRlcmZhY2UsIGJ5dGVjb2RlLCBzaWduZXIpIHtcbiAgICAgICAgbGV0IGJ5dGVjb2RlSGV4ID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiAoYnl0ZWNvZGUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBieXRlY29kZUhleCA9IGJ5dGVjb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQnl0ZXMoYnl0ZWNvZGUpKSB7XG4gICAgICAgICAgICBieXRlY29kZUhleCA9IGhleGxpZnkoYnl0ZWNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJ5dGVjb2RlICYmIHR5cGVvZiAoYnl0ZWNvZGUub2JqZWN0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gQWxsb3cgdGhlIGJ5dGVjb2RlIG9iamVjdCBmcm9tIHRoZSBTb2xpZGl0eSBjb21waWxlclxuICAgICAgICAgICAgYnl0ZWNvZGVIZXggPSBieXRlY29kZS5vYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDcmFzaCBpbiB0aGUgbmV4dCB2ZXJpZmljYXRpb24gc3RlcFxuICAgICAgICAgICAgYnl0ZWNvZGVIZXggPSBcIiFcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgaXQgaXMgMHggcHJlZml4ZWRcbiAgICAgICAgaWYgKGJ5dGVjb2RlSGV4LnN1YnN0cmluZygwLCAyKSAhPT0gXCIweFwiKSB7XG4gICAgICAgICAgICBieXRlY29kZUhleCA9IFwiMHhcIiArIGJ5dGVjb2RlSGV4O1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZmluYWwgcmVzdWx0IGlzIHZhbGlkIGJ5dGVjb2RlXG4gICAgICAgIGlmICghaXNIZXhTdHJpbmcoYnl0ZWNvZGVIZXgpIHx8IChieXRlY29kZUhleC5sZW5ndGggJSAyKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYnl0ZWNvZGVcIiwgXCJieXRlY29kZVwiLCBieXRlY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHNpZ25lciwgbWFrZSBzdXJlIGl0IGlzIHZhbGlkXG4gICAgICAgIGlmIChzaWduZXIgJiYgIVNpZ25lci5pc1NpZ25lcihzaWduZXIpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBzaWduZXJcIiwgXCJzaWduZXJcIiwgc2lnbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImJ5dGVjb2RlXCIsIGJ5dGVjb2RlSGV4KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJpbnRlcmZhY2VcIiwgZ2V0U3RhdGljKG5ldy50YXJnZXQsIFwiZ2V0SW50ZXJmYWNlXCIpKGNvbnRyYWN0SW50ZXJmYWNlKSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwic2lnbmVyXCIsIHNpZ25lciB8fCBudWxsKTtcbiAgICB9XG4gICAgLy8gQFRPRE86IEZ1dHVyZTsgcmVuYW1lIHRvIHBvcHVsYXRlVHJhbnNhY3Rpb24/XG4gICAgZ2V0RGVwbG95VHJhbnNhY3Rpb24oLi4uYXJncykge1xuICAgICAgICBsZXQgdHggPSB7fTtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSAxIGFkZGl0aW9uYWwgYXJndW1lbnQsIHdlIGFsbG93IHRyYW5zYWN0aW9uIG92ZXJyaWRlc1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IHRoaXMuaW50ZXJmYWNlLmRlcGxveS5pbnB1dHMubGVuZ3RoICsgMSAmJiB0eXBlb2YgKGFyZ3NbYXJncy5sZW5ndGggLSAxXSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHR4ID0gc2hhbGxvd0NvcHkoYXJncy5wb3AoKSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0eCkge1xuICAgICAgICAgICAgICAgIGlmICghYWxsb3dlZFRyYW5zYWN0aW9uS2V5c1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHJhbnNhY3Rpb24gb3ZlcnJpZGUgXCIgKyBrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEbyBub3QgYWxsb3cgdGhlc2UgdG8gYmUgb3ZlcnJpZGRlbiBpbiBhIGRlcGxveW1lbnQgdHJhbnNhY3Rpb25cbiAgICAgICAgW1wiZGF0YVwiLCBcImZyb21cIiwgXCJ0b1wiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICh0eFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBvdmVycmlkZSBcIiArIGtleSwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgb3BlcmF0aW9uOiBrZXkgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHgudmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gQmlnTnVtYmVyLmZyb20odHgudmFsdWUpO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZS5pc1plcm8oKSAmJiAhdGhpcy5pbnRlcmZhY2UuZGVwbG95LnBheWFibGUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5vbi1wYXlhYmxlIGNvbnN0cnVjdG9yIGNhbm5vdCBvdmVycmlkZSB2YWx1ZVwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwib3ZlcnJpZGVzLnZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0eC52YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgY2FsbCBtYXRjaGVzIHRoZSBjb25zdHJ1Y3RvciBzaWduYXR1cmVcbiAgICAgICAgbG9nZ2VyLmNoZWNrQXJndW1lbnRDb3VudChhcmdzLmxlbmd0aCwgdGhpcy5pbnRlcmZhY2UuZGVwbG95LmlucHV0cy5sZW5ndGgsIFwiIGluIENvbnRyYWN0IGNvbnN0cnVjdG9yXCIpO1xuICAgICAgICAvLyBTZXQgdGhlIGRhdGEgdG8gdGhlIGJ5dGVjb2RlICsgdGhlIGVuY29kZWQgY29uc3RydWN0b3IgYXJndW1lbnRzXG4gICAgICAgIHR4LmRhdGEgPSBoZXhsaWZ5KGNvbmNhdChbXG4gICAgICAgICAgICB0aGlzLmJ5dGVjb2RlLFxuICAgICAgICAgICAgdGhpcy5pbnRlcmZhY2UuZW5jb2RlRGVwbG95KGFyZ3MpXG4gICAgICAgIF0pKTtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICBkZXBsb3koLi4uYXJncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IG92ZXJyaWRlcyA9IHt9O1xuICAgICAgICAgICAgLy8gSWYgMSBleHRyYSBwYXJhbWV0ZXIgd2FzIHBhc3NlZCBpbiwgaXQgY29udGFpbnMgb3ZlcnJpZGVzXG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IHRoaXMuaW50ZXJmYWNlLmRlcGxveS5pbnB1dHMubGVuZ3RoICsgMSkge1xuICAgICAgICAgICAgICAgIG92ZXJyaWRlcyA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGNhbGwgbWF0Y2hlcyB0aGUgY29uc3RydWN0b3Igc2lnbmF0dXJlXG4gICAgICAgICAgICBsb2dnZXIuY2hlY2tBcmd1bWVudENvdW50KGFyZ3MubGVuZ3RoLCB0aGlzLmludGVyZmFjZS5kZXBsb3kuaW5wdXRzLmxlbmd0aCwgXCIgaW4gQ29udHJhY3QgY29uc3RydWN0b3JcIik7XG4gICAgICAgICAgICAvLyBSZXNvbHZlIEVOUyBuYW1lcyBhbmQgcHJvbWlzZXMgaW4gdGhlIGFyZ3VtZW50c1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0geWllbGQgcmVzb2x2ZUFkZHJlc3Nlcyh0aGlzLnNpZ25lciwgYXJncywgdGhpcy5pbnRlcmZhY2UuZGVwbG95LmlucHV0cyk7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChvdmVycmlkZXMpO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBkZXBsb3ltZW50IHRyYW5zYWN0aW9uICh3aXRoIG9wdGlvbmFsIG92ZXJyaWRlcylcbiAgICAgICAgICAgIGNvbnN0IHVuc2lnbmVkVHggPSB0aGlzLmdldERlcGxveVRyYW5zYWN0aW9uKC4uLnBhcmFtcyk7XG4gICAgICAgICAgICAvLyBTZW5kIHRoZSBkZXBsb3ltZW50IHRyYW5zYWN0aW9uXG4gICAgICAgICAgICBjb25zdCB0eCA9IHlpZWxkIHRoaXMuc2lnbmVyLnNlbmRUcmFuc2FjdGlvbih1bnNpZ25lZFR4KTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJnZXRDb250cmFjdEFkZHJlc3NcIikodHgpO1xuICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJnZXRDb250cmFjdFwiKShhZGRyZXNzLCB0aGlzLmludGVyZmFjZSwgdGhpcy5zaWduZXIpO1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBtb2RpZmllZCB3YWl0IHRoYXQgd3JhcHMgZXZlbnRzXG4gICAgICAgICAgICBhZGRDb250cmFjdFdhaXQoY29udHJhY3QsIHR4KTtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KGNvbnRyYWN0LCBcImRlcGxveVRyYW5zYWN0aW9uXCIsIHR4KTtcbiAgICAgICAgICAgIHJldHVybiBjb250cmFjdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGF0dGFjaChhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5jb25zdHJ1Y3RvcikuZ2V0Q29udHJhY3QoYWRkcmVzcywgdGhpcy5pbnRlcmZhY2UsIHRoaXMuc2lnbmVyKTtcbiAgICB9XG4gICAgY29ubmVjdChzaWduZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAodGhpcy5jb25zdHJ1Y3RvcikodGhpcy5pbnRlcmZhY2UsIHRoaXMuYnl0ZWNvZGUsIHNpZ25lcik7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU29saWRpdHkoY29tcGlsZXJPdXRwdXQsIHNpZ25lcikge1xuICAgICAgICBpZiAoY29tcGlsZXJPdXRwdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJtaXNzaW5nIGNvbXBpbGVyIG91dHB1dFwiLCBMb2dnZXIuZXJyb3JzLk1JU1NJTkdfQVJHVU1FTlQsIHsgYXJndW1lbnQ6IFwiY29tcGlsZXJPdXRwdXRcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChjb21waWxlck91dHB1dCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbXBpbGVyT3V0cHV0ID0gSlNPTi5wYXJzZShjb21waWxlck91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWJpID0gY29tcGlsZXJPdXRwdXQuYWJpO1xuICAgICAgICBsZXQgYnl0ZWNvZGUgPSBudWxsO1xuICAgICAgICBpZiAoY29tcGlsZXJPdXRwdXQuYnl0ZWNvZGUpIHtcbiAgICAgICAgICAgIGJ5dGVjb2RlID0gY29tcGlsZXJPdXRwdXQuYnl0ZWNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcGlsZXJPdXRwdXQuZXZtICYmIGNvbXBpbGVyT3V0cHV0LmV2bS5ieXRlY29kZSkge1xuICAgICAgICAgICAgYnl0ZWNvZGUgPSBjb21waWxlck91dHB1dC5ldm0uYnl0ZWNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKGFiaSwgYnl0ZWNvZGUsIHNpZ25lcik7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRJbnRlcmZhY2UoY29udHJhY3RJbnRlcmZhY2UpIHtcbiAgICAgICAgcmV0dXJuIENvbnRyYWN0LmdldEludGVyZmFjZShjb250cmFjdEludGVyZmFjZSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRDb250cmFjdEFkZHJlc3ModHgpIHtcbiAgICAgICAgcmV0dXJuIGdldENvbnRyYWN0QWRkcmVzcyh0eCk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRDb250cmFjdChhZGRyZXNzLCBjb250cmFjdEludGVyZmFjZSwgc2lnbmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3QoYWRkcmVzcywgY29udHJhY3RJbnRlcmZhY2UsIHNpZ25lcik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsImNoZWNrUmVzdWx0RXJyb3JzIiwiSW5kZXhlZCIsIkludGVyZmFjZSIsIlByb3ZpZGVyIiwiU2lnbmVyIiwiVm9pZFNpZ25lciIsImdldEFkZHJlc3MiLCJnZXRDb250cmFjdEFkZHJlc3MiLCJCaWdOdW1iZXIiLCJhcnJheWlmeSIsImNvbmNhdCIsImhleGxpZnkiLCJpc0J5dGVzIiwiaXNIZXhTdHJpbmciLCJkZWZpbmVSZWFkT25seSIsImRlZXBDb3B5IiwiZ2V0U3RhdGljIiwicmVzb2x2ZVByb3BlcnRpZXMiLCJzaGFsbG93Q29weSIsImFjY2Vzc0xpc3RpZnkiLCJMb2dnZXIiLCJ2ZXJzaW9uIiwibG9nZ2VyIiwiYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyIsImNoYWluSWQiLCJkYXRhIiwiZnJvbSIsImdhc0xpbWl0IiwiZ2FzUHJpY2UiLCJub25jZSIsInRvIiwidHlwZSIsImFjY2Vzc0xpc3QiLCJtYXhGZWVQZXJHYXMiLCJtYXhQcmlvcml0eUZlZVBlckdhcyIsImN1c3RvbURhdGEiLCJjY2lwUmVhZEVuYWJsZWQiLCJyZXNvbHZlTmFtZSIsInJlc29sdmVyIiwibmFtZU9yUHJvbWlzZSIsIm5hbWUiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJlcnJvciIsInRocm93RXJyb3IiLCJlcnJvcnMiLCJVTlNVUFBPUlRFRF9PUEVSQVRJT04iLCJvcGVyYXRpb24iLCJhZGRyZXNzIiwicmVzb2x2ZUFkZHJlc3NlcyIsInBhcmFtVHlwZSIsIkFycmF5IiwiaXNBcnJheSIsImFsbCIsIm1hcCIsImluZGV4IiwiY29tcG9uZW50cyIsImJhc2VUeXBlIiwibWFrZUVycm9yIiwiSU5WQUxJRF9BUkdVTUVOVCIsImFyZ3VtZW50IiwidiIsImFycmF5Q2hpbGRyZW4iLCJwb3B1bGF0ZVRyYW5zYWN0aW9uIiwiY29udHJhY3QiLCJmcmFnbWVudCIsImFyZ3MiLCJvdmVycmlkZXMiLCJsZW5ndGgiLCJpbnB1dHMiLCJwb3AiLCJjaGVja0FyZ3VtZW50Q291bnQiLCJzaWduZXIiLCJvdmVycmlkZSIsImNoZWNrIiwicHJvdmlkZXIiLCJyZXNvbHZlZCIsInJlc29sdmVkQWRkcmVzcyIsImludGVyZmFjZSIsImVuY29kZUZ1bmN0aW9uRGF0YSIsInR4Iiwicm8iLCJ0b051bWJlciIsImdhcyIsImludHJpbnNpYyIsImJ5dGVzIiwiaSIsImFkZCIsInJvVmFsdWUiLCJpc1plcm8iLCJwYXlhYmxlIiwibGVmdG92ZXJzIiwiT2JqZWN0Iiwia2V5cyIsImZpbHRlciIsImtleSIsImwiLCJKU09OIiwic3RyaW5naWZ5Iiwiam9pbiIsImJ1aWxkUG9wdWxhdGUiLCJidWlsZEVzdGltYXRlIiwic2lnbmVyT3JQcm92aWRlciIsImVzdGltYXRlR2FzIiwiYWRkQ29udHJhY3RXYWl0Iiwid2FpdCIsImJpbmQiLCJjb25maXJtYXRpb25zIiwicmVjZWlwdCIsImV2ZW50cyIsImxvZ3MiLCJsb2ciLCJldmVudCIsInBhcnNlZCIsInBhcnNlTG9nIiwiZGVjb2RlIiwidG9waWNzIiwiZGVjb2RlRXZlbnRMb2ciLCJldmVudEZyYWdtZW50IiwiZXZlbnRTaWduYXR1cmUiLCJzaWduYXR1cmUiLCJyZW1vdmVMaXN0ZW5lciIsImdldEJsb2NrIiwiYmxvY2tIYXNoIiwiZ2V0VHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbkhhc2giLCJnZXRUcmFuc2FjdGlvblJlY2VpcHQiLCJidWlsZENhbGwiLCJjb2xsYXBzZVNpbXBsZSIsImJsb2NrVGFnIiwidW5kZWZpbmVkIiwicHVzaCIsImRlcGxveVRyYW5zYWN0aW9uIiwiX2RlcGxveWVkIiwiY2FsbCIsImRlY29kZUZ1bmN0aW9uUmVzdWx0Iiwib3V0cHV0cyIsImNvZGUiLCJDQUxMX0VYQ0VQVElPTiIsInRyYW5zYWN0aW9uIiwiYnVpbGRTZW5kIiwidHhSZXF1ZXN0Iiwic2VuZFRyYW5zYWN0aW9uIiwiYnVpbGREZWZhdWx0IiwiY29uc3RhbnQiLCJnZXRFdmVudFRhZyIsInRvcGljIiwiUnVubmluZ0V2ZW50IiwiY29uc3RydWN0b3IiLCJ0YWciLCJfbGlzdGVuZXJzIiwiYWRkTGlzdGVuZXIiLCJsaXN0ZW5lciIsIm9uY2UiLCJpdGVtIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwibGlzdGVuZXJzIiwibGlzdGVuZXJDb3VudCIsInJ1biIsImFyZ3NDb3B5Iiwic2xpY2UiLCJzZXRUaW1lb3V0IiwicHJlcGFyZUV2ZW50IiwiZ2V0RW1pdCIsIkVycm9yUnVubmluZ0V2ZW50IiwiRnJhZ21lbnRSdW5uaW5nRXZlbnQiLCJjb250cmFjdEludGVyZmFjZSIsImdldEV2ZW50VG9waWMiLCJmb3JtYXQiLCJkZWNvZGVFcnJvciIsIldpbGRjYXJkUnVubmluZ0V2ZW50IiwiQmFzZUNvbnRyYWN0IiwiYWRkcmVzc09yTmFtZSIsImlzU2lnbmVyIiwiaXNQcm92aWRlciIsInVuaXF1ZUZpbHRlcnMiLCJmb3JFYWNoIiwiZmlsdGVycyIsImVuY29kZUZpbHRlclRvcGljcyIsIndhcm4iLCJjYXRjaCIsInVuaXF1ZU5hbWVzIiwidW5pcXVlU2lnbmF0dXJlcyIsImZ1bmN0aW9ucyIsImNhbGxTdGF0aWMiLCJzaWduYXR1cmVzIiwic3Vic3RyaW5nIiwiZ2V0SW50ZXJmYWNlIiwiaXNJbnRlcmZhY2UiLCJkZXBsb3llZCIsIl9kZXBsb3llZFByb21pc2UiLCJnZXRDb2RlIiwiY29udHJhY3RBZGRyZXNzIiwiZmFsbGJhY2siLCJjb25uZWN0IiwiYXR0YWNoIiwiaXNJbmRleGVkIiwiX25vcm1hbGl6ZVJ1bm5pbmdFdmVudCIsInJ1bm5pbmdFdmVudCIsIl9ydW5uaW5nRXZlbnRzIiwiX2dldFJ1bm5pbmdFdmVudCIsImV2ZW50TmFtZSIsImdldEV2ZW50IiwiRXJyb3IiLCJfY2hlY2tSdW5uaW5nRXZlbnRzIiwiZW1pdCIsIl93cmFwcGVkRW1pdHMiLCJvZmYiLCJfd3JhcEV2ZW50IiwiX2FkZEV2ZW50TGlzdGVuZXIiLCJ3cmFwcGVkRW1pdCIsIm9uIiwicXVlcnlGaWx0ZXIiLCJmcm9tQmxvY2tPckJsb2NraGFzaCIsInRvQmxvY2siLCJmcm9tQmxvY2siLCJnZXRMb2dzIiwicmVkdWNlIiwiYWNjdW0iLCJDb250cmFjdCIsIkNvbnRyYWN0RmFjdG9yeSIsImJ5dGVjb2RlIiwiYnl0ZWNvZGVIZXgiLCJvYmplY3QiLCJnZXREZXBsb3lUcmFuc2FjdGlvbiIsImRlcGxveSIsImVuY29kZURlcGxveSIsInBhcmFtcyIsInVuc2lnbmVkVHgiLCJnZXRDb250cmFjdCIsImZyb21Tb2xpZGl0eSIsImNvbXBpbGVyT3V0cHV0IiwiTUlTU0lOR19BUkdVTUVOVCIsInBhcnNlIiwiYWJpIiwiZXZtIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/contracts/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/_version.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/_version.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"hash/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLFVBQVUsYUFBYSxDQUNwQyxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbGltZS1iZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi5lc20vX3ZlcnNpb24uanM/ZTZhYSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiaGFzaC81LjcuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode_arithmetic: () => (/* binding */ decode_arithmetic),\n/* harmony export */   read_compressed_payload: () => (/* binding */ read_compressed_payload),\n/* harmony export */   read_emoji_trie: () => (/* binding */ read_emoji_trie),\n/* harmony export */   read_mapped_map: () => (/* binding */ read_mapped_map),\n/* harmony export */   read_member_array: () => (/* binding */ read_member_array),\n/* harmony export */   read_payload: () => (/* binding */ read_payload),\n/* harmony export */   read_zero_terminated_array: () => (/* binding */ read_zero_terminated_array),\n/* harmony export */   signed: () => (/* binding */ signed)\n/* harmony export */ });\n/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */ // https://github.com/behnammodi/polyfill/blob/master/array.polyfill.js\nfunction flat(array, depth) {\n    if (depth == null) {\n        depth = 1;\n    }\n    const result = [];\n    const forEach = result.forEach;\n    const flatDeep = function(arr, depth) {\n        forEach.call(arr, function(val) {\n            if (depth > 0 && Array.isArray(val)) {\n                flatDeep(val, depth - 1);\n            } else {\n                result.push(val);\n            }\n        });\n    };\n    flatDeep(array, depth);\n    return result;\n}\nfunction fromEntries(array) {\n    const result = {};\n    for(let i = 0; i < array.length; i++){\n        const value = array[i];\n        result[value[0]] = value[1];\n    }\n    return result;\n}\nfunction decode_arithmetic(bytes) {\n    let pos = 0;\n    function u16() {\n        return bytes[pos++] << 8 | bytes[pos++];\n    }\n    // decode the frequency table\n    let symbol_count = u16();\n    let total = 1;\n    let acc = [\n        0,\n        1\n    ]; // first symbol has frequency 1\n    for(let i = 1; i < symbol_count; i++){\n        acc.push(total += u16());\n    }\n    // skip the sized-payload that the last 3 symbols index into\n    let skip = u16();\n    let pos_payload = pos;\n    pos += skip;\n    let read_width = 0;\n    let read_buffer = 0;\n    function read_bit() {\n        if (read_width == 0) {\n            // this will read beyond end of buffer\n            // but (undefined|0) => zero pad\n            read_buffer = read_buffer << 8 | bytes[pos++];\n            read_width = 8;\n        }\n        return read_buffer >> --read_width & 1;\n    }\n    const N = 31;\n    const FULL = Math.pow(2, N);\n    const HALF = FULL >>> 1;\n    const QRTR = HALF >> 1;\n    const MASK = FULL - 1;\n    // fill register\n    let register = 0;\n    for(let i = 0; i < N; i++)register = register << 1 | read_bit();\n    let symbols = [];\n    let low = 0;\n    let range = FULL; // treat like a float\n    while(true){\n        let value = Math.floor(((register - low + 1) * total - 1) / range);\n        let start = 0;\n        let end = symbol_count;\n        while(end - start > 1){\n            let mid = start + end >>> 1;\n            if (value < acc[mid]) {\n                end = mid;\n            } else {\n                start = mid;\n            }\n        }\n        if (start == 0) break; // first symbol is end mark\n        symbols.push(start);\n        let a = low + Math.floor(range * acc[start] / total);\n        let b = low + Math.floor(range * acc[start + 1] / total) - 1;\n        while(((a ^ b) & HALF) == 0){\n            register = register << 1 & MASK | read_bit();\n            a = a << 1 & MASK;\n            b = b << 1 & MASK | 1;\n        }\n        while(a & ~b & QRTR){\n            register = register & HALF | register << 1 & MASK >>> 1 | read_bit();\n            a = a << 1 ^ HALF;\n            b = (b ^ HALF) << 1 | HALF | 1;\n        }\n        low = a;\n        range = 1 + b - a;\n    }\n    let offset = symbol_count - 4;\n    return symbols.map((x)=>{\n        switch(x - offset){\n            case 3:\n                return offset + 0x10100 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n            case 2:\n                return offset + 0x100 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n            case 1:\n                return offset + bytes[pos_payload++];\n            default:\n                return x - 1;\n        }\n    });\n}\n// returns an iterator which returns the next symbol\nfunction read_payload(v) {\n    let pos = 0;\n    return ()=>v[pos++];\n}\nfunction read_compressed_payload(bytes) {\n    return read_payload(decode_arithmetic(bytes));\n}\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\nfunction signed(i) {\n    return i & 1 ? ~i >> 1 : i >> 1;\n}\nfunction read_counts(n, next) {\n    let v = Array(n);\n    for(let i = 0; i < n; i++)v[i] = 1 + next();\n    return v;\n}\nfunction read_ascending(n, next) {\n    let v = Array(n);\n    for(let i = 0, x = -1; i < n; i++)v[i] = x += 1 + next();\n    return v;\n}\nfunction read_deltas(n, next) {\n    let v = Array(n);\n    for(let i = 0, x = 0; i < n; i++)v[i] = x += signed(next());\n    return v;\n}\nfunction read_member_array(next, lookup) {\n    let v = read_ascending(next(), next);\n    let n = next();\n    let vX = read_ascending(n, next);\n    let vN = read_counts(n, next);\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < vN[i]; j++){\n            v.push(vX[i] + j);\n        }\n    }\n    return lookup ? v.map((x)=>lookup[x]) : v;\n}\n// returns array of \n// [x, ys] => single replacement rule\n// [x, ys, n, dx, dx] => linear map\nfunction read_mapped_map(next) {\n    let ret = [];\n    while(true){\n        let w = next();\n        if (w == 0) break;\n        ret.push(read_linear_table(w, next));\n    }\n    while(true){\n        let w = next() - 1;\n        if (w < 0) break;\n        ret.push(read_replacement_table(w, next));\n    }\n    return fromEntries(flat(ret));\n}\nfunction read_zero_terminated_array(next) {\n    let v = [];\n    while(true){\n        let i = next();\n        if (i == 0) break;\n        v.push(i);\n    }\n    return v;\n}\nfunction read_transposed(n, w, next) {\n    let m = Array(n).fill(undefined).map(()=>[]);\n    for(let i = 0; i < w; i++){\n        read_deltas(n, next).forEach((x, j)=>m[j].push(x));\n    }\n    return m;\n}\nfunction read_linear_table(w, next) {\n    let dx = 1 + next();\n    let dy = next();\n    let vN = read_zero_terminated_array(next);\n    let m = read_transposed(vN.length, 1 + w, next);\n    return flat(m.map((v, i)=>{\n        const x = v[0], ys = v.slice(1);\n        //let [x, ...ys] = v;\n        //return Array(vN[i]).fill().map((_, j) => {\n        return Array(vN[i]).fill(undefined).map((_, j)=>{\n            let j_dy = j * dy;\n            return [\n                x + j * dx,\n                ys.map((y)=>y + j_dy)\n            ];\n        });\n    }));\n}\nfunction read_replacement_table(w, next) {\n    let n = 1 + next();\n    let m = read_transposed(n, 1 + w, next);\n    return m.map((v)=>[\n            v[0],\n            v.slice(1)\n        ]);\n}\nfunction read_emoji_trie(next) {\n    let sorted = read_member_array(next).sort((a, b)=>a - b);\n    return read();\n    function read() {\n        let branches = [];\n        while(true){\n            let keys = read_member_array(next, sorted);\n            if (keys.length == 0) break;\n            branches.push({\n                set: new Set(keys),\n                node: read()\n            });\n        }\n        branches.sort((a, b)=>b.set.size - a.set.size); // sort by likelihood\n        let temp = next();\n        let valid = temp % 3;\n        temp = temp / 3 | 0;\n        let fe0f = !!(temp & 1);\n        temp >>= 1;\n        let save = temp == 1;\n        let check = temp == 2;\n        return {\n            branches,\n            valid,\n            fe0f,\n            save,\n            check\n        };\n    }\n} //# sourceMappingURL=decoder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi5lc20vZW5zLW5vcm1hbGl6ZS9kZWNvZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTJCQyxHQUNELHVFQUF1RTtBQUN2RSxTQUFTQSxLQUFLQyxLQUFLLEVBQUVDLEtBQUs7SUFDdEIsSUFBSUEsU0FBUyxNQUFNO1FBQ2ZBLFFBQVE7SUFDWjtJQUNBLE1BQU1DLFNBQVMsRUFBRTtJQUNqQixNQUFNQyxVQUFVRCxPQUFPQyxPQUFPO0lBQzlCLE1BQU1DLFdBQVcsU0FBVUMsR0FBRyxFQUFFSixLQUFLO1FBQ2pDRSxRQUFRRyxJQUFJLENBQUNELEtBQUssU0FBVUUsR0FBRztZQUMzQixJQUFJTixRQUFRLEtBQUtPLE1BQU1DLE9BQU8sQ0FBQ0YsTUFBTTtnQkFDakNILFNBQVNHLEtBQUtOLFFBQVE7WUFDMUIsT0FDSztnQkFDREMsT0FBT1EsSUFBSSxDQUFDSDtZQUNoQjtRQUNKO0lBQ0o7SUFDQUgsU0FBU0osT0FBT0M7SUFDaEIsT0FBT0M7QUFDWDtBQUNBLFNBQVNTLFlBQVlYLEtBQUs7SUFDdEIsTUFBTUUsU0FBUyxDQUFDO0lBQ2hCLElBQUssSUFBSVUsSUFBSSxHQUFHQSxJQUFJWixNQUFNYSxNQUFNLEVBQUVELElBQUs7UUFDbkMsTUFBTUUsUUFBUWQsS0FBSyxDQUFDWSxFQUFFO1FBQ3RCVixNQUFNLENBQUNZLEtBQUssQ0FBQyxFQUFFLENBQUMsR0FBR0EsS0FBSyxDQUFDLEVBQUU7SUFDL0I7SUFDQSxPQUFPWjtBQUNYO0FBQ08sU0FBU2Esa0JBQWtCQyxLQUFLO0lBQ25DLElBQUlDLE1BQU07SUFDVixTQUFTQztRQUFRLE9BQU8sS0FBTSxDQUFDRCxNQUFNLElBQUksSUFBS0QsS0FBSyxDQUFDQyxNQUFNO0lBQUU7SUFDNUQsNkJBQTZCO0lBQzdCLElBQUlFLGVBQWVEO0lBQ25CLElBQUlFLFFBQVE7SUFDWixJQUFJQyxNQUFNO1FBQUM7UUFBRztLQUFFLEVBQUUsK0JBQStCO0lBQ2pELElBQUssSUFBSVQsSUFBSSxHQUFHQSxJQUFJTyxjQUFjUCxJQUFLO1FBQ25DUyxJQUFJWCxJQUFJLENBQUNVLFNBQVNGO0lBQ3RCO0lBQ0EsNERBQTREO0lBQzVELElBQUlJLE9BQU9KO0lBQ1gsSUFBSUssY0FBY047SUFDbEJBLE9BQU9LO0lBQ1AsSUFBSUUsYUFBYTtJQUNqQixJQUFJQyxjQUFjO0lBQ2xCLFNBQVNDO1FBQ0wsSUFBSUYsY0FBYyxHQUFHO1lBQ2pCLHNDQUFzQztZQUN0QyxnQ0FBZ0M7WUFDaENDLGNBQWMsZUFBZ0IsSUFBS1QsS0FBSyxDQUFDQyxNQUFNO1lBQy9DTyxhQUFhO1FBQ2pCO1FBQ0EsT0FBTyxlQUFnQixFQUFFQSxhQUFjO0lBQzNDO0lBQ0EsTUFBTUcsSUFBSTtJQUNWLE1BQU1DLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQyxHQUFHSDtJQUN6QixNQUFNSSxPQUFPSCxTQUFTO0lBQ3RCLE1BQU1JLE9BQU9ELFFBQVE7SUFDckIsTUFBTUUsT0FBT0wsT0FBTztJQUNwQixnQkFBZ0I7SUFDaEIsSUFBSU0sV0FBVztJQUNmLElBQUssSUFBSXRCLElBQUksR0FBR0EsSUFBSWUsR0FBR2YsSUFDbkJzQixXQUFXLFlBQWEsSUFBS1I7SUFDakMsSUFBSVMsVUFBVSxFQUFFO0lBQ2hCLElBQUlDLE1BQU07SUFDVixJQUFJQyxRQUFRVCxNQUFNLHFCQUFxQjtJQUN2QyxNQUFPLEtBQU07UUFDVCxJQUFJZCxRQUFRZSxLQUFLUyxLQUFLLENBQUMsQ0FBQyxDQUFFSixXQUFXRSxNQUFNLEtBQUtoQixRQUFTLEtBQUtpQjtRQUM5RCxJQUFJRSxRQUFRO1FBQ1osSUFBSUMsTUFBTXJCO1FBQ1YsTUFBT3FCLE1BQU1ELFFBQVEsRUFBRztZQUNwQixJQUFJRSxNQUFNLFFBQVNELFFBQVM7WUFDNUIsSUFBSTFCLFFBQVFPLEdBQUcsQ0FBQ29CLElBQUksRUFBRTtnQkFDbEJELE1BQU1DO1lBQ1YsT0FDSztnQkFDREYsUUFBUUU7WUFDWjtRQUNKO1FBQ0EsSUFBSUYsU0FBUyxHQUNULE9BQU8sMkJBQTJCO1FBQ3RDSixRQUFRekIsSUFBSSxDQUFDNkI7UUFDYixJQUFJRyxJQUFJTixNQUFNUCxLQUFLUyxLQUFLLENBQUNELFFBQVFoQixHQUFHLENBQUNrQixNQUFNLEdBQUduQjtRQUM5QyxJQUFJdUIsSUFBSVAsTUFBTVAsS0FBS1MsS0FBSyxDQUFDRCxRQUFRaEIsR0FBRyxDQUFDa0IsUUFBUSxFQUFFLEdBQUduQixTQUFTO1FBQzNELE1BQU8sQ0FBQyxDQUFDc0IsSUFBSUMsQ0FBQUEsSUFBS1osSUFBRyxLQUFNLEVBQUc7WUFDMUJHLFdBQVcsWUFBYSxJQUFLRCxPQUFPUDtZQUNwQ2dCLElBQUksS0FBTSxJQUFLVDtZQUNmVSxJQUFJLEtBQU0sSUFBS1YsT0FBTztRQUMxQjtRQUNBLE1BQU9TLElBQUksQ0FBQ0MsSUFBSVgsS0FBTTtZQUNsQkUsV0FBVyxXQUFZSCxPQUFTLFlBQWEsSUFBTUUsU0FBUyxJQUFNUDtZQUNsRWdCLElBQUksS0FBTSxJQUFLWDtZQUNmWSxJQUFJLENBQUVBLElBQUlaLElBQUcsS0FBTSxJQUFLQSxPQUFPO1FBQ25DO1FBQ0FLLE1BQU1NO1FBQ05MLFFBQVEsSUFBSU0sSUFBSUQ7SUFDcEI7SUFDQSxJQUFJRSxTQUFTekIsZUFBZTtJQUM1QixPQUFPZ0IsUUFBUVUsR0FBRyxDQUFDQyxDQUFBQTtRQUNmLE9BQVFBLElBQUlGO1lBQ1IsS0FBSztnQkFBRyxPQUFPQSxTQUFTLFVBQVcsTUFBTSxDQUFDckIsY0FBYyxJQUFJLEtBQU9QLEtBQUssQ0FBQ08sY0FBYyxJQUFJLElBQUtQLEtBQUssQ0FBQ08sY0FBYztZQUNwSCxLQUFLO2dCQUFHLE9BQU9xQixTQUFTLFFBQVMsTUFBTSxDQUFDckIsY0FBYyxJQUFJLElBQUtQLEtBQUssQ0FBQ08sY0FBYztZQUNuRixLQUFLO2dCQUFHLE9BQU9xQixTQUFTNUIsS0FBSyxDQUFDTyxjQUFjO1lBQzVDO2dCQUFTLE9BQU91QixJQUFJO1FBQ3hCO0lBQ0o7QUFDSjtBQUNBLG9EQUFvRDtBQUM3QyxTQUFTQyxhQUFhQyxDQUFDO0lBQzFCLElBQUkvQixNQUFNO0lBQ1YsT0FBTyxJQUFNK0IsQ0FBQyxDQUFDL0IsTUFBTTtBQUN6QjtBQUNPLFNBQVNnQyx3QkFBd0JqQyxLQUFLO0lBQ3pDLE9BQU8rQixhQUFhaEMsa0JBQWtCQztBQUMxQztBQUNBLHNDQUFzQztBQUMvQixTQUFTa0MsT0FBT3RDLENBQUM7SUFDcEIsT0FBTyxJQUFLLElBQU0sQ0FBQ0EsS0FBSyxJQUFNQSxLQUFLO0FBQ3ZDO0FBQ0EsU0FBU3VDLFlBQVlDLENBQUMsRUFBRUMsSUFBSTtJQUN4QixJQUFJTCxJQUFJeEMsTUFBTTRDO0lBQ2QsSUFBSyxJQUFJeEMsSUFBSSxHQUFHQSxJQUFJd0MsR0FBR3hDLElBQ25Cb0MsQ0FBQyxDQUFDcEMsRUFBRSxHQUFHLElBQUl5QztJQUNmLE9BQU9MO0FBQ1g7QUFDQSxTQUFTTSxlQUFlRixDQUFDLEVBQUVDLElBQUk7SUFDM0IsSUFBSUwsSUFBSXhDLE1BQU00QztJQUNkLElBQUssSUFBSXhDLElBQUksR0FBR2tDLElBQUksQ0FBQyxHQUFHbEMsSUFBSXdDLEdBQUd4QyxJQUMzQm9DLENBQUMsQ0FBQ3BDLEVBQUUsR0FBR2tDLEtBQUssSUFBSU87SUFDcEIsT0FBT0w7QUFDWDtBQUNBLFNBQVNPLFlBQVlILENBQUMsRUFBRUMsSUFBSTtJQUN4QixJQUFJTCxJQUFJeEMsTUFBTTRDO0lBQ2QsSUFBSyxJQUFJeEMsSUFBSSxHQUFHa0MsSUFBSSxHQUFHbEMsSUFBSXdDLEdBQUd4QyxJQUMxQm9DLENBQUMsQ0FBQ3BDLEVBQUUsR0FBR2tDLEtBQUtJLE9BQU9HO0lBQ3ZCLE9BQU9MO0FBQ1g7QUFDTyxTQUFTUSxrQkFBa0JILElBQUksRUFBRUksTUFBTTtJQUMxQyxJQUFJVCxJQUFJTSxlQUFlRCxRQUFRQTtJQUMvQixJQUFJRCxJQUFJQztJQUNSLElBQUlLLEtBQUtKLGVBQWVGLEdBQUdDO0lBQzNCLElBQUlNLEtBQUtSLFlBQVlDLEdBQUdDO0lBQ3hCLElBQUssSUFBSXpDLElBQUksR0FBR0EsSUFBSXdDLEdBQUd4QyxJQUFLO1FBQ3hCLElBQUssSUFBSWdELElBQUksR0FBR0EsSUFBSUQsRUFBRSxDQUFDL0MsRUFBRSxFQUFFZ0QsSUFBSztZQUM1QlosRUFBRXRDLElBQUksQ0FBQ2dELEVBQUUsQ0FBQzlDLEVBQUUsR0FBR2dEO1FBQ25CO0lBQ0o7SUFDQSxPQUFPSCxTQUFTVCxFQUFFSCxHQUFHLENBQUNDLENBQUFBLElBQUtXLE1BQU0sQ0FBQ1gsRUFBRSxJQUFJRTtBQUM1QztBQUNBLG9CQUFvQjtBQUNwQixxQ0FBcUM7QUFDckMsbUNBQW1DO0FBQzVCLFNBQVNhLGdCQUFnQlIsSUFBSTtJQUNoQyxJQUFJUyxNQUFNLEVBQUU7SUFDWixNQUFPLEtBQU07UUFDVCxJQUFJQyxJQUFJVjtRQUNSLElBQUlVLEtBQUssR0FDTDtRQUNKRCxJQUFJcEQsSUFBSSxDQUFDc0Qsa0JBQWtCRCxHQUFHVjtJQUNsQztJQUNBLE1BQU8sS0FBTTtRQUNULElBQUlVLElBQUlWLFNBQVM7UUFDakIsSUFBSVUsSUFBSSxHQUNKO1FBQ0pELElBQUlwRCxJQUFJLENBQUN1RCx1QkFBdUJGLEdBQUdWO0lBQ3ZDO0lBQ0EsT0FBTzFDLFlBQVlaLEtBQUsrRDtBQUM1QjtBQUNPLFNBQVNJLDJCQUEyQmIsSUFBSTtJQUMzQyxJQUFJTCxJQUFJLEVBQUU7SUFDVixNQUFPLEtBQU07UUFDVCxJQUFJcEMsSUFBSXlDO1FBQ1IsSUFBSXpDLEtBQUssR0FDTDtRQUNKb0MsRUFBRXRDLElBQUksQ0FBQ0U7SUFDWDtJQUNBLE9BQU9vQztBQUNYO0FBQ0EsU0FBU21CLGdCQUFnQmYsQ0FBQyxFQUFFVyxDQUFDLEVBQUVWLElBQUk7SUFDL0IsSUFBSWUsSUFBSTVELE1BQU00QyxHQUFHaUIsSUFBSSxDQUFDQyxXQUFXekIsR0FBRyxDQUFDLElBQU0sRUFBRTtJQUM3QyxJQUFLLElBQUlqQyxJQUFJLEdBQUdBLElBQUltRCxHQUFHbkQsSUFBSztRQUN4QjJDLFlBQVlILEdBQUdDLE1BQU1sRCxPQUFPLENBQUMsQ0FBQzJDLEdBQUdjLElBQU1RLENBQUMsQ0FBQ1IsRUFBRSxDQUFDbEQsSUFBSSxDQUFDb0M7SUFDckQ7SUFDQSxPQUFPc0I7QUFDWDtBQUNBLFNBQVNKLGtCQUFrQkQsQ0FBQyxFQUFFVixJQUFJO0lBQzlCLElBQUlrQixLQUFLLElBQUlsQjtJQUNiLElBQUltQixLQUFLbkI7SUFDVCxJQUFJTSxLQUFLTywyQkFBMkJiO0lBQ3BDLElBQUllLElBQUlELGdCQUFnQlIsR0FBRzlDLE1BQU0sRUFBRSxJQUFJa0QsR0FBR1Y7SUFDMUMsT0FBT3RELEtBQUtxRSxFQUFFdkIsR0FBRyxDQUFDLENBQUNHLEdBQUdwQztRQUNsQixNQUFNa0MsSUFBSUUsQ0FBQyxDQUFDLEVBQUUsRUFBRXlCLEtBQUt6QixFQUFFMEIsS0FBSyxDQUFDO1FBQzdCLHFCQUFxQjtRQUNyQiw0Q0FBNEM7UUFDNUMsT0FBT2xFLE1BQU1tRCxFQUFFLENBQUMvQyxFQUFFLEVBQUV5RCxJQUFJLENBQUNDLFdBQVd6QixHQUFHLENBQUMsQ0FBQzhCLEdBQUdmO1lBQ3hDLElBQUlnQixPQUFPaEIsSUFBSVk7WUFDZixPQUFPO2dCQUFDMUIsSUFBSWMsSUFBSVc7Z0JBQUlFLEdBQUc1QixHQUFHLENBQUNnQyxDQUFBQSxJQUFLQSxJQUFJRDthQUFNO1FBQzlDO0lBQ0o7QUFDSjtBQUNBLFNBQVNYLHVCQUF1QkYsQ0FBQyxFQUFFVixJQUFJO0lBQ25DLElBQUlELElBQUksSUFBSUM7SUFDWixJQUFJZSxJQUFJRCxnQkFBZ0JmLEdBQUcsSUFBSVcsR0FBR1Y7SUFDbEMsT0FBT2UsRUFBRXZCLEdBQUcsQ0FBQ0csQ0FBQUEsSUFBSztZQUFDQSxDQUFDLENBQUMsRUFBRTtZQUFFQSxFQUFFMEIsS0FBSyxDQUFDO1NBQUc7QUFDeEM7QUFDTyxTQUFTSSxnQkFBZ0J6QixJQUFJO0lBQ2hDLElBQUkwQixTQUFTdkIsa0JBQWtCSCxNQUFNMkIsSUFBSSxDQUFDLENBQUN0QyxHQUFHQyxJQUFNRCxJQUFJQztJQUN4RCxPQUFPc0M7SUFDUCxTQUFTQTtRQUNMLElBQUlDLFdBQVcsRUFBRTtRQUNqQixNQUFPLEtBQU07WUFDVCxJQUFJQyxPQUFPM0Isa0JBQWtCSCxNQUFNMEI7WUFDbkMsSUFBSUksS0FBS3RFLE1BQU0sSUFBSSxHQUNmO1lBQ0pxRSxTQUFTeEUsSUFBSSxDQUFDO2dCQUFFMEUsS0FBSyxJQUFJQyxJQUFJRjtnQkFBT0csTUFBTUw7WUFBTztRQUNyRDtRQUNBQyxTQUFTRixJQUFJLENBQUMsQ0FBQ3RDLEdBQUdDLElBQU1BLEVBQUV5QyxHQUFHLENBQUNHLElBQUksR0FBRzdDLEVBQUUwQyxHQUFHLENBQUNHLElBQUksR0FBRyxxQkFBcUI7UUFDdkUsSUFBSUMsT0FBT25DO1FBQ1gsSUFBSW9DLFFBQVFELE9BQU87UUFDbkJBLE9BQU8sT0FBUSxJQUFLO1FBQ3BCLElBQUlFLE9BQU8sQ0FBQyxDQUFFRixDQUFBQSxPQUFPO1FBQ3JCQSxTQUFTO1FBQ1QsSUFBSUcsT0FBT0gsUUFBUTtRQUNuQixJQUFJSSxRQUFRSixRQUFRO1FBQ3BCLE9BQU87WUFBRU47WUFBVU87WUFBT0M7WUFBTUM7WUFBTUM7UUFBTTtJQUNoRDtBQUNKLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2xpbWUtYmV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvaGFzaC9saWIuZXNtL2Vucy1ub3JtYWxpemUvZGVjb2Rlci5qcz9iNTE5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTUlUIExpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjEgQW5kcmV3IFJhZmZlbnNwZXJnZXJcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICpcbiAqIFRoaXMgaXMgYSBuZWFyIGNhcmJvbi1jb3B5IG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UgKGxpbmsgYmVsb3cpIHdpdGggdGhlXG4gKiBUeXBlU2NyaXB0IHR5cGluZ3MgYWRkZWQgYW5kIGEgZmV3IHR3ZWFrcyB0byBtYWtlIGl0IEVTMy1jb21wYXRpYmxlLlxuICpcbiAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qc1xuICovXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYmVobmFtbW9kaS9wb2x5ZmlsbC9ibG9iL21hc3Rlci9hcnJheS5wb2x5ZmlsbC5qc1xuZnVuY3Rpb24gZmxhdChhcnJheSwgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPT0gbnVsbCkge1xuICAgICAgICBkZXB0aCA9IDE7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IGZvckVhY2ggPSByZXN1bHQuZm9yRWFjaDtcbiAgICBjb25zdCBmbGF0RGVlcCA9IGZ1bmN0aW9uIChhcnIsIGRlcHRoKSB7XG4gICAgICAgIGZvckVhY2guY2FsbChhcnIsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGlmIChkZXB0aCA+IDAgJiYgQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgZmxhdERlZXAodmFsLCBkZXB0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBmbGF0RGVlcChhcnJheSwgZGVwdGgpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmcm9tRW50cmllcyhhcnJheSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhcnJheVtpXTtcbiAgICAgICAgcmVzdWx0W3ZhbHVlWzBdXSA9IHZhbHVlWzFdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZV9hcml0aG1ldGljKGJ5dGVzKSB7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgZnVuY3Rpb24gdTE2KCkgeyByZXR1cm4gKGJ5dGVzW3BvcysrXSA8PCA4KSB8IGJ5dGVzW3BvcysrXTsgfVxuICAgIC8vIGRlY29kZSB0aGUgZnJlcXVlbmN5IHRhYmxlXG4gICAgbGV0IHN5bWJvbF9jb3VudCA9IHUxNigpO1xuICAgIGxldCB0b3RhbCA9IDE7XG4gICAgbGV0IGFjYyA9IFswLCAxXTsgLy8gZmlyc3Qgc3ltYm9sIGhhcyBmcmVxdWVuY3kgMVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3ltYm9sX2NvdW50OyBpKyspIHtcbiAgICAgICAgYWNjLnB1c2godG90YWwgKz0gdTE2KCkpO1xuICAgIH1cbiAgICAvLyBza2lwIHRoZSBzaXplZC1wYXlsb2FkIHRoYXQgdGhlIGxhc3QgMyBzeW1ib2xzIGluZGV4IGludG9cbiAgICBsZXQgc2tpcCA9IHUxNigpO1xuICAgIGxldCBwb3NfcGF5bG9hZCA9IHBvcztcbiAgICBwb3MgKz0gc2tpcDtcbiAgICBsZXQgcmVhZF93aWR0aCA9IDA7XG4gICAgbGV0IHJlYWRfYnVmZmVyID0gMDtcbiAgICBmdW5jdGlvbiByZWFkX2JpdCgpIHtcbiAgICAgICAgaWYgKHJlYWRfd2lkdGggPT0gMCkge1xuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIHJlYWQgYmV5b25kIGVuZCBvZiBidWZmZXJcbiAgICAgICAgICAgIC8vIGJ1dCAodW5kZWZpbmVkfDApID0+IHplcm8gcGFkXG4gICAgICAgICAgICByZWFkX2J1ZmZlciA9IChyZWFkX2J1ZmZlciA8PCA4KSB8IGJ5dGVzW3BvcysrXTtcbiAgICAgICAgICAgIHJlYWRfd2lkdGggPSA4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAocmVhZF9idWZmZXIgPj4gLS1yZWFkX3dpZHRoKSAmIDE7XG4gICAgfVxuICAgIGNvbnN0IE4gPSAzMTtcbiAgICBjb25zdCBGVUxMID0gTWF0aC5wb3coMiwgTik7XG4gICAgY29uc3QgSEFMRiA9IEZVTEwgPj4+IDE7XG4gICAgY29uc3QgUVJUUiA9IEhBTEYgPj4gMTtcbiAgICBjb25zdCBNQVNLID0gRlVMTCAtIDE7XG4gICAgLy8gZmlsbCByZWdpc3RlclxuICAgIGxldCByZWdpc3RlciA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyBpKyspXG4gICAgICAgIHJlZ2lzdGVyID0gKHJlZ2lzdGVyIDw8IDEpIHwgcmVhZF9iaXQoKTtcbiAgICBsZXQgc3ltYm9scyA9IFtdO1xuICAgIGxldCBsb3cgPSAwO1xuICAgIGxldCByYW5nZSA9IEZVTEw7IC8vIHRyZWF0IGxpa2UgYSBmbG9hdFxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IE1hdGguZmxvb3IoKCgocmVnaXN0ZXIgLSBsb3cgKyAxKSAqIHRvdGFsKSAtIDEpIC8gcmFuZ2UpO1xuICAgICAgICBsZXQgc3RhcnQgPSAwO1xuICAgICAgICBsZXQgZW5kID0gc3ltYm9sX2NvdW50O1xuICAgICAgICB3aGlsZSAoZW5kIC0gc3RhcnQgPiAxKSB7IC8vIGJpbmFyeSBzZWFyY2hcbiAgICAgICAgICAgIGxldCBtaWQgPSAoc3RhcnQgKyBlbmQpID4+PiAxO1xuICAgICAgICAgICAgaWYgKHZhbHVlIDwgYWNjW21pZF0pIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPT0gMClcbiAgICAgICAgICAgIGJyZWFrOyAvLyBmaXJzdCBzeW1ib2wgaXMgZW5kIG1hcmtcbiAgICAgICAgc3ltYm9scy5wdXNoKHN0YXJ0KTtcbiAgICAgICAgbGV0IGEgPSBsb3cgKyBNYXRoLmZsb29yKHJhbmdlICogYWNjW3N0YXJ0XSAvIHRvdGFsKTtcbiAgICAgICAgbGV0IGIgPSBsb3cgKyBNYXRoLmZsb29yKHJhbmdlICogYWNjW3N0YXJ0ICsgMV0gLyB0b3RhbCkgLSAxO1xuICAgICAgICB3aGlsZSAoKChhIF4gYikgJiBIQUxGKSA9PSAwKSB7XG4gICAgICAgICAgICByZWdpc3RlciA9IChyZWdpc3RlciA8PCAxKSAmIE1BU0sgfCByZWFkX2JpdCgpO1xuICAgICAgICAgICAgYSA9IChhIDw8IDEpICYgTUFTSztcbiAgICAgICAgICAgIGIgPSAoYiA8PCAxKSAmIE1BU0sgfCAxO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChhICYgfmIgJiBRUlRSKSB7XG4gICAgICAgICAgICByZWdpc3RlciA9IChyZWdpc3RlciAmIEhBTEYpIHwgKChyZWdpc3RlciA8PCAxKSAmIChNQVNLID4+PiAxKSkgfCByZWFkX2JpdCgpO1xuICAgICAgICAgICAgYSA9IChhIDw8IDEpIF4gSEFMRjtcbiAgICAgICAgICAgIGIgPSAoKGIgXiBIQUxGKSA8PCAxKSB8IEhBTEYgfCAxO1xuICAgICAgICB9XG4gICAgICAgIGxvdyA9IGE7XG4gICAgICAgIHJhbmdlID0gMSArIGIgLSBhO1xuICAgIH1cbiAgICBsZXQgb2Zmc2V0ID0gc3ltYm9sX2NvdW50IC0gNDtcbiAgICByZXR1cm4gc3ltYm9scy5tYXAoeCA9PiB7XG4gICAgICAgIHN3aXRjaCAoeCAtIG9mZnNldCkge1xuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gb2Zmc2V0ICsgMHgxMDEwMCArICgoYnl0ZXNbcG9zX3BheWxvYWQrK10gPDwgMTYpIHwgKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDgpIHwgYnl0ZXNbcG9zX3BheWxvYWQrK10pO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gb2Zmc2V0ICsgMHgxMDAgKyAoKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDgpIHwgYnl0ZXNbcG9zX3BheWxvYWQrK10pO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gb2Zmc2V0ICsgYnl0ZXNbcG9zX3BheWxvYWQrK107XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4geCAtIDE7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8vIHJldHVybnMgYW4gaXRlcmF0b3Igd2hpY2ggcmV0dXJucyB0aGUgbmV4dCBzeW1ib2xcbmV4cG9ydCBmdW5jdGlvbiByZWFkX3BheWxvYWQodikge1xuICAgIGxldCBwb3MgPSAwO1xuICAgIHJldHVybiAoKSA9PiB2W3BvcysrXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZWFkX2NvbXByZXNzZWRfcGF5bG9hZChieXRlcykge1xuICAgIHJldHVybiByZWFkX3BheWxvYWQoZGVjb2RlX2FyaXRobWV0aWMoYnl0ZXMpKTtcbn1cbi8vIGVnLiBbMCwxLDIsMy4uLl0gPT4gWzAsLTEsMSwtMiwuLi5dXG5leHBvcnQgZnVuY3Rpb24gc2lnbmVkKGkpIHtcbiAgICByZXR1cm4gKGkgJiAxKSA/ICh+aSA+PiAxKSA6IChpID4+IDEpO1xufVxuZnVuY3Rpb24gcmVhZF9jb3VudHMobiwgbmV4dCkge1xuICAgIGxldCB2ID0gQXJyYXkobik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspXG4gICAgICAgIHZbaV0gPSAxICsgbmV4dCgpO1xuICAgIHJldHVybiB2O1xufVxuZnVuY3Rpb24gcmVhZF9hc2NlbmRpbmcobiwgbmV4dCkge1xuICAgIGxldCB2ID0gQXJyYXkobik7XG4gICAgZm9yIChsZXQgaSA9IDAsIHggPSAtMTsgaSA8IG47IGkrKylcbiAgICAgICAgdltpXSA9IHggKz0gMSArIG5leHQoKTtcbiAgICByZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIHJlYWRfZGVsdGFzKG4sIG5leHQpIHtcbiAgICBsZXQgdiA9IEFycmF5KG4pO1xuICAgIGZvciAobGV0IGkgPSAwLCB4ID0gMDsgaSA8IG47IGkrKylcbiAgICAgICAgdltpXSA9IHggKz0gc2lnbmVkKG5leHQoKSk7XG4gICAgcmV0dXJuIHY7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVhZF9tZW1iZXJfYXJyYXkobmV4dCwgbG9va3VwKSB7XG4gICAgbGV0IHYgPSByZWFkX2FzY2VuZGluZyhuZXh0KCksIG5leHQpO1xuICAgIGxldCBuID0gbmV4dCgpO1xuICAgIGxldCB2WCA9IHJlYWRfYXNjZW5kaW5nKG4sIG5leHQpO1xuICAgIGxldCB2TiA9IHJlYWRfY291bnRzKG4sIG5leHQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdk5baV07IGorKykge1xuICAgICAgICAgICAgdi5wdXNoKHZYW2ldICsgaik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvb2t1cCA/IHYubWFwKHggPT4gbG9va3VwW3hdKSA6IHY7XG59XG4vLyByZXR1cm5zIGFycmF5IG9mIFxuLy8gW3gsIHlzXSA9PiBzaW5nbGUgcmVwbGFjZW1lbnQgcnVsZVxuLy8gW3gsIHlzLCBuLCBkeCwgZHhdID0+IGxpbmVhciBtYXBcbmV4cG9ydCBmdW5jdGlvbiByZWFkX21hcHBlZF9tYXAobmV4dCkge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgdyA9IG5leHQoKTtcbiAgICAgICAgaWYgKHcgPT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICByZXQucHVzaChyZWFkX2xpbmVhcl90YWJsZSh3LCBuZXh0KSk7XG4gICAgfVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCB3ID0gbmV4dCgpIC0gMTtcbiAgICAgICAgaWYgKHcgPCAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHJldC5wdXNoKHJlYWRfcmVwbGFjZW1lbnRfdGFibGUodywgbmV4dCkpO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbUVudHJpZXMoZmxhdChyZXQpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZWFkX3plcm9fdGVybWluYXRlZF9hcnJheShuZXh0KSB7XG4gICAgbGV0IHYgPSBbXTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgaSA9IG5leHQoKTtcbiAgICAgICAgaWYgKGkgPT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB2LnB1c2goaSk7XG4gICAgfVxuICAgIHJldHVybiB2O1xufVxuZnVuY3Rpb24gcmVhZF90cmFuc3Bvc2VkKG4sIHcsIG5leHQpIHtcbiAgICBsZXQgbSA9IEFycmF5KG4pLmZpbGwodW5kZWZpbmVkKS5tYXAoKCkgPT4gW10pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdzsgaSsrKSB7XG4gICAgICAgIHJlYWRfZGVsdGFzKG4sIG5leHQpLmZvckVhY2goKHgsIGopID0+IG1bal0ucHVzaCh4KSk7XG4gICAgfVxuICAgIHJldHVybiBtO1xufVxuZnVuY3Rpb24gcmVhZF9saW5lYXJfdGFibGUodywgbmV4dCkge1xuICAgIGxldCBkeCA9IDEgKyBuZXh0KCk7XG4gICAgbGV0IGR5ID0gbmV4dCgpO1xuICAgIGxldCB2TiA9IHJlYWRfemVyb190ZXJtaW5hdGVkX2FycmF5KG5leHQpO1xuICAgIGxldCBtID0gcmVhZF90cmFuc3Bvc2VkKHZOLmxlbmd0aCwgMSArIHcsIG5leHQpO1xuICAgIHJldHVybiBmbGF0KG0ubWFwKCh2LCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHggPSB2WzBdLCB5cyA9IHYuc2xpY2UoMSk7XG4gICAgICAgIC8vbGV0IFt4LCAuLi55c10gPSB2O1xuICAgICAgICAvL3JldHVybiBBcnJheSh2TltpXSkuZmlsbCgpLm1hcCgoXywgaikgPT4ge1xuICAgICAgICByZXR1cm4gQXJyYXkodk5baV0pLmZpbGwodW5kZWZpbmVkKS5tYXAoKF8sIGopID0+IHtcbiAgICAgICAgICAgIGxldCBqX2R5ID0gaiAqIGR5O1xuICAgICAgICAgICAgcmV0dXJuIFt4ICsgaiAqIGR4LCB5cy5tYXAoeSA9PiB5ICsgal9keSldO1xuICAgICAgICB9KTtcbiAgICB9KSk7XG59XG5mdW5jdGlvbiByZWFkX3JlcGxhY2VtZW50X3RhYmxlKHcsIG5leHQpIHtcbiAgICBsZXQgbiA9IDEgKyBuZXh0KCk7XG4gICAgbGV0IG0gPSByZWFkX3RyYW5zcG9zZWQobiwgMSArIHcsIG5leHQpO1xuICAgIHJldHVybiBtLm1hcCh2ID0+IFt2WzBdLCB2LnNsaWNlKDEpXSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVhZF9lbW9qaV90cmllKG5leHQpIHtcbiAgICBsZXQgc29ydGVkID0gcmVhZF9tZW1iZXJfYXJyYXkobmV4dCkuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIHJldHVybiByZWFkKCk7XG4gICAgZnVuY3Rpb24gcmVhZCgpIHtcbiAgICAgICAgbGV0IGJyYW5jaGVzID0gW107XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBsZXQga2V5cyA9IHJlYWRfbWVtYmVyX2FycmF5KG5leHQsIHNvcnRlZCk7XG4gICAgICAgICAgICBpZiAoa2V5cy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGJyYW5jaGVzLnB1c2goeyBzZXQ6IG5ldyBTZXQoa2V5cyksIG5vZGU6IHJlYWQoKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmFuY2hlcy5zb3J0KChhLCBiKSA9PiBiLnNldC5zaXplIC0gYS5zZXQuc2l6ZSk7IC8vIHNvcnQgYnkgbGlrZWxpaG9vZFxuICAgICAgICBsZXQgdGVtcCA9IG5leHQoKTtcbiAgICAgICAgbGV0IHZhbGlkID0gdGVtcCAlIDM7XG4gICAgICAgIHRlbXAgPSAodGVtcCAvIDMpIHwgMDtcbiAgICAgICAgbGV0IGZlMGYgPSAhISh0ZW1wICYgMSk7XG4gICAgICAgIHRlbXAgPj49IDE7XG4gICAgICAgIGxldCBzYXZlID0gdGVtcCA9PSAxO1xuICAgICAgICBsZXQgY2hlY2sgPSB0ZW1wID09IDI7XG4gICAgICAgIHJldHVybiB7IGJyYW5jaGVzLCB2YWxpZCwgZmUwZiwgc2F2ZSwgY2hlY2sgfTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWNvZGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJmbGF0IiwiYXJyYXkiLCJkZXB0aCIsInJlc3VsdCIsImZvckVhY2giLCJmbGF0RGVlcCIsImFyciIsImNhbGwiLCJ2YWwiLCJBcnJheSIsImlzQXJyYXkiLCJwdXNoIiwiZnJvbUVudHJpZXMiLCJpIiwibGVuZ3RoIiwidmFsdWUiLCJkZWNvZGVfYXJpdGhtZXRpYyIsImJ5dGVzIiwicG9zIiwidTE2Iiwic3ltYm9sX2NvdW50IiwidG90YWwiLCJhY2MiLCJza2lwIiwicG9zX3BheWxvYWQiLCJyZWFkX3dpZHRoIiwicmVhZF9idWZmZXIiLCJyZWFkX2JpdCIsIk4iLCJGVUxMIiwiTWF0aCIsInBvdyIsIkhBTEYiLCJRUlRSIiwiTUFTSyIsInJlZ2lzdGVyIiwic3ltYm9scyIsImxvdyIsInJhbmdlIiwiZmxvb3IiLCJzdGFydCIsImVuZCIsIm1pZCIsImEiLCJiIiwib2Zmc2V0IiwibWFwIiwieCIsInJlYWRfcGF5bG9hZCIsInYiLCJyZWFkX2NvbXByZXNzZWRfcGF5bG9hZCIsInNpZ25lZCIsInJlYWRfY291bnRzIiwibiIsIm5leHQiLCJyZWFkX2FzY2VuZGluZyIsInJlYWRfZGVsdGFzIiwicmVhZF9tZW1iZXJfYXJyYXkiLCJsb29rdXAiLCJ2WCIsInZOIiwiaiIsInJlYWRfbWFwcGVkX21hcCIsInJldCIsInciLCJyZWFkX2xpbmVhcl90YWJsZSIsInJlYWRfcmVwbGFjZW1lbnRfdGFibGUiLCJyZWFkX3plcm9fdGVybWluYXRlZF9hcnJheSIsInJlYWRfdHJhbnNwb3NlZCIsIm0iLCJmaWxsIiwidW5kZWZpbmVkIiwiZHgiLCJkeSIsInlzIiwic2xpY2UiLCJfIiwial9keSIsInkiLCJyZWFkX2Vtb2ppX3RyaWUiLCJzb3J0ZWQiLCJzb3J0IiwicmVhZCIsImJyYW5jaGVzIiwia2V5cyIsInNldCIsIlNldCIsIm5vZGUiLCJzaXplIiwidGVtcCIsInZhbGlkIiwiZmUwZiIsInNhdmUiLCJjaGVjayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getData: () => (/* binding */ getData)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_base64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/base64 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/base64/lib.esm/base64.js\");\n/* harmony import */ var _decoder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decoder.js */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js\");\n/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */ \n\nfunction getData() {\n    return (0,_decoder_js__WEBPACK_IMPORTED_MODULE_0__.read_compressed_payload)((0,_ethersproject_base64__WEBPACK_IMPORTED_MODULE_1__.decode)(\"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\"));\n} //# sourceMappingURL=include.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi5lc20vZW5zLW5vcm1hbGl6ZS9pbmNsdWRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0EyQkMsR0FDOEM7QUFDUTtBQUNoRCxTQUFTRTtJQUNaLE9BQU9ELG9FQUF1QkEsQ0FBQ0QsNkRBQU1BLENBQUM7QUFDMUMsRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbGltZS1iZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi5lc20vZW5zLW5vcm1hbGl6ZS9pbmNsdWRlLmpzPzgwNWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNSVQgTGljZW5zZVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAyMSBBbmRyZXcgUmFmZmVuc3BlcmdlclxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKlxuICogVGhpcyBpcyBhIG5lYXIgY2FyYm9uLWNvcHkgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZSAobGluayBiZWxvdykgd2l0aCB0aGVcbiAqIFR5cGVTY3JpcHQgdHlwaW5ncyBhZGRlZCBhbmQgYSBmZXcgdHdlYWtzIHRvIG1ha2UgaXQgRVMzLWNvbXBhdGlibGUuXG4gKlxuICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzXG4gKi9cbmltcG9ydCB7IGRlY29kZSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iYXNlNjRcIjtcbmltcG9ydCB7IHJlYWRfY29tcHJlc3NlZF9wYXlsb2FkIH0gZnJvbSAnLi9kZWNvZGVyLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBnZXREYXRhKCkge1xuICAgIHJldHVybiByZWFkX2NvbXByZXNzZWRfcGF5bG9hZChkZWNvZGUoJ0FFUUYyQU8yREVzQTJ3SXJBR3NCUkFCeEFOOEFad0NjQUV3QXFnQTBBR3dBVWdCeUFEY0FUQUFWQUZZQUlRQXlBQ0VBS0FBWUFGZ0FHd0FqQUJRQU1BQW1BRElBRkFBZkFCUUFLd0FUQUNvQURnQWJBQThBSFFBWUFCb0FHUUF4QURnQUxBQW9BRHdBRXdBOUFCTUFHZ0FSQUE0QUR3QVdBQk1BRmdBSUFBOEFIZ1FYQllNQTVCSEpBUzhKdEFZb0FlNEFFeG96aTBVQUgyMXRBYU1uQlQ4Q3JuSXlock1EaFJnRHlnSUJVQUVIY29GSFVQZThBWEJqQWV3Q2pnRFFSOElJQ0ljRWNRTHdBVFhDRGd6dkh3Qm1Cb0hOQXFzQmRCY1VBeWtnRGhBTVNoc2tNZ284QVk4anFBUWZBVUFmSHc4QkR3ODdNaW9HbENJUEJ3WkNhNEVMYXRNQUFNc3BKVmdzRGw4QUloY2tTZzhYQUhkdlR3QmNJUUVpRFQ0T1BoVXFieUVDQUVvQVMzNEFlajhZYng4M0pnVC9YdzhnSHhaLzd3OFJJQ3hQSEE5dkJ3K1BmdzhQSHdBUEZ2K2ZBc0F2Q2M4dkVyOGl2d0QvRVE4Qm9sOE9FQmEvQTc4aHJ3QVBDVTh2RVNOdnZ3V2ZId05mQVZvREhyK1pBQUVEMzRZYUFkSlBBSzdQTHdTRWdETEhBR28xUHo4UHZ4OWZVd01ycGI4Ty81OFZUekFQSUJvWEl5UUpORjhocHdJVkFUOFlHQVVBREROQmFYM1JBTW9tSkNnOUVoVWVBMjlNQUJzWkJUTU5KaXBqT2hjMTlnY0lEUjhiQndRSEVnZ0NXaTZESWdMdUFRWUErQkFGQ2hhM0E1WGlBRXNxTTdVRkZnRkxoQU1qRlRNWUUxS2xudzc0blJWQkcvQVNDbTBCWVJOL0Jyc1UzVm9XeStTMHZWOExReCt2TjhnRjJBQzJBSzVFQVd3QXBnWURLbUFBcm9RME5EUTBBVCtPQ2c3d0FBSUhSQWJwTmdWY0JWMEFQVEE1QmZiUEZnTUx6Y1lML1FxcUE4MmVCQUxLQ2pRQ2pxWUNodDAvazIrT0FzWFFBb1AzQVNUS0RnRHc2QUNLQVVZQ01wSUtKcFJhQUU0QTV3b21BQnpadnMwUkVFS2lBQ0lRQWQ1UWRBRUNBajRZd2cvd0dxWTJBVmdBWUFEWXZBb0NHQUV1YkEwZ3ZBWTJBTEFBYnBidnFweUVBR0FFcGdRQUpnQUc3Z0FnQUVBQ21naFVGd0NxQU1wQUlOUUl3QzREdGhSQUFQY3ljS2dBcG9JZEFCd0JmQ2lzQUJvQVR3QnFBU0lBdmhuU0JQOGFIL0VDZUFLWEFxNDBOamdEQlR3RllRVTZBWHMzb0FCZ0FENFhOZ21jQ1kxZUNsNXRJRlplVXFHZ3lvTkhBQmdBRVFBYUFCTndXUUFtQUJNQVRQTWEzVDM0QURsZHlwcm1NMU0yWG9jaVVRZ0x6dndBWFQzeEFCZ0FFUUFhQUJOd0lHRkFuQUREOEFBZ0FENEJCSld6YUNjSUFJRUJGTUFXd0tvQUFkcTlCV0FGNXdMUXBBTEV0UUFLVVNHa2FoUjRHbkpNK2dzQXdDZ2VGQWlVQUVDUTBCUXVMOEFBSUFBQUFES2VJaGVjbHZGcVFBQUVUcjRpQU14SUFSTWdBTUlvSGhRSUFuMEUwcERRRkM0SGh6bm9BQUFBSUFJMkMwLzRsdkZxUUFBRVRnQkpKd1lDQXk0QUJnWUFGQUE4TUJLWUVINGVSaFRrQWpZZUZjZ0FDQVlBZUFCc09xeVE1Z1J3RGF5cXVnRWdhSUlBdGdvQUNnRG1FQUJtQkFXR21lNU9CSkpBMm00Y0Rlb0FtSVRXQVh3ck1nT2dBR3dCQ2g2Q0JYWUYxVHpnMXdLQUFGZGl1QUJSQUZ3QVhRQnNBRzhBZGdCckFIWUFid0NFQUhFd2Z4UUJWRTVURVFBRFZGaFRCd0JEQU5JTEFxY0N6Z0xUQXBRQ3JRTDZ2QUFNQUw4QVBMaE5CS2tFNmdsR0tUQVU0RHI0TjJFWUV3QkNrQUJLazhySEFiWUJtd0lvQWlVNEFqZi9BcTRDb3dDQUFOSUNoemdhTkJzQ3NUZ2VPRGNGWHJnQ2xRS2RBcVFCaVFHWUFxc0NzalRzTkhzZk5QQTBpeHNBV1RXaU9BTUZQRFFTTkNrMkJEWkhOb3cyVFRaVU5oazI4Sms5VnpJM1FrRW9Bb0lDb1FLd0FxY0FRQUF4QlY0RlhiUzlCVzQ3WWtJWFAxY2lVcXMwNURTL0Z3QUJVd0pXMTFlNm5IdVlabVNoL1JBWUE4b01Ldlo4S0FTb1VBSllXQUo2SUxBc0FaU29xanBnQTBvY0JJaG1EZ0RXQUFhd1JEUW9BQWN1QWo1aUFIQUJaaVIyQUlnaUhnQ2FBVTY4QUN4dUhBRzB5Z004TWlaSUFsZ0JkRjRHYWdKcUFQWk9IQU11QmdvQVRrWUFzQUJpQUhnQU1Mb0dEUGowSHBLRUJBQU9KZ0F1QUxnZ1RBSFdBZUFNRURiZDIwVWVnZTBBRHdBV0FEa0FRZ0E5T0hkKzJNVVFaQkJoQmdOTkRreHhQeFVRQXJFUHF3dnFFUm9NMWlyUTA5MEFOSzRIOEFOWUIvQURXQU5ZQi9BSDhBTllCL0FEV0FOWUExZ0RXQndQOEIvWXhSQmtEMDBFY2dXVEJaQUUyd2lJSms0UmhnY3RDTmRVRW5RakhFd0RTZ0VCSXlwSklUdVlNeEFsUjB3UlRRZ0lBVFpIYkt4OVBRTk1NYkJVK3BDbkE5QXlWRGx4QmdNZWRoS2xBQzhQZUNFMXVrNkRla3h4cFFwUVQ3Tlg5d0JGQmdBU3F3QVM1Z0JKRFNnQVVDd0dQUUJJNHpUWUFCTkdBRTJiQUUzS0FFeGRHQUJLYUFiZ0FGQlhBRkNPQUZCSkFCSTJTV2RPYkFMRE9xMC8vUW9tQ1podndIZFRCa0lRSENlbUVQZ01OQUcyQVR3TjdrdlpCUElHUEFUS0gzNFpHZy9PbFowSXBpM2VETzRtNUM2aWdGc2o5aXFFQmU1TDlUemVDMDVSYVE5YUMyWUo1RHBrZ1U4RElnRU9Jb3dLM2cwNkNHNFE5QXJLYkEzbUVVWUhPZ1BXU1pzQXBnY0NDeElkTmhXMkpoRmlyUXNLT1hnRy9CcjNDNUFtc0JNcWV2MEYxQm9pQms0Qktoc0FBTkF1NklXeFdqSmNIVTlnQmdRTEppUElGS2xRSVEwbVFMaDRTUm9jQnhZbHFnS1NRM0ZLaUZFM0hwUWg5encrRFdjdUZGRjlCL1k4QmhsUUM0SThuMGFzUlE4UjB6Nk9QVWtpU2t3dEJEYUFMREFuakFuUUQ0WU11bnh6QVZvSklnbXlESElUTWhFWU44WUlPZ2NhTHBjbEp4WUlJa2FXWUpzRStLQUQ5QlBTQXd3RlFBbENCeFFEdGh3dUV5OFZLZ1VPZ1NYWUF2UTIxaTYwQXBCV2dRRVlCY3dQSmgvZ0VGRkg0UTdxQ0p3Q1pnT0VKZXdBTGhVaUFCZ2luQWhFWkFCZ2o5bFRCaTdNQ01ocWJTTjFBMmdVNkdJUmRBZVNEbGdIcUJ3MEZjQWM0bkRKWGd5R0NTaWtzQWxjQVhZSm1nRmdCT1FJQ2pWY2pLRWdRbWRVaTFrWW5DQmlRVUJkL1FJeURHWVZvRVMraDNrQ2pBOXNFaHdCTmdGMEJ6b05BZ0o0RWU0UmJCQ1dDT3lHQlRXMk0vazZKZ1JRSVlRZ0Vnb29BMUJzendzb0p2b00rV29CcEJKakF3MDBQbmZ2WjZ4Z3R5VVgvZ2NhTXNaQllTSHlDNU5Qemd5ZEdzSVlRMVF2R2VVSHdBUDBHdlFuNjBGWUJnQURwQVFVT2s0ejd3UytDMm9JakFsQUFFb09wQmdIMkJockNuS00wUUV5akFHNG1nTllrb1FDY0pBR09BY01BR2dNaUFWNjVnQWVBcWdJcEFBR0FOQURXQUE2QXE0SG5nQWFBSVpDQVQ0REtEQUJJdVlDa0FPVUNETE1BWll3QWZRcUJCekVEQllBK0RodVN3TERzZ0tBYTJhakJkNVpBbzhDU2pZQlRpWUVCazlJVWdPd2N1SUEzQUJNQmhUZ1NBRVdyRXZNRytSRUFlQndMQURJQVB3QUJqWUhCa0lCemdIMGJnQzRBV0FMTWdtanRMWUJUdW9xQUlRQUZtd0IyQUtLQU40QU5nQ0E4Z0ZVQUU0Rld2b0YxQUpRU2dFU01oa3NXR0lCdkFNZ0FUUUJEZ0I2QnN5T3Bzb0lJQVJ1QjlRQ0VCd1Y0Z0x2THdlMkFnTWk0QlBPUXNZQ3ZkOVdBRElYVXU1ZVp3cW9DcWRlYUFDMFlUUUhNbk05VVFBUEg2ayt5QWR5L0JaSWlRSW1Td0JRNWdCUVF6U2FOVEZXU1RZQnB3R3FLUUszOEFGdHF3Qkkvd0szN2dLM3JRSzNzQUs2MjgwQzBnSzMzQUszenhBQVVFSUFVRDlTa2xLREFyZWtBcnc1QUVRQXpBSENPMTQ3V1R0ZU8xazdYanRaTzE0N1dUdGVPMWtEbUNoWUkwM0FWVTBvSnFrS2JWOUdZZXdNcHczVlJNazZTaFBjWUZKZ014UEpMYmdVd2hYUEpWY1pQaHE5SndZbDVWVUtEd1V0MUdZeENDMDBkaGU5QUVBcGFZTkNZNGNlTVFwTUhPaFRrbFQ1TFJ3QXNrdWpNN0FOclJzV1JFRUZTSFh1WWlzV0R3b2pBbVNDQW1KRFhFNndYRGNoQXFINEFtaVpBbVlLQXArRk9Cd01BbVk4QW1ZbkJHOEVnQU4vRkFOK2t6a0hPWGdZT1lNNkpDUUNiQjRDTWpjNEN3SnR5QUp0ci9DTEFEUm9SaXdCYUFEZkFPSUFTd1lIbVF5T0FQOE13d0FPdGdKM01BSjJvMEFDZVV4RUFuaTdIbDNjUmE5RzlBSjhRQUo2eVFKOUNnSjg4VWdCU0g1a0pRQXNGa2xaU2x3V0dFck5BdEVDQXRETlN5Z0RpRkFEaCtkRXhwRXpBdktpWFFRREE2OUx6MHd1SmdUUVRVMU5zQUtMUUFLSzJjSWNDQjVFYUFhNEFvNDRBbzVkUVppQ0FvN2FBbzVkZVZHMVV6WUxVdFZVaGdLVC9BS1REUURxQUIxVkgxV3dWZEVITEJ3cGxvY3k0bmhuUlR3NkFwZWdBdSt6V0NLcEFGb21BcGFRQXBaOW5RQ3FXYTFhQ29KT0FEd0NscllDbGs5Y1JWelNBcG5NQXBsbFhNdGRDQm9Dbkp3NXd6cWVBcHdYQXArY0FwNjVpd0FlRURJckVBS2Q4Z0tla3dDMlBtRTFZZkFDbnRRQ29HOEJxZ0tlb0NBQ25rK21ZOGxrS0NZc0FpZXdBaVovQXFEOEFxQk4yQUttTUFLbHp3S29BQUIrQXFmemFIMW9zZ0FFU21vZGF0SUNyT1FDcks4Q3JXZ0NyUU1DVng0Q1ZkMENzZUxZQXg5UGJKZ0NzcjRPQXJMcEdHemhiV1J0U1dBREpjNEN0bDA4UUc2UkF5bEdBcmhmQXJsSUZnSzVLM2h3TjNEaUFyMGFBeTJ6QXpJU0FyNkpjZ01ETTNJQ3ZodHpJM05RQXNQTUFzTUZjNE4wVERaR2RPRURQS2dEUEpzRFBjQUN4WDBDeGtnQ3hoR0tBc2hxVWdMSVJRTEpVQUxKTHdKa25nTGQwM2g2WW5pdmVTWkwwUU1ZcEdjREFtSDFHZlNWSlhzTVhwTmV2QklDejJ3Q3oyMHdURlRUOUJTZ0FNZXVBczkwQVNyckEwNFRma3dHQXR3b0F0dUxBdEpRQTFKZEExTmdBUUlEVlkyQWlrQUJ6QmZ1WVVaMkFJTFBnNDRDMnNnQzJkK0VFWVJLcHowRGhxWUFNQU5rRDRaeVd2b0FWZ0xmWmdMZXVYUjRBdUl3N1JVQjh6RW9BZlNjQWZMVGlBTHI5QUxwY1hvQUF1cjZBdXJsQVBwSUFib0M3b29DNjUyV3E1Y0VBdTVBQTRYaG1IcHc0WEdpQXZNRUFHb0RqaGVabEFMM0ZBT1Jid09TaUFMM21RTDUyZ0w0WjVvZG1xeThPSnNmQTUyRUF2NzdBUndBT3A4ZG43UURCWTREcG1zRHB0b0Ewc1lEQm11aGlhSUdDZ01NU2dGZ0FTQUN0Z05HQUp3RWdMcG9CZ0M4Qkd6QUVvd2NnZ0NFREM2a2Rqb0FKQU0wQzVJS1JvQUJaQ2dpQUl6dzNBWUJMQUNrZm5nOW9naWdrZ05tV0FONkFFUUN2cmtFVnFUR0F3Q3NCUmJBQSs0aVFrTUNIUjA3MmpJMlBUYlVOc2syUmpZNU52QTIzVFpLTmlVM0VEY1pONUkrUlR4RFJUQkNKa0s1VkJZS0ZoWmZ3UUNXeWdVM0FKQlJIcHUrT3l0Z054YTYxQTQwR01zWWpzbjdCVndGWFFWY0JWMEZhQVZkQlZ3RlhRVmNCVjBGWEFWZEJWd0ZYVXNhQ055S0FLNEFBUVVIQndLVTdvSUNvVzFlN2pBRXpnUHhBK1lEd2dDa0JGREF3QURBQkt6QUFPeEZMaGl0QTFVRlREZXlQa00rYmo1MVFrUkN1d1RRV1dROFgrMEFXQll6c0FDTkE4eHd6QUdtN0VaL1Fpc29DVEFiTERzNmZuTGZiOEgyR2Njc2JnRncxM00xSEFWa0JXL0p4c205Q05STzhFOEZERDBGQlF3OUZrY0NsT1lDb01GZWdwRGZBRGdjTWlBMkFKUUFDQjhBc2lnS0FJeklFQUpLZUJJQXBZNXlQWlFJQUtRaUhiNGZ2ajVCS1NSUFFyWkNPejBvWHl4Z095d2ZLQW5HYmdNQ2xRYUNBa0lMWGdkZUNEOUlJR1VnUWo1ZlBvWStkVDUyQW81Q00wZEFYOUJUVkc5U0R6RndXVFFBYnhCekpGL2xPRUlRUWdsQ0NrS0pJQWxzNUFjQ2xRSUNvS1BNT0RFRnhoaTZLU0FiaXlmSVJyTWp0Q2dkV0NBa1BsRkJJaXRDc0VKUnpBYk1BVi9PRXlRekRnME9BUVFFSjM2aTMyOC9NazlBeWJESnNRbHEzdERSQXBVS0FrRnpYZjFkL2o5dUFMWVA2aENvRmdDVEdEOGtQc0ZLUWlvYnJtMCt6ajBLU0Q4a1BuVkNSQndNRHlKUlRIRmdNVEphNXJ3WFFpUTJZZkkvSkQ3Qk1FSkVIR0lOVHc0VE9GbElSendKTzBpY01RcHlQeVErd3pKQ1JCdjZEVmduS0IwMU5nVUtqMmJ3WXpNcUNvQmt6bkJnRUYrellESW9jd1JJWCtOZ0hqNEhJQ05maDJDNEN3ZHdGV3BURy9sZ1VoWUdBd1JmdjJUczhtQWFYelZnbWwvWFlJSmZ1V0M0SEkxZ1VGOXBZSlpnTVI2aWxRSE1BT3dMQWxEUmVmQzBpbjRBWEFFSkE2UGpDd2MwSWFtT0FOTU1DQUVDUlFERk5SVFpCZ2QrQ3dRbFJBK3I2K2dMQkRFRkJud1VCWGdLQVRJQXJ3QUdSQUFIQTNjRGRBTjJBM2tEZHdOOUEzb0RkUU43QTMwRGZBTjRBM29EZlFBWUVBQWxBdFlBU3dNQVVBRnNBSGNLQUhjQW1nQjNBSFVBZFFCMkFIVnU4VWdBeWdEQUFIY0FkUUIxQUhZQWRRQUxDZ0IzQUFzQW1nQjNBQXNDT3dCM0FBdHU4VWdBeWdEQUFIZ0tBSm9BZHdCM0FIVUFkUUIyQUhVQWVBQjFBSFVBZGdCMWJ2RklBTW9Bd0FBTENnQ2FBSGNBQ3dCM0FBc0NPd0IzQUF0dThVZ0F5Z0RBQUg0QUN3R2dBTGNCcHdDNkFhaGRBdTBDT3dMdGJ2RklBTW9Bd0FBTENnQ2FBdTBBQ3dMdEFBc0NPd0x0QUF0dThVZ0F5Z0RBQTI0QUN3TnZBQXUwVnNRQUF6c0FBQkNralVJcEFBc0FVSXVzT2dnV2NnTWVCeFZzR3dMNjdVLzJIbHptV09FZU9nQUxBU3Z1QUFzZUFmcEtVcG5wR2dZSkRDSVpNNll5QVJVRTlUaHFBRDVpWFFnbkFKWUpQbk96dzBaQUVaeEVLc0lBa0E0RGhBSG5UQUlEeHhVREswbHhDUWxQWWdJdklRVllKUUJWcUUxR2FrVUFLR1lpRFRvU0JBMUV0QVlBWFFKWUFJRjhHZ01IUnlBQUlBak9lOVluY2VrUkFBMEtBQ1VyandFN0F5YzZBQVlXQXFhaUtHNE1jRWNxQU5vTjMrTWc5VHdDQmhJa3VDbnkrSndVUTI5TDAwOEpsdVJ4dTNLK29BZHFpSE9xRkgwQUc1U1VJZlVKNVN4Q0dmeGRpcFJ6cVRtVDRWNVpiK3IxVW80Vm0rTnFTU0VsMm1OdlIySmhJYThTcFlPNm50ZHdGWEhDV1RDSzhmMitIeG83dWlHM2RyRHljQXVLSU1QNWJoaTA2QUNucUFySDFyejRScWcvL2xtNlNnSkdFVmJGOXhKSElTYVI2SHhxeFNua3c2c2hEbmVsSEtORWZHVVhTSlJKMUdjc210SncyNXhyWk1ESzlnWFNtMS9ZTWtkWDQvNk5LWU9kdGsvTlEzL05uREFTalRjM2ZQaklqVy81c1ZmVk9iWDJvVERXa3IxZEY5ZjNreEJzRDMvM2FRTzhoUGZSeitlMHVFaUpxdDExNjFncml1N2d6OGhERHd0cHkrRitCV3RlZm5LSFpQQXhjWm9XYm56bmhKcHkwZTg0MmozNmJjTnpHbklFdXNnR1gwYThaeHNuamNTc1BEWjA5eVozNmZDUWJyaUhlUTcySlJNSUxObDZlUFBmMkhXb1Z3Z1dBbTFmYjNWMnNBWTArQjZyQVhxU3dQQmdzZVZtb3FzQlRTcm05MStYYXNNWVl5U0k4ZWVSeEgzWnZIa016M0JRNWFKM2lVVmJZUE5NMy83ZW1SdGpsc01ndi85VnlUc3l0L21LKzhmZ1dlVDZTb0ZhY2xYcW40MmRBSXN2QWFyRjV2Tk5XSHpLU2tLUS84SGZrNVpXSzdyOXlsaU9zb295QmpSaGZrSFA0UTJEa1dYUWk2RkcvOXIvSXdibWtWNVQ3SlNvcEhLbjFwSndtOXRiNU90MG95TjFaMm1QcEtYSFR4eDJubEswOGZLazFoRVlBOFdnVlZXTDVsZ3gwaVR2K0tkb2pKZVUyM1pEam1pdWJYT3hWWEpLS2kyV2p1aDJITFpPRkxpU0M3VGxzNVNNaDRmK1BqNnhVU3JOakZxTEdlaFJOQjhsQzBRU0xObWtKSngvd1NHM01uakU5VDFDa1B3Skkwd0gybGZ6d0VUSWlWcVV4ZzBkZnU1cTM5R3QraHdkY3hraGhOdlE0VHlyQmNlb2YzTWhzL0l4RmNpMUhtSHI0Rk1aZ1hFRWN6UGlHQ3gwSFJ3ekFxRHEyajlBVm0xa3dOMG1SVkxXTHlsZ3RvUE5hcEY1Y1k0WTF3SmgvZTBCQndaajQ0WWdackROcXZELzlIdjdHRllkVVFlREp1UTNFV0k0SGFLcWF2VTFYakMvbjQxa1Q0TDc5a3FHcTBrTGhkVFp2Z1AzVEEzZlMwb3pWeis1cGlac29PdEl2QlVGb01LYk5jbUJMNll4eGFVQXVzSEIzOFhyUzhkUU1uUXdKZlVVa3BSb0dyNUFVZVdpY3ZCVHp5SzlnNzcreUNrZjVQQXlzTDdyL0pqY1pncmJ2UnBNVzlpeWF4WnZLTzZjZVpOMkV3SXhLd1ZGUHV2RnVpRVBHQ29hZ2JNbytTcHlkTHJYcUJ6TkNER0ZDck8vcmtjd2EyeGhva1FaNUNkWjBBc1UzSmZTcUo2bjVJMTRZQStQL3VBZ2ZoUFU4NFRsdzdjRUZmcDdBRUU4ZXk0c1AxMlBUdDRDb2RzMUdSZ0RPQjV4dnlpUjVtK0J4OE81bkJDTmN0VThCZXZmVjVBMDh4NlJIZDVqY3dQVE1EU1pKT2VkSVoxY0dRNzA0bHhiQXpxWk9QMDVaeGFPZ2h6U2R2RkJIWXFvbUFUQVJ5QUFESzRlbFA4THkzSXJVWktmV2gyM1h5MjB1QlVtTFM0UGZhZ3U5K295VmEyaVBncVJQM0YyQ1RVc3ZKNytSWW5OOGZGWmJVL0hWdnh2Y0ZGREtraVRxVjVVQlozR3o1NEpBS0J5aTloa0tNWkp2dUdnY1NZWEZtdzA4VXlvUXlWZGZURDEvZE1rQ0hYY1RHQUtlUk9nQXJzdm1SclFUTFVPWGlvT0hHSzJRa2pIdW9ZRmdYY2lab1RKZDZGczVxMVFYMUcrcC9lMjZoWXNFZjdRWkQxbm5JeWwvU0ZrTnRZWW1tQmhwQnJ4bDlXYlkwWXBIV1J1dzJMbC90ajltRDhQNHNuVnpKbDRGOUorMWFyVmVUYjlFNXIySUxIMDRxU3RqeFFOd24zbTRZTnF4bWFOYkxBcVcyVE42TGlkd3VKUnFTK05YYnRxeG9lRFhweGVHV214elNrV3hqa3lDa1g0TlFSbWU2cTVTQWNDK003KzlFVGZBL0V3cnpRYWpLYWtDd1l5ZXVuUDZaRmx4VTJvTUVuMVB6MzF6ZVN0Vzc0RzQwNlpKRkNsMXdBWElvVUtrV290WUVwT3VYQjF1Vk54SjYzZHBKRXFmeEJlcHR3SUhOclB6OEJsbFpvSWNCb1h3Z2ZKKzhWQVVuVlB2UnZleG53ME1hL1dpR1l1Sk81eThRVHZFWUJpZ0ZtaFV4WTVScXpFOE9jeXdOLzhtNFVZcmxhbmlKTzc1WFE2S1NvOSt0V0hsdStoTWkwVVZkaUtRcDdOZWxub1pVek5hSXlCUFZlT3dLNkdOcCtGZkh1UE9veWhhV3VOdlRZRmt2eHNjTVFXRGgremVGQ0ZrZ3diWGZ0aVYyM3l3SjQrdXdScW1nOWszS3p3SVFwenBwdDhEQkJPTWJycXdRTTVHYjA1c0V3ZEt6TWlBcU9sb2FBL2xyMEtBKzFwcjAvK0hpV29pSWpIQS93aXIybkl1UzNQZVUvamkzTzZad294Y1IxU1o5Rmh0TEM1UzBGSXpGaGJCV2NHVlAvS3B4T1BTaVVvQWRXVXBxS0grKzZTY3o1MDdpQ2N4WUk2cmRNQklDUEpaZWE3T2NtZUZ3NW1PYkpTaXFwamcyVW9XTklzK2NGaHlEU3Q2Z2VWNXFnaTNGdW5td3dEb0dTTWdlckZPWkdYMW0wZE1DWW81WE9ydXhPMDYzZHdFTks5RGJuVk05d1lGUkV6aDR2eVUxV1lZSi9MUlJwNm94Z2pxUC9YNWE4LzRBZjZwNk5Xa1FmZXJ6Qm1YbWUwelkvNG53TUptL3dkMXRJcVN3R3orRTN4UEVBT29abEppdDNYZGRENy9CVDFwbGx6T3grOGJtUXRBTlEvUzZmWmV4YzZxaTNXK1EyeGNtWFRVaHVTNW1wSFFSdmN4WlVOMFM1K1BMOWxYV1VBYVJaaEVIOGhUZEFjdU5NTUN1Vk5LVEVHdFNVS05pM082S2hTYVR6Y2s4Y3NaMnZXUlorZDdtVzhjNElLd1hJWWQyNVMveklmdFBrd1B6dWZqRXZPSFdWRDFtK0ZqcERWVVRWMERHRHVIajZRbmFFd0x1L2RFZ2RMUU9nOUUxU3JvOVhISjh5a0xBd3RQdStweHFLRHVGZXhxT04xc0tRbTdyd2JFMUU2OFVDZkEvZXJvdnJUQ0crREJTTmcwbDRnb0RRdlpONnVObGJ5THBjWkF3ajJVY2x5Y3ZMcElaTWd2NHlSbHBiM1l1TWZ0b3pvcmJjR1ZIdC9WZURWMytGZGYxVFAwaXVhQ3NQaTJHNFhlR2hzeUYxdWJWRHhrb0pobW5pUTAvalNnL2VZTUw5S0xmbkNGZ0lTV2twOTFlYXVSM0lRdkVEMG5BUFhLKzZoUENZcytuMytoQ1piaXNrbVZNRzJkYSswRXNaUG9uVWVJWThFYmZ1c1FYanNLL2VGRGFvc2JQakVmUVMwUktHN3lqNUdHNjlNN01lTzFIbWlVWW9jZ3lnSkhMNk0xcXpVRER3VVNtcjk5VjdTZHIyRjNKalFBSlkrRjB5SDMzSXYzK0M5TTM4ZU1MN2dUZ21OdS9yMmJVTWlQdnBZYlo2djEvSWFFU2lyQkhOYTdtUEtuNGRFbVlnN3YvK0hRZ1BOMUc3OWpCUTErc295ZGZEQzJyK2gyQmwvS0ljNUtqTUs3T0g2bmIxakxzTmYwRUhWZTJLQmlFNTFveDYzNnV5RzZMaG8wdDNKMzRMNVFZL2lsRTNtaWthRjRIS1hHMW1HMXJDZXZUMVZ2Nkdhdmx0eG9RZS9iTXJwWnZSZ2duQnhTRVBFZUV6a0VkT3hUblBYSFZqVVlkdzhKWXZqQi9vN0VlZ2MzTWErTlV4TExuc0swa0psaW5QbVVIekhHdHJrNStDQWJWekZPQnFweXkzUVZVbnpURGZDLzBYRDk0L29rSCtPQitpN2c5bG9saFdJalNuZkliK0VxNDNaWE9XbXd2anlWL3FxRCt0MGUrN21URU03NHFQL096dDhubUM3bVJweXU2M09CNEtuVXpGYzA3NFNxb3lQVUFnTSsvVEpHRm82VDQ0RUhuUVU0WDR6NnFhbm5WcWd3L1U3ekNwd2NtWFYxQXViSXJ2T21rS0hhekpBUjU1ZVBqcDV0TEJzTjh2QXFzM05BSGRjRUhPUjJ4UTBsc05BRnpTVXV4RlFDRll2WExaSmRPajlwNGZOcTZwMEhCR1VpazJZemFJNHh5U3k5MUt6aFEwK3ExaGp4dkltUndQUmY3NnRDaGxSa2hSQ2k3NE5YWjlxVU5lSXdQK3M1cCszbTVud1BkTk9IZ1NMRDc5bjdPOW0xbjF1REhpTW50cTRua1l3VjVPWjFFTmJYeEZkNFBncmx2YXZac3lVTzRNcVlscXFuMU84Vy9JMWRFWnE1ZFhocmJFVExhWkliQzJLai9BYS9RTStmcVVPSGRmMHRYQVExaHVaM2NtV0VDV1NYeS80M2ozNStNdnE5eHdzN0pLc2VyaVoxcEVXS2M4cWx6TnJHUFVHY1ZnT2E5Y1BKWUlKc0duSlRBVXNFY0RPRVZVTE81eDByWEJpamMxbGdYRXpRUUtoUk9mOHpJVjgydzhlc3djNzhZWDExS1lMV1FSY2dITkpFbEJ4ZlhyNzJsUzJSQlNsMDdxVEtvck8ydVVEWnIzc0ZoWXN2bmhMWm4wQTk0S1J6Si83REVHSUFoVzVaV0ZwTDhnRXd1MWFMQTlNdVdaek53bDhPemU5WStiWCt2OWd5d1JWbm9CNUkvOGtYVFhVMzE0MXlSTFlySU9PejZTT255SE55NFNpZXF6a0JYaGFyamZqcXExcTZ0a2xhRWJBOFFmbTJEYUlQczdPVHEvbnZKQmpLZk8ySDliSDJjQ01oMSs1Z3NwZnljdThmL2N1dVJtdERqeXFaN3VDSU15amRWM2ErcDNmcW1Yc1J4NEM4bHVqZXpJRkhuUWlWVFhMWHVJMVhyd04zK3NpWVlqMkhIVHZFU1V4OERsT1RYcGFrOXFGUksrTDNtZ0oxV3NEN0Y0Y3UxYUpvRm9ZUW51K3dHRE1PakpNM2tpQlFXSENjdmhKL0hSZHhvZE9RcDQ1WVphT1RBMjJOYjRYS0NWeHFrYndNWUZoellRWUlBbkNXOEZXMTR1Zjk4amhVRzJ6cktoUVEwcTBDRXEwdDVuWHl2VXl2UjhEdkQ2OUxVK2czaStIRldRTVE4UHFadUhEK3NOS0FWMCtNNkVKQzBzenE3ckVyN0I1YlE4QmNOSHp2RE1jOWVxQjVaQ1FkVGY4ME9ibjR1emp3cFlVN1NJU2R0VjBRR2E5RDNXcmgyQkRRdHBCS3hhTkZWKy9DeTJQL1N2KzhzN1VkMEZkNzRYNCtvL1ROenRXZ0VUVWFweSttYWpOUTY4THEzZWUwWk80OFZFYlRaWWlIMUNvNE9sZldlZjgyUldleVVYbzd3b00wM1B5YXBHZmlrVG5RaW5vTnE1ejV2ZUxwZU1WM0hDQU1UYVptQTFvR0xBbjdYUzNYWXN6K1hLN1ZNUXNjNFhLcm1EWE9MVS9wU1hWTlVxOGRJcVRiYS8vLzN4NkxpTFM2eHMxeHVDQVlTZmNRMytyUWdtdTd1dmYzVEhLdDVPb285N1RxY2JScXh4N0VBU2l6YVFDQlFsbEcvcll4VmFwTUxndExiWlM2NHcxTURCTVhYK1BRcEJLTndxVUtPZjJERFJEVVhRZjlFaE9TMFFqNG5UbWxBOGR6U0x6L0cxZCtVZDhNVHkvNmdoaGRpTHBlZXJHWS9VbERPZml1cUZzTVVVNS9VWWxQK0JBbWdSTHVOcHZyVWFMbFZrcnFEaWV2TlZFQXdGKzRDb00xTVpUbWp4akpNc0tKcSt1OFpkN3ROQ1VGeTZMaXlZWFJKUTRWeXZFUUZGYUNHS3N4SXdRa2s3RXpaNkxUSnEyaFV1UGh2QVcrZ1FuU0c2SitNc3pDKzdRQ1JIY25xRGR5TlJKNlQ5eHlTODdBNk1EdXRiektHdkdrdHBiWHF0eld0WGI5SHNmSzJjQk1vbWpOOWE0eStUYUpMblh4QWVYL0hXem1mNGNSNHZBTHQvUDR3NHFnS1kwNG1sNFpkTE9pbkZZUzZjdXAzRy8xaWU0K3QxZU9ucEJObHFHcXM3NWlsemtUNCtEc1pReE52YVNLSi8vNnpJYmJrL003TE9oRm1SYy8xUitrQnR6N0pGR2RabS9DT290SWR2UW9YcFRxUC8xdXFFVW1DYi9RV29HTE13TzVBTmNIenhkWTQ4SUdQNStKK3pLT1RCRlo0UGlkK0dUTStXcTEyTVYvSDg2eEVKcHRCYTZUK3Aza2dwd0xlZE1hbkJIQzJHZ05yRnBvTjJ4bnJNejlXRldYLzgveWdTQmthdnEyVXY3RmRDc0xFWUx1OUxMSXZBVTBiTlJEdHpZbCsvdlhtanBJdnVKRllqbUkwaW02UUVZcW5JZU1zTmpYRzR2SXV0SUdIaWplQUcvOUVEQm96S1Y1Y2xka0hiTHhIaDI1dlQrWkV6YmhYbHF2cHpLSndjRWdmTndMQUtGZW8wL3B2RUUxMFhEQitFWFJUWHRTekpvelFLRkZBSmhNeFlrVmFDVytFOUFMN3RNZVU4YWN4aWRIcXpiNmxYNDY5MVVzRHB5L0xMUm1UK2VwZ1c1Nis1Q3c4dEI0a01VdjZzOWxoM2VSS2J5R3MrSC80bVFNYVl6UFRmMk9PZG9rRW4renpndm9EM0ZxTktrOFFxR0FYVnNxY0dkWHJUNjJmU1BrUjJ2Uk9GaTY4QTZzZTg2VXhSVWs0Y2FqZlB5Q0M0RzV3RGhEK3pOcTRqb2RRNHU0bi9tMzdMcjM2bjRMSUFBc1ZyMDJkRmk5QWl3QTgxTVlzMnJtNGVEbERObWRNUnZFS1JIZkJ3VzVEZE1OcDBqUEZaTWVBUnFGL3dMNFhCZmQrRU1MQmZNenBINUdINk5hVysxdnJ2TWRnK1Z4RHphdGszTVhnTzNybzNQL0RwY0M2K01vNE15U0poS0poU1IwMVNHR0dwNWhQV21yclVncnYzbERuUCtIaGNJM250M1lxQm9WQVZUQkFRVDVpdWhUZzhudlB0ZDhaZVlqNncxeDZScUdVQnJTa3U3K04xK0JhYXNadmpUazY0Um9JRGxMOGJycEVjSngzT21ZN2pMb1pzc3dkdG1oZkMvRzIxbGxYaElUT3dtdlJERGVUVFBieUFTT2ExNmNGNS9BMWZaQWlkSnBxanUzd1lBeTlhdlBSMXlhNmVOcDlLOFhZcnJ0dXhscWkrYkRLd2xmcllkUjBSUmlLUlZUTE9IODUrWlk3WFNtelJwZlpCSmphVGE4MVZEY0pIcFpuWm5TUUxBU0dZVzlsNTFaVi9oN2VWelRpM0h2NmhVc2djLzUxQXFKUlRrcGJGVkxYWHN6b0JMOG5CWDB1LzBqQkxUOG5IK2ZKZVBicndVUlQ1OE9ZK1VpZVJqZDF2czA0dzBWRzVWTjJVNk1vR1prUXpLTi9wdHowUTM2NmR4b1RHbWo3aTFOUUdIaTlHZ25xdVhGWWRyQ2ZaQm1lYjdzMFQ2eXJkbFpINWNadXdIRnlJSi9rQXRHc1RnMHhINXRhQUFxNDRCQWsxQ1BrOUtWVmJxUXpyQ1VpRmRGLzZndGxQUThiSEhjMUcxVzkyTVhHWjVIRUhmdHlMWXM4bWJELzl4WVJVV2tIbWxNMHpDMmlsSmxuTmdWNGJmQUxwUWdoeE9Vb1pMN1ZUcXRDSElhUVNYbStZVU1ucGtYeWJuVitBNnhsbTJDVnk4Zm4wWGxtMlhSYTArenpPYTIxSldXbWl4ZmlQTVNDWjdxQTRyUzkzVk4zcGtwRjFzNVRvblFqaXNIZjdpVTlaR3ZVUE9BS1pjUjFwYmVWZi9VbDdPaGVwR0NhSWQ5d090cW83cEo3eUxjQlowcEZrT0YyOHk0ekVJL2tjVU5tdXRCSGFRcEJkTk04dmpDUzZIWlJva2tlbzg4VEJBakd5RzdTUis2dlVnVGN5SzlJbWFsajBrdXh6MHdtSytieVFVMTFBaUpGay95YTVkTmR1UkNsY25VNjR5R3UvaWVXU2VPb3MxdDNlcCtSUElXUTJweVRZVmJabHRUYnNiN05pd1NpM0FWKzhLTFdrN0x4Q25mWlVldEVNOFRobnNTb0dIMzgvbnlBd0ZndUpwOEZqdmxIdGNXWnVVNGhQdmEwckhmcjBVaE9PSi9GNnZTNjJGVzdLemttUmxsMkhFYzdvVXE0ZnlpNVQ3MFZsN1lWSWZzUEhVQ2RIZXNmOUxrN1dOVldPNzVKRGtZYk1JOFRPVzhKS1Z0TFk5ZDZVSlJJVE84b0tvMHhTK285OVl5MDRpbmlHSEFhR2o4OGtFV2d3djBPckhkWS9ucjc2RE9HTlM1OWhYQ0dYelRLVXZEbDlpS3BMU1dZTjFseElleXl3ZE5wVGtoYXk3NHcyakZUNk5TOHFram81Q3hBMXlmU1l3cDZBSklaTktJZUVLNVBKQVc3T1JnV2d3cDBWZ3pZcHFvdk1yV3hidStER1o2TGhpZTFSQXFwem04VlV6S0pPSDNtQ3pXdVRPTHNOM1ZUL2R2MmVlWWU5VWpiUjhZVEJzTHo3cTYwVk4xc1U1MWsrdW0xZjhKeEQ1cFBoYmhTQzhyUmFCNDU0dG1oNllVV3JKSTMrR1dZMHFlV2lvai90YmtZSVRPa0phZXVHdDRKckp2SEErbDBHdTdrWTdYT2FhMDVhbE1uUldWQ1hxRmdMSXdTWTR1RjU5VWU1U1U0UUt1Yy9IYW1EeGJyMHg2Y3NDZXRYR29QN1FuMUJrL0o5RHN5bk8vVUQ2aVoxSHlyeitqaXQwaERDd2kvRTlPamdLVGJCM1pRS1EvMFpPdmV2Zk5IRzBOSzRBajNDcDdOcFJrMDdSVDFpL1MwRUw5M0FnOEdSZ0tJOUNmcGFqS3lLNitKai9QSTFLTzUvODVWQXd6MkF3elA4RlRCYjA3NUl4Q1h2NlQ5UlZ2V1QydFVhcXhEUzkyenJHVWJXelVZazltU3M4MnBFQ0grZmtxc0R0OTNWVysrNFlzUi9kSENZY1FTWVRPL0thQk1EajlMU0QvSi8rejIwS3E4WHZaVUFJSHRtOWhSUFAzSXRidUF1MkhtNWxrUHM5MnBkN2tDeGdSczB4T1ZCbloxM2NjZEEwYXVucnd2OVNkcUVsSlJDM2crb0N1K25YeUNnbVhVczl5TWpUTUFJSGZ4WlYrYVBLY1plVUJXdDA1N1hvODVLczFJcjVnekVIQ1dxWkVockxaTXVGMTF6aUd0RlFVZHMvRUVTYWpoYWd6Y0tzeGFtY1NaeEd0aDRVSUkrYWRQaFFrVW54Mld5Tis0WVdSK3IzZjhNbmt5R0Z1UjR6anp4SlM4V3NRWVI1UFR5UmFEOWl4YTZNaDc0MW5CSGJ6ZmpYSHNrR0RxMTc5eGFSTnJDSUIxejF4UmZXZmpxdzJwSGMxems5eGxQcEw4c1FXQUl1RVRaWmhibm1MNTRyY2VYVk5SdlVpS3JycUlrZW9nc2wwWFhiMTd5bE5iMGY0R0E5V2Q0NHZmZkVHOEZTWkdIRUwyZmJhVEdSY1NpQ2VBOFBtQS9mNkh6OEhDUzc2ZlhVSHdnd2t6U3dsSTcxZWtaN0ZhcG1say9LQytIczhoVWN3M04yTE41TGhrVll5aXpZRmwvdVBlVlA1bHNvSkhoaGZXdnZTV3J1Q1VXMVpjSk9ldVRickRneXdKL3FHMDdnWkpwbG5UdkxjWWROYUgwS01ZT1lNR1grckI0TkdQRm1Rc05hSXdsV3JmQ2V6eHJlOHpYQnJzTVQrZWRWTGJMcU4xQnFCNzZKSDRCdlpUcVVJTWZHd1BHRW4rRW5tVFY4NmZQQmFZYkZMM0RGRWhqQjQ1Q2V3a1hFQXRKeGs0L01zMnBQWG5hUnFka3kwSE9ZZGNVY0UyemNYcTR2YUl2VzIvdjBuSEZKSDJYWGUyMnVlRG1xLzE4WEd0RUxTcTg1ajlYOHEwdGNOU1NLSklYOEZUdUpGL1BmOGo1UGhxRzJ1K29zdnNMeFlydnZmZVZKTCs0dGtjWGNyOUpWN3YwRVJtai9YNmZNM05DNGo2ZFMxKzlVbXIyb1BhdnFpQXlkVFpQTE1OUkdZMjNMTzl6QVZEbHk3akQrNzBHNVRQUExkaFJJbDRXeGNZakxuTStTTmNKMjZGT3JrcklTVXRQT2JJejVaYjNBRzYxMmtybnB5MTVSTVcrMWNRamxuV0ZJNjUzOHFreTlheGQyb0ptSElIUDA4S3lQMHViR08rVFFOT1l1djJ1aDE3eUNJdlI4VmNTdHc3bzFnME5NNjBzays4VHE3WWZJQkpydHA1M0drdnpYSDdPQTBwOC9uL3Uxc2F0Zi9WSmh0UjFsOFdhNkdtYXVnN2hhU3BhQ2FZUWF4NnRhMG1rdXRsYitlQU9TRzFhb2JNODFEOUE0aVMxUlJsekJCb1ZYNnRVMVM2V0UyTjlPUlk2RGZlTFJDNGw5UnZyNWg5NVhEV0IybVIxZDRXRnVkcHNnVll3aVR3VDMxbGpza0Q4WnlET2xtNURrR2g5Ti9VQi8wQUk1WHZiOFpCbWFpMmhRNEJXTXFGd1luenh3QjI2WUhTT3Y5V2dZM0pYbnZvTisyUjRycUdWaC9MTERNdHBGUCtTcE1HSk5XdmJJbDVTT29kYkNjelcyUktsZWtzUG9VZUdFenJqdEtIVmR0WkEra2ZxTytyVngvaWNsQ3F3b29wZXB2SnBTVERqVCtiOUdXeWxHUkY4RURiR2x3NmVVem1KTTk1T3Zveitrd0xYM2MyZlRqRmVZRXNFN3ZVWm0zbXFkR0p1S2gydzkvUUdTYXFSSHM5OWFTY0dPZERxa0ZjQUNvcWRiQm9RcXFqYW1oSDZROW5nMzlKQ2czbHJHSndkNTBRazlvdm5xQlRyOE1NRTdQczJ3aVZmeWdVbVBvVUJKSmZKV1g1TmRhMG51bmNiRmtBPT0nKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmNsdWRlLmpzLm1hcCJdLCJuYW1lcyI6WyJkZWNvZGUiLCJyZWFkX2NvbXByZXNzZWRfcGF5bG9hZCIsImdldERhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ens_normalize: () => (/* binding */ ens_normalize),\n/* harmony export */   ens_normalize_post_check: () => (/* binding */ ens_normalize_post_check)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _include_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./include.js */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js\");\n/* harmony import */ var _decoder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decoder.js */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js\");\n/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */ \n\nconst r = (0,_include_js__WEBPACK_IMPORTED_MODULE_0__.getData)();\n\n// @TODO: This should be lazily loaded\nconst VALID = new Set((0,_decoder_js__WEBPACK_IMPORTED_MODULE_1__.read_member_array)(r));\nconst IGNORED = new Set((0,_decoder_js__WEBPACK_IMPORTED_MODULE_1__.read_member_array)(r));\nconst MAPPED = (0,_decoder_js__WEBPACK_IMPORTED_MODULE_1__.read_mapped_map)(r);\nconst EMOJI_ROOT = (0,_decoder_js__WEBPACK_IMPORTED_MODULE_1__.read_emoji_trie)(r);\n//const NFC_CHECK = new Set(read_member_array(r, Array.from(VALID.values()).sort((a, b) => a - b)));\n//const STOP = 0x2E;\nconst HYPHEN = 0x2D;\nconst UNDERSCORE = 0x5F;\nfunction explode_cp(name) {\n    return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__.toUtf8CodePoints)(name);\n}\nfunction filter_fe0f(cps) {\n    return cps.filter((cp)=>cp != 0xFE0F);\n}\nfunction ens_normalize_post_check(name) {\n    for (let label of name.split(\".\")){\n        let cps = explode_cp(label);\n        try {\n            for(let i = cps.lastIndexOf(UNDERSCORE) - 1; i >= 0; i--){\n                if (cps[i] !== UNDERSCORE) {\n                    throw new Error(`underscore only allowed at start`);\n                }\n            }\n            if (cps.length >= 4 && cps.every((cp)=>cp < 0x80) && cps[2] === HYPHEN && cps[3] === HYPHEN) {\n                throw new Error(`invalid label extension`);\n            }\n        } catch (err) {\n            throw new Error(`Invalid label \"${label}\": ${err.message}`);\n        }\n    }\n    return name;\n}\nfunction ens_normalize(name) {\n    return ens_normalize_post_check(normalize(name, filter_fe0f));\n}\nfunction normalize(name, emoji_filter) {\n    let input = explode_cp(name).reverse(); // flip for pop\n    let output = [];\n    while(input.length){\n        let emoji = consume_emoji_reversed(input);\n        if (emoji) {\n            output.push(...emoji_filter(emoji));\n            continue;\n        }\n        let cp = input.pop();\n        if (VALID.has(cp)) {\n            output.push(cp);\n            continue;\n        }\n        if (IGNORED.has(cp)) {\n            continue;\n        }\n        let cps = MAPPED[cp];\n        if (cps) {\n            output.push(...cps);\n            continue;\n        }\n        throw new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);\n    }\n    return ens_normalize_post_check(nfc(String.fromCodePoint(...output)));\n}\nfunction nfc(s) {\n    return s.normalize(\"NFC\");\n}\nfunction consume_emoji_reversed(cps, eaten) {\n    var _a;\n    let node = EMOJI_ROOT;\n    let emoji;\n    let saved;\n    let stack = [];\n    let pos = cps.length;\n    if (eaten) eaten.length = 0; // clear input buffer (if needed)\n    while(pos){\n        let cp = cps[--pos];\n        node = (_a = node.branches.find((x)=>x.set.has(cp))) === null || _a === void 0 ? void 0 : _a.node;\n        if (!node) break;\n        if (node.save) {\n            saved = cp;\n        } else if (node.check) {\n            if (cp === saved) break;\n        }\n        stack.push(cp);\n        if (node.fe0f) {\n            stack.push(0xFE0F);\n            if (pos > 0 && cps[pos - 1] == 0xFE0F) pos--; // consume optional FE0F\n        }\n        if (node.valid) {\n            emoji = stack.slice(); // copy stack\n            if (node.valid == 2) emoji.splice(1, 1); // delete FE0F at position 1 (RGI ZWJ don't follow spec!)\n            if (eaten) eaten.push(...cps.slice(pos).reverse()); // copy input (if needed)\n            cps.length = pos; // truncate\n        }\n    }\n    return emoji;\n} //# sourceMappingURL=lib.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi5lc20vZW5zLW5vcm1hbGl6ZS9saWIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMkJDLEdBQ3lEO0FBQ25CO0FBQ3ZDLE1BQU1FLElBQUlELG9EQUFPQTtBQUNrRTtBQUNuRixzQ0FBc0M7QUFDdEMsTUFBTUssUUFBUSxJQUFJQyxJQUFJSiw4REFBaUJBLENBQUNEO0FBQ3hDLE1BQU1NLFVBQVUsSUFBSUQsSUFBSUosOERBQWlCQSxDQUFDRDtBQUMxQyxNQUFNTyxTQUFTTCw0REFBZUEsQ0FBQ0Y7QUFDL0IsTUFBTVEsYUFBYUwsNERBQWVBLENBQUNIO0FBQ25DLG9HQUFvRztBQUNwRyxvQkFBb0I7QUFDcEIsTUFBTVMsU0FBUztBQUNmLE1BQU1DLGFBQWE7QUFDbkIsU0FBU0MsV0FBV0MsSUFBSTtJQUNwQixPQUFPZCx3RUFBZ0JBLENBQUNjO0FBQzVCO0FBQ0EsU0FBU0MsWUFBWUMsR0FBRztJQUNwQixPQUFPQSxJQUFJQyxNQUFNLENBQUNDLENBQUFBLEtBQU1BLE1BQU07QUFDbEM7QUFDTyxTQUFTQyx5QkFBeUJMLElBQUk7SUFDekMsS0FBSyxJQUFJTSxTQUFTTixLQUFLTyxLQUFLLENBQUMsS0FBTTtRQUMvQixJQUFJTCxNQUFNSCxXQUFXTztRQUNyQixJQUFJO1lBQ0EsSUFBSyxJQUFJRSxJQUFJTixJQUFJTyxXQUFXLENBQUNYLGNBQWMsR0FBR1UsS0FBSyxHQUFHQSxJQUFLO2dCQUN2RCxJQUFJTixHQUFHLENBQUNNLEVBQUUsS0FBS1YsWUFBWTtvQkFDdkIsTUFBTSxJQUFJWSxNQUFNLENBQUMsZ0NBQWdDLENBQUM7Z0JBQ3REO1lBQ0o7WUFDQSxJQUFJUixJQUFJUyxNQUFNLElBQUksS0FBS1QsSUFBSVUsS0FBSyxDQUFDUixDQUFBQSxLQUFNQSxLQUFLLFNBQVNGLEdBQUcs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LE1BQU0sR0FBRzBCLEtBQUssV0FBVztRQUNqQztJQUNKO0lBQ0EsT0FBT2hCO0FBQ1gsRUFDQSwrQkFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbGltZS1iZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi5lc20vZW5zLW5vcm1hbGl6ZS9saWIuanM/MWU1YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1JVCBMaWNlbnNlXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDIxIEFuZHJldyBSYWZmZW5zcGVyZ2VyXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqXG4gKiBUaGlzIGlzIGEgbmVhciBjYXJib24tY29weSBvZiB0aGUgb3JpZ2luYWwgc291cmNlIChsaW5rIGJlbG93KSB3aXRoIHRoZVxuICogVHlwZVNjcmlwdCB0eXBpbmdzIGFkZGVkIGFuZCBhIGZldyB0d2Vha3MgdG8gbWFrZSBpdCBFUzMtY29tcGF0aWJsZS5cbiAqXG4gKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanNcbiAqL1xuaW1wb3J0IHsgdG9VdGY4Q29kZVBvaW50cyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9zdHJpbmdzXCI7XG5pbXBvcnQgeyBnZXREYXRhIH0gZnJvbSAnLi9pbmNsdWRlLmpzJztcbmNvbnN0IHIgPSBnZXREYXRhKCk7XG5pbXBvcnQgeyByZWFkX21lbWJlcl9hcnJheSwgcmVhZF9tYXBwZWRfbWFwLCByZWFkX2Vtb2ppX3RyaWUgfSBmcm9tICcuL2RlY29kZXIuanMnO1xuLy8gQFRPRE86IFRoaXMgc2hvdWxkIGJlIGxhemlseSBsb2FkZWRcbmNvbnN0IFZBTElEID0gbmV3IFNldChyZWFkX21lbWJlcl9hcnJheShyKSk7XG5jb25zdCBJR05PUkVEID0gbmV3IFNldChyZWFkX21lbWJlcl9hcnJheShyKSk7XG5jb25zdCBNQVBQRUQgPSByZWFkX21hcHBlZF9tYXAocik7XG5jb25zdCBFTU9KSV9ST09UID0gcmVhZF9lbW9qaV90cmllKHIpO1xuLy9jb25zdCBORkNfQ0hFQ0sgPSBuZXcgU2V0KHJlYWRfbWVtYmVyX2FycmF5KHIsIEFycmF5LmZyb20oVkFMSUQudmFsdWVzKCkpLnNvcnQoKGEsIGIpID0+IGEgLSBiKSkpO1xuLy9jb25zdCBTVE9QID0gMHgyRTtcbmNvbnN0IEhZUEhFTiA9IDB4MkQ7XG5jb25zdCBVTkRFUlNDT1JFID0gMHg1RjtcbmZ1bmN0aW9uIGV4cGxvZGVfY3AobmFtZSkge1xuICAgIHJldHVybiB0b1V0ZjhDb2RlUG9pbnRzKG5hbWUpO1xufVxuZnVuY3Rpb24gZmlsdGVyX2ZlMGYoY3BzKSB7XG4gICAgcmV0dXJuIGNwcy5maWx0ZXIoY3AgPT4gY3AgIT0gMHhGRTBGKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbnNfbm9ybWFsaXplX3Bvc3RfY2hlY2sobmFtZSkge1xuICAgIGZvciAobGV0IGxhYmVsIG9mIG5hbWUuc3BsaXQoJy4nKSkge1xuICAgICAgICBsZXQgY3BzID0gZXhwbG9kZV9jcChsYWJlbCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gY3BzLmxhc3RJbmRleE9mKFVOREVSU0NPUkUpIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoY3BzW2ldICE9PSBVTkRFUlNDT1JFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5kZXJzY29yZSBvbmx5IGFsbG93ZWQgYXQgc3RhcnRgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3BzLmxlbmd0aCA+PSA0ICYmIGNwcy5ldmVyeShjcCA9PiBjcCA8IDB4ODApICYmIGNwc1syXSA9PT0gSFlQSEVOICYmIGNwc1szXSA9PT0gSFlQSEVOKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGxhYmVsIGV4dGVuc2lvbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBsYWJlbCBcIiR7bGFiZWx9XCI6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5zX25vcm1hbGl6ZShuYW1lKSB7XG4gICAgcmV0dXJuIGVuc19ub3JtYWxpemVfcG9zdF9jaGVjayhub3JtYWxpemUobmFtZSwgZmlsdGVyX2ZlMGYpKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZShuYW1lLCBlbW9qaV9maWx0ZXIpIHtcbiAgICBsZXQgaW5wdXQgPSBleHBsb2RlX2NwKG5hbWUpLnJldmVyc2UoKTsgLy8gZmxpcCBmb3IgcG9wXG4gICAgbGV0IG91dHB1dCA9IFtdO1xuICAgIHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGVtb2ppID0gY29uc3VtZV9lbW9qaV9yZXZlcnNlZChpbnB1dCk7XG4gICAgICAgIGlmIChlbW9qaSkge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goLi4uZW1vamlfZmlsdGVyKGVtb2ppKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3AgPSBpbnB1dC5wb3AoKTtcbiAgICAgICAgaWYgKFZBTElELmhhcyhjcCkpIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGNwKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJR05PUkVELmhhcyhjcCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjcHMgPSBNQVBQRURbY3BdO1xuICAgICAgICBpZiAoY3BzKSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaCguLi5jcHMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaXNhbGxvd2VkIGNvZGVwb2ludDogMHgke2NwLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gZW5zX25vcm1hbGl6ZV9wb3N0X2NoZWNrKG5mYyhTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5vdXRwdXQpKSk7XG59XG5mdW5jdGlvbiBuZmMocykge1xuICAgIHJldHVybiBzLm5vcm1hbGl6ZSgnTkZDJyk7XG59XG5mdW5jdGlvbiBjb25zdW1lX2Vtb2ppX3JldmVyc2VkKGNwcywgZWF0ZW4pIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG5vZGUgPSBFTU9KSV9ST09UO1xuICAgIGxldCBlbW9qaTtcbiAgICBsZXQgc2F2ZWQ7XG4gICAgbGV0IHN0YWNrID0gW107XG4gICAgbGV0IHBvcyA9IGNwcy5sZW5ndGg7XG4gICAgaWYgKGVhdGVuKVxuICAgICAgICBlYXRlbi5sZW5ndGggPSAwOyAvLyBjbGVhciBpbnB1dCBidWZmZXIgKGlmIG5lZWRlZClcbiAgICB3aGlsZSAocG9zKSB7XG4gICAgICAgIGxldCBjcCA9IGNwc1stLXBvc107XG4gICAgICAgIG5vZGUgPSAoX2EgPSBub2RlLmJyYW5jaGVzLmZpbmQoeCA9PiB4LnNldC5oYXMoY3ApKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vZGU7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAobm9kZS5zYXZlKSB7IC8vIHJlbWVtYmVyXG4gICAgICAgICAgICBzYXZlZCA9IGNwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUuY2hlY2spIHsgLy8gY2hlY2sgZXhjbHVzaW9uXG4gICAgICAgICAgICBpZiAoY3AgPT09IHNhdmVkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2goY3ApO1xuICAgICAgICBpZiAobm9kZS5mZTBmKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKDB4RkUwRik7XG4gICAgICAgICAgICBpZiAocG9zID4gMCAmJiBjcHNbcG9zIC0gMV0gPT0gMHhGRTBGKVxuICAgICAgICAgICAgICAgIHBvcy0tOyAvLyBjb25zdW1lIG9wdGlvbmFsIEZFMEZcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS52YWxpZCkgeyAvLyB0aGlzIGlzIGEgdmFsaWQgZW1vamkgKHNvIGZhcilcbiAgICAgICAgICAgIGVtb2ppID0gc3RhY2suc2xpY2UoKTsgLy8gY29weSBzdGFja1xuICAgICAgICAgICAgaWYgKG5vZGUudmFsaWQgPT0gMilcbiAgICAgICAgICAgICAgICBlbW9qaS5zcGxpY2UoMSwgMSk7IC8vIGRlbGV0ZSBGRTBGIGF0IHBvc2l0aW9uIDEgKFJHSSBaV0ogZG9uJ3QgZm9sbG93IHNwZWMhKVxuICAgICAgICAgICAgaWYgKGVhdGVuKVxuICAgICAgICAgICAgICAgIGVhdGVuLnB1c2goLi4uY3BzLnNsaWNlKHBvcykucmV2ZXJzZSgpKTsgLy8gY29weSBpbnB1dCAoaWYgbmVlZGVkKVxuICAgICAgICAgICAgY3BzLmxlbmd0aCA9IHBvczsgLy8gdHJ1bmNhdGVcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW1vamk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saWIuanMubWFwIl0sIm5hbWVzIjpbInRvVXRmOENvZGVQb2ludHMiLCJnZXREYXRhIiwiciIsInJlYWRfbWVtYmVyX2FycmF5IiwicmVhZF9tYXBwZWRfbWFwIiwicmVhZF9lbW9qaV90cmllIiwiVkFMSUQiLCJTZXQiLCJJR05PUkVEIiwiTUFQUEVEIiwiRU1PSklfUk9PVCIsIkhZUEhFTiIsIlVOREVSU0NPUkUiLCJleHBsb2RlX2NwIiwibmFtZSIsImZpbHRlcl9mZTBmIiwiY3BzIiwiZmlsdGVyIiwiY3AiLCJlbnNfbm9ybWFsaXplX3Bvc3RfY2hlY2siLCJsYWJlbCIsInNwbGl0IiwiaSIsImxhc3RJbmRleE9mIiwiRXJyb3IiLCJsZW5ndGgiLCJldmVyeSIsImVyciIsIm1lc3NhZ2UiLCJlbnNfbm9ybWFsaXplIiwibm9ybWFsaXplIiwiZW1vamlfZmlsdGVyIiwiaW5wdXQiLCJyZXZlcnNlIiwib3V0cHV0IiwiZW1vamkiLCJjb25zdW1lX2Vtb2ppX3JldmVyc2VkIiwicHVzaCIsInBvcCIsImhhcyIsInRvU3RyaW5nIiwidG9VcHBlckNhc2UiLCJuZmMiLCJTdHJpbmciLCJmcm9tQ29kZVBvaW50IiwicyIsImVhdGVuIiwiX2EiLCJub2RlIiwic2F2ZWQiLCJzdGFjayIsInBvcyIsImJyYW5jaGVzIiwiZmluZCIsIngiLCJzZXQiLCJzYXZlIiwiY2hlY2siLCJmZTBmIiwidmFsaWQiLCJzbGljZSIsInNwbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/id.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/id.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   id: () => (/* binding */ id)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/keccak256/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n\n\nfunction id(text) {\n    return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_0__.keccak256)((0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(text));\n} //# sourceMappingURL=id.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi5lc20vaWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFEO0FBQ0E7QUFDOUMsU0FBU0UsR0FBR0MsSUFBSTtJQUNuQixPQUFPSCxtRUFBU0EsQ0FBQ0MsbUVBQVdBLENBQUNFO0FBQ2pDLEVBQ0EsOEJBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2xpbWUtYmV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvaGFzaC9saWIuZXNtL2lkLmpzPzNjMDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2tlY2NhazI1NlwiO1xuaW1wb3J0IHsgdG9VdGY4Qnl0ZXMgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvc3RyaW5nc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGlkKHRleHQpIHtcbiAgICByZXR1cm4ga2VjY2FrMjU2KHRvVXRmOEJ5dGVzKHRleHQpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkLmpzLm1hcCJdLCJuYW1lcyI6WyJrZWNjYWsyNTYiLCJ0b1V0ZjhCeXRlcyIsImlkIiwidGV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/id.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/namehash.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/namehash.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dnsEncode: () => (/* binding */ dnsEncode),\n/* harmony export */   ensNormalize: () => (/* binding */ ensNormalize),\n/* harmony export */   isValidName: () => (/* binding */ isValidName),\n/* harmony export */   namehash: () => (/* binding */ namehash)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/keccak256/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/_version.js\");\n/* harmony import */ var _ens_normalize_lib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ens-normalize/lib */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js\");\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nfunction checkComponent(comp) {\n    if (comp.length === 0) {\n        throw new Error(\"invalid ENS name; empty component\");\n    }\n    return comp;\n}\nfunction ensNameSplit(name) {\n    const bytes = (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__.toUtf8Bytes)((0,_ens_normalize_lib__WEBPACK_IMPORTED_MODULE_3__.ens_normalize)(name));\n    const comps = [];\n    if (name.length === 0) {\n        return comps;\n    }\n    let last = 0;\n    for(let i = 0; i < bytes.length; i++){\n        const d = bytes[i];\n        // A separator (i.e. \".\"); copy this component\n        if (d === 0x2e) {\n            comps.push(checkComponent(bytes.slice(last, i)));\n            last = i + 1;\n        }\n    }\n    // There was a stray separator at the end of the name\n    if (last >= bytes.length) {\n        throw new Error(\"invalid ENS name; empty component\");\n    }\n    comps.push(checkComponent(bytes.slice(last)));\n    return comps;\n}\nfunction ensNormalize(name) {\n    return ensNameSplit(name).map((comp)=>(0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__.toUtf8String)(comp)).join(\".\");\n}\nfunction isValidName(name) {\n    try {\n        return ensNameSplit(name).length !== 0;\n    } catch (error) {}\n    return false;\n}\nfunction namehash(name) {\n    /* istanbul ignore if */ if (typeof name !== \"string\") {\n        logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n    }\n    let result = Zeros;\n    const comps = ensNameSplit(name);\n    while(comps.length){\n        result = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_4__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.concat)([\n            result,\n            (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_4__.keccak256)(comps.pop())\n        ]));\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexlify)(result);\n}\nfunction dnsEncode(name) {\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.concat)(ensNameSplit(name).map((comp)=>{\n        // DNS does not allow components over 63 bytes in length\n        if (comp.length > 63) {\n            throw new Error(\"invalid DNS encoded entry; length exceeds 63 bytes\");\n        }\n        const bytes = new Uint8Array(comp.length + 1);\n        bytes.set(comp, 1);\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n} //# sourceMappingURL=namehash.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi5lc20vbmFtZWhhc2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF1RDtBQUNZO0FBQ2Q7QUFDTjtBQUNWO0FBQ3JDLE1BQU1PLFNBQVMsSUFBSUYseURBQU1BLENBQUNDLDZDQUFPQTtBQUNtQjtBQUNwRCxNQUFNRyxRQUFRLElBQUlDLFdBQVc7QUFDN0JELE1BQU1FLElBQUksQ0FBQztBQUNYLFNBQVNDLGVBQWVDLElBQUk7SUFDeEIsSUFBSUEsS0FBS0MsTUFBTSxLQUFLLEdBQUc7UUFDbkIsTUFBTSxJQUFJQyxNQUFNO0lBQ3BCO0lBQ0EsT0FBT0Y7QUFDWDtBQUNBLFNBQVNHLGFBQWFDLElBQUk7SUFDdEIsTUFBTUMsUUFBUWhCLG1FQUFXQSxDQUFDTSxpRUFBYUEsQ0FBQ1M7SUFDeEMsTUFBTUUsUUFBUSxFQUFFO0lBQ2hCLElBQUlGLEtBQUtILE1BQU0sS0FBSyxHQUFHO1FBQ25CLE9BQU9LO0lBQ1g7SUFDQSxJQUFJQyxPQUFPO0lBQ1gsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILE1BQU1KLE1BQU0sRUFBRU8sSUFBSztRQUNuQyxNQUFNQyxJQUFJSixLQUFLLENBQUNHLEVBQUU7UUFDbEIsOENBQThDO1FBQzlDLElBQUlDLE1BQU0sTUFBTTtZQUNaSCxNQUFNSSxJQUFJLENBQUNYLGVBQWVNLE1BQU1NLEtBQUssQ0FBQ0osTUFBTUM7WUFDNUNELE9BQU9DLElBQUk7UUFDZjtJQUNKO0lBQ0EscURBQXFEO0lBQ3JELElBQUlELFFBQVFGLE1BQU1KLE1BQU0sRUFBRTtRQUN0QixNQUFNLElBQUlDLE1BQU07SUFDcEI7SUFDQUksTUFBTUksSUFBSSxDQUFDWCxlQUFlTSxNQUFNTSxLQUFLLENBQUNKO0lBQ3RDLE9BQU9EO0FBQ1g7QUFDTyxTQUFTTSxhQUFhUixJQUFJO0lBQzdCLE9BQU9ELGFBQWFDLE1BQU1TLEdBQUcsQ0FBQyxDQUFDYixPQUFTVixvRUFBWUEsQ0FBQ1UsT0FBT2MsSUFBSSxDQUFDO0FBQ3JFO0FBQ08sU0FBU0MsWUFBWVgsSUFBSTtJQUM1QixJQUFJO1FBQ0EsT0FBUUQsYUFBYUMsTUFBTUgsTUFBTSxLQUFLO0lBQzFDLEVBQ0EsT0FBT2UsT0FBTyxDQUFFO0lBQ2hCLE9BQU87QUFDWDtBQUNPLFNBQVNDLFNBQVNiLElBQUk7SUFDekIsc0JBQXNCLEdBQ3RCLElBQUksT0FBUUEsU0FBVSxVQUFVO1FBQzVCVixPQUFPd0Isa0JBQWtCLENBQUMsa0NBQWtDLFFBQVFkO0lBQ3hFO0lBQ0EsSUFBSWUsU0FBU3ZCO0lBQ2IsTUFBTVUsUUFBUUgsYUFBYUM7SUFDM0IsTUFBT0UsTUFBTUwsTUFBTSxDQUFFO1FBQ2pCa0IsU0FBUzVCLG1FQUFTQSxDQUFDSiw0REFBTUEsQ0FBQztZQUFDZ0M7WUFBUTVCLG1FQUFTQSxDQUFDZSxNQUFNYyxHQUFHO1NBQUk7SUFDOUQ7SUFDQSxPQUFPaEMsNkRBQU9BLENBQUMrQjtBQUNuQjtBQUNPLFNBQVNFLFVBQVVqQixJQUFJO0lBQzFCLE9BQU9oQiw2REFBT0EsQ0FBQ0QsNERBQU1BLENBQUNnQixhQUFhQyxNQUFNUyxHQUFHLENBQUMsQ0FBQ2I7UUFDMUMsd0RBQXdEO1FBQ3hELElBQUlBLEtBQUtDLE1BQU0sR0FBRyxJQUFJO1lBQ2xCLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUNBLE1BQU1HLFFBQVEsSUFBSVIsV0FBV0csS0FBS0MsTUFBTSxHQUFHO1FBQzNDSSxNQUFNaUIsR0FBRyxDQUFDdEIsTUFBTTtRQUNoQkssS0FBSyxDQUFDLEVBQUUsR0FBR0EsTUFBTUosTUFBTSxHQUFHO1FBQzFCLE9BQU9JO0lBQ1gsT0FBTztBQUNYLEVBQ0Esb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2xpbWUtYmV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvaGFzaC9saWIuZXNtL25hbWVoYXNoLmpzPzFlMWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29uY2F0LCBoZXhsaWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcywgdG9VdGY4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3N0cmluZ3NcIjtcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9rZWNjYWsyNTZcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IGVuc19ub3JtYWxpemUgfSBmcm9tIFwiLi9lbnMtbm9ybWFsaXplL2xpYlwiO1xuY29uc3QgWmVyb3MgPSBuZXcgVWludDhBcnJheSgzMik7XG5aZXJvcy5maWxsKDApO1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnQoY29tcCkge1xuICAgIGlmIChjb21wLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEVOUyBuYW1lOyBlbXB0eSBjb21wb25lbnRcIik7XG4gICAgfVxuICAgIHJldHVybiBjb21wO1xufVxuZnVuY3Rpb24gZW5zTmFtZVNwbGl0KG5hbWUpIHtcbiAgICBjb25zdCBieXRlcyA9IHRvVXRmOEJ5dGVzKGVuc19ub3JtYWxpemUobmFtZSkpO1xuICAgIGNvbnN0IGNvbXBzID0gW107XG4gICAgaWYgKG5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBjb21wcztcbiAgICB9XG4gICAgbGV0IGxhc3QgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZCA9IGJ5dGVzW2ldO1xuICAgICAgICAvLyBBIHNlcGFyYXRvciAoaS5lLiBcIi5cIik7IGNvcHkgdGhpcyBjb21wb25lbnRcbiAgICAgICAgaWYgKGQgPT09IDB4MmUpIHtcbiAgICAgICAgICAgIGNvbXBzLnB1c2goY2hlY2tDb21wb25lbnQoYnl0ZXMuc2xpY2UobGFzdCwgaSkpKTtcbiAgICAgICAgICAgIGxhc3QgPSBpICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGVyZSB3YXMgYSBzdHJheSBzZXBhcmF0b3IgYXQgdGhlIGVuZCBvZiB0aGUgbmFtZVxuICAgIGlmIChsYXN0ID49IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEVOUyBuYW1lOyBlbXB0eSBjb21wb25lbnRcIik7XG4gICAgfVxuICAgIGNvbXBzLnB1c2goY2hlY2tDb21wb25lbnQoYnl0ZXMuc2xpY2UobGFzdCkpKTtcbiAgICByZXR1cm4gY29tcHM7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5zTm9ybWFsaXplKG5hbWUpIHtcbiAgICByZXR1cm4gZW5zTmFtZVNwbGl0KG5hbWUpLm1hcCgoY29tcCkgPT4gdG9VdGY4U3RyaW5nKGNvbXApKS5qb2luKFwiLlwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkTmFtZShuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChlbnNOYW1lU3BsaXQobmFtZSkubGVuZ3RoICE9PSAwKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gbmFtZWhhc2gobmFtZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0eXBlb2YgKG5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEVOUyBuYW1lOyBub3QgYSBzdHJpbmdcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gWmVyb3M7XG4gICAgY29uc3QgY29tcHMgPSBlbnNOYW1lU3BsaXQobmFtZSk7XG4gICAgd2hpbGUgKGNvbXBzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSBrZWNjYWsyNTYoY29uY2F0KFtyZXN1bHQsIGtlY2NhazI1Nihjb21wcy5wb3AoKSldKSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KHJlc3VsdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZG5zRW5jb2RlKG5hbWUpIHtcbiAgICByZXR1cm4gaGV4bGlmeShjb25jYXQoZW5zTmFtZVNwbGl0KG5hbWUpLm1hcCgoY29tcCkgPT4ge1xuICAgICAgICAvLyBETlMgZG9lcyBub3QgYWxsb3cgY29tcG9uZW50cyBvdmVyIDYzIGJ5dGVzIGluIGxlbmd0aFxuICAgICAgICBpZiAoY29tcC5sZW5ndGggPiA2Mykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBETlMgZW5jb2RlZCBlbnRyeTsgbGVuZ3RoIGV4Y2VlZHMgNjMgYnl0ZXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShjb21wLmxlbmd0aCArIDEpO1xuICAgICAgICBieXRlcy5zZXQoY29tcCwgMSk7XG4gICAgICAgIGJ5dGVzWzBdID0gYnl0ZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0pKSkgKyBcIjAwXCI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYW1laGFzaC5qcy5tYXAiXSwibmFtZXMiOlsiY29uY2F0IiwiaGV4bGlmeSIsInRvVXRmOEJ5dGVzIiwidG9VdGY4U3RyaW5nIiwia2VjY2FrMjU2IiwiTG9nZ2VyIiwidmVyc2lvbiIsImxvZ2dlciIsImVuc19ub3JtYWxpemUiLCJaZXJvcyIsIlVpbnQ4QXJyYXkiLCJmaWxsIiwiY2hlY2tDb21wb25lbnQiLCJjb21wIiwibGVuZ3RoIiwiRXJyb3IiLCJlbnNOYW1lU3BsaXQiLCJuYW1lIiwiYnl0ZXMiLCJjb21wcyIsImxhc3QiLCJpIiwiZCIsInB1c2giLCJzbGljZSIsImVuc05vcm1hbGl6ZSIsIm1hcCIsImpvaW4iLCJpc1ZhbGlkTmFtZSIsImVycm9yIiwibmFtZWhhc2giLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJyZXN1bHQiLCJwb3AiLCJkbnNFbmNvZGUiLCJzZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/namehash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/typed-data.js":
/*!************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/typed-data.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypedDataEncoder: () => (/* binding */ TypedDataEncoder)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/keccak256/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/_version.js\");\n/* harmony import */ var _id__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./id */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/id.js\");\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst NegativeOne = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(-1);\nconst Zero = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(0);\nconst One = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(1);\nconst MaxUint256 = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nfunction hexPadRight(value) {\n    const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value);\n    const padOffset = bytes.length % 32;\n    if (padOffset) {\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n            bytes,\n            padding.slice(padOffset)\n        ]);\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(bytes);\n}\nconst hexTrue = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(One.toHexString(), 32);\nconst hexFalse = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(Zero.toHexString(), 32);\nconst domainFieldTypes = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\nconst domainFieldNames = [\n    \"name\",\n    \"version\",\n    \"chainId\",\n    \"verifyingContract\",\n    \"salt\"\n];\nfunction checkString(key) {\n    return function(value) {\n        if (typeof value !== \"string\") {\n            logger.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n        }\n        return value;\n    };\n}\nconst domainChecks = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function(value) {\n        try {\n            return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(value).toString();\n        } catch (error) {}\n        return logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\n    },\n    verifyingContract: function(value) {\n        try {\n            return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_4__.getAddress)(value).toLowerCase();\n        } catch (error) {}\n        return logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function(value) {\n        try {\n            const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value);\n            if (bytes.length !== 32) {\n                throw new Error(\"bad length\");\n            }\n            return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(bytes);\n        } catch (error) {}\n        return logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\n    }\n};\nfunction getBaseEncoder(type) {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = match[1] === \"\";\n            const width = parseInt(match[2] || \"256\");\n            if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {\n                logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n            }\n            const boundsUpper = MaxUint256.mask(signed ? width - 1 : width);\n            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;\n            return function(value) {\n                const v = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(value);\n                if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n                    logger.throwArgumentError(`value out-of-bounds for ${type}`, \"value\", value);\n                }\n                return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            if (width === 0 || width > 32 || match[1] !== String(width)) {\n                logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n            }\n            return function(value) {\n                const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value);\n                if (bytes.length !== width) {\n                    logger.throwArgumentError(`invalid length for ${type}`, \"value\", value);\n                }\n                return hexPadRight(value);\n            };\n        }\n    }\n    switch(type){\n        case \"address\":\n            return function(value) {\n                return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)((0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_4__.getAddress)(value), 32);\n            };\n        case \"bool\":\n            return function(value) {\n                return !value ? hexFalse : hexTrue;\n            };\n        case \"bytes\":\n            return function(value) {\n                return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256)(value);\n            };\n        case \"string\":\n            return function(value) {\n                return (0,_id__WEBPACK_IMPORTED_MODULE_6__.id)(value);\n            };\n    }\n    return null;\n}\nfunction encodeType(name, fields) {\n    return `${name}(${fields.map(({ name, type })=>type + \" \" + name).join(\",\")})`;\n}\nclass TypedDataEncoder {\n    constructor(types){\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.defineReadOnly)(this, \"types\", Object.freeze((0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.deepCopy)(types)));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.defineReadOnly)(this, \"_encoderCache\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.defineReadOnly)(this, \"_types\", {});\n        // Link struct types to their direct child structs\n        const links = {};\n        // Link structs to structs which contain them as a child\n        const parents = {};\n        // Link all subtypes within a given struct\n        const subtypes = {};\n        Object.keys(types).forEach((type)=>{\n            links[type] = {};\n            parents[type] = [];\n            subtypes[type] = {};\n        });\n        for(const name in types){\n            const uniqueNames = {};\n            types[name].forEach((field)=>{\n                // Check each field has a unique name\n                if (uniqueNames[field.name]) {\n                    logger.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", types);\n                }\n                uniqueNames[field.name] = true;\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n                if (baseType === name) {\n                    logger.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, \"types\", types);\n                }\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) {\n                    return;\n                }\n                if (!parents[baseType]) {\n                    logger.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, \"types\", types);\n                }\n                // Add linkage\n                parents[baseType].push(name);\n                links[name][baseType] = true;\n            });\n        }\n        // Deduce the primary type\n        const primaryTypes = Object.keys(parents).filter((n)=>parents[n].length === 0);\n        if (primaryTypes.length === 0) {\n            logger.throwArgumentError(\"missing primary type\", \"types\", types);\n        } else if (primaryTypes.length > 1) {\n            logger.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t)=>JSON.stringify(t)).join(\", \")}`, \"types\", types);\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.defineReadOnly)(this, \"primaryType\", primaryTypes[0]);\n        // Check for circular type references\n        function checkCircular(type, found) {\n            if (found[type]) {\n                logger.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, \"types\", types);\n            }\n            found[type] = true;\n            Object.keys(links[type]).forEach((child)=>{\n                if (!parents[child]) {\n                    return;\n                }\n                // Recursively check children\n                checkCircular(child, found);\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach((subtype)=>{\n                    subtypes[subtype][child] = true;\n                });\n            });\n            delete found[type];\n        }\n        checkCircular(this.primaryType, {});\n        // Compute each fully describe type\n        for(const name in subtypes){\n            const st = Object.keys(subtypes[name]);\n            st.sort();\n            this._types[name] = encodeType(name, types[name]) + st.map((t)=>encodeType(t, types[t])).join(\"\");\n        }\n    }\n    getEncoder(type) {\n        let encoder = this._encoderCache[type];\n        if (!encoder) {\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n        }\n        return encoder;\n    }\n    _getEncoder(type) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return encoder;\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            const length = parseInt(match[3]);\n            return (value)=>{\n                if (length >= 0 && value.length !== length) {\n                    logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n                }\n                let result = value.map(subEncoder);\n                if (this._types[subtype]) {\n                    result = result.map(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256);\n                }\n                return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)(result));\n            };\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = (0,_id__WEBPACK_IMPORTED_MODULE_6__.id)(this._types[type]);\n            return (value)=>{\n                const values = fields.map(({ name, type })=>{\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this._types[type]) {\n                        return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256)(result);\n                    }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)(values);\n            };\n        }\n        return logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\n    }\n    encodeType(name) {\n        const result = this._types[name];\n        if (!result) {\n            logger.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, \"name\", name);\n        }\n        return result;\n    }\n    encodeData(type, value) {\n        return this.getEncoder(type)(value);\n    }\n    hashStruct(name, value) {\n        return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256)(this.encodeData(name, value));\n    }\n    encode(value) {\n        return this.encodeData(this.primaryType, value);\n    }\n    hash(value) {\n        return this.hashStruct(this.primaryType, value);\n    }\n    _visit(type, value, callback) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return callback(type, value);\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const length = parseInt(match[3]);\n            if (length >= 0 && value.length !== length) {\n                logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n            }\n            return value.map((v)=>this._visit(subtype, v, callback));\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type })=>{\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, {});\n        }\n        return logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\n    }\n    visit(value, callback) {\n        return this._visit(this.primaryType, value, callback);\n    }\n    static from(types) {\n        return new TypedDataEncoder(types);\n    }\n    static getPrimaryType(types) {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n    static hashStruct(name, types, value) {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n    static hashDomain(domain) {\n        const domainFields = [];\n        for(const name in domain){\n            const type = domainFieldTypes[name];\n            if (!type) {\n                logger.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n            }\n            domainFields.push({\n                name,\n                type\n            });\n        }\n        domainFields.sort((a, b)=>{\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", {\n            EIP712Domain: domainFields\n        }, domain);\n    }\n    static encode(domain, types, value) {\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n    static hash(domain, types, value) {\n        return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256)(TypedDataEncoder.encode(domain, types, value));\n    }\n    // Replaces all address types with ENS names with their looked up address\n    static resolveNames(domain, types, value, resolveName) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // Make a copy to isolate it from the object passed in\n            domain = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.shallowCopy)(domain);\n            // Look up all ENS names\n            const ensCache = {};\n            // Do we need to look up the domain's verifyingContract?\n            if (domain.verifyingContract && !(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(domain.verifyingContract, 20)) {\n                ensCache[domain.verifyingContract] = \"0x\";\n            }\n            // We are going to use the encoder to visit all the base values\n            const encoder = TypedDataEncoder.from(types);\n            // Get a list of all the addresses\n            encoder.visit(value, (type, value)=>{\n                if (type === \"address\" && !(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(value, 20)) {\n                    ensCache[value] = \"0x\";\n                }\n                return value;\n            });\n            // Lookup each name\n            for(const name in ensCache){\n                ensCache[name] = yield resolveName(name);\n            }\n            // Replace the domain verifyingContract if needed\n            if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n                domain.verifyingContract = ensCache[domain.verifyingContract];\n            }\n            // Replace all ENS names with their address\n            value = encoder.visit(value, (type, value)=>{\n                if (type === \"address\" && ensCache[value]) {\n                    return ensCache[value];\n                }\n                return value;\n            });\n            return {\n                domain,\n                value\n            };\n        });\n    }\n    static getPayload(domain, types, value) {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n        // Derive the EIP712Domain Struct reference type\n        const domainValues = {};\n        const domainTypes = [];\n        domainFieldNames.forEach((name)=>{\n            const value = domain[name];\n            if (value == null) {\n                return;\n            }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({\n                name,\n                type: domainFieldTypes[name]\n            });\n        });\n        const encoder = TypedDataEncoder.from(types);\n        const typesWithDomain = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.shallowCopy)(types);\n        if (typesWithDomain.EIP712Domain) {\n            logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        } else {\n            typesWithDomain.EIP712Domain = domainTypes;\n        }\n        // Validate the data structures and types\n        encoder.encode(value);\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type, value)=>{\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value));\n                }\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(value).toString();\n                }\n                switch(type){\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        if (typeof value !== \"string\") {\n                            logger.throwArgumentError(`invalid string`, \"value\", value);\n                        }\n                        return value;\n                }\n                return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n            })\n        };\n    }\n} //# sourceMappingURL=typed-data.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi5lc20vdHlwZWQtZGF0YS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxZQUFZLFNBQUssSUFBSSxTQUFJLENBQUNBLFNBQVMsSUFBSyxTQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ25GLFNBQVNDLE1BQU1DLEtBQUs7UUFBSSxPQUFPQSxpQkFBaUJILElBQUlHLFFBQVEsSUFBSUgsRUFBRSxTQUFVSSxPQUFPO1lBQUlBLFFBQVFEO1FBQVE7SUFBSTtJQUMzRyxPQUFPLElBQUtILENBQUFBLEtBQU1BLENBQUFBLElBQUlLLE9BQU0sQ0FBQyxFQUFHLFNBQVVELE9BQU8sRUFBRUUsTUFBTTtRQUNyRCxTQUFTQyxVQUFVSixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsVUFBVVEsSUFBSSxDQUFDTjtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzFGLFNBQVNDLFNBQVNSLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxTQUFTLENBQUMsUUFBUSxDQUFDRTtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzdGLFNBQVNGLEtBQUtJLE1BQU07WUFBSUEsT0FBT0MsSUFBSSxHQUFHVCxRQUFRUSxPQUFPVCxLQUFLLElBQUlELE1BQU1VLE9BQU9ULEtBQUssRUFBRVcsSUFBSSxDQUFDUCxXQUFXSTtRQUFXO1FBQzdHSCxLQUFLLENBQUNQLFlBQVlBLFVBQVVjLEtBQUssQ0FBQ2pCLFNBQVNDLGNBQWMsRUFBRSxHQUFHVSxJQUFJO0lBQ3RFO0FBQ0o7QUFDb0Q7QUFDQztBQUN3QztBQUN4QztBQUM2QjtBQUNuQztBQUNWO0FBQ3JDLE1BQU1vQixTQUFTLElBQUlGLHlEQUFNQSxDQUFDQyw2Q0FBT0E7QUFDUDtBQUMx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bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliLmVzbS90eXBlZC1kYXRhLmpzPzQ4N2UiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2FkZHJlc3NcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGFycmF5aWZ5LCBoZXhDb25jYXQsIGhleGxpZnksIGhleFplcm9QYWQsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qva2VjY2FrMjU2XCI7XG5pbXBvcnQgeyBkZWVwQ29weSwgZGVmaW5lUmVhZE9ubHksIHNoYWxsb3dDb3B5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IGlkIH0gZnJvbSBcIi4vaWRcIjtcbmNvbnN0IHBhZGRpbmcgPSBuZXcgVWludDhBcnJheSgzMik7XG5wYWRkaW5nLmZpbGwoMCk7XG5jb25zdCBOZWdhdGl2ZU9uZSA9IEJpZ051bWJlci5mcm9tKC0xKTtcbmNvbnN0IFplcm8gPSBCaWdOdW1iZXIuZnJvbSgwKTtcbmNvbnN0IE9uZSA9IEJpZ051bWJlci5mcm9tKDEpO1xuY29uc3QgTWF4VWludDI1NiA9IEJpZ051bWJlci5mcm9tKFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO1xuZnVuY3Rpb24gaGV4UGFkUmlnaHQodmFsdWUpIHtcbiAgICBjb25zdCBieXRlcyA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICBjb25zdCBwYWRPZmZzZXQgPSBieXRlcy5sZW5ndGggJSAzMjtcbiAgICBpZiAocGFkT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBoZXhDb25jYXQoW2J5dGVzLCBwYWRkaW5nLnNsaWNlKHBhZE9mZnNldCldKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleGxpZnkoYnl0ZXMpO1xufVxuY29uc3QgaGV4VHJ1ZSA9IGhleFplcm9QYWQoT25lLnRvSGV4U3RyaW5nKCksIDMyKTtcbmNvbnN0IGhleEZhbHNlID0gaGV4WmVyb1BhZChaZXJvLnRvSGV4U3RyaW5nKCksIDMyKTtcbmNvbnN0IGRvbWFpbkZpZWxkVHlwZXMgPSB7XG4gICAgbmFtZTogXCJzdHJpbmdcIixcbiAgICB2ZXJzaW9uOiBcInN0cmluZ1wiLFxuICAgIGNoYWluSWQ6IFwidWludDI1NlwiLFxuICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBcImFkZHJlc3NcIixcbiAgICBzYWx0OiBcImJ5dGVzMzJcIlxufTtcbmNvbnN0IGRvbWFpbkZpZWxkTmFtZXMgPSBbXG4gICAgXCJuYW1lXCIsIFwidmVyc2lvblwiLCBcImNoYWluSWRcIiwgXCJ2ZXJpZnlpbmdDb250cmFjdFwiLCBcInNhbHRcIlxuXTtcbmZ1bmN0aW9uIGNoZWNrU3RyaW5nKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBmb3IgJHtKU09OLnN0cmluZ2lmeShrZXkpfWAsIGBkb21haW4uJHtrZXl9YCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufVxuY29uc3QgZG9tYWluQ2hlY2tzID0ge1xuICAgIG5hbWU6IGNoZWNrU3RyaW5nKFwibmFtZVwiKSxcbiAgICB2ZXJzaW9uOiBjaGVja1N0cmluZyhcInZlcnNpb25cIiksXG4gICAgY2hhaW5JZDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20odmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgZG9tYWluIHZhbHVlIGZvciBcImNoYWluSWRcImAsIFwiZG9tYWluLmNoYWluSWRcIiwgdmFsdWUpO1xuICAgIH0sXG4gICAgdmVyaWZ5aW5nQ29udHJhY3Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEFkZHJlc3ModmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgZG9tYWluIHZhbHVlIFwidmVyaWZ5aW5nQ29udHJhY3RcImAsIFwiZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XCIsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNhbHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBhcnJheWlmeSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSAzMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBsZW5ndGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGV4bGlmeShieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgZG9tYWluIHZhbHVlIFwic2FsdFwiYCwgXCJkb21haW4uc2FsdFwiLCB2YWx1ZSk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGdldEJhc2VFbmNvZGVyKHR5cGUpIHtcbiAgICAvLyBpbnRYWCBhbmQgdWludFhYXG4gICAge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2goL14odT8paW50KFxcZCopJC8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lZCA9IChtYXRjaFsxXSA9PT0gXCJcIik7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHBhcnNlSW50KG1hdGNoWzJdIHx8IFwiMjU2XCIpO1xuICAgICAgICAgICAgaWYgKHdpZHRoICUgOCAhPT0gMCB8fCB3aWR0aCA+IDI1NiB8fCAobWF0Y2hbMl0gJiYgbWF0Y2hbMl0gIT09IFN0cmluZyh3aWR0aCkpKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbnVtZXJpYyB3aWR0aFwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBib3VuZHNVcHBlciA9IE1heFVpbnQyNTYubWFzayhzaWduZWQgPyAod2lkdGggLSAxKSA6IHdpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kc0xvd2VyID0gc2lnbmVkID8gYm91bmRzVXBwZXIuYWRkKE9uZSkubXVsKE5lZ2F0aXZlT25lKSA6IFplcm87XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IEJpZ051bWJlci5mcm9tKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodi5sdChib3VuZHNMb3dlcikgfHwgdi5ndChib3VuZHNVcHBlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgdmFsdWUgb3V0LW9mLWJvdW5kcyBmb3IgJHt0eXBlfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4WmVyb1BhZCh2LnRvVHdvcygyNTYpLnRvSGV4U3RyaW5nKCksIDMyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYnl0ZXNYWFxuICAgIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eYnl0ZXMoXFxkKykkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgICAgICBpZiAod2lkdGggPT09IDAgfHwgd2lkdGggPiAzMiB8fCBtYXRjaFsxXSAhPT0gU3RyaW5nKHdpZHRoKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGJ5dGVzIHdpZHRoXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBieXRlcyA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIGxlbmd0aCBmb3IgJHt0eXBlfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4UGFkUmlnaHQodmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImFkZHJlc3NcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGhleFplcm9QYWQoZ2V0QWRkcmVzcyh2YWx1ZSksIDMyKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImJvb2xcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICgoIXZhbHVlKSA/IGhleEZhbHNlIDogaGV4VHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJieXRlc1wiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQodmFsdWUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGVuY29kZVR5cGUobmFtZSwgZmllbGRzKSB7XG4gICAgcmV0dXJuIGAke25hbWV9KCR7ZmllbGRzLm1hcCgoeyBuYW1lLCB0eXBlIH0pID0+ICh0eXBlICsgXCIgXCIgKyBuYW1lKSkuam9pbihcIixcIil9KWA7XG59XG5leHBvcnQgY2xhc3MgVHlwZWREYXRhRW5jb2RlciB7XG4gICAgY29uc3RydWN0b3IodHlwZXMpIHtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJ0eXBlc1wiLCBPYmplY3QuZnJlZXplKGRlZXBDb3B5KHR5cGVzKSkpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9lbmNvZGVyQ2FjaGVcIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl90eXBlc1wiLCB7fSk7XG4gICAgICAgIC8vIExpbmsgc3RydWN0IHR5cGVzIHRvIHRoZWlyIGRpcmVjdCBjaGlsZCBzdHJ1Y3RzXG4gICAgICAgIGNvbnN0IGxpbmtzID0ge307XG4gICAgICAgIC8vIExpbmsgc3RydWN0cyB0byBzdHJ1Y3RzIHdoaWNoIGNvbnRhaW4gdGhlbSBhcyBhIGNoaWxkXG4gICAgICAgIGNvbnN0IHBhcmVudHMgPSB7fTtcbiAgICAgICAgLy8gTGluayBhbGwgc3VidHlwZXMgd2l0aGluIGEgZ2l2ZW4gc3RydWN0XG4gICAgICAgIGNvbnN0IHN1YnR5cGVzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHR5cGVzKS5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgICAgICBsaW5rc1t0eXBlXSA9IHt9O1xuICAgICAgICAgICAgcGFyZW50c1t0eXBlXSA9IFtdO1xuICAgICAgICAgICAgc3VidHlwZXNbdHlwZV0gPSB7fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB0eXBlcykge1xuICAgICAgICAgICAgY29uc3QgdW5pcXVlTmFtZXMgPSB7fTtcbiAgICAgICAgICAgIHR5cGVzW25hbWVdLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZWFjaCBmaWVsZCBoYXMgYSB1bmlxdWUgbmFtZVxuICAgICAgICAgICAgICAgIGlmICh1bmlxdWVOYW1lc1tmaWVsZC5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBkdXBsaWNhdGUgdmFyaWFibGUgbmFtZSAke0pTT04uc3RyaW5naWZ5KGZpZWxkLm5hbWUpfSBpbiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bmlxdWVOYW1lc1tmaWVsZC5uYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBiYXNlIHR5cGUgKGRyb3AgYW55IGFycmF5IHNwZWNpZmllcnMpXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZVR5cGUgPSBmaWVsZC50eXBlLm1hdGNoKC9eKFteXFx4NWJdKikoXFx4NWJ8JCkvKVsxXTtcbiAgICAgICAgICAgICAgICBpZiAoYmFzZVR5cGUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgY2lyY3VsYXIgdHlwZSByZWZlcmVuY2UgdG8gJHtKU09OLnN0cmluZ2lmeShiYXNlVHlwZSl9YCwgXCJ0eXBlc1wiLCB0eXBlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElzIHRoaXMgYSBiYXNlIGVuY29kaW5nIHR5cGU/XG4gICAgICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IGdldEJhc2VFbmNvZGVyKGJhc2VUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcGFyZW50c1tiYXNlVHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgdW5rbm93biB0eXBlICR7SlNPTi5zdHJpbmdpZnkoYmFzZVR5cGUpfWAsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBZGQgbGlua2FnZVxuICAgICAgICAgICAgICAgIHBhcmVudHNbYmFzZVR5cGVdLnB1c2gobmFtZSk7XG4gICAgICAgICAgICAgICAgbGlua3NbbmFtZV1bYmFzZVR5cGVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlZHVjZSB0aGUgcHJpbWFyeSB0eXBlXG4gICAgICAgIGNvbnN0IHByaW1hcnlUeXBlcyA9IE9iamVjdC5rZXlzKHBhcmVudHMpLmZpbHRlcigobikgPT4gKHBhcmVudHNbbl0ubGVuZ3RoID09PSAwKSk7XG4gICAgICAgIGlmIChwcmltYXJ5VHlwZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibWlzc2luZyBwcmltYXJ5IHR5cGVcIiwgXCJ0eXBlc1wiLCB0eXBlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJpbWFyeVR5cGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGFtYmlndW91cyBwcmltYXJ5IHR5cGVzIG9yIHVudXNlZCB0eXBlczogJHtwcmltYXJ5VHlwZXMubWFwKCh0KSA9PiAoSlNPTi5zdHJpbmdpZnkodCkpKS5qb2luKFwiLCBcIil9YCwgXCJ0eXBlc1wiLCB0eXBlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcmltYXJ5VHlwZVwiLCBwcmltYXJ5VHlwZXNbMF0pO1xuICAgICAgICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgdHlwZSByZWZlcmVuY2VzXG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrQ2lyY3VsYXIodHlwZSwgZm91bmQpIHtcbiAgICAgICAgICAgIGlmIChmb3VuZFt0eXBlXSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlIHRvICR7SlNPTi5zdHJpbmdpZnkodHlwZSl9YCwgXCJ0eXBlc1wiLCB0eXBlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3VuZFt0eXBlXSA9IHRydWU7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhsaW5rc1t0eXBlXSkuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudHNbY2hpbGRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgY2hlY2sgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBjaGVja0NpcmN1bGFyKGNoaWxkLCBmb3VuZCk7XG4gICAgICAgICAgICAgICAgLy8gTWFyayBhbGwgYW5jZXN0b3JzIGFzIGhhdmluZyB0aGlzIGRlY2VuZGFudFxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGZvdW5kKS5mb3JFYWNoKChzdWJ0eXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnR5cGVzW3N1YnR5cGVdW2NoaWxkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlbGV0ZSBmb3VuZFt0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja0NpcmN1bGFyKHRoaXMucHJpbWFyeVR5cGUsIHt9KTtcbiAgICAgICAgLy8gQ29tcHV0ZSBlYWNoIGZ1bGx5IGRlc2NyaWJlIHR5cGVcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHN1YnR5cGVzKSB7XG4gICAgICAgICAgICBjb25zdCBzdCA9IE9iamVjdC5rZXlzKHN1YnR5cGVzW25hbWVdKTtcbiAgICAgICAgICAgIHN0LnNvcnQoKTtcbiAgICAgICAgICAgIHRoaXMuX3R5cGVzW25hbWVdID0gZW5jb2RlVHlwZShuYW1lLCB0eXBlc1tuYW1lXSkgKyBzdC5tYXAoKHQpID0+IGVuY29kZVR5cGUodCwgdHlwZXNbdF0pKS5qb2luKFwiXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEVuY29kZXIodHlwZSkge1xuICAgICAgICBsZXQgZW5jb2RlciA9IHRoaXMuX2VuY29kZXJDYWNoZVt0eXBlXTtcbiAgICAgICAgaWYgKCFlbmNvZGVyKSB7XG4gICAgICAgICAgICBlbmNvZGVyID0gdGhpcy5fZW5jb2RlckNhY2hlW3R5cGVdID0gdGhpcy5fZ2V0RW5jb2Rlcih0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jb2RlcjtcbiAgICB9XG4gICAgX2dldEVuY29kZXIodHlwZSkge1xuICAgICAgICAvLyBCYXNpYyBlbmNvZGVyIHR5cGUgKGFkZHJlc3MsIGJvb2wsIHVpbnQyNTYsIGV0YylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IGdldEJhc2VFbmNvZGVyKHR5cGUpO1xuICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheVxuICAgICAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2goL14oLiopKFxceDViKFxcZCopXFx4NWQpJC8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnR5cGUgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIGNvbnN0IHN1YkVuY29kZXIgPSB0aGlzLmdldEVuY29kZXIoc3VidHlwZSk7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA+PSAwICYmIHZhbHVlLmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJhcnJheSBsZW5ndGggbWlzbWF0Y2g7IGV4cGVjdGVkIGxlbmd0aCAkeyBhcnJheUxlbmd0aCB9XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gdmFsdWUubWFwKHN1YkVuY29kZXIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90eXBlc1tzdWJ0eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubWFwKGtlY2NhazI1Nik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBrZWNjYWsyNTYoaGV4Q29uY2F0KHJlc3VsdCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHJ1Y3RcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy50eXBlc1t0eXBlXTtcbiAgICAgICAgaWYgKGZpZWxkcykge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlZFR5cGUgPSBpZCh0aGlzLl90eXBlc1t0eXBlXSk7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gZmllbGRzLm1hcCgoeyBuYW1lLCB0eXBlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5nZXRFbmNvZGVyKHR5cGUpKHZhbHVlW25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGVzW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YWx1ZXMudW5zaGlmdChlbmNvZGVkVHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleENvbmNhdCh2YWx1ZXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgdW5rbm93biB0eXBlOiAke3R5cGV9YCwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICBlbmNvZGVUeXBlKG5hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fdHlwZXNbbmFtZV07XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGB1bmtub3duIHR5cGU6ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVuY29kZURhdGEodHlwZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RW5jb2Rlcih0eXBlKSh2YWx1ZSk7XG4gICAgfVxuICAgIGhhc2hTdHJ1Y3QobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGtlY2NhazI1Nih0aGlzLmVuY29kZURhdGEobmFtZSwgdmFsdWUpKTtcbiAgICB9XG4gICAgZW5jb2RlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZURhdGEodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICBoYXNoKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc2hTdHJ1Y3QodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICBfdmlzaXQodHlwZSwgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIEJhc2ljIGVuY29kZXIgdHlwZSAoYWRkcmVzcywgYm9vbCwgdWludDI1NiwgZXRjKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gZ2V0QmFzZUVuY29kZXIodHlwZSk7XG4gICAgICAgICAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0eXBlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXlcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eKC4qKShcXHg1YihcXGQqKVxceDVkKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJ0eXBlID0gbWF0Y2hbMV07XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICAgICAgICBpZiAobGVuZ3RoID49IDAgJiYgdmFsdWUubGVuZ3RoICE9PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYXJyYXkgbGVuZ3RoIG1pc21hdGNoOyBleHBlY3RlZCBsZW5ndGggJHsgYXJyYXlMZW5ndGggfVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHYpID0+IHRoaXMuX3Zpc2l0KHN1YnR5cGUsIHYsIGNhbGxiYWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RydWN0XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMudHlwZXNbdHlwZV07XG4gICAgICAgIGlmIChmaWVsZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZHMucmVkdWNlKChhY2N1bSwgeyBuYW1lLCB0eXBlIH0pID0+IHtcbiAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IHRoaXMuX3Zpc2l0KHR5cGUsIHZhbHVlW25hbWVdLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGB1bmtub3duIHR5cGU6ICR7dHlwZX1gLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgfVxuICAgIHZpc2l0KHZhbHVlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXQodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZERhdGFFbmNvZGVyKHR5cGVzKTtcbiAgICB9XG4gICAgc3RhdGljIGdldFByaW1hcnlUeXBlKHR5cGVzKSB7XG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLnByaW1hcnlUeXBlO1xuICAgIH1cbiAgICBzdGF0aWMgaGFzaFN0cnVjdChuYW1lLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcykuaGFzaFN0cnVjdChuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBoYXNoRG9tYWluKGRvbWFpbikge1xuICAgICAgICBjb25zdCBkb21haW5GaWVsZHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGRvbWFpbikge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGRvbWFpbkZpZWxkVHlwZXNbbmFtZV07XG4gICAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIHR5cGVkLWRhdGEgZG9tYWluIGtleTogJHtKU09OLnN0cmluZ2lmeShuYW1lKX1gLCBcImRvbWFpblwiLCBkb21haW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tYWluRmllbGRzLnB1c2goeyBuYW1lLCB0eXBlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRvbWFpbkZpZWxkcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZG9tYWluRmllbGROYW1lcy5pbmRleE9mKGEubmFtZSkgLSBkb21haW5GaWVsZE5hbWVzLmluZGV4T2YoYi5uYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmhhc2hTdHJ1Y3QoXCJFSVA3MTJEb21haW5cIiwgeyBFSVA3MTJEb21haW46IGRvbWFpbkZpZWxkcyB9LCBkb21haW4pO1xuICAgIH1cbiAgICBzdGF0aWMgZW5jb2RlKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBoZXhDb25jYXQoW1xuICAgICAgICAgICAgXCIweDE5MDFcIixcbiAgICAgICAgICAgIFR5cGVkRGF0YUVuY29kZXIuaGFzaERvbWFpbihkb21haW4pLFxuICAgICAgICAgICAgVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5oYXNoKHZhbHVlKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgc3RhdGljIGhhc2goZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGtlY2NhazI1NihUeXBlZERhdGFFbmNvZGVyLmVuY29kZShkb21haW4sIHR5cGVzLCB2YWx1ZSkpO1xuICAgIH1cbiAgICAvLyBSZXBsYWNlcyBhbGwgYWRkcmVzcyB0eXBlcyB3aXRoIEVOUyBuYW1lcyB3aXRoIHRoZWlyIGxvb2tlZCB1cCBhZGRyZXNzXG4gICAgc3RhdGljIHJlc29sdmVOYW1lcyhkb21haW4sIHR5cGVzLCB2YWx1ZSwgcmVzb2x2ZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIE1ha2UgYSBjb3B5IHRvIGlzb2xhdGUgaXQgZnJvbSB0aGUgb2JqZWN0IHBhc3NlZCBpblxuICAgICAgICAgICAgZG9tYWluID0gc2hhbGxvd0NvcHkoZG9tYWluKTtcbiAgICAgICAgICAgIC8vIExvb2sgdXAgYWxsIEVOUyBuYW1lc1xuICAgICAgICAgICAgY29uc3QgZW5zQ2FjaGUgPSB7fTtcbiAgICAgICAgICAgIC8vIERvIHdlIG5lZWQgdG8gbG9vayB1cCB0aGUgZG9tYWluJ3MgdmVyaWZ5aW5nQ29udHJhY3Q/XG4gICAgICAgICAgICBpZiAoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ICYmICFpc0hleFN0cmluZyhkb21haW4udmVyaWZ5aW5nQ29udHJhY3QsIDIwKSkge1xuICAgICAgICAgICAgICAgIGVuc0NhY2hlW2RvbWFpbi52ZXJpZnlpbmdDb250cmFjdF0gPSBcIjB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBhcmUgZ29pbmcgdG8gdXNlIHRoZSBlbmNvZGVyIHRvIHZpc2l0IGFsbCB0aGUgYmFzZSB2YWx1ZXNcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpO1xuICAgICAgICAgICAgLy8gR2V0IGEgbGlzdCBvZiBhbGwgdGhlIGFkZHJlc3Nlc1xuICAgICAgICAgICAgZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYWRkcmVzc1wiICYmICFpc0hleFN0cmluZyh2YWx1ZSwgMjApKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuc0NhY2hlW3ZhbHVlXSA9IFwiMHhcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBMb29rdXAgZWFjaCBuYW1lXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZW5zQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICBlbnNDYWNoZVtuYW1lXSA9IHlpZWxkIHJlc29sdmVOYW1lKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgZG9tYWluIHZlcmlmeWluZ0NvbnRyYWN0IGlmIG5lZWRlZFxuICAgICAgICAgICAgaWYgKGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCAmJiBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdKSB7XG4gICAgICAgICAgICAgICAgZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ID0gZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlcGxhY2UgYWxsIEVOUyBuYW1lcyB3aXRoIHRoZWlyIGFkZHJlc3NcbiAgICAgICAgICAgIHZhbHVlID0gZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYWRkcmVzc1wiICYmIGVuc0NhY2hlW3ZhbHVlXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5zQ2FjaGVbdmFsdWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IGRvbWFpbiwgdmFsdWUgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRQYXlsb2FkKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSBkb21haW4gZmllbGRzXG4gICAgICAgIFR5cGVkRGF0YUVuY29kZXIuaGFzaERvbWFpbihkb21haW4pO1xuICAgICAgICAvLyBEZXJpdmUgdGhlIEVJUDcxMkRvbWFpbiBTdHJ1Y3QgcmVmZXJlbmNlIHR5cGVcbiAgICAgICAgY29uc3QgZG9tYWluVmFsdWVzID0ge307XG4gICAgICAgIGNvbnN0IGRvbWFpblR5cGVzID0gW107XG4gICAgICAgIGRvbWFpbkZpZWxkTmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkb21haW5bbmFtZV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbWFpblZhbHVlc1tuYW1lXSA9IGRvbWFpbkNoZWNrc1tuYW1lXSh2YWx1ZSk7XG4gICAgICAgICAgICBkb21haW5UeXBlcy5wdXNoKHsgbmFtZSwgdHlwZTogZG9tYWluRmllbGRUeXBlc1tuYW1lXSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpO1xuICAgICAgICBjb25zdCB0eXBlc1dpdGhEb21haW4gPSBzaGFsbG93Q29weSh0eXBlcyk7XG4gICAgICAgIGlmICh0eXBlc1dpdGhEb21haW4uRUlQNzEyRG9tYWluKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidHlwZXMgbXVzdCBub3QgY29udGFpbiBFSVA3MTJEb21haW4gdHlwZVwiLCBcInR5cGVzLkVJUDcxMkRvbWFpblwiLCB0eXBlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0eXBlc1dpdGhEb21haW4uRUlQNzEyRG9tYWluID0gZG9tYWluVHlwZXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGRhdGEgc3RydWN0dXJlcyBhbmQgdHlwZXNcbiAgICAgICAgZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZXM6IHR5cGVzV2l0aERvbWFpbixcbiAgICAgICAgICAgIGRvbWFpbjogZG9tYWluVmFsdWVzLFxuICAgICAgICAgICAgcHJpbWFyeVR5cGU6IGVuY29kZXIucHJpbWFyeVR5cGUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlbmNvZGVyLnZpc2l0KHZhbHVlLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBieXRlc1xuICAgICAgICAgICAgICAgIGlmICh0eXBlLm1hdGNoKC9eYnl0ZXMoXFxkKikvKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGV4bGlmeShhcnJheWlmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB1aW50IG9yIGludFxuICAgICAgICAgICAgICAgIGlmICh0eXBlLm1hdGNoKC9edT9pbnQvKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20odmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYWRkcmVzc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJib29sXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gISF2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCBzdHJpbmdgLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCB0eXBlXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZWQtZGF0YS5qcy5tYXAiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiZ2V0QWRkcmVzcyIsIkJpZ051bWJlciIsImFycmF5aWZ5IiwiaGV4Q29uY2F0IiwiaGV4bGlmeSIsImhleFplcm9QYWQiLCJpc0hleFN0cmluZyIsImtlY2NhazI1NiIsImRlZXBDb3B5IiwiZGVmaW5lUmVhZE9ubHkiLCJzaGFsbG93Q29weSIsIkxvZ2dlciIsInZlcnNpb24iLCJsb2dnZXIiLCJpZCIsInBhZGRpbmciLCJVaW50OEFycmF5IiwiZmlsbCIsIk5lZ2F0aXZlT25lIiwiZnJvbSIsIlplcm8iLCJPbmUiLCJNYXhVaW50MjU2IiwiaGV4UGFkUmlnaHQiLCJieXRlcyIsInBhZE9mZnNldCIsImxlbmd0aCIsInNsaWNlIiwiaGV4VHJ1ZSIsInRvSGV4U3RyaW5nIiwiaGV4RmFsc2UiLCJkb21haW5GaWVsZFR5cGVzIiwibmFtZSIsImNoYWluSWQiLCJ2ZXJpZnlpbmdDb250cmFjdCIsInNhbHQiLCJkb21haW5GaWVsZE5hbWVzIiwiY2hlY2tTdHJpbmciLCJrZXkiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwiZG9tYWluQ2hlY2tzIiwidG9TdHJpbmciLCJlcnJvciIsInRvTG93ZXJDYXNlIiwiRXJyb3IiLCJnZXRCYXNlRW5jb2RlciIsInR5cGUiLCJtYXRjaCIsInNpZ25lZCIsIndpZHRoIiwicGFyc2VJbnQiLCJTdHJpbmciLCJib3VuZHNVcHBlciIsIm1hc2siLCJib3VuZHNMb3dlciIsImFkZCIsIm11bCIsInYiLCJsdCIsImd0IiwidG9Ud29zIiwiZW5jb2RlVHlwZSIsImZpZWxkcyIsIm1hcCIsImpvaW4iLCJUeXBlZERhdGFFbmNvZGVyIiwiY29uc3RydWN0b3IiLCJ0eXBlcyIsIk9iamVjdCIsImZyZWV6ZSIsImxpbmtzIiwicGFyZW50cyIsInN1YnR5cGVzIiwia2V5cyIsImZvckVhY2giLCJ1bmlxdWVOYW1lcyIsImZpZWxkIiwiYmFzZVR5cGUiLCJlbmNvZGVyIiwicHVzaCIsInByaW1hcnlUeXBlcyIsImZpbHRlciIsIm4iLCJ0IiwiY2hlY2tDaXJjdWxhciIsImZvdW5kIiwiY2hpbGQiLCJzdWJ0eXBlIiwicHJpbWFyeVR5cGUiLCJzdCIsInNvcnQiLCJfdHlwZXMiLCJnZXRFbmNvZGVyIiwiX2VuY29kZXJDYWNoZSIsIl9nZXRFbmNvZGVyIiwic3ViRW5jb2RlciIsImVuY29kZWRUeXBlIiwidmFsdWVzIiwidW5zaGlmdCIsImVuY29kZURhdGEiLCJoYXNoU3RydWN0IiwiZW5jb2RlIiwiaGFzaCIsIl92aXNpdCIsImNhbGxiYWNrIiwicmVkdWNlIiwiYWNjdW0iLCJ2aXNpdCIsImdldFByaW1hcnlUeXBlIiwiaGFzaERvbWFpbiIsImRvbWFpbiIsImRvbWFpbkZpZWxkcyIsImEiLCJiIiwiaW5kZXhPZiIsIkVJUDcxMkRvbWFpbiIsInJlc29sdmVOYW1lcyIsInJlc29sdmVOYW1lIiwiZW5zQ2FjaGUiLCJnZXRQYXlsb2FkIiwiZG9tYWluVmFsdWVzIiwiZG9tYWluVHlwZXMiLCJ0eXBlc1dpdGhEb21haW4iLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/typed-data.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/keccak256/lib.esm/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/keccak256/lib.esm/index.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keccak256: () => (/* binding */ keccak256)\n/* harmony export */ });\n/* harmony import */ var js_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! js-sha3 */ \"(ssr)/./node_modules/js-sha3/src/sha3.js\");\n/* harmony import */ var js_sha3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(js_sha3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n\n\n\nfunction keccak256(data) {\n    return \"0x\" + js_sha3__WEBPACK_IMPORTED_MODULE_0___default().keccak_256((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(data));\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9rZWNjYWsyNTYvbGliLmVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWE7QUFDYztBQUNxQjtBQUN6QyxTQUFTRSxVQUFVQyxJQUFJO0lBQzFCLE9BQU8sT0FBT0gseURBQWUsQ0FBQ0MsOERBQVFBLENBQUNFO0FBQzNDLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2xpbWUtYmV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qva2VjY2FrMjU2L2xpYi5lc20vaW5kZXguanM/MjE2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCBzaGEzIGZyb20gXCJqcy1zaGEzXCI7XG5pbXBvcnQgeyBhcnJheWlmeSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGtlY2NhazI1NihkYXRhKSB7XG4gICAgcmV0dXJuICcweCcgKyBzaGEzLmtlY2Nha18yNTYoYXJyYXlpZnkoZGF0YSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbInNoYTMiLCJhcnJheWlmeSIsImtlY2NhazI1NiIsImRhdGEiLCJrZWNjYWtfMjU2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/keccak256/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/_version.js":
/*!************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/_version.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"logger/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9sb2dnZXIvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsVUFBVSxlQUFlLENBQ3RDLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NsaW1lLWJldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2xvZ2dlci9saWIuZXNtL192ZXJzaW9uLmpzP2M1OWYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcImxvZ2dlci81LjcuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorCode: () => (/* binding */ ErrorCode),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   Logger: () => (/* binding */ Logger)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/_version.js\");\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\nconst LogLevels = {\n    debug: 1,\n    \"default\": 2,\n    info: 2,\n    warning: 3,\n    error: 4,\n    off: 5\n};\nlet _logLevel = LogLevels[\"default\"];\n\nlet _globalLogger = null;\nfunction _checkNormalize() {\n    try {\n        const missing = [];\n        // Make sure all forms of normalization are supported\n        [\n            \"NFD\",\n            \"NFC\",\n            \"NFKD\",\n            \"NFKC\"\n        ].forEach((form)=>{\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                }\n                ;\n            } catch (error) {\n                missing.push(form);\n            }\n        });\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\");\n        }\n    } catch (error) {\n        return error.message;\n    }\n    return null;\n}\nconst _normalizeError = _checkNormalize();\nvar LogLevel;\n(function(LogLevel) {\n    LogLevel[\"DEBUG\"] = \"DEBUG\";\n    LogLevel[\"INFO\"] = \"INFO\";\n    LogLevel[\"WARNING\"] = \"WARNING\";\n    LogLevel[\"ERROR\"] = \"ERROR\";\n    LogLevel[\"OFF\"] = \"OFF\";\n})(LogLevel || (LogLevel = {}));\nvar ErrorCode;\n(function(ErrorCode) {\n    ///////////////////\n    // Generic Errors\n    // Unknown Error\n    ErrorCode[\"UNKNOWN_ERROR\"] = \"UNKNOWN_ERROR\";\n    // Not Implemented\n    ErrorCode[\"NOT_IMPLEMENTED\"] = \"NOT_IMPLEMENTED\";\n    // Unsupported Operation\n    //   - operation\n    ErrorCode[\"UNSUPPORTED_OPERATION\"] = \"UNSUPPORTED_OPERATION\";\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    ErrorCode[\"NETWORK_ERROR\"] = \"NETWORK_ERROR\";\n    // Some sort of bad response from the server\n    ErrorCode[\"SERVER_ERROR\"] = \"SERVER_ERROR\";\n    // Timeout\n    ErrorCode[\"TIMEOUT\"] = \"TIMEOUT\";\n    ///////////////////\n    // Operational  Errors\n    // Buffer Overrun\n    ErrorCode[\"BUFFER_OVERRUN\"] = \"BUFFER_OVERRUN\";\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    ErrorCode[\"NUMERIC_FAULT\"] = \"NUMERIC_FAULT\";\n    ///////////////////\n    // Argument Errors\n    // Missing new operator to an object\n    //  - name: The name of the class\n    ErrorCode[\"MISSING_NEW\"] = \"MISSING_NEW\";\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    ErrorCode[\"INVALID_ARGUMENT\"] = \"INVALID_ARGUMENT\";\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"MISSING_ARGUMENT\"] = \"MISSING_ARGUMENT\";\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"UNEXPECTED_ARGUMENT\"] = \"UNEXPECTED_ARGUMENT\";\n    ///////////////////\n    // Blockchain Errors\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    ErrorCode[\"CALL_EXCEPTION\"] = \"CALL_EXCEPTION\";\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    ErrorCode[\"INSUFFICIENT_FUNDS\"] = \"INSUFFICIENT_FUNDS\";\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    ErrorCode[\"NONCE_EXPIRED\"] = \"NONCE_EXPIRED\";\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    ErrorCode[\"REPLACEMENT_UNDERPRICED\"] = \"REPLACEMENT_UNDERPRICED\";\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    ErrorCode[\"UNPREDICTABLE_GAS_LIMIT\"] = \"UNPREDICTABLE_GAS_LIMIT\";\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    ErrorCode[\"TRANSACTION_REPLACED\"] = \"TRANSACTION_REPLACED\";\n    ///////////////////\n    // Interaction Errors\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ErrorCode[\"ACTION_REJECTED\"] = \"ACTION_REJECTED\";\n})(ErrorCode || (ErrorCode = {}));\n;\nconst HEX = \"0123456789abcdef\";\nclass Logger {\n    constructor(version){\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n    _log(logLevel, args) {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) {\n            return;\n        }\n        console.log.apply(console, args);\n    }\n    debug(...args) {\n        this._log(Logger.levels.DEBUG, args);\n    }\n    info(...args) {\n        this._log(Logger.levels.INFO, args);\n    }\n    warn(...args) {\n        this._log(Logger.levels.WARNING, args);\n    }\n    makeError(message, code, params) {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, {});\n        }\n        if (!code) {\n            code = Logger.errors.UNKNOWN_ERROR;\n        }\n        if (!params) {\n            params = {};\n        }\n        const messageDetails = [];\n        Object.keys(params).forEach((key)=>{\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for(let i = 0; i < value.length; i++){\n                        hex += HEX[value[i] >> 4];\n                        hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${code}`);\n        messageDetails.push(`version=${this.version}`);\n        const reason = message;\n        let url = \"\";\n        switch(code){\n            case ErrorCode.NUMERIC_FAULT:\n                {\n                    url = \"NUMERIC_FAULT\";\n                    const fault = message;\n                    switch(fault){\n                        case \"overflow\":\n                        case \"underflow\":\n                        case \"division-by-zero\":\n                            url += \"-\" + fault;\n                            break;\n                        case \"negative-power\":\n                        case \"negative-width\":\n                            url += \"-unsupported\";\n                            break;\n                        case \"unbound-bitwise-result\":\n                            url += \"-unbound-result\";\n                            break;\n                    }\n                    break;\n                }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n        if (url) {\n            message += \" [ See: https://links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n        // @TODO: Any??\n        const error = new Error(message);\n        error.reason = reason;\n        error.code = code;\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n        return error;\n    }\n    throwError(message, code, params) {\n        throw this.makeError(message, code, params);\n    }\n    throwArgumentError(message, name, value) {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n    assert(condition, message, code, params) {\n        if (!!condition) {\n            return;\n        }\n        this.throwError(message, code, params);\n    }\n    assertArgument(condition, message, name, value) {\n        if (!!condition) {\n            return;\n        }\n        this.throwArgumentError(message, name, value);\n    }\n    checkNormalize(message) {\n        if (message == null) {\n            message = \"platform missing String.prototype.normalize\";\n        }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\",\n                form: _normalizeError\n            });\n        }\n    }\n    checkSafeUint53(value, message) {\n        if (typeof value !== \"number\") {\n            return;\n        }\n        if (message == null) {\n            message = \"value not safe\";\n        }\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n    checkArgumentCount(count, expectedCount, message) {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n    checkNew(target, kind) {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, {\n                name: kind.name\n            });\n        }\n    }\n    checkAbstract(target, kind) {\n        if (target === kind) {\n            this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\", Logger.errors.UNSUPPORTED_OPERATION, {\n                name: target.name,\n                operation: \"new\"\n            });\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, {\n                name: kind.name\n            });\n        }\n    }\n    static globalLogger() {\n        if (!_globalLogger) {\n            _globalLogger = new Logger(_version__WEBPACK_IMPORTED_MODULE_0__.version);\n        }\n        return _globalLogger;\n    }\n    static setCensorship(censorship, permanent) {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        if (_permanentCensorErrors) {\n            if (!censorship) {\n                return;\n            }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n    static setLogLevel(logLevel) {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n    static from(version) {\n        return new Logger(version);\n    }\n}\nLogger.errors = ErrorCode;\nLogger.levels = LogLevel; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9sb2dnZXIvbGliLmVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWE7QUFDYixJQUFJQSx5QkFBeUI7QUFDN0IsSUFBSUMsZ0JBQWdCO0FBQ3BCLE1BQU1DLFlBQVk7SUFBRUMsT0FBTztJQUFHLFdBQVc7SUFBR0MsTUFBTTtJQUFHQyxTQUFTO0lBQUdDLE9BQU87SUFBR0MsS0FBSztBQUFFO0FBQ2xGLElBQUlDLFlBQVlOLFNBQVMsQ0FBQyxVQUFVO0FBQ0M7QUFDckMsSUFBSVEsZ0JBQWdCO0FBQ3BCLFNBQVNDO0lBQ0wsSUFBSTtRQUNBLE1BQU1DLFVBQVUsRUFBRTtRQUNsQixxREFBcUQ7UUFDckQ7WUFBQztZQUFPO1lBQU87WUFBUTtTQUFPLENBQUNDLE9BQU8sQ0FBQyxDQUFDQztZQUNwQyxJQUFJO2dCQUNBLElBQUksT0FBT0MsU0FBUyxDQUFDRCxVQUFVLFFBQVE7b0JBQ25DLE1BQU0sSUFBSUUsTUFBTTtnQkFDcEI7O1lBRUosRUFDQSxPQUFPVixPQUFPO2dCQUNWTSxRQUFRSyxJQUFJLENBQUNIO1lBQ2pCO1FBQ0o7UUFDQSxJQUFJRixRQUFRTSxNQUFNLEVBQUU7WUFDaEIsTUFBTSxJQUFJRixNQUFNLGFBQWFKLFFBQVFPLElBQUksQ0FBQztRQUM5QztRQUNBLElBQUlDLE9BQU9DLFlBQVksQ0FBQyxNQUFNTixTQUFTLENBQUMsV0FBV0ssT0FBT0MsWUFBWSxDQUFDLE1BQU0sU0FBUztZQUNsRixNQUFNLElBQUlMLE1BQU07UUFDcEI7SUFDSixFQUNBLE9BQU9WLE9BQU87UUFDVixPQUFPQSxNQUFNZ0IsT0FBTztJQUN4QjtJQUNBLE9BQU87QUFDWDtBQUNBLE1BQU1DLGtCQUFrQlo7QUFDakIsSUFBSWEsU0FBUztBQUNuQixVQUFVQSxRQUFRO0lBQ2ZBLFFBQVEsQ0FBQyxRQUFRLEdBQUc7SUFDcEJBLFFBQVEsQ0FBQyxPQUFPLEdB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QkFBcUIsRUFBRTtnQkFDOUZDLFdBQVc7WUFDZjtRQUNKO1FBQ0FqRixnQkFBZ0IsQ0FBQyxDQUFDOEY7UUFDbEIvRix5QkFBeUIsQ0FBQyxDQUFDZ0c7SUFDL0I7SUFDQSxPQUFPQyxZQUFZOUQsUUFBUSxFQUFFO1FBQ3pCLE1BQU1FLFFBQVFuQyxTQUFTLENBQUNpQyxTQUFTRyxXQUFXLEdBQUc7UUFDL0MsSUFBSUQsU0FBUyxNQUFNO1lBQ2ZWLE9BQU9rRSxZQUFZLEdBQUcvQyxJQUFJLENBQUMseUJBQXlCWDtZQUNwRDtRQUNKO1FBQ0EzQixZQUFZNkI7SUFDaEI7SUFDQSxPQUFPNkQsS0FBS3pGLE9BQU8sRUFBRTtRQUNqQixPQUFPLElBQUlrQixPQUFPbEI7SUFDdEI7QUFDSjtBQUNBa0IsT0FBT3dCLE1BQU0sR0FBRzFCO0FBQ2hCRSxPQUFPZ0IsTUFBTSxHQUFHbkIsVUFDaEIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2xpbWUtYmV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvbG9nZ2VyL2xpYi5lc20vaW5kZXguanM/YTU0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmxldCBfcGVybWFuZW50Q2Vuc29yRXJyb3JzID0gZmFsc2U7XG5sZXQgX2NlbnNvckVycm9ycyA9IGZhbHNlO1xuY29uc3QgTG9nTGV2ZWxzID0geyBkZWJ1ZzogMSwgXCJkZWZhdWx0XCI6IDIsIGluZm86IDIsIHdhcm5pbmc6IDMsIGVycm9yOiA0LCBvZmY6IDUgfTtcbmxldCBfbG9nTGV2ZWwgPSBMb2dMZXZlbHNbXCJkZWZhdWx0XCJdO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5sZXQgX2dsb2JhbExvZ2dlciA9IG51bGw7XG5mdW5jdGlvbiBfY2hlY2tOb3JtYWxpemUoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWlzc2luZyA9IFtdO1xuICAgICAgICAvLyBNYWtlIHN1cmUgYWxsIGZvcm1zIG9mIG5vcm1hbGl6YXRpb24gYXJlIHN1cHBvcnRlZFxuICAgICAgICBbXCJORkRcIiwgXCJORkNcIiwgXCJORktEXCIsIFwiTkZLQ1wiXS5mb3JFYWNoKChmb3JtKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChcInRlc3RcIi5ub3JtYWxpemUoZm9ybSkgIT09IFwidGVzdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBub3JtYWxpemVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG1pc3NpbmcucHVzaChmb3JtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChtaXNzaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBcIiArIG1pc3Npbmcuam9pbihcIiwgXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoU3RyaW5nLmZyb21DaGFyQ29kZSgweGU5KS5ub3JtYWxpemUoXCJORkRcIikgIT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg2NSwgMHgwMzAxKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYnJva2VuIGltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5jb25zdCBfbm9ybWFsaXplRXJyb3IgPSBfY2hlY2tOb3JtYWxpemUoKTtcbmV4cG9ydCB2YXIgTG9nTGV2ZWw7XG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XG4gICAgTG9nTGV2ZWxbXCJERUJVR1wiXSA9IFwiREVCVUdcIjtcbiAgICBMb2dMZXZlbFtcIklORk9cIl0gPSBcIklORk9cIjtcbiAgICBMb2dMZXZlbFtcIldBUk5JTkdcIl0gPSBcIldBUk5JTkdcIjtcbiAgICBMb2dMZXZlbFtcIkVSUk9SXCJdID0gXCJFUlJPUlwiO1xuICAgIExvZ0xldmVsW1wiT0ZGXCJdID0gXCJPRkZcIjtcbn0pKExvZ0xldmVsIHx8IChMb2dMZXZlbCA9IHt9KSk7XG5leHBvcnQgdmFyIEVycm9yQ29kZTtcbihmdW5jdGlvbiAoRXJyb3JDb2RlKSB7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEdlbmVyaWMgRXJyb3JzXG4gICAgLy8gVW5rbm93biBFcnJvclxuICAgIEVycm9yQ29kZVtcIlVOS05PV05fRVJST1JcIl0gPSBcIlVOS05PV05fRVJST1JcIjtcbiAgICAvLyBOb3QgSW1wbGVtZW50ZWRcbiAgICBFcnJvckNvZGVbXCJOT1RfSU1QTEVNRU5URURcIl0gPSBcIk5PVF9JTVBMRU1FTlRFRFwiO1xuICAgIC8vIFVuc3VwcG9ydGVkIE9wZXJhdGlvblxuICAgIC8vICAgLSBvcGVyYXRpb25cbiAgICBFcnJvckNvZGVbXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIl0gPSBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiO1xuICAgIC8vIE5ldHdvcmsgRXJyb3IgKGkuZS4gRXRoZXJldW0gTmV0d29yaywgc3VjaCBhcyBhbiBpbnZhbGlkIGNoYWluIElEKVxuICAgIC8vICAgLSBldmVudCAoXCJub05ldHdvcmtcIiBpcyBub3QgcmUtdGhyb3duIGluIHByb3ZpZGVyLnJlYWR5OyBvdGhlcndpc2UgdGhyb3duKVxuICAgIEVycm9yQ29kZVtcIk5FVFdPUktfRVJST1JcIl0gPSBcIk5FVFdPUktfRVJST1JcIjtcbiAgICAvLyBTb21lIHNvcnQgb2YgYmFkIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlclxuICAgIEVycm9yQ29kZVtcIlNFUlZFUl9FUlJPUlwiXSA9IFwiU0VSVkVSX0VSUk9SXCI7XG4gICAgLy8gVGltZW91dFxuICAgIEVycm9yQ29kZVtcIlRJTUVPVVRcIl0gPSBcIlRJTUVPVVRcIjtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gT3BlcmF0aW9uYWwgIEVycm9yc1xuICAgIC8vIEJ1ZmZlciBPdmVycnVuXG4gICAgRXJyb3JDb2RlW1wiQlVGRkVSX09WRVJSVU5cIl0gPSBcIkJVRkZFUl9PVkVSUlVOXCI7XG4gICAgLy8gTnVtZXJpYyBGYXVsdFxuICAgIC8vICAgLSBvcGVyYXRpb246IHRoZSBvcGVyYXRpb24gYmVpbmcgZXhlY3V0ZWRcbiAgICAvLyAgIC0gZmF1bHQ6IHRoZSByZWFzb24gdGhpcyBmYXVsdGVkXG4gICAgRXJyb3JDb2RlW1wiTlVNRVJJQ19GQVVMVFwiXSA9IFwiTlVNRVJJQ19GQVVMVFwiO1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBBcmd1bWVudCBFcnJvcnNcbiAgICAvLyBNaXNzaW5nIG5ldyBvcGVyYXRvciB0byBhbiBvYmplY3RcbiAgICAvLyAgLSBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgY2xhc3NcbiAgICBFcnJvckNvZGVbXCJNSVNTSU5HX05FV1wiXSA9IFwiTUlTU0lOR19ORVdcIjtcbiAgICAvLyBJbnZhbGlkIGFyZ3VtZW50IChlLmcuIHZhbHVlIGlzIGluY29tcGF0aWJsZSB3aXRoIHR5cGUpIHRvIGEgZnVuY3Rpb246XG4gICAgLy8gICAtIGFyZ3VtZW50OiBUaGUgYXJndW1lbnQgbmFtZSB0aGF0IHdhcyBpbnZhbGlkXG4gICAgLy8gICAtIHZhbHVlOiBUaGUgdmFsdWUgb2YgdGhlIGFyZ3VtZW50XG4gICAgRXJyb3JDb2RlW1wiSU5WQUxJRF9BUkdVTUVOVFwiXSA9IFwiSU5WQUxJRF9BUkdVTUVOVFwiO1xuICAgIC8vIE1pc3NpbmcgYXJndW1lbnQgdG8gYSBmdW5jdGlvbjpcbiAgICAvLyAgIC0gY291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHJlY2VpdmVkXG4gICAgLy8gICAtIGV4cGVjdGVkQ291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIGV4cGVjdGVkXG4gICAgRXJyb3JDb2RlW1wiTUlTU0lOR19BUkdVTUVOVFwiXSA9IFwiTUlTU0lOR19BUkdVTUVOVFwiO1xuICAgIC8vIFRvbyBtYW55IGFyZ3VtZW50c1xuICAgIC8vICAgLSBjb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgcmVjZWl2ZWRcbiAgICAvLyAgIC0gZXhwZWN0ZWRDb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgZXhwZWN0ZWRcbiAgICBFcnJvckNvZGVbXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCJdID0gXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCI7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEJsb2NrY2hhaW4gRXJyb3JzXG4gICAgLy8gQ2FsbCBleGNlcHRpb25cbiAgICAvLyAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uXG4gICAgLy8gIC0gYWRkcmVzcz86IHRoZSBjb250cmFjdCBhZGRyZXNzXG4gICAgLy8gIC0gYXJncz86IFRoZSBhcmd1bWVudHMgcGFzc2VkIGludG8gdGhlIGZ1bmN0aW9uXG4gICAgLy8gIC0gbWV0aG9kPzogVGhlIFNvbGlkaXR5IG1ldGhvZCBzaWduYXR1cmVcbiAgICAvLyAgLSBlcnJvclNpZ25hdHVyZT86IFRoZSBFSVA4NDggZXJyb3Igc2lnbmF0dXJlXG4gICAgLy8gIC0gZXJyb3JBcmdzPzogVGhlIEVJUDg0OCBlcnJvciBwYXJhbWV0ZXJzXG4gICAgLy8gIC0gcmVhc29uOiBUaGUgcmVhc29uIChvbmx5IGZvciBFSVA4NDggXCJFcnJvcihzdHJpbmcpXCIpXG4gICAgRXJyb3JDb2RlW1wiQ0FMTF9FWENFUFRJT05cIl0gPSBcIkNBTExfRVhDRVBUSU9OXCI7XG4gICAgLy8gSW5zdWZmaWNpZW50IGZ1bmRzICg8IHZhbHVlICsgZ2FzTGltaXQgKiBnYXNQcmljZSlcbiAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBhdHRlbXB0ZWRcbiAgICBFcnJvckNvZGVbXCJJTlNVRkZJQ0lFTlRfRlVORFNcIl0gPSBcIklOU1VGRklDSUVOVF9GVU5EU1wiO1xuICAgIC8vIE5vbmNlIGhhcyBhbHJlYWR5IGJlZW4gdXNlZFxuICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIGF0dGVtcHRlZFxuICAgIEVycm9yQ29kZVtcIk5PTkNFX0VYUElSRURcIl0gPSBcIk5PTkNFX0VYUElSRURcIjtcbiAgICAvLyBUaGUgcmVwbGFjZW1lbnQgZmVlIGZvciB0aGUgdHJhbnNhY3Rpb24gaXMgdG9vIGxvd1xuICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIGF0dGVtcHRlZFxuICAgIEVycm9yQ29kZVtcIlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEXCJdID0gXCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFwiO1xuICAgIC8vIFRoZSBnYXMgbGltaXQgY291bGQgbm90IGJlIGVzdGltYXRlZFxuICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIHBhc3NlZCB0byBlc3RpbWF0ZUdhc1xuICAgIEVycm9yQ29kZVtcIlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUXCJdID0gXCJVTlBSRURJQ1RBQkxFX0dBU19MSU1JVFwiO1xuICAgIC8vIFRoZSB0cmFuc2FjdGlvbiB3YXMgcmVwbGFjZWQgYnkgb25lIHdpdGggYSBoaWdoZXIgZ2FzIHByaWNlXG4gICAgLy8gICAtIHJlYXNvbjogXCJjYW5jZWxsZWRcIiwgXCJyZXBsYWNlZFwiIG9yIFwicmVwcmljZWRcIlxuICAgIC8vICAgLSBjYW5jZWxsZWQ6IHRydWUgaWYgcmVhc29uID09IFwiY2FuY2VsbGVkXCIgb3IgcmVhc29uID09IFwicmVwbGFjZWRcIilcbiAgICAvLyAgIC0gaGFzaDogb3JpZ2luYWwgdHJhbnNhY3Rpb24gaGFzaFxuICAgIC8vICAgLSByZXBsYWNlbWVudDogdGhlIGZ1bGwgVHJhbnNhY3Rpb25zUmVzcG9uc2UgZm9yIHRoZSByZXBsYWNlbWVudFxuICAgIC8vICAgLSByZWNlaXB0OiB0aGUgcmVjZWlwdCBvZiB0aGUgcmVwbGFjZW1lbnRcbiAgICBFcnJvckNvZGVbXCJUUkFOU0FDVElPTl9SRVBMQUNFRFwiXSA9IFwiVFJBTlNBQ1RJT05fUkVQTEFDRURcIjtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gSW50ZXJhY3Rpb24gRXJyb3JzXG4gICAgLy8gVGhlIHVzZXIgcmVqZWN0ZWQgdGhlIGFjdGlvbiwgc3VjaCBhcyBzaWduaW5nIGEgbWVzc2FnZSBvciBzZW5kaW5nXG4gICAgLy8gYSB0cmFuc2FjdGlvblxuICAgIEVycm9yQ29kZVtcIkFDVElPTl9SRUpFQ1RFRFwiXSA9IFwiQUNUSU9OX1JFSkVDVEVEXCI7XG59KShFcnJvckNvZGUgfHwgKEVycm9yQ29kZSA9IHt9KSk7XG47XG5jb25zdCBIRVggPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbmV4cG9ydCBjbGFzcyBMb2dnZXIge1xuICAgIGNvbnN0cnVjdG9yKHZlcnNpb24pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmVyc2lvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZlcnNpb24sXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9sb2cobG9nTGV2ZWwsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBsb2dMZXZlbC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoTG9nTGV2ZWxzW2xldmVsXSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbG9nIGxldmVsIG5hbWVcIiwgXCJsb2dMZXZlbFwiLCBsb2dMZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9sb2dMZXZlbCA+IExvZ0xldmVsc1tsZXZlbF0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICB9XG4gICAgZGVidWcoLi4uYXJncykge1xuICAgICAgICB0aGlzLl9sb2coTG9nZ2VyLmxldmVscy5ERUJVRywgYXJncyk7XG4gICAgfVxuICAgIGluZm8oLi4uYXJncykge1xuICAgICAgICB0aGlzLl9sb2coTG9nZ2VyLmxldmVscy5JTkZPLCBhcmdzKTtcbiAgICB9XG4gICAgd2FybiguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2xvZyhMb2dnZXIubGV2ZWxzLldBUk5JTkcsIGFyZ3MpO1xuICAgIH1cbiAgICBtYWtlRXJyb3IobWVzc2FnZSwgY29kZSwgcGFyYW1zKSB7XG4gICAgICAgIC8vIEVycm9ycyBhcmUgYmVpbmcgY2Vuc29yZWRcbiAgICAgICAgaWYgKF9jZW5zb3JFcnJvcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VFcnJvcihcImNlbnNvcmVkIGVycm9yXCIsIGNvZGUsIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIGNvZGUgPSBMb2dnZXIuZXJyb3JzLlVOS05PV05fRVJST1I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VEZXRhaWxzID0gW107XG4gICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBoZXggPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZXggKz0gSEVYW3ZhbHVlW2ldID4+IDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGV4ICs9IEhFWFt2YWx1ZVtpXSAmIDB4MGZdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goa2V5ICsgXCI9VWludDhBcnJheSgweFwiICsgaGV4ICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChrZXkgKyBcIj1cIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChrZXkgKyBcIj1cIiArIEpTT04uc3RyaW5naWZ5KHBhcmFtc1trZXldLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goYGNvZGU9JHtjb2RlfWApO1xuICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGB2ZXJzaW9uPSR7dGhpcy52ZXJzaW9ufWApO1xuICAgICAgICBjb25zdCByZWFzb24gPSBtZXNzYWdlO1xuICAgICAgICBsZXQgdXJsID0gXCJcIjtcbiAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5OVU1FUklDX0ZBVUxUOiB7XG4gICAgICAgICAgICAgICAgdXJsID0gXCJOVU1FUklDX0ZBVUxUXCI7XG4gICAgICAgICAgICAgICAgY29uc3QgZmF1bHQgPSBtZXNzYWdlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm92ZXJmbG93XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ1bmRlcmZsb3dcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRpdmlzaW9uLWJ5LXplcm9cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIi1cIiArIGZhdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJuZWdhdGl2ZS1wb3dlclwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibmVnYXRpdmUtd2lkdGhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIi11bnN1cHBvcnRlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ1bmJvdW5kLWJpdHdpc2UtcmVzdWx0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCItdW5ib3VuZC1yZXN1bHRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLkNBTExfRVhDRVBUSU9OOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuSU5TVUZGSUNJRU5UX0ZVTkRTOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuTUlTU0lOR19ORVc6XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5OT05DRV9FWFBJUkVEOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQ6XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5UUkFOU0FDVElPTl9SRVBMQUNFRDpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUOlxuICAgICAgICAgICAgICAgIHVybCA9IGNvZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiBbIFNlZTogaHR0cHM6L1xcL2xpbmtzLmV0aGVycy5vcmcvdjUtZXJyb3JzLVwiICsgdXJsICsgXCIgXVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlRGV0YWlscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKFwiICsgbWVzc2FnZURldGFpbHMuam9pbihcIiwgXCIpICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IEFueT8/XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICBlcnJvci5yZWFzb24gPSByZWFzb247XG4gICAgICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgZXJyb3Jba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICB0aHJvd0Vycm9yKG1lc3NhZ2UsIGNvZGUsIHBhcmFtcykge1xuICAgICAgICB0aHJvdyB0aGlzLm1ha2VFcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpO1xuICAgIH1cbiAgICB0aHJvd0FyZ3VtZW50RXJyb3IobWVzc2FnZSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgIGFyZ3VtZW50OiBuYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlLCBjb2RlLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKCEhY29uZGl0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIGNvZGUsIHBhcmFtcyk7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGNvbmRpdGlvbiwgbWVzc2FnZSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCEhY29uZGl0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aHJvd0FyZ3VtZW50RXJyb3IobWVzc2FnZSwgbmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICBjaGVja05vcm1hbGl6ZShtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcInBsYXRmb3JtIG1pc3NpbmcgU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX25vcm1hbGl6ZUVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJwbGF0Zm9ybSBtaXNzaW5nIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIlN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIGZvcm06IF9ub3JtYWxpemVFcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tTYWZlVWludDUzKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcInZhbHVlIG5vdCBzYWZlXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAweDFmZmZmZmZmZmZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5OVU1FUklDX0ZBVUxULCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImNoZWNrU2FmZUludGVnZXJcIixcbiAgICAgICAgICAgICAgICBmYXVsdDogXCJvdXQtb2Ytc2FmZS1yYW5nZVwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICUgMSkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuTlVNRVJJQ19GQVVMVCwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJjaGVja1NhZmVJbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgZmF1bHQ6IFwibm9uLWludGVnZXJcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrQXJndW1lbnRDb3VudChjb3VudCwgZXhwZWN0ZWRDb3VudCwgbWVzc2FnZSkge1xuICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwiOiBcIiArIG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY291bnQgPCBleHBlY3RlZENvdW50KSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJtaXNzaW5nIGFyZ3VtZW50XCIgKyBtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLk1JU1NJTkdfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50ID4gZXhwZWN0ZWRDb3VudCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwidG9vIG1hbnkgYXJndW1lbnRzXCIgKyBtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tOZXcodGFyZ2V0LCBraW5kKSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IE9iamVjdCB8fCB0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBuZXdcIiwgTG9nZ2VyLmVycm9ycy5NSVNTSU5HX05FVywgeyBuYW1lOiBraW5kLm5hbWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tBYnN0cmFjdCh0YXJnZXQsIGtpbmQpIHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0ga2luZCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwiY2Fubm90IGluc3RhbnRpYXRlIGFic3RyYWN0IGNsYXNzIFwiICsgSlNPTi5zdHJpbmdpZnkoa2luZC5uYW1lKSArIFwiIGRpcmVjdGx5OyB1c2UgYSBzdWItY2xhc3NcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgbmFtZTogdGFyZ2V0Lm5hbWUsIG9wZXJhdGlvbjogXCJuZXdcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0YXJnZXQgPT09IE9iamVjdCB8fCB0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBuZXdcIiwgTG9nZ2VyLmVycm9ycy5NSVNTSU5HX05FVywgeyBuYW1lOiBraW5kLm5hbWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdsb2JhbExvZ2dlcigpIHtcbiAgICAgICAgaWYgKCFfZ2xvYmFsTG9nZ2VyKSB7XG4gICAgICAgICAgICBfZ2xvYmFsTG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2dsb2JhbExvZ2dlcjtcbiAgICB9XG4gICAgc3RhdGljIHNldENlbnNvcnNoaXAoY2Vuc29yc2hpcCwgcGVybWFuZW50KSB7XG4gICAgICAgIGlmICghY2Vuc29yc2hpcCAmJiBwZXJtYW5lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsTG9nZ2VyKCkudGhyb3dFcnJvcihcImNhbm5vdCBwZXJtYW5lbnRseSBkaXNhYmxlIGNlbnNvcnNoaXBcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2V0Q2Vuc29yc2hpcFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3Blcm1hbmVudENlbnNvckVycm9ycykge1xuICAgICAgICAgICAgaWYgKCFjZW5zb3JzaGlwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5nbG9iYWxMb2dnZXIoKS50aHJvd0Vycm9yKFwiZXJyb3IgY2Vuc29yc2hpcCBwZXJtYW5lbnRcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2V0Q2Vuc29yc2hpcFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBfY2Vuc29yRXJyb3JzID0gISFjZW5zb3JzaGlwO1xuICAgICAgICBfcGVybWFuZW50Q2Vuc29yRXJyb3JzID0gISFwZXJtYW5lbnQ7XG4gICAgfVxuICAgIHN0YXRpYyBzZXRMb2dMZXZlbChsb2dMZXZlbCkge1xuICAgICAgICBjb25zdCBsZXZlbCA9IExvZ0xldmVsc1tsb2dMZXZlbC50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgaWYgKGxldmVsID09IG51bGwpIHtcbiAgICAgICAgICAgIExvZ2dlci5nbG9iYWxMb2dnZXIoKS53YXJuKFwiaW52YWxpZCBsb2cgbGV2ZWwgLSBcIiArIGxvZ0xldmVsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfbG9nTGV2ZWwgPSBsZXZlbDtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmVyc2lvbikge1xuICAgICAgICByZXR1cm4gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbiAgICB9XG59XG5Mb2dnZXIuZXJyb3JzID0gRXJyb3JDb2RlO1xuTG9nZ2VyLmxldmVscyA9IExvZ0xldmVsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9wZXJtYW5lbnRDZW5zb3JFcnJvcnMiLCJfY2Vuc29yRXJyb3JzIiwiTG9nTGV2ZWxzIiwiZGVidWciLCJpbmZvIiwid2FybmluZyIsImVycm9yIiwib2ZmIiwiX2xvZ0xldmVsIiwidmVyc2lvbiIsIl9nbG9iYWxMb2dnZXIiLCJfY2hlY2tOb3JtYWxpemUiLCJtaXNzaW5nIiwiZm9yRWFjaCIsImZvcm0iLCJub3JtYWxpemUiLCJFcnJvciIsInB1c2giLCJsZW5ndGgiLCJqb2luIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwibWVzc2FnZSIsIl9ub3JtYWxpemVFcnJvciIsIkxvZ0xldmVsIiwiRXJyb3JDb2RlIiwiSEVYIiwiTG9nZ2VyIiwiY29uc3RydWN0b3IiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiX2xvZyIsImxvZ0xldmVsIiwiYXJncyIsImxldmVsIiwidG9Mb3dlckNhc2UiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJjb25zb2xlIiwibG9nIiwiYXBwbHkiLCJsZXZlbHMiLCJERUJVRyIsIklORk8iLCJ3YXJuIiwiV0FSTklORyIsIm1ha2VFcnJvciIsImNvZGUiLCJwYXJhbXMiLCJlcnJvcnMiLCJVTktOT1dOX0VSUk9SIiwibWVzc2FnZURldGFpbHMiLCJrZXlzIiwia2V5IiwiVWludDhBcnJheSIsImhleCIsImkiLCJKU09OIiwic3RyaW5naWZ5IiwidG9TdHJpbmciLCJyZWFzb24iLCJ1cmwiLCJOVU1FUklDX0ZBVUxUIiwiZmF1bHQiLCJDQUxMX0VYQ0VQVElPTiIsIklOU1VGRklDSUVOVF9GVU5EUyIsIk1JU1NJTkdfTkVXIiwiTk9OQ0VfRVhQSVJFRCIsIlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEIiwiVFJBTlNBQ1RJT05fUkVQTEFDRUQiLCJVTlBSRURJQ1RBQkxFX0dBU19MSU1JVCIsInRocm93RXJyb3IiLCJuYW1lIiwiSU5WQUxJRF9BUkdVTUVOVCIsImFyZ3VtZW50IiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwiYXNzZXJ0QXJndW1lbnQiLCJjaGVja05vcm1hbGl6ZSIsIlVOU1VQUE9SVEVEX09QRVJBVElPTiIsIm9wZXJhdGlvbiIsImNoZWNrU2FmZVVpbnQ1MyIsImNoZWNrQXJndW1lbnRDb3VudCIsImNvdW50IiwiZXhwZWN0ZWRDb3VudCIsIk1JU1NJTkdfQVJHVU1FTlQiLCJVTkVYUEVDVEVEX0FSR1VNRU5UIiwiY2hlY2tOZXciLCJ0YXJnZXQiLCJraW5kIiwiY2hlY2tBYnN0cmFjdCIsImdsb2JhbExvZ2dlciIsInNldENlbnNvcnNoaXAiLCJjZW5zb3JzaGlwIiwicGVybWFuZW50Iiwic2V0TG9nTGV2ZWwiLCJmcm9tIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/networks/lib.esm/_version.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/networks/lib.esm/_version.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"networks/5.7.1\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9uZXR3b3Jrcy9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxNQUFNQSxVQUFVLGlCQUFpQixDQUN4QyxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbGltZS1iZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9uZXR3b3Jrcy9saWIuZXNtL192ZXJzaW9uLmpzPzljZjgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcIm5ldHdvcmtzLzUuNy4xXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/networks/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/networks/lib.esm/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/networks/lib.esm/index.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getNetwork: () => (/* binding */ getNetwork)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/networks/lib.esm/_version.js\");\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n;\nfunction isRenetworkable(value) {\n    return value && typeof value.renetwork === \"function\";\n}\nfunction ethDefaultProvider(network) {\n    const func = function(providers, options) {\n        if (options == null) {\n            options = {};\n        }\n        const providerList = [];\n        if (providers.InfuraProvider && options.infura !== \"-\") {\n            try {\n                providerList.push(new providers.InfuraProvider(network, options.infura));\n            } catch (error) {}\n        }\n        if (providers.EtherscanProvider && options.etherscan !== \"-\") {\n            try {\n                providerList.push(new providers.EtherscanProvider(network, options.etherscan));\n            } catch (error) {}\n        }\n        if (providers.AlchemyProvider && options.alchemy !== \"-\") {\n            try {\n                providerList.push(new providers.AlchemyProvider(network, options.alchemy));\n            } catch (error) {}\n        }\n        if (providers.PocketProvider && options.pocket !== \"-\") {\n            // These networks are currently faulty on Pocket as their\n            // network does not handle the Berlin hardfork, which is\n            // live on these ones.\n            // @TODO: This goes away once Pocket has upgraded their nodes\n            const skip = [\n                \"goerli\",\n                \"ropsten\",\n                \"rinkeby\",\n                \"sepolia\"\n            ];\n            try {\n                const provider = new providers.PocketProvider(network, options.pocket);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            } catch (error) {}\n        }\n        if (providers.CloudflareProvider && options.cloudflare !== \"-\") {\n            try {\n                providerList.push(new providers.CloudflareProvider(network));\n            } catch (error) {}\n        }\n        if (providers.AnkrProvider && options.ankr !== \"-\") {\n            try {\n                const skip = [\n                    \"ropsten\"\n                ];\n                const provider = new providers.AnkrProvider(network, options.ankr);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            } catch (error) {}\n        }\n        if (providerList.length === 0) {\n            return null;\n        }\n        if (providers.FallbackProvider) {\n            let quorum = 1;\n            if (options.quorum != null) {\n                quorum = options.quorum;\n            } else if (network === \"homestead\") {\n                quorum = 2;\n            }\n            return new providers.FallbackProvider(providerList, quorum);\n        }\n        return providerList[0];\n    };\n    func.renetwork = function(network) {\n        return ethDefaultProvider(network);\n    };\n    return func;\n}\nfunction etcDefaultProvider(url, network) {\n    const func = function(providers, options) {\n        if (providers.JsonRpcProvider) {\n            return new providers.JsonRpcProvider(url, network);\n        }\n        return null;\n    };\n    func.renetwork = function(network) {\n        return etcDefaultProvider(url, network);\n    };\n    return func;\n}\nconst homestead = {\n    chainId: 1,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"homestead\",\n    _defaultProvider: ethDefaultProvider(\"homestead\")\n};\nconst ropsten = {\n    chainId: 3,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"ropsten\",\n    _defaultProvider: ethDefaultProvider(\"ropsten\")\n};\nconst classicMordor = {\n    chainId: 63,\n    name: \"classicMordor\",\n    _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/mordor\", \"classicMordor\")\n};\n// See: https://chainlist.org\nconst networks = {\n    unspecified: {\n        chainId: 0,\n        name: \"unspecified\"\n    },\n    homestead: homestead,\n    mainnet: homestead,\n    morden: {\n        chainId: 2,\n        name: \"morden\"\n    },\n    ropsten: ropsten,\n    testnet: ropsten,\n    rinkeby: {\n        chainId: 4,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"rinkeby\",\n        _defaultProvider: ethDefaultProvider(\"rinkeby\")\n    },\n    kovan: {\n        chainId: 42,\n        name: \"kovan\",\n        _defaultProvider: ethDefaultProvider(\"kovan\")\n    },\n    goerli: {\n        chainId: 5,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"goerli\",\n        _defaultProvider: ethDefaultProvider(\"goerli\")\n    },\n    kintsugi: {\n        chainId: 1337702,\n        name: \"kintsugi\"\n    },\n    sepolia: {\n        chainId: 11155111,\n        name: \"sepolia\",\n        _defaultProvider: ethDefaultProvider(\"sepolia\")\n    },\n    // ETC (See: #351)\n    classic: {\n        chainId: 61,\n        name: \"classic\",\n        _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/etc\", \"classic\")\n    },\n    classicMorden: {\n        chainId: 62,\n        name: \"classicMorden\"\n    },\n    classicMordor: classicMordor,\n    classicTestnet: classicMordor,\n    classicKotti: {\n        chainId: 6,\n        name: \"classicKotti\",\n        _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/kotti\", \"classicKotti\")\n    },\n    xdai: {\n        chainId: 100,\n        name: \"xdai\"\n    },\n    matic: {\n        chainId: 137,\n        name: \"matic\",\n        _defaultProvider: ethDefaultProvider(\"matic\")\n    },\n    maticmum: {\n        chainId: 80001,\n        name: \"maticmum\"\n    },\n    optimism: {\n        chainId: 10,\n        name: \"optimism\",\n        _defaultProvider: ethDefaultProvider(\"optimism\")\n    },\n    \"optimism-kovan\": {\n        chainId: 69,\n        name: \"optimism-kovan\"\n    },\n    \"optimism-goerli\": {\n        chainId: 420,\n        name: \"optimism-goerli\"\n    },\n    arbitrum: {\n        chainId: 42161,\n        name: \"arbitrum\"\n    },\n    \"arbitrum-rinkeby\": {\n        chainId: 421611,\n        name: \"arbitrum-rinkeby\"\n    },\n    \"arbitrum-goerli\": {\n        chainId: 421613,\n        name: \"arbitrum-goerli\"\n    },\n    bnb: {\n        chainId: 56,\n        name: \"bnb\"\n    },\n    bnbt: {\n        chainId: 97,\n        name: \"bnbt\"\n    }\n};\n/**\n *  getNetwork\n *\n *  Converts a named common networks or chain ID (network ID) to a Network\n *  and verifies a network is a valid Network..\n */ function getNetwork(network) {\n    // No network (null)\n    if (network == null) {\n        return null;\n    }\n    if (typeof network === \"number\") {\n        for(const name in networks){\n            const standard = networks[name];\n            if (standard.chainId === network) {\n                return {\n                    name: standard.name,\n                    chainId: standard.chainId,\n                    ensAddress: standard.ensAddress || null,\n                    _defaultProvider: standard._defaultProvider || null\n                };\n            }\n        }\n        return {\n            chainId: network,\n            name: \"unknown\"\n        };\n    }\n    if (typeof network === \"string\") {\n        const standard = networks[network];\n        if (standard == null) {\n            return null;\n        }\n        return {\n            name: standard.name,\n            chainId: standard.chainId,\n            ensAddress: standard.ensAddress,\n            _defaultProvider: standard._defaultProvider || null\n        };\n    }\n    const standard = networks[network.name];\n    // Not a standard network; check that it is a valid network in general\n    if (!standard) {\n        if (typeof network.chainId !== \"number\") {\n            logger.throwArgumentError(\"invalid network chainId\", \"network\", network);\n        }\n        return network;\n    }\n    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)\n    if (network.chainId !== 0 && network.chainId !== standard.chainId) {\n        logger.throwArgumentError(\"network chainId mismatch\", \"network\", network);\n    }\n    // @TODO: In the next major version add an attach function to a defaultProvider\n    // class and move the _defaultProvider internal to this file (extend Network)\n    let defaultProvider = network._defaultProvider || null;\n    if (defaultProvider == null && standard._defaultProvider) {\n        if (isRenetworkable(standard._defaultProvider)) {\n            defaultProvider = standard._defaultProvider.renetwork(network);\n        } else {\n            defaultProvider = standard._defaultProvider;\n        }\n    }\n    // Standard Network (allow overriding the ENS address)\n    return {\n        name: network.name,\n        chainId: standard.chainId,\n        ensAddress: network.ensAddress || standard.ensAddress || null,\n        _defaultProvider: defaultProvider\n    };\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9uZXR3b3Jrcy9saWIuZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFhO0FBQ2tDO0FBQ1Y7QUFDckMsTUFBTUUsU0FBUyxJQUFJRix5REFBTUEsQ0FBQ0MsNkNBQU9BOztBQUVqQyxTQUFTRSxnQkFBZ0JDLEtBQUs7SUFDMUIsT0FBUUEsU0FBUyxPQUFRQSxNQUFNQyxTQUFTLEtBQU07QUFDbEQ7QUFDQSxTQUFTQyxtQkFBbUJDLE9BQU87SUFDL0IsTUFBTUMsT0FBTyxTQUFVQyxTQUFTLEVBQUVDLE9BQU87UUFDckMsSUFBSUEsV0FBVyxNQUFNO1lBQ2pCQSxVQUFVLENBQUM7UUFDZjtRQUNBLE1BQU1DLGVBQWUsRUFBRTtRQUN2QixJQUFJRixVQUFVRyxjQUFjLElBQUlGLFFBQVFHLE1BQU0sS0FBSyxLQUFLO1lBQ3BELElBQUk7Z0JBQ0FGLGFBQWFHLElBQUksQ0FBQyxJQUFJTCxVQUFVRyxjQUFjLENBQUNMLFNBQVNHLFFBQVFHLE1BQU07WUFDMUUsRUFDQSxPQUFPRSxPQUFPLENBQUU7UUFDcEI7UUFDQSxJQUFJTixVQUFVTyxpQkFBaUIsSUFBSU4sUUFBUU8sU0FBUyxLQUFLLEtBQUs7WUFDMUQsSUFBSTtnQkFDQU4sYUFBYUcsSUFBSSxDQUFDLElBQUlMLFVBQVVPLGlCQUFpQixDQUFDVCxTQUFTRyxRQUFRTyxTQUFTO1lBQ2hGLEVBQ0EsT0FBT0YsT0FBTyxDQUFFO1FBQ3BCO1FBQ0EsSUFBSU4sVUFBVVMsZUFBZSxJQUFJUixRQUFRUyxPQUFPLEtBQUssS0FBSztZQUN0RCxJQUFJO2dCQUNBUixhQUFhRyxJQUFJLENBQUMsSUFBSUwsVUFBVVMsZUFBZSxDQUFDWCxTQUFTRyxRQUFRUyxPQUFPO1lBQzVFLEVBQ0EsT0FBT0osT0FBTyxDQUFFO1FBQ3BCO1FBQ0EsSUFBSU4sVUFBVVcsY0FBYyxJQUFJVixRQUFRVyxNQUFNLEtBQUssS0FB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LENBQUMsMkJBQTJCLFdBQVcxRDtRQUNwRTtRQUNBLE9BQU9BO0lBQ1g7SUFDQSx3RkFBd0Y7SUFDeEYsSUFBSUEsUUFBUThCLE9BQU8sS0FBSyxLQUFLOUIsUUFBUThCLE9BQU8sS0FBSzJCLFNBQVMzQixPQUFPLEVBQUU7UUFDL0RuQyxPQUFPK0Qsa0JBQWtCLENBQUMsNEJBQTRCLFdBQVcxRDtJQUNyRTtJQUNBLCtFQUErRTtJQUMvRSw2RUFBNkU7SUFDN0UsSUFBSTJELGtCQUFrQjNELFFBQVFnQyxnQkFBZ0IsSUFBSTtJQUNsRCxJQUFJMkIsbUJBQW1CLFFBQVFGLFNBQVN6QixnQkFBZ0IsRUFBRTtRQUN0RCxJQUFJcEMsZ0JBQWdCNkQsU0FBU3pCLGdCQUFnQixHQUFHO1lBQzVDMkIsa0JBQWtCRixTQUFTekIsZ0JBQWdCLENBQUNsQyxTQUFTLENBQUNFO1FBQzFELE9BQ0s7WUFDRDJELGtCQUFrQkYsU0FBU3pCLGdCQUFnQjtRQUMvQztJQUNKO0lBQ0Esc0RBQXNEO0lBQ3RELE9BQU87UUFDSGQsTUFBTWxCLFFBQVFrQixJQUFJO1FBQ2xCWSxTQUFTMkIsU0FBUzNCLE9BQU87UUFDekJDLFlBQWEvQixRQUFRK0IsVUFBVSxJQUFJMEIsU0FBUzFCLFVBQVUsSUFBSTtRQUMxREMsa0JBQWtCMkI7SUFDdEI7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NsaW1lLWJldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L25ldHdvcmtzL2xpYi5lc20vaW5kZXguanM/NWI5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbjtcbmZ1bmN0aW9uIGlzUmVuZXR3b3JrYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5yZW5ldHdvcmspID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gZXRoRGVmYXVsdFByb3ZpZGVyKG5ldHdvcmspIHtcbiAgICBjb25zdCBmdW5jID0gZnVuY3Rpb24gKHByb3ZpZGVycywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvdmlkZXJMaXN0ID0gW107XG4gICAgICAgIGlmIChwcm92aWRlcnMuSW5mdXJhUHJvdmlkZXIgJiYgb3B0aW9ucy5pbmZ1cmEgIT09IFwiLVwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyTGlzdC5wdXNoKG5ldyBwcm92aWRlcnMuSW5mdXJhUHJvdmlkZXIobmV0d29yaywgb3B0aW9ucy5pbmZ1cmEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVycy5FdGhlcnNjYW5Qcm92aWRlciAmJiBvcHRpb25zLmV0aGVyc2NhbiAhPT0gXCItXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJMaXN0LnB1c2gobmV3IHByb3ZpZGVycy5FdGhlcnNjYW5Qcm92aWRlcihuZXR3b3JrLCBvcHRpb25zLmV0aGVyc2NhbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdmlkZXJzLkFsY2hlbXlQcm92aWRlciAmJiBvcHRpb25zLmFsY2hlbXkgIT09IFwiLVwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyTGlzdC5wdXNoKG5ldyBwcm92aWRlcnMuQWxjaGVteVByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMuYWxjaGVteSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdmlkZXJzLlBvY2tldFByb3ZpZGVyICYmIG9wdGlvbnMucG9ja2V0ICE9PSBcIi1cIikge1xuICAgICAgICAgICAgLy8gVGhlc2UgbmV0d29ya3MgYXJlIGN1cnJlbnRseSBmYXVsdHkgb24gUG9ja2V0IGFzIHRoZWlyXG4gICAgICAgICAgICAvLyBuZXR3b3JrIGRvZXMgbm90IGhhbmRsZSB0aGUgQmVybGluIGhhcmRmb3JrLCB3aGljaCBpc1xuICAgICAgICAgICAgLy8gbGl2ZSBvbiB0aGVzZSBvbmVzLlxuICAgICAgICAgICAgLy8gQFRPRE86IFRoaXMgZ29lcyBhd2F5IG9uY2UgUG9ja2V0IGhhcyB1cGdyYWRlZCB0aGVpciBub2Rlc1xuICAgICAgICAgICAgY29uc3Qgc2tpcCA9IFtcImdvZXJsaVwiLCBcInJvcHN0ZW5cIiwgXCJyaW5rZWJ5XCIsIFwic2Vwb2xpYVwiXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgcHJvdmlkZXJzLlBvY2tldFByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMucG9ja2V0KTtcbiAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIubmV0d29yayAmJiBza2lwLmluZGV4T2YocHJvdmlkZXIubmV0d29yay5uYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJMaXN0LnB1c2gocHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVycy5DbG91ZGZsYXJlUHJvdmlkZXIgJiYgb3B0aW9ucy5jbG91ZGZsYXJlICE9PSBcIi1cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwcm92aWRlckxpc3QucHVzaChuZXcgcHJvdmlkZXJzLkNsb3VkZmxhcmVQcm92aWRlcihuZXR3b3JrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm92aWRlcnMuQW5rclByb3ZpZGVyICYmIG9wdGlvbnMuYW5rciAhPT0gXCItXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2tpcCA9IFtcInJvcHN0ZW5cIl07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgcHJvdmlkZXJzLkFua3JQcm92aWRlcihuZXR3b3JrLCBvcHRpb25zLmFua3IpO1xuICAgICAgICAgICAgICAgIGlmIChwcm92aWRlci5uZXR3b3JrICYmIHNraXAuaW5kZXhPZihwcm92aWRlci5uZXR3b3JrLm5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlckxpc3QucHVzaChwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdmlkZXJMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVycy5GYWxsYmFja1Byb3ZpZGVyKSB7XG4gICAgICAgICAgICBsZXQgcXVvcnVtID0gMTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnF1b3J1bSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcXVvcnVtID0gb3B0aW9ucy5xdW9ydW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXR3b3JrID09PSBcImhvbWVzdGVhZFwiKSB7XG4gICAgICAgICAgICAgICAgcXVvcnVtID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgcHJvdmlkZXJzLkZhbGxiYWNrUHJvdmlkZXIocHJvdmlkZXJMaXN0LCBxdW9ydW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm92aWRlckxpc3RbMF07XG4gICAgfTtcbiAgICBmdW5jLnJlbmV0d29yayA9IGZ1bmN0aW9uIChuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBldGhEZWZhdWx0UHJvdmlkZXIobmV0d29yayk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuYztcbn1cbmZ1bmN0aW9uIGV0Y0RlZmF1bHRQcm92aWRlcih1cmwsIG5ldHdvcmspIHtcbiAgICBjb25zdCBmdW5jID0gZnVuY3Rpb24gKHByb3ZpZGVycywgb3B0aW9ucykge1xuICAgICAgICBpZiAocHJvdmlkZXJzLkpzb25ScGNQcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm92aWRlcnMuSnNvblJwY1Byb3ZpZGVyKHVybCwgbmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBmdW5jLnJlbmV0d29yayA9IGZ1bmN0aW9uIChuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBldGNEZWZhdWx0UHJvdmlkZXIodXJsLCBuZXR3b3JrKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jO1xufVxuY29uc3QgaG9tZXN0ZWFkID0ge1xuICAgIGNoYWluSWQ6IDEsXG4gICAgZW5zQWRkcmVzczogXCIweDAwMDAwMDAwMDAwQzJFMDc0ZUM2OUEwZEZiMjk5N0JBNkM3ZDJlMWVcIixcbiAgICBuYW1lOiBcImhvbWVzdGVhZFwiLFxuICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0aERlZmF1bHRQcm92aWRlcihcImhvbWVzdGVhZFwiKVxufTtcbmNvbnN0IHJvcHN0ZW4gPSB7XG4gICAgY2hhaW5JZDogMyxcbiAgICBlbnNBZGRyZXNzOiBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLFxuICAgIG5hbWU6IFwicm9wc3RlblwiLFxuICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0aERlZmF1bHRQcm92aWRlcihcInJvcHN0ZW5cIilcbn07XG5jb25zdCBjbGFzc2ljTW9yZG9yID0ge1xuICAgIGNoYWluSWQ6IDYzLFxuICAgIG5hbWU6IFwiY2xhc3NpY01vcmRvclwiLFxuICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0Y0RlZmF1bHRQcm92aWRlcihcImh0dHBzOi8vd3d3LmV0aGVyY2x1c3Rlci5jb20vbW9yZG9yXCIsIFwiY2xhc3NpY01vcmRvclwiKVxufTtcbi8vIFNlZTogaHR0cHM6Ly9jaGFpbmxpc3Qub3JnXG5jb25zdCBuZXR3b3JrcyA9IHtcbiAgICB1bnNwZWNpZmllZDogeyBjaGFpbklkOiAwLCBuYW1lOiBcInVuc3BlY2lmaWVkXCIgfSxcbiAgICBob21lc3RlYWQ6IGhvbWVzdGVhZCxcbiAgICBtYWlubmV0OiBob21lc3RlYWQsXG4gICAgbW9yZGVuOiB7IGNoYWluSWQ6IDIsIG5hbWU6IFwibW9yZGVuXCIgfSxcbiAgICByb3BzdGVuOiByb3BzdGVuLFxuICAgIHRlc3RuZXQ6IHJvcHN0ZW4sXG4gICAgcmlua2VieToge1xuICAgICAgICBjaGFpbklkOiA0LFxuICAgICAgICBlbnNBZGRyZXNzOiBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLFxuICAgICAgICBuYW1lOiBcInJpbmtlYnlcIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwicmlua2VieVwiKVxuICAgIH0sXG4gICAga292YW46IHtcbiAgICAgICAgY2hhaW5JZDogNDIsXG4gICAgICAgIG5hbWU6IFwia292YW5cIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwia292YW5cIilcbiAgICB9LFxuICAgIGdvZXJsaToge1xuICAgICAgICBjaGFpbklkOiA1LFxuICAgICAgICBlbnNBZGRyZXNzOiBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLFxuICAgICAgICBuYW1lOiBcImdvZXJsaVwiLFxuICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGhEZWZhdWx0UHJvdmlkZXIoXCJnb2VybGlcIilcbiAgICB9LFxuICAgIGtpbnRzdWdpOiB7IGNoYWluSWQ6IDEzMzc3MDIsIG5hbWU6IFwia2ludHN1Z2lcIiB9LFxuICAgIHNlcG9saWE6IHtcbiAgICAgICAgY2hhaW5JZDogMTExNTUxMTEsXG4gICAgICAgIG5hbWU6IFwic2Vwb2xpYVwiLFxuICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGhEZWZhdWx0UHJvdmlkZXIoXCJzZXBvbGlhXCIpXG4gICAgfSxcbiAgICAvLyBFVEMgKFNlZTogIzM1MSlcbiAgICBjbGFzc2ljOiB7XG4gICAgICAgIGNoYWluSWQ6IDYxLFxuICAgICAgICBuYW1lOiBcImNsYXNzaWNcIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRjRGVmYXVsdFByb3ZpZGVyKFwiaHR0cHM6L1xcL3d3dy5ldGhlcmNsdXN0ZXIuY29tL2V0Y1wiLCBcImNsYXNzaWNcIilcbiAgICB9LFxuICAgIGNsYXNzaWNNb3JkZW46IHsgY2hhaW5JZDogNjIsIG5hbWU6IFwiY2xhc3NpY01vcmRlblwiIH0sXG4gICAgY2xhc3NpY01vcmRvcjogY2xhc3NpY01vcmRvcixcbiAgICBjbGFzc2ljVGVzdG5ldDogY2xhc3NpY01vcmRvcixcbiAgICBjbGFzc2ljS290dGk6IHtcbiAgICAgICAgY2hhaW5JZDogNixcbiAgICAgICAgbmFtZTogXCJjbGFzc2ljS290dGlcIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRjRGVmYXVsdFByb3ZpZGVyKFwiaHR0cHM6L1xcL3d3dy5ldGhlcmNsdXN0ZXIuY29tL2tvdHRpXCIsIFwiY2xhc3NpY0tvdHRpXCIpXG4gICAgfSxcbiAgICB4ZGFpOiB7IGNoYWluSWQ6IDEwMCwgbmFtZTogXCJ4ZGFpXCIgfSxcbiAgICBtYXRpYzoge1xuICAgICAgICBjaGFpbklkOiAxMzcsXG4gICAgICAgIG5hbWU6IFwibWF0aWNcIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwibWF0aWNcIilcbiAgICB9LFxuICAgIG1hdGljbXVtOiB7IGNoYWluSWQ6IDgwMDAxLCBuYW1lOiBcIm1hdGljbXVtXCIgfSxcbiAgICBvcHRpbWlzbToge1xuICAgICAgICBjaGFpbklkOiAxMCxcbiAgICAgICAgbmFtZTogXCJvcHRpbWlzbVwiLFxuICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGhEZWZhdWx0UHJvdmlkZXIoXCJvcHRpbWlzbVwiKVxuICAgIH0sXG4gICAgXCJvcHRpbWlzbS1rb3ZhblwiOiB7IGNoYWluSWQ6IDY5LCBuYW1lOiBcIm9wdGltaXNtLWtvdmFuXCIgfSxcbiAgICBcIm9wdGltaXNtLWdvZXJsaVwiOiB7IGNoYWluSWQ6IDQyMCwgbmFtZTogXCJvcHRpbWlzbS1nb2VybGlcIiB9LFxuICAgIGFyYml0cnVtOiB7IGNoYWluSWQ6IDQyMTYxLCBuYW1lOiBcImFyYml0cnVtXCIgfSxcbiAgICBcImFyYml0cnVtLXJpbmtlYnlcIjogeyBjaGFpbklkOiA0MjE2MTEsIG5hbWU6IFwiYXJiaXRydW0tcmlua2VieVwiIH0sXG4gICAgXCJhcmJpdHJ1bS1nb2VybGlcIjogeyBjaGFpbklkOiA0MjE2MTMsIG5hbWU6IFwiYXJiaXRydW0tZ29lcmxpXCIgfSxcbiAgICBibmI6IHsgY2hhaW5JZDogNTYsIG5hbWU6IFwiYm5iXCIgfSxcbiAgICBibmJ0OiB7IGNoYWluSWQ6IDk3LCBuYW1lOiBcImJuYnRcIiB9LFxufTtcbi8qKlxuICogIGdldE5ldHdvcmtcbiAqXG4gKiAgQ29udmVydHMgYSBuYW1lZCBjb21tb24gbmV0d29ya3Mgb3IgY2hhaW4gSUQgKG5ldHdvcmsgSUQpIHRvIGEgTmV0d29ya1xuICogIGFuZCB2ZXJpZmllcyBhIG5ldHdvcmsgaXMgYSB2YWxpZCBOZXR3b3JrLi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5ldHdvcmsobmV0d29yaykge1xuICAgIC8vIE5vIG5ldHdvcmsgKG51bGwpXG4gICAgaWYgKG5ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIG5ldHdvcmtzKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFuZGFyZCA9IG5ldHdvcmtzW25hbWVdO1xuICAgICAgICAgICAgaWYgKHN0YW5kYXJkLmNoYWluSWQgPT09IG5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzdGFuZGFyZC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBzdGFuZGFyZC5jaGFpbklkLFxuICAgICAgICAgICAgICAgICAgICBlbnNBZGRyZXNzOiAoc3RhbmRhcmQuZW5zQWRkcmVzcyB8fCBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogKHN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXIgfHwgbnVsbClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFpbklkOiBuZXR3b3JrLFxuICAgICAgICAgICAgbmFtZTogXCJ1bmtub3duXCJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3Qgc3RhbmRhcmQgPSBuZXR3b3Jrc1tuZXR3b3JrXTtcbiAgICAgICAgaWYgKHN0YW5kYXJkID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBzdGFuZGFyZC5uYW1lLFxuICAgICAgICAgICAgY2hhaW5JZDogc3RhbmRhcmQuY2hhaW5JZCxcbiAgICAgICAgICAgIGVuc0FkZHJlc3M6IHN0YW5kYXJkLmVuc0FkZHJlc3MsXG4gICAgICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiAoc3RhbmRhcmQuX2RlZmF1bHRQcm92aWRlciB8fCBudWxsKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzdGFuZGFyZCA9IG5ldHdvcmtzW25ldHdvcmsubmFtZV07XG4gICAgLy8gTm90IGEgc3RhbmRhcmQgbmV0d29yazsgY2hlY2sgdGhhdCBpdCBpcyBhIHZhbGlkIG5ldHdvcmsgaW4gZ2VuZXJhbFxuICAgIGlmICghc3RhbmRhcmQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yay5jaGFpbklkKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbmV0d29yayBjaGFpbklkXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBjaGFpbklkIG1hdGNoZXMgdGhlIGV4cGVjdGVkIG5ldHdvcmsgY2hhaW5JZCAob3IgaXMgMDsgZGlzYWJsZSBFSVAtMTU1KVxuICAgIGlmIChuZXR3b3JrLmNoYWluSWQgIT09IDAgJiYgbmV0d29yay5jaGFpbklkICE9PSBzdGFuZGFyZC5jaGFpbklkKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJuZXR3b3JrIGNoYWluSWQgbWlzbWF0Y2hcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuICAgIH1cbiAgICAvLyBAVE9ETzogSW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBhZGQgYW4gYXR0YWNoIGZ1bmN0aW9uIHRvIGEgZGVmYXVsdFByb3ZpZGVyXG4gICAgLy8gY2xhc3MgYW5kIG1vdmUgdGhlIF9kZWZhdWx0UHJvdmlkZXIgaW50ZXJuYWwgdG8gdGhpcyBmaWxlIChleHRlbmQgTmV0d29yaylcbiAgICBsZXQgZGVmYXVsdFByb3ZpZGVyID0gbmV0d29yay5fZGVmYXVsdFByb3ZpZGVyIHx8IG51bGw7XG4gICAgaWYgKGRlZmF1bHRQcm92aWRlciA9PSBudWxsICYmIHN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXIpIHtcbiAgICAgICAgaWYgKGlzUmVuZXR3b3JrYWJsZShzdGFuZGFyZC5fZGVmYXVsdFByb3ZpZGVyKSkge1xuICAgICAgICAgICAgZGVmYXVsdFByb3ZpZGVyID0gc3RhbmRhcmQuX2RlZmF1bHRQcm92aWRlci5yZW5ldHdvcmsobmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZhdWx0UHJvdmlkZXIgPSBzdGFuZGFyZC5fZGVmYXVsdFByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFN0YW5kYXJkIE5ldHdvcmsgKGFsbG93IG92ZXJyaWRpbmcgdGhlIEVOUyBhZGRyZXNzKVxuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5ldHdvcmsubmFtZSxcbiAgICAgICAgY2hhaW5JZDogc3RhbmRhcmQuY2hhaW5JZCxcbiAgICAgICAgZW5zQWRkcmVzczogKG5ldHdvcmsuZW5zQWRkcmVzcyB8fCBzdGFuZGFyZC5lbnNBZGRyZXNzIHx8IG51bGwpLFxuICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBkZWZhdWx0UHJvdmlkZXJcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIkxvZ2dlciIsInZlcnNpb24iLCJsb2dnZXIiLCJpc1JlbmV0d29ya2FibGUiLCJ2YWx1ZSIsInJlbmV0d29yayIsImV0aERlZmF1bHRQcm92aWRlciIsIm5ldHdvcmsiLCJmdW5jIiwicHJvdmlkZXJzIiwib3B0aW9ucyIsInByb3ZpZGVyTGlzdCIsIkluZnVyYVByb3ZpZGVyIiwiaW5mdXJhIiwicHVzaCIsImVycm9yIiwiRXRoZXJzY2FuUHJvdmlkZXIiLCJldGhlcnNjYW4iLCJBbGNoZW15UHJvdmlkZXIiLCJhbGNoZW15IiwiUG9ja2V0UHJvdmlkZXIiLCJwb2NrZXQiLCJza2lwIiwicHJvdmlkZXIiLCJpbmRleE9mIiwibmFtZSIsIkNsb3VkZmxhcmVQcm92aWRlciIsImNsb3VkZmxhcmUiLCJBbmtyUHJvdmlkZXIiLCJhbmtyIiwibGVuZ3RoIiwiRmFsbGJhY2tQcm92aWRlciIsInF1b3J1bSIsImV0Y0RlZmF1bHRQcm92aWRlciIsInVybCIsIkpzb25ScGNQcm92aWRlciIsImhvbWVzdGVhZCIsImNoYWluSWQiLCJlbnNBZGRyZXNzIiwiX2RlZmF1bHRQcm92aWRlciIsInJvcHN0ZW4iLCJjbGFzc2ljTW9yZG9yIiwibmV0d29ya3MiLCJ1bnNwZWNpZmllZCIsIm1haW5uZXQiLCJtb3JkZW4iLCJ0ZXN0bmV0Iiwicmlua2VieSIsImtvdmFuIiwiZ29lcmxpIiwia2ludHN1Z2kiLCJzZXBvbGlhIiwiY2xhc3NpYyIsImNsYXNzaWNNb3JkZW4iLCJjbGFzc2ljVGVzdG5ldCIsImNsYXNzaWNLb3R0aSIsInhkYWkiLCJtYXRpYyIsIm1hdGljbXVtIiwib3B0aW1pc20iLCJhcmJpdHJ1bSIsImJuYiIsImJuYnQiLCJnZXROZXR3b3JrIiwic3RhbmRhcmQiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJkZWZhdWx0UHJvdmlkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/networks/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib.esm/_version.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/properties/lib.esm/_version.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"properties/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLFVBQVUsbUJBQW1CLENBQzFDLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NsaW1lLWJldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXMvbGliLmVzbS9fdmVyc2lvbi5qcz9jYWQwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJwcm9wZXJ0aWVzLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib.esm/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/properties/lib.esm/index.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Description: () => (/* binding */ Description),\n/* harmony export */   checkProperties: () => (/* binding */ checkProperties),\n/* harmony export */   deepCopy: () => (/* binding */ deepCopy),\n/* harmony export */   defineReadOnly: () => (/* binding */ defineReadOnly),\n/* harmony export */   getStatic: () => (/* binding */ getStatic),\n/* harmony export */   resolveProperties: () => (/* binding */ resolveProperties),\n/* harmony export */   shallowCopy: () => (/* binding */ shallowCopy)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib.esm/_version.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nfunction defineReadOnly(object, name, value) {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false\n    });\n}\n// Crawl up the constructor chain to find a static method\nfunction getStatic(ctor, key) {\n    for(let i = 0; i < 32; i++){\n        if (ctor[key]) {\n            return ctor[key];\n        }\n        if (!ctor.prototype || typeof ctor.prototype !== \"object\") {\n            break;\n        }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\nfunction resolveProperties(object) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const promises = Object.keys(object).map((key)=>{\n            const value = object[key];\n            return Promise.resolve(value).then((v)=>({\n                    key: key,\n                    value: v\n                }));\n        });\n        const results = yield Promise.all(promises);\n        return results.reduce((accum, result)=>{\n            accum[result.key] = result.value;\n            return accum;\n        }, {});\n    });\n}\nfunction checkProperties(object, properties) {\n    if (!object || typeof object !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n    Object.keys(object).forEach((key)=>{\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\nfunction shallowCopy(object) {\n    const result = {};\n    for(const key in object){\n        result[key] = object[key];\n    }\n    return result;\n}\nconst opaque = {\n    bigint: true,\n    boolean: true,\n    \"function\": true,\n    number: true,\n    string: true\n};\nfunction _isFrozen(object) {\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof object]) {\n        return true;\n    }\n    if (Array.isArray(object) || typeof object === \"object\") {\n        if (!Object.isFrozen(object)) {\n            return false;\n        }\n        const keys = Object.keys(object);\n        for(let i = 0; i < keys.length; i++){\n            let value = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                continue;\n            }\n            if (!_isFrozen(value)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof object}`, \"object\", object);\n}\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object) {\n    if (_isFrozen(object)) {\n        return object;\n    }\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item)=>deepCopy(item)));\n    }\n    if (typeof object === \"object\") {\n        const result = {};\n        for(const key in object){\n            const value = object[key];\n            if (value === undefined) {\n                continue;\n            }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n        return result;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof object}`, \"object\", object);\n}\nfunction deepCopy(object) {\n    return _deepCopy(object);\n}\nclass Description {\n    constructor(info){\n        for(const key in info){\n            this[key] = deepCopy(info[key]);\n        }\n    }\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzL2xpYi5lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQWE7QUFDYixJQUFJQSxZQUFZLFNBQUssSUFBSSxTQUFJLENBQUNBLFNBQVMsSUFBSyxTQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ25GLFNBQVNDLE1BQU1DLEtBQUs7UUFBSSxPQUFPQSxpQkFBaUJILElBQUlHLFFBQVEsSUFBSUgsRUFBRSxTQUFVSSxPQUFPO1lBQUlBLFFBQVFEO1FBQVE7SUFBSTtJQUMzRyxPQUFPLElBQUtILENBQUFBLEtBQU1BLENBQUFBLElBQUlLLE9BQU0sQ0FBQyxFQUFHLFNBQVVELE9BQU8sRUFBRUUsTUFBTTtRQUNyRCxTQUFTQyxVQUFVSixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsVUFBVVEsSUFBSSxDQUFDTjtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzFGLFNBQVNDLFNBQVNSLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxTQUFTLENBQUMsUUFBUSxDQUFDRTtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzdGLFNBQVNGLEtBQUtJLE1BQU07WUFBSUEsT0FBT0MsSUFBSSxHQUFHVCxRQUFRUSxPQUFPVCxLQUFLLElBQUlELE1BQU1VLE9BQU9ULEtBQUssRUFBRVcsSUFBSSxDQUFDUCxXQUFXSTtRQUFXO1FBQzdHSCxLQUFLLENBQUNQLFlBQVlBLFVBQVVjLEtBQUssQ0FBQ2pCLFNBQVNDLGNBQWMsRUFBRSxHQUFHVSxJQUFJO0lBQ3RFO0FBQ0o7QUFDK0M7QUFDVjtBQUNyQyxNQUFNUyxTQUFTLElBQUlGLHlEQUFNQSxDQUFDQyw2Q0FBT0E7QUFDMUIsU0FBU0UsZUFBZUMsTUFBTSxFQUFFQyxJQUFJ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WDtRQUNKO1FBQ0EsT0FBTztJQUNYO0lBQ0EsT0FBT2UsT0FBTzBCLGtCQUFrQixDQUFDLENBQUMsZ0JBQWdCLEVBQUUsT0FBUXhCLE9BQVEsQ0FBQyxFQUFFLFVBQVVBO0FBQ3JGO0FBQ0EseUVBQXlFO0FBQ3pFLCtDQUErQztBQUMvQyxTQUFTdUMsVUFBVXZDLE1BQU07SUFDckIsSUFBSWdDLFVBQVVoQyxTQUFTO1FBQ25CLE9BQU9BO0lBQ1g7SUFDQSxrREFBa0Q7SUFDbEQsSUFBSWtDLE1BQU1DLE9BQU8sQ0FBQ25DLFNBQVM7UUFDdkIsT0FBT0UsT0FBT3NDLE1BQU0sQ0FBQ3hDLE9BQU9nQixHQUFHLENBQUMsQ0FBQ3lCLE9BQVNDLFNBQVNEO0lBQ3ZEO0lBQ0EsSUFBSSxPQUFRekMsV0FBWSxVQUFVO1FBQzlCLE1BQU1SLFNBQVMsQ0FBQztRQUNoQixJQUFLLE1BQU1nQixPQUFPUixPQUFRO1lBQ3RCLE1BQU1qQixRQUFRaUIsTUFBTSxDQUFDUSxJQUFJO1lBQ3pCLElBQUl6QixVQUFVa0QsV0FBVztnQkFDckI7WUFDSjtZQUNBbEMsZUFBZVAsUUFBUWdCLEtBQUtrQyxTQUFTM0Q7UUFDekM7UUFDQSxPQUFPUztJQUNYO0lBQ0EsT0FBT00sT0FBTzBCLGtCQUFrQixDQUFDLENBQUMsZ0JBQWdCLEVBQUUsT0FBUXhCLE9BQVEsQ0FBQyxFQUFFLFVBQVVBO0FBQ3JGO0FBQ08sU0FBUzBDLFNBQVMxQyxNQUFNO0lBQzNCLE9BQU91QyxVQUFVdkM7QUFDckI7QUFDTyxNQUFNMkM7SUFDVC9CLFlBQVlnQyxJQUFJLENBQUU7UUFDZCxJQUFLLE1BQU1wQyxPQUFPb0MsS0FBTTtZQUNwQixJQUFJLENBQUNwQyxJQUFJLEdBQUdrQyxTQUFTRSxJQUFJLENBQUNwQyxJQUFJO1FBQ2xDO0lBQ0o7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NsaW1lLWJldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXMvbGliLmVzbS9pbmRleC5qcz82MWI3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lUmVhZE9ubHkob2JqZWN0LCBuYW1lLCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgfSk7XG59XG4vLyBDcmF3bCB1cCB0aGUgY29uc3RydWN0b3IgY2hhaW4gdG8gZmluZCBhIHN0YXRpYyBtZXRob2RcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGF0aWMoY3Rvciwga2V5KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICAgIGlmIChjdG9yW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiBjdG9yW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdG9yLnByb3RvdHlwZSB8fCB0eXBlb2YgKGN0b3IucHJvdG90eXBlKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY3RvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjdG9yLnByb3RvdHlwZSkuY29uc3RydWN0b3I7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVQcm9wZXJ0aWVzKG9iamVjdCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gT2JqZWN0LmtleXMob2JqZWN0KS5tYXAoKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oKHYpID0+ICh7IGtleToga2V5LCB2YWx1ZTogdiB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHRzID0geWllbGQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0cy5yZWR1Y2UoKGFjY3VtLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGFjY3VtWyhyZXN1bHQua2V5KV0gPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1Byb3BlcnRpZXMob2JqZWN0LCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFvYmplY3QgfHwgdHlwZW9mIChvYmplY3QpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG9iamVjdFwiLCBcIm9iamVjdFwiLCBvYmplY3QpO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhvYmplY3QpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAoIXByb3BlcnRpZXNba2V5XSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgb2JqZWN0IGtleSAtIFwiICsga2V5LCBcInRyYW5zYWN0aW9uOlwiICsga2V5LCBvYmplY3QpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2hhbGxvd0NvcHkob2JqZWN0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBvcGFxdWUgPSB7IGJpZ2ludDogdHJ1ZSwgYm9vbGVhbjogdHJ1ZSwgXCJmdW5jdGlvblwiOiB0cnVlLCBudW1iZXI6IHRydWUsIHN0cmluZzogdHJ1ZSB9O1xuZnVuY3Rpb24gX2lzRnJvemVuKG9iamVjdCkge1xuICAgIC8vIE9wYXF1ZSBvYmplY3RzIGFyZSBub3QgbXV0YWJsZSwgc28gc2FmZSB0byBjb3B5IGJ5IGFzc2lnbm1lbnRcbiAgICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQgfHwgb2JqZWN0ID09PSBudWxsIHx8IG9wYXF1ZVt0eXBlb2YgKG9iamVjdCldKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpIHx8IHR5cGVvZiAob2JqZWN0KSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoIU9iamVjdC5pc0Zyb3plbihvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5c1tpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhY2Nlc3NpbmcgYSB2YWx1ZSB0cmlnZ2VycyBhbiBlcnJvciwgaXQgaXMgYSBnZXR0ZXJcbiAgICAgICAgICAgICAgICAvLyBkZXNpZ25lZCB0byBkbyBzbyAoZS5nLiBSZXN1bHQpIGFuZCBpcyB0aGVyZWZvcmUgXCJmcm96ZW5cIlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfaXNGcm96ZW4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgQ2Fubm90IGRlZXBDb3B5ICR7dHlwZW9mIChvYmplY3QpfWAsIFwib2JqZWN0XCIsIG9iamVjdCk7XG59XG4vLyBSZXR1cm5zIGEgbmV3IGNvcHkgb2Ygb2JqZWN0LCBzdWNoIHRoYXQgbm8gcHJvcGVydGllcyBtYXkgYmUgcmVwbGFjZWQuXG4vLyBOZXcgcHJvcGVydGllcyBtYXkgYmUgYWRkZWQgb25seSB0byBvYmplY3RzLlxuZnVuY3Rpb24gX2RlZXBDb3B5KG9iamVjdCkge1xuICAgIGlmIChfaXNGcm96ZW4ob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgICAvLyBBcnJheXMgYXJlIG11dGFibGUsIHNvIHdlIG5lZWQgdG8gY3JlYXRlIGEgY29weVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUob2JqZWN0Lm1hcCgoaXRlbSkgPT4gZGVlcENvcHkoaXRlbSkpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAob2JqZWN0KSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHJlc3VsdCwga2V5LCBkZWVwQ29weSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBDYW5ub3QgZGVlcENvcHkgJHt0eXBlb2YgKG9iamVjdCl9YCwgXCJvYmplY3RcIiwgb2JqZWN0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWVwQ29weShvYmplY3QpIHtcbiAgICByZXR1cm4gX2RlZXBDb3B5KG9iamVjdCk7XG59XG5leHBvcnQgY2xhc3MgRGVzY3JpcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGluZm8pIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5mbykge1xuICAgICAgICAgICAgdGhpc1trZXldID0gZGVlcENvcHkoaW5mb1trZXldKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJMb2dnZXIiLCJ2ZXJzaW9uIiwibG9nZ2VyIiwiZGVmaW5lUmVhZE9ubHkiLCJvYmplY3QiLCJuYW1lIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJnZXRTdGF0aWMiLCJjdG9yIiwia2V5IiwiaSIsInByb3RvdHlwZSIsImdldFByb3RvdHlwZU9mIiwiY29uc3RydWN0b3IiLCJyZXNvbHZlUHJvcGVydGllcyIsInByb21pc2VzIiwia2V5cyIsIm1hcCIsInYiLCJyZXN1bHRzIiwiYWxsIiwicmVkdWNlIiwiYWNjdW0iLCJjaGVja1Byb3BlcnRpZXMiLCJwcm9wZXJ0aWVzIiwidGhyb3dBcmd1bWVudEVycm9yIiwiZm9yRWFjaCIsInNoYWxsb3dDb3B5Iiwib3BhcXVlIiwiYmlnaW50IiwiYm9vbGVhbiIsIm51bWJlciIsInN0cmluZyIsIl9pc0Zyb3plbiIsInVuZGVmaW5lZCIsIkFycmF5IiwiaXNBcnJheSIsImlzRnJvemVuIiwibGVuZ3RoIiwiZXJyb3IiLCJfZGVlcENvcHkiLCJmcmVlemUiLCJpdGVtIiwiZGVlcENvcHkiLCJEZXNjcmlwdGlvbiIsImluZm8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/_version.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/_version.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"providers/5.7.2\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsVUFBVSxrQkFBa0IsQ0FDekMsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2xpbWUtYmV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vX3ZlcnNpb24uanM/NmI3YSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwicHJvdmlkZXJzLzUuNy4yXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/base-provider.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/base-provider.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseProvider: () => (/* binding */ BaseProvider),\n/* harmony export */   Event: () => (/* binding */ Event),\n/* harmony export */   Resolver: () => (/* binding */ Resolver)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-provider/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_base64__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @ethersproject/base64 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/base64/lib.esm/base64.js\");\n/* harmony import */ var _ethersproject_basex__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/basex */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/basex/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @ethersproject/constants */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib.esm/hashes.js\");\n/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/hash */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/namehash.js\");\n/* harmony import */ var _ethersproject_networks__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @ethersproject/networks */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/networks/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/sha2 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/sha2/lib.esm/sha2.js\");\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @ethersproject/web */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/web/lib.esm/index.js\");\n/* harmony import */ var bech32__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bech32 */ \"(ssr)/./node_modules/bech32/index.js\");\n/* harmony import */ var bech32__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bech32__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./formatter */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/formatter.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger(_version__WEBPACK_IMPORTED_MODULE_2__.version);\n\nconst MAX_CCIP_REDIRECTS = 10;\n//////////////////////////////\n// Event Serializeing\nfunction checkTopic(topic) {\n    if (topic == null) {\n        return \"null\";\n    }\n    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataLength)(topic) !== 32) {\n        logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n    }\n    return topic.toLowerCase();\n}\nfunction serializeTopics(topics) {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while(topics.length > 0 && topics[topics.length - 1] == null){\n        topics.pop();\n    }\n    return topics.map((topic)=>{\n        if (Array.isArray(topic)) {\n            // Only track unique OR-topics\n            const unique = {};\n            topic.forEach((topic)=>{\n                unique[checkTopic(topic)] = true;\n            });\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n            return sorted.join(\"|\");\n        } else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\nfunction deserializeTopics(data) {\n    if (data === \"\") {\n        return [];\n    }\n    return data.split(/&/g).map((topic)=>{\n        if (topic === \"\") {\n            return [];\n        }\n        const comps = topic.split(\"|\").map((topic)=>{\n            return topic === \"null\" ? null : topic;\n        });\n        return comps.length === 1 ? comps[0] : comps;\n    });\n}\nfunction getEventTag(eventName) {\n    if (typeof eventName === \"string\") {\n        eventName = eventName.toLowerCase();\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataLength)(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n    } else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n    } else if (_ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_4__.ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n    } else if (eventName && typeof eventName === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n    throw new Error(\"invalid event - \" + eventName);\n}\n//////////////////////////////\n// Helper Object\nfunction getTime() {\n    return new Date().getTime();\n}\nfunction stall(duration) {\n    return new Promise((resolve)=>{\n        setTimeout(resolve, duration);\n    });\n}\n//////////////////////////////\n// Provider Object\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */ const PollableEvents = [\n    \"block\",\n    \"network\",\n    \"pending\",\n    \"poll\"\n];\nclass Event {\n    constructor(tag, listener, once){\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"tag\", tag);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"listener\", listener);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"once\", once);\n        this._lastBlockNumber = -2;\n        this._inflight = false;\n    }\n    get event() {\n        switch(this.type){\n            case \"tx\":\n                return this.hash;\n            case \"filter\":\n                return this.filter;\n        }\n        return this.tag;\n    }\n    get type() {\n        return this.tag.split(\":\")[0];\n    }\n    get hash() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") {\n            return null;\n        }\n        return comps[1];\n    }\n    get filter() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") {\n            return null;\n        }\n        const address = comps[1];\n        const topics = deserializeTopics(comps[2]);\n        const filter = {};\n        if (topics.length > 0) {\n            filter.topics = topics;\n        }\n        if (address && address !== \"*\") {\n            filter.address = address;\n        }\n        return filter;\n    }\n    pollable() {\n        return this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0;\n    }\n}\n;\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos = {\n    \"0\": {\n        symbol: \"btc\",\n        p2pkh: 0x00,\n        p2sh: 0x05,\n        prefix: \"bc\"\n    },\n    \"2\": {\n        symbol: \"ltc\",\n        p2pkh: 0x30,\n        p2sh: 0x32,\n        prefix: \"ltc\"\n    },\n    \"3\": {\n        symbol: \"doge\",\n        p2pkh: 0x1e,\n        p2sh: 0x16\n    },\n    \"60\": {\n        symbol: \"eth\",\n        ilk: \"eth\"\n    },\n    \"61\": {\n        symbol: \"etc\",\n        ilk: \"eth\"\n    },\n    \"700\": {\n        symbol: \"xdai\",\n        ilk: \"eth\"\n    }\n};\nfunction bytes32ify(value) {\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(value).toHexString(), 32);\n}\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data) {\n    return _ethersproject_basex__WEBPACK_IMPORTED_MODULE_7__.Base58.encode((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([\n        data,\n        (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)((0,_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_8__.sha256)((0,_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_8__.sha256)(data)), 0, 4)\n    ]));\n}\nconst matcherIpfs = new RegExp(\"^(ipfs)://(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https)://(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\")\n];\nfunction _parseString(result, start) {\n    try {\n        return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__.toUtf8String)(_parseBytes(result, start));\n    } catch (error) {}\n    return null;\n}\nfunction _parseBytes(result, start) {\n    if (result === \"0x\") {\n        return null;\n    }\n    const offset = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(result, start, start + 32)).toNumber();\n    const length = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(result, offset, offset + 32)).toNumber();\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(result, offset + 32, offset + 32 + length);\n}\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    } else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    } else {\n        logger.throwArgumentError(\"unsupported IPFS format\", \"link\", link);\n    }\n    return `https:/\\/gateway.ipfs.io/ipfs/${link}`;\n}\nfunction numPad(value) {\n    const result = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value);\n    if (result.length > 32) {\n        throw new Error(\"internal; should not happen\");\n    }\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\nfunction bytesPad(value) {\n    if (value.length % 32 === 0) {\n        return value;\n    }\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n    const result = [];\n    let byteCount = 0;\n    // Add place-holders for pointers as we add items\n    for(let i = 0; i < datas.length; i++){\n        result.push(null);\n        byteCount += 32;\n    }\n    for(let i = 0; i < datas.length; i++){\n        const data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(datas[i]);\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)(result);\n}\nclass Resolver {\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    constructor(provider, address, name, resolvedAddress){\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"provider\", provider);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"name\", name);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"address\", provider.formatter.address(address));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"_resolvedAddress\", resolvedAddress);\n    }\n    supportsWildcard() {\n        if (!this._supportsEip2544) {\n            // supportsInterface(bytes4 = selector(\"resolve(bytes,bytes)\"))\n            this._supportsEip2544 = this.provider.call({\n                to: this.address,\n                data: \"0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000\"\n            }).then((result)=>{\n                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result).eq(1);\n            }).catch((error)=>{\n                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {\n                    return false;\n                }\n                // Rethrow the error: link is down, etc. Let future attempts retry.\n                this._supportsEip2544 = null;\n                throw error;\n            });\n        }\n        return this._supportsEip2544;\n    }\n    _fetch(selector, parameters) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // e.g. keccak256(\"addr(bytes32,uint256)\")\n            const tx = {\n                to: this.address,\n                ccipReadEnabled: true,\n                data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n                    selector,\n                    (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.namehash)(this.name),\n                    parameters || \"0x\"\n                ])\n            };\n            // Wildcard support; use EIP-2544 to resolve the request\n            let parseBytes = false;\n            if (yield this.supportsWildcard()) {\n                parseBytes = true;\n                // selector(\"resolve(bytes,bytes)\")\n                tx.data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n                    \"0x9061b923\",\n                    encodeBytes([\n                        (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.dnsEncode)(this.name),\n                        tx.data\n                    ])\n                ]);\n            }\n            try {\n                let result = yield this.provider.call(tx);\n                if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(result).length % 32 === 4) {\n                    logger.throwError(\"resolver threw error\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                        transaction: tx,\n                        data: result\n                    });\n                }\n                if (parseBytes) {\n                    result = _parseBytes(result, 0);\n                }\n                return result;\n            } catch (error) {\n                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {\n                    return null;\n                }\n                throw error;\n            }\n        });\n    }\n    _fetchBytes(selector, parameters) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const result = yield this._fetch(selector, parameters);\n            if (result != null) {\n                return _parseBytes(result, 0);\n            }\n            return null;\n        });\n    }\n    _getAddress(coinType, hexBytes) {\n        const coinInfo = coinInfos[String(coinType)];\n        if (coinInfo == null) {\n            logger.throwError(`unsupported coin type: ${coinType}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${coinType})`\n            });\n        }\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n        const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(hexBytes);\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([\n                        [\n                            coinInfo.p2pkh\n                        ],\n                        \"0x\" + p2pkh[2]\n                    ]));\n                }\n            }\n        }\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([\n                        [\n                            coinInfo.p2sh\n                        ],\n                        \"0x\" + p2sh[2]\n                    ]));\n                }\n            }\n        }\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            } else {\n                version = -1;\n            }\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32__WEBPACK_IMPORTED_MODULE_0___default().toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32__WEBPACK_IMPORTED_MODULE_0___default().encode(coinInfo.prefix, words);\n            }\n        }\n        return null;\n    }\n    getAddress(coinType) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (coinType == null) {\n                coinType = 60;\n            }\n            // If Ethereum, use the standard `addr(bytes32)`\n            if (coinType === 60) {\n                try {\n                    // keccak256(\"addr(bytes32)\")\n                    const result = yield this._fetch(\"0x3b3b57de\");\n                    // No address\n                    if (result === \"0x\" || result === _ethersproject_constants__WEBPACK_IMPORTED_MODULE_11__.HashZero) {\n                        return null;\n                    }\n                    return this.provider.formatter.callAddress(result);\n                } catch (error) {\n                    if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {\n                        return null;\n                    }\n                    throw error;\n                }\n            }\n            // keccak256(\"addr(bytes32,uint256\")\n            const hexBytes = yield this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n            // No address\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // Compute the address\n            const address = this._getAddress(coinType, hexBytes);\n            if (address == null) {\n                logger.throwError(`invalid or unsupported coin data`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `getAddress(${coinType})`,\n                    coinType: coinType,\n                    data: hexBytes\n                });\n            }\n            return address;\n        });\n    }\n    getAvatar() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const linkage = [\n                {\n                    type: \"name\",\n                    content: this.name\n                }\n            ];\n            try {\n                // test data for ricmoo.eth\n                //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n                const avatar = yield this.getText(\"avatar\");\n                if (avatar == null) {\n                    return null;\n                }\n                for(let i = 0; i < matchers.length; i++){\n                    const match = avatar.match(matchers[i]);\n                    if (match == null) {\n                        continue;\n                    }\n                    const scheme = match[1].toLowerCase();\n                    switch(scheme){\n                        case \"https\":\n                            linkage.push({\n                                type: \"url\",\n                                content: avatar\n                            });\n                            return {\n                                linkage,\n                                url: avatar\n                            };\n                        case \"data\":\n                            linkage.push({\n                                type: \"data\",\n                                content: avatar\n                            });\n                            return {\n                                linkage,\n                                url: avatar\n                            };\n                        case \"ipfs\":\n                            linkage.push({\n                                type: \"ipfs\",\n                                content: avatar\n                            });\n                            return {\n                                linkage,\n                                url: getIpfsLink(avatar)\n                            };\n                        case \"erc721\":\n                        case \"erc1155\":\n                            {\n                                // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                                const selector = scheme === \"erc721\" ? \"0xc87b56dd\" : \"0x0e89341c\";\n                                linkage.push({\n                                    type: scheme,\n                                    content: avatar\n                                });\n                                // The owner of this name\n                                const owner = this._resolvedAddress || (yield this.getAddress());\n                                const comps = (match[2] || \"\").split(\"/\");\n                                if (comps.length !== 2) {\n                                    return null;\n                                }\n                                const addr = yield this.provider.formatter.address(comps[0]);\n                                const tokenId = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(comps[1]).toHexString(), 32);\n                                // Check that this account owns the token\n                                if (scheme === \"erc721\") {\n                                    // ownerOf(uint256 tokenId)\n                                    const tokenOwner = this.provider.formatter.callAddress((yield this.provider.call({\n                                        to: addr,\n                                        data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n                                            \"0x6352211e\",\n                                            tokenId\n                                        ])\n                                    })));\n                                    if (owner !== tokenOwner) {\n                                        return null;\n                                    }\n                                    linkage.push({\n                                        type: \"owner\",\n                                        content: tokenOwner\n                                    });\n                                } else if (scheme === \"erc1155\") {\n                                    // balanceOf(address owner, uint256 tokenId)\n                                    const balance = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((yield this.provider.call({\n                                        to: addr,\n                                        data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n                                            \"0x00fdd58e\",\n                                            (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(owner, 32),\n                                            tokenId\n                                        ])\n                                    })));\n                                    if (balance.isZero()) {\n                                        return null;\n                                    }\n                                    linkage.push({\n                                        type: \"balance\",\n                                        content: balance.toString()\n                                    });\n                                }\n                                // Call the token contract for the metadata URL\n                                const tx = {\n                                    to: this.provider.formatter.address(comps[0]),\n                                    data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n                                        selector,\n                                        tokenId\n                                    ])\n                                };\n                                let metadataUrl = _parseString((yield this.provider.call(tx)), 0);\n                                if (metadataUrl == null) {\n                                    return null;\n                                }\n                                linkage.push({\n                                    type: \"metadata-url-base\",\n                                    content: metadataUrl\n                                });\n                                // ERC-1155 allows a generic {id} in the URL\n                                if (scheme === \"erc1155\") {\n                                    metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                                    linkage.push({\n                                        type: \"metadata-url-expanded\",\n                                        content: metadataUrl\n                                    });\n                                }\n                                // Transform IPFS metadata links\n                                if (metadataUrl.match(/^ipfs:/i)) {\n                                    metadataUrl = getIpfsLink(metadataUrl);\n                                }\n                                linkage.push({\n                                    type: \"metadata-url\",\n                                    content: metadataUrl\n                                });\n                                // Get the token metadata\n                                const metadata = yield (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.fetchJson)(metadataUrl);\n                                if (!metadata) {\n                                    return null;\n                                }\n                                linkage.push({\n                                    type: \"metadata\",\n                                    content: JSON.stringify(metadata)\n                                });\n                                // Pull the image URL out\n                                let imageUrl = metadata.image;\n                                if (typeof imageUrl !== \"string\") {\n                                    return null;\n                                }\n                                if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                                // Allow\n                                } else {\n                                    // Transform IPFS link to gateway\n                                    const ipfs = imageUrl.match(matcherIpfs);\n                                    if (ipfs == null) {\n                                        return null;\n                                    }\n                                    linkage.push({\n                                        type: \"url-ipfs\",\n                                        content: imageUrl\n                                    });\n                                    imageUrl = getIpfsLink(imageUrl);\n                                }\n                                linkage.push({\n                                    type: \"url\",\n                                    content: imageUrl\n                                });\n                                return {\n                                    linkage,\n                                    url: imageUrl\n                                };\n                            }\n                    }\n                }\n            } catch (error) {}\n            return null;\n        });\n    }\n    getContentHash() {\n        return __awaiter(this, void 0, void 0, function*() {\n            // keccak256(\"contenthash()\")\n            const hexBytes = yield this._fetchBytes(\"0xbc1c58d1\");\n            // No contenthash\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // IPFS (CID: 1, Type: DAG-PB)\n            const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n            if (ipfs) {\n                const length = parseInt(ipfs[3], 16);\n                if (ipfs[4].length === length * 2) {\n                    return \"ipfs://\" + _ethersproject_basex__WEBPACK_IMPORTED_MODULE_7__.Base58.encode(\"0x\" + ipfs[1]);\n                }\n            }\n            // IPNS (CID: 1, Type: libp2p-key)\n            const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n            if (ipns) {\n                const length = parseInt(ipns[3], 16);\n                if (ipns[4].length === length * 2) {\n                    return \"ipns://\" + _ethersproject_basex__WEBPACK_IMPORTED_MODULE_7__.Base58.encode(\"0x\" + ipns[1]);\n                }\n            }\n            // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n            const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n            if (swarm) {\n                if (swarm[1].length === 32 * 2) {\n                    return \"bzz://\" + swarm[1];\n                }\n            }\n            const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);\n            if (skynet) {\n                if (skynet[1].length === 34 * 2) {\n                    // URL Safe base64; https://datatracker.ietf.org/doc/html/rfc4648#section-5\n                    const urlSafe = {\n                        \"=\": \"\",\n                        \"+\": \"-\",\n                        \"/\": \"_\"\n                    };\n                    const hash = (0,_ethersproject_base64__WEBPACK_IMPORTED_MODULE_13__.encode)(\"0x\" + skynet[1]).replace(/[=+\\/]/g, (a)=>urlSafe[a]);\n                    return \"sia://\" + hash;\n                }\n            }\n            return logger.throwError(`invalid or unsupported content hash data`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"getContentHash()\",\n                data: hexBytes\n            });\n        });\n    }\n    getText(key) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // The key encoded as parameter to fetchBytes\n            let keyBytes = (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__.toUtf8Bytes)(key);\n            // The nodehash consumes the first slot, so the string pointer targets\n            // offset 64, with the length at offset 64 and data starting at offset 96\n            keyBytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([\n                bytes32ify(64),\n                bytes32ify(keyBytes.length),\n                keyBytes\n            ]);\n            // Pad to word-size (32 bytes)\n            if (keyBytes.length % 32 !== 0) {\n                keyBytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([\n                    keyBytes,\n                    (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(\"0x\", 32 - key.length % 32)\n                ]);\n            }\n            const hexBytes = yield this._fetchBytes(\"0x59d1d43c\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(keyBytes));\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__.toUtf8String)(hexBytes);\n        });\n    }\n}\nlet defaultFormatter = null;\nlet nextPollId = 1;\nclass BaseProvider extends _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_4__.Provider {\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */ constructor(network){\n        super();\n        // Events being listened to\n        this._events = [];\n        this._emitted = {\n            block: -2\n        };\n        this.disableCcipRead = false;\n        this.formatter = new.target.getFormatter();\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"anyNetwork\", network === \"any\");\n        if (this.anyNetwork) {\n            network = this.detectNetwork();\n        }\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error)=>{});\n            // Trigger initial network setting (async)\n            this._ready().catch((error)=>{});\n        } else {\n            const knownNetwork = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.getStatic)(new.target, \"getNetwork\")(network);\n            if (knownNetwork) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n            } else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n        this._maxInternalBlockNumber = -1024;\n        this._lastBlockNumber = -2;\n        this._maxFilterBlockRange = 10;\n        this._pollingInterval = 4000;\n        this._fastQueryDate = 0;\n    }\n    _ready() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this._network == null) {\n                let network = null;\n                if (this._networkPromise) {\n                    try {\n                        network = yield this._networkPromise;\n                    } catch (error) {}\n                }\n                // Try the Provider's network detection (this MUST throw if it cannot)\n                if (network == null) {\n                    network = yield this.detectNetwork();\n                }\n                // This should never happen; every Provider sub-class should have\n                // suggested a network by here (or have thrown).\n                if (!network) {\n                    logger.throwError(\"no network detected\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // Possible this call stacked so do not call defineReadOnly again\n                if (this._network == null) {\n                    if (this.anyNetwork) {\n                        this._network = network;\n                    } else {\n                        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"_network\", network);\n                    }\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return this._network;\n        });\n    }\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is reflected); otherwise this cannot change\n    get ready() {\n        return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.poll)(()=>{\n            return this._ready().then((network)=>{\n                return network;\n            }, (error)=>{\n                // If the network isn't running yet, we will wait\n                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter() {\n        if (defaultFormatter == null) {\n            defaultFormatter = new _formatter__WEBPACK_IMPORTED_MODULE_14__.Formatter();\n        }\n        return defaultFormatter;\n    }\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network) {\n        return (0,_ethersproject_networks__WEBPACK_IMPORTED_MODULE_15__.getNetwork)(network == null ? \"homestead\" : network);\n    }\n    ccipReadFetch(tx, calldata, urls) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.disableCcipRead || urls.length === 0) {\n                return null;\n            }\n            const sender = tx.to.toLowerCase();\n            const data = calldata.toLowerCase();\n            const errorMessages = [];\n            for(let i = 0; i < urls.length; i++){\n                const url = urls[i];\n                // URL expansion\n                const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n                // If no {data} is present, use POST; otherwise GET\n                const json = url.indexOf(\"{data}\") >= 0 ? null : JSON.stringify({\n                    data,\n                    sender\n                });\n                const result = yield (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.fetchJson)({\n                    url: href,\n                    errorPassThrough: true\n                }, json, (value, response)=>{\n                    value.status = response.statusCode;\n                    return value;\n                });\n                if (result.data) {\n                    return result.data;\n                }\n                const errorMessage = result.message || \"unknown error\";\n                // 4xx indicates the result is not present; stop\n                if (result.status >= 400 && result.status < 500) {\n                    return logger.throwError(`response not found during CCIP fetch: ${errorMessage}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                        url,\n                        errorMessage\n                    });\n                }\n                // 5xx indicates server issue; try the next url\n                errorMessages.push(errorMessage);\n            }\n            return logger.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m)=>JSON.stringify(m)).join(\", \")}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                urls,\n                errorMessages\n            });\n        });\n    }\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    _getInternalBlockNumber(maxAge) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this._ready();\n            // Allowing stale data up to maxAge old\n            if (maxAge > 0) {\n                // While there are pending internal block requests...\n                while(this._internalBlockNumber){\n                    // ...\"remember\" which fetch we started with\n                    const internalBlockNumber = this._internalBlockNumber;\n                    try {\n                        // Check the result is not too stale\n                        const result = yield internalBlockNumber;\n                        if (getTime() - result.respTime <= maxAge) {\n                            return result.blockNumber;\n                        }\n                        break;\n                    } catch (error) {\n                        // The fetch rejected; if we are the first to get the\n                        // rejection, drop through so we replace it with a new\n                        // fetch; all others blocked will then get that fetch\n                        // which won't match the one they \"remembered\" and loop\n                        if (this._internalBlockNumber === internalBlockNumber) {\n                            break;\n                        }\n                    }\n                }\n            }\n            const reqTime = getTime();\n            const checkInternalBlockNumber = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                blockNumber: this.perform(\"getBlockNumber\", {}),\n                networkError: this.getNetwork().then((network)=>null, (error)=>error)\n            }).then(({ blockNumber, networkError })=>{\n                if (networkError) {\n                    // Unremember this bad internal block number\n                    if (this._internalBlockNumber === checkInternalBlockNumber) {\n                        this._internalBlockNumber = null;\n                    }\n                    throw networkError;\n                }\n                const respTime = getTime();\n                blockNumber = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(blockNumber).toNumber();\n                if (blockNumber < this._maxInternalBlockNumber) {\n                    blockNumber = this._maxInternalBlockNumber;\n                }\n                this._maxInternalBlockNumber = blockNumber;\n                this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n                return {\n                    blockNumber,\n                    reqTime,\n                    respTime\n                };\n            });\n            this._internalBlockNumber = checkInternalBlockNumber;\n            // Swallow unhandled exceptions; if needed they are handled else where\n            checkInternalBlockNumber.catch((error)=>{\n                // Don't null the dead (rejected) fetch, if it has already been updated\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n            });\n            return (yield checkInternalBlockNumber).blockNumber;\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const pollId = nextPollId++;\n            // Track all running promises, so we can trigger a post-poll once they are complete\n            const runners = [];\n            let blockNumber = null;\n            try {\n                blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n            } catch (error) {\n                this.emit(\"error\", error);\n                return;\n            }\n            this._setFastBlockNumber(blockNumber);\n            // Emit a poll event after we have the latest (fast) block number\n            this.emit(\"poll\", pollId, blockNumber);\n            // If the block has not changed, meh.\n            if (blockNumber === this._lastBlockNumber) {\n                this.emit(\"didPoll\", pollId);\n                return;\n            }\n            // First polling cycle, trigger a \"block\" events\n            if (this._emitted.block === -2) {\n                this._emitted.block = blockNumber - 1;\n            }\n            if (Math.abs(this._emitted.block - blockNumber) > 1000) {\n                logger.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);\n                this.emit(\"error\", logger.makeError(\"network block skew detected\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NETWORK_ERROR, {\n                    blockNumber: blockNumber,\n                    event: \"blockSkew\",\n                    previousBlockNumber: this._emitted.block\n                }));\n                this.emit(\"block\", blockNumber);\n            } else {\n                // Notify all listener for each block that has passed\n                for(let i = this._emitted.block + 1; i <= blockNumber; i++){\n                    this.emit(\"block\", i);\n                }\n            }\n            // The emitted block was updated, check for obsolete events\n            if (this._emitted.block !== blockNumber) {\n                this._emitted.block = blockNumber;\n                Object.keys(this._emitted).forEach((key)=>{\n                    // The block event does not expire\n                    if (key === \"block\") {\n                        return;\n                    }\n                    // The block we were at when we emitted this event\n                    const eventBlockNumber = this._emitted[key];\n                    // We cannot garbage collect pending transactions or blocks here\n                    // They should be garbage collected by the Provider when setting\n                    // \"pending\" events\n                    if (eventBlockNumber === \"pending\") {\n                        return;\n                    }\n                    // Evict any transaction hashes or block hashes over 12 blocks\n                    // old, since they should not return null anyways\n                    if (blockNumber - eventBlockNumber > 12) {\n                        delete this._emitted[key];\n                    }\n                });\n            }\n            // First polling cycle\n            if (this._lastBlockNumber === -2) {\n                this._lastBlockNumber = blockNumber - 1;\n            }\n            // Find all transaction hashes we are waiting on\n            this._events.forEach((event)=>{\n                switch(event.type){\n                    case \"tx\":\n                        {\n                            const hash = event.hash;\n                            let runner = this.getTransactionReceipt(hash).then((receipt)=>{\n                                if (!receipt || receipt.blockNumber == null) {\n                                    return null;\n                                }\n                                this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                                this.emit(hash, receipt);\n                                return null;\n                            }).catch((error)=>{\n                                this.emit(\"error\", error);\n                            });\n                            runners.push(runner);\n                            break;\n                        }\n                    case \"filter\":\n                        {\n                            // We only allow a single getLogs to be in-flight at a time\n                            if (!event._inflight) {\n                                event._inflight = true;\n                                // This is the first filter for this event, so we want to\n                                // restrict events to events that happened no earlier than now\n                                if (event._lastBlockNumber === -2) {\n                                    event._lastBlockNumber = blockNumber - 1;\n                                }\n                                // Filter from the last *known* event; due to load-balancing\n                                // and some nodes returning updated block numbers before\n                                // indexing events, a logs result with 0 entries cannot be\n                                // trusted and we must retry a range which includes it again\n                                const filter = event.filter;\n                                filter.fromBlock = event._lastBlockNumber + 1;\n                                filter.toBlock = blockNumber;\n                                // Prevent fitler ranges from growing too wild, since it is quite\n                                // likely there just haven't been any events to move the lastBlockNumber.\n                                const minFromBlock = filter.toBlock - this._maxFilterBlockRange;\n                                if (minFromBlock > filter.fromBlock) {\n                                    filter.fromBlock = minFromBlock;\n                                }\n                                if (filter.fromBlock < 0) {\n                                    filter.fromBlock = 0;\n                                }\n                                const runner = this.getLogs(filter).then((logs)=>{\n                                    // Allow the next getLogs\n                                    event._inflight = false;\n                                    if (logs.length === 0) {\n                                        return;\n                                    }\n                                    logs.forEach((log)=>{\n                                        // Only when we get an event for a given block number\n                                        // can we trust the events are indexed\n                                        if (log.blockNumber > event._lastBlockNumber) {\n                                            event._lastBlockNumber = log.blockNumber;\n                                        }\n                                        // Make sure we stall requests to fetch blocks and txs\n                                        this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                                        this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n                                        this.emit(filter, log);\n                                    });\n                                }).catch((error)=>{\n                                    this.emit(\"error\", error);\n                                    // Allow another getLogs (the range was not updated)\n                                    event._inflight = false;\n                                });\n                                runners.push(runner);\n                            }\n                            break;\n                        }\n                }\n            });\n            this._lastBlockNumber = blockNumber;\n            // Once all events for this loop have been processed, emit \"didPoll\"\n            Promise.all(runners).then(()=>{\n                this.emit(\"didPoll\", pollId);\n            }).catch((error)=>{\n                this.emit(\"error\", error);\n            });\n            return;\n        });\n    }\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber) {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) {\n            this.poll();\n        }\n    }\n    get network() {\n        return this._network;\n    }\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return logger.throwError(\"provider does not support network detection\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"provider.detectNetwork\"\n            });\n        });\n    }\n    getNetwork() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const network = yield this._ready();\n            // Make sure we are still connected to the same network; this is\n            // only an external call for backends which can have the underlying\n            // network change spontaneously\n            const currentNetwork = yield this.detectNetwork();\n            if (network.chainId !== currentNetwork.chainId) {\n                // We are allowing network changes, things can get complex fast;\n                // make sure you know what you are doing if you use \"any\"\n                if (this.anyNetwork) {\n                    this._network = currentNetwork;\n                    // Reset all internal block number guards and caches\n                    this._lastBlockNumber = -2;\n                    this._fastBlockNumber = null;\n                    this._fastBlockNumberPromise = null;\n                    this._fastQueryDate = 0;\n                    this._emitted.block = -2;\n                    this._maxInternalBlockNumber = -1024;\n                    this._internalBlockNumber = null;\n                    // The \"network\" event MUST happen before this method resolves\n                    // so any events have a chance to unregister, so we stall an\n                    // additional event loop before returning from /this/ call\n                    this.emit(\"network\", currentNetwork, network);\n                    yield stall(0);\n                    return this._network;\n                }\n                const error = logger.makeError(\"underlying network changed\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NETWORK_ERROR, {\n                    event: \"changed\",\n                    network: network,\n                    detectedNetwork: currentNetwork\n                });\n                this.emit(\"error\", error);\n                throw error;\n            }\n            return network;\n        });\n    }\n    get blockNumber() {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber)=>{\n            this._setFastBlockNumber(blockNumber);\n        }, (error)=>{});\n        return this._fastBlockNumber != null ? this._fastBlockNumber : -1;\n    }\n    get polling() {\n        return this._poller != null;\n    }\n    set polling(value) {\n        if (value && !this._poller) {\n            this._poller = setInterval(()=>{\n                this.poll();\n            }, this.pollingInterval);\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(()=>{\n                    this.poll();\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(()=>{\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) {\n                            this.poll();\n                        }\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n        } else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n    get pollingInterval() {\n        return this._pollingInterval;\n    }\n    set pollingInterval(value) {\n        if (typeof value !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n        this._pollingInterval = value;\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(()=>{\n                this.poll();\n            }, this._pollingInterval);\n        }\n    }\n    _getFastBlockNumber() {\n        const now = getTime();\n        // Stale block number, request a newer value\n        if (now - this._fastQueryDate > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber)=>{\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n        return this._fastBlockNumberPromise;\n    }\n    _setFastBlockNumber(blockNumber) {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {\n            return;\n        }\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n    waitForTransaction(transactionHash, confirmations, timeout) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null);\n        });\n    }\n    _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const receipt = yield this.getTransactionReceipt(transactionHash);\n            // Receipt is already good\n            if ((receipt ? receipt.confirmations : 0) >= confirmations) {\n                return receipt;\n            }\n            // Poll until the receipt is good...\n            return new Promise((resolve, reject)=>{\n                const cancelFuncs = [];\n                let done = false;\n                const alreadyDone = function() {\n                    if (done) {\n                        return true;\n                    }\n                    done = true;\n                    cancelFuncs.forEach((func)=>{\n                        func();\n                    });\n                    return false;\n                };\n                const minedHandler = (receipt)=>{\n                    if (receipt.confirmations < confirmations) {\n                        return;\n                    }\n                    if (alreadyDone()) {\n                        return;\n                    }\n                    resolve(receipt);\n                };\n                this.on(transactionHash, minedHandler);\n                cancelFuncs.push(()=>{\n                    this.removeListener(transactionHash, minedHandler);\n                });\n                if (replaceable) {\n                    let lastBlockNumber = replaceable.startBlock;\n                    let scannedBlock = null;\n                    const replaceHandler = (blockNumber)=>__awaiter(this, void 0, void 0, function*() {\n                            if (done) {\n                                return;\n                            }\n                            // Wait 1 second; this is only used in the case of a fault, so\n                            // we will trade off a little bit of latency for more consistent\n                            // results and fewer JSON-RPC calls\n                            yield stall(1000);\n                            this.getTransactionCount(replaceable.from).then((nonce)=>__awaiter(this, void 0, void 0, function*() {\n                                    if (done) {\n                                        return;\n                                    }\n                                    if (nonce <= replaceable.nonce) {\n                                        lastBlockNumber = blockNumber;\n                                    } else {\n                                        // First check if the transaction was mined\n                                        {\n                                            const mined = yield this.getTransaction(transactionHash);\n                                            if (mined && mined.blockNumber != null) {\n                                                return;\n                                            }\n                                        }\n                                        // First time scanning. We start a little earlier for some\n                                        // wiggle room here to handle the eventually consistent nature\n                                        // of blockchain (e.g. the getTransactionCount was for a\n                                        // different block)\n                                        if (scannedBlock == null) {\n                                            scannedBlock = lastBlockNumber - 3;\n                                            if (scannedBlock < replaceable.startBlock) {\n                                                scannedBlock = replaceable.startBlock;\n                                            }\n                                        }\n                                        while(scannedBlock <= blockNumber){\n                                            if (done) {\n                                                return;\n                                            }\n                                            const block = yield this.getBlockWithTransactions(scannedBlock);\n                                            for(let ti = 0; ti < block.transactions.length; ti++){\n                                                const tx = block.transactions[ti];\n                                                // Successfully mined!\n                                                if (tx.hash === transactionHash) {\n                                                    return;\n                                                }\n                                                // Matches our transaction from and nonce; its a replacement\n                                                if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                                    if (done) {\n                                                        return;\n                                                    }\n                                                    // Get the receipt of the replacement\n                                                    const receipt = yield this.waitForTransaction(tx.hash, confirmations);\n                                                    // Already resolved or rejected (prolly a timeout)\n                                                    if (alreadyDone()) {\n                                                        return;\n                                                    }\n                                                    // The reason we were replaced\n                                                    let reason = \"replaced\";\n                                                    if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                                        reason = \"repriced\";\n                                                    } else if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                                        reason = \"cancelled\";\n                                                    }\n                                                    // Explain why we were replaced\n                                                    reject(logger.makeError(\"transaction was replaced\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.TRANSACTION_REPLACED, {\n                                                        cancelled: reason === \"replaced\" || reason === \"cancelled\",\n                                                        reason,\n                                                        replacement: this._wrapTransaction(tx),\n                                                        hash: transactionHash,\n                                                        receipt\n                                                    }));\n                                                    return;\n                                                }\n                                            }\n                                            scannedBlock++;\n                                        }\n                                    }\n                                    if (done) {\n                                        return;\n                                    }\n                                    this.once(\"block\", replaceHandler);\n                                }), (error)=>{\n                                if (done) {\n                                    return;\n                                }\n                                this.once(\"block\", replaceHandler);\n                            });\n                        });\n                    if (done) {\n                        return;\n                    }\n                    this.once(\"block\", replaceHandler);\n                    cancelFuncs.push(()=>{\n                        this.removeListener(\"block\", replaceHandler);\n                    });\n                }\n                if (typeof timeout === \"number\" && timeout > 0) {\n                    const timer = setTimeout(()=>{\n                        if (alreadyDone()) {\n                            return;\n                        }\n                        reject(logger.makeError(\"timeout exceeded\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.TIMEOUT, {\n                            timeout: timeout\n                        }));\n                    }, timeout);\n                    if (timer.unref) {\n                        timer.unref();\n                    }\n                    cancelFuncs.push(()=>{\n                        clearTimeout(timer);\n                    });\n                }\n            });\n        });\n    }\n    getBlockNumber() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this._getInternalBlockNumber(0);\n        });\n    }\n    getGasPrice() {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const result = yield this.perform(\"getGasPrice\", {});\n            try {\n                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result);\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"getGasPrice\",\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    getBalance(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getBalance\", params);\n            try {\n                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result);\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"getBalance\",\n                    params,\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    getTransactionCount(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getTransactionCount\", params);\n            try {\n                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result).toNumber();\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"getTransactionCount\",\n                    params,\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    getCode(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getCode\", params);\n            try {\n                return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(result);\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"getCode\",\n                    params,\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    getStorageAt(addressOrName, position, blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag),\n                position: Promise.resolve(position).then((p)=>(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexValue)(p))\n            });\n            const result = yield this.perform(\"getStorageAt\", params);\n            try {\n                return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(result);\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"getStorageAt\",\n                    params,\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx, hash, startBlock) {\n        if (hash != null && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataLength)(hash) !== 32) {\n            throw new Error(\"invalid response - sendTransaction\");\n        }\n        const result = tx;\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNKNOWN_ERROR, {\n                expectedHash: tx.hash,\n                returnedHash: hash\n            });\n        }\n        result.wait = (confirms, timeout)=>__awaiter(this, void 0, void 0, function*() {\n                if (confirms == null) {\n                    confirms = 1;\n                }\n                if (timeout == null) {\n                    timeout = 0;\n                }\n                // Get the details to detect replacement\n                let replacement = undefined;\n                if (confirms !== 0 && startBlock != null) {\n                    replacement = {\n                        data: tx.data,\n                        from: tx.from,\n                        nonce: tx.nonce,\n                        to: tx.to,\n                        value: tx.value,\n                        startBlock\n                    };\n                }\n                const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n                if (receipt == null && confirms === 0) {\n                    return null;\n                }\n                // No longer pending, allow the polling loop to garbage collect this\n                this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n                if (receipt.status === 0) {\n                    logger.throwError(\"transaction failed\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                        transactionHash: tx.hash,\n                        transaction: tx,\n                        receipt: receipt\n                    });\n                }\n                return receipt;\n            });\n        return result;\n    }\n    sendTransaction(signedTransaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const hexTx = yield Promise.resolve(signedTransaction).then((t)=>(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(t));\n            const tx = this.formatter.transaction(signedTransaction);\n            if (tx.confirmations == null) {\n                tx.confirmations = 0;\n            }\n            const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            try {\n                const hash = yield this.perform(\"sendTransaction\", {\n                    signedTransaction: hexTx\n                });\n                return this._wrapTransaction(tx, hash, blockNumber);\n            } catch (error) {\n                error.transaction = tx;\n                error.transactionHash = tx.hash;\n                throw error;\n            }\n        });\n    }\n    _getTransactionRequest(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const values = yield transaction;\n            const tx = {};\n            [\n                \"from\",\n                \"to\"\n            ].forEach((key)=>{\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v)=>v ? this._getAddress(v) : null);\n            });\n            [\n                \"gasLimit\",\n                \"gasPrice\",\n                \"maxFeePerGas\",\n                \"maxPriorityFeePerGas\",\n                \"value\"\n            ].forEach((key)=>{\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v)=>v ? _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(v) : null);\n            });\n            [\n                \"type\"\n            ].forEach((key)=>{\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v)=>v != null ? v : null);\n            });\n            if (values.accessList) {\n                tx.accessList = this.formatter.accessList(values.accessList);\n            }\n            [\n                \"data\"\n            ].forEach((key)=>{\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v)=>v ? (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(v) : null);\n            });\n            return this.formatter.transactionRequest((yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)(tx)));\n        });\n    }\n    _getFilter(filter) {\n        return __awaiter(this, void 0, void 0, function*() {\n            filter = yield filter;\n            const result = {};\n            if (filter.address != null) {\n                result.address = this._getAddress(filter.address);\n            }\n            [\n                \"blockHash\",\n                \"topics\"\n            ].forEach((key)=>{\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = filter[key];\n            });\n            [\n                \"fromBlock\",\n                \"toBlock\"\n            ].forEach((key)=>{\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = this._getBlockTag(filter[key]);\n            });\n            return this.formatter.filter((yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)(result)));\n        });\n    }\n    _call(transaction, blockTag, attempt) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (attempt >= MAX_CCIP_REDIRECTS) {\n                logger.throwError(\"CCIP read exceeded maximum redirections\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    redirects: attempt,\n                    transaction\n                });\n            }\n            const txSender = transaction.to;\n            const result = yield this.perform(\"call\", {\n                transaction,\n                blockTag\n            });\n            // CCIP Read request via OffchainLookup(address,string[],bytes,bytes4,bytes)\n            if (attempt >= 0 && blockTag === \"latest\" && txSender != null && result.substring(0, 10) === \"0x556f1830\" && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataLength)(result) % 32 === 4) {\n                try {\n                    const data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(result, 4);\n                    // Check the sender of the OffchainLookup matches the transaction\n                    const sender = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, 0, 32);\n                    if (!_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(sender).eq(txSender)) {\n                        logger.throwError(\"CCIP Read sender did not match\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction,\n                            data: result\n                        });\n                    }\n                    // Read the URLs from the response\n                    const urls = [];\n                    const urlsOffset = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, 32, 64)).toNumber();\n                    const urlsLength = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, urlsOffset, urlsOffset + 32)).toNumber();\n                    const urlsData = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, urlsOffset + 32);\n                    for(let u = 0; u < urlsLength; u++){\n                        const url = _parseString(urlsData, u * 32);\n                        if (url == null) {\n                            logger.throwError(\"CCIP Read contained corrupt URL string\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                                name: \"OffchainLookup\",\n                                signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                                transaction,\n                                data: result\n                            });\n                        }\n                        urls.push(url);\n                    }\n                    // Get the CCIP calldata to forward\n                    const calldata = _parseBytes(data, 64);\n                    // Get the callbackSelector (bytes4)\n                    if (!_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, 100, 128)).isZero()) {\n                        logger.throwError(\"CCIP Read callback selector included junk\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction,\n                            data: result\n                        });\n                    }\n                    const callbackSelector = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, 96, 100);\n                    // Get the extra data to send back to the contract as context\n                    const extraData = _parseBytes(data, 128);\n                    const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);\n                    if (ccipResult == null) {\n                        logger.throwError(\"CCIP Read disabled or provided no URLs\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction,\n                            data: result\n                        });\n                    }\n                    const tx = {\n                        to: txSender,\n                        data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n                            callbackSelector,\n                            encodeBytes([\n                                ccipResult,\n                                extraData\n                            ])\n                        ])\n                    };\n                    return this._call(tx, blockTag, attempt + 1);\n                } catch (error) {\n                    if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR) {\n                        throw error;\n                    }\n                }\n            }\n            try {\n                return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(result);\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"call\",\n                    params: {\n                        transaction,\n                        blockTag\n                    },\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    call(transaction, blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const resolved = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                transaction: this._getTransactionRequest(transaction),\n                blockTag: this._getBlockTag(blockTag),\n                ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)\n            });\n            return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);\n        });\n    }\n    estimateGas(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                transaction: this._getTransactionRequest(transaction)\n            });\n            const result = yield this.perform(\"estimateGas\", params);\n            try {\n                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result);\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"estimateGas\",\n                    params,\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    _getAddress(addressOrName) {\n        return __awaiter(this, void 0, void 0, function*() {\n            addressOrName = yield addressOrName;\n            if (typeof addressOrName !== \"string\") {\n                logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n            }\n            const address = yield this.resolveName(addressOrName);\n            if (address == null) {\n                logger.throwError(\"ENS name not configured\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `resolveName(${JSON.stringify(addressOrName)})`\n                });\n            }\n            return address;\n        });\n    }\n    _getBlock(blockHashOrBlockTag, includeTransactions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            blockHashOrBlockTag = yield blockHashOrBlockTag;\n            // If blockTag is a number (not \"latest\", etc), this is the block number\n            let blockNumber = -128;\n            const params = {\n                includeTransactions: !!includeTransactions\n            };\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(blockHashOrBlockTag, 32)) {\n                params.blockHash = blockHashOrBlockTag;\n            } else {\n                try {\n                    params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);\n                    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(params.blockTag)) {\n                        blockNumber = parseInt(params.blockTag.substring(2), 16);\n                    }\n                } catch (error) {\n                    logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n                }\n            }\n            return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.poll)(()=>__awaiter(this, void 0, void 0, function*() {\n                    const block = yield this.perform(\"getBlock\", params);\n                    // Block was not found\n                    if (block == null) {\n                        // For blockhashes, if we didn't say it existed, that blockhash may\n                        // not exist. If we did see it though, perhaps from a log, we know\n                        // it exists, and this node is just not caught up yet.\n                        if (params.blockHash != null) {\n                            if (this._emitted[\"b:\" + params.blockHash] == null) {\n                                return null;\n                            }\n                        }\n                        // For block tags, if we are asking for a future block, we return null\n                        if (params.blockTag != null) {\n                            if (blockNumber > this._emitted.block) {\n                                return null;\n                            }\n                        }\n                        // Retry on the next block\n                        return undefined;\n                    }\n                    // Add transactions\n                    if (includeTransactions) {\n                        let blockNumber = null;\n                        for(let i = 0; i < block.transactions.length; i++){\n                            const tx = block.transactions[i];\n                            if (tx.blockNumber == null) {\n                                tx.confirmations = 0;\n                            } else if (tx.confirmations == null) {\n                                if (blockNumber == null) {\n                                    blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                                }\n                                // Add the confirmations using the fast block number (pessimistic)\n                                let confirmations = blockNumber - tx.blockNumber + 1;\n                                if (confirmations <= 0) {\n                                    confirmations = 1;\n                                }\n                                tx.confirmations = confirmations;\n                            }\n                        }\n                        const blockWithTxs = this.formatter.blockWithTransactions(block);\n                        blockWithTxs.transactions = blockWithTxs.transactions.map((tx)=>this._wrapTransaction(tx));\n                        return blockWithTxs;\n                    }\n                    return this.formatter.block(block);\n                }), {\n                oncePoll: this\n            });\n        });\n    }\n    getBlock(blockHashOrBlockTag) {\n        return this._getBlock(blockHashOrBlockTag, false);\n    }\n    getBlockWithTransactions(blockHashOrBlockTag) {\n        return this._getBlock(blockHashOrBlockTag, true);\n    }\n    getTransaction(transactionHash) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = {\n                transactionHash: this.formatter.hash(transactionHash, true)\n            };\n            return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.poll)(()=>__awaiter(this, void 0, void 0, function*() {\n                    const result = yield this.perform(\"getTransaction\", params);\n                    if (result == null) {\n                        if (this._emitted[\"t:\" + transactionHash] == null) {\n                            return null;\n                        }\n                        return undefined;\n                    }\n                    const tx = this.formatter.transactionResponse(result);\n                    if (tx.blockNumber == null) {\n                        tx.confirmations = 0;\n                    } else if (tx.confirmations == null) {\n                        const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                        // Add the confirmations using the fast block number (pessimistic)\n                        let confirmations = blockNumber - tx.blockNumber + 1;\n                        if (confirmations <= 0) {\n                            confirmations = 1;\n                        }\n                        tx.confirmations = confirmations;\n                    }\n                    return this._wrapTransaction(tx);\n                }), {\n                oncePoll: this\n            });\n        });\n    }\n    getTransactionReceipt(transactionHash) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = {\n                transactionHash: this.formatter.hash(transactionHash, true)\n            };\n            return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.poll)(()=>__awaiter(this, void 0, void 0, function*() {\n                    const result = yield this.perform(\"getTransactionReceipt\", params);\n                    if (result == null) {\n                        if (this._emitted[\"t:\" + transactionHash] == null) {\n                            return null;\n                        }\n                        return undefined;\n                    }\n                    // \"geth-etc\" returns receipts before they are ready\n                    if (result.blockHash == null) {\n                        return undefined;\n                    }\n                    const receipt = this.formatter.receipt(result);\n                    if (receipt.blockNumber == null) {\n                        receipt.confirmations = 0;\n                    } else if (receipt.confirmations == null) {\n                        const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                        // Add the confirmations using the fast block number (pessimistic)\n                        let confirmations = blockNumber - receipt.blockNumber + 1;\n                        if (confirmations <= 0) {\n                            confirmations = 1;\n                        }\n                        receipt.confirmations = confirmations;\n                    }\n                    return receipt;\n                }), {\n                oncePoll: this\n            });\n        });\n    }\n    getLogs(filter) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                filter: this._getFilter(filter)\n            });\n            const logs = yield this.perform(\"getLogs\", params);\n            logs.forEach((log)=>{\n                if (log.removed == null) {\n                    log.removed = false;\n                }\n            });\n            return _formatter__WEBPACK_IMPORTED_MODULE_14__.Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n        });\n    }\n    getEtherPrice() {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            return this.perform(\"getEtherPrice\", {});\n        });\n    }\n    _getBlockTag(blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            blockTag = yield blockTag;\n            if (typeof blockTag === \"number\" && blockTag < 0) {\n                if (blockTag % 1) {\n                    logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n                }\n                let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                blockNumber += blockTag;\n                if (blockNumber < 0) {\n                    blockNumber = 0;\n                }\n                return this.formatter.blockTag(blockNumber);\n            }\n            return this.formatter.blockTag(blockTag);\n        });\n    }\n    getResolver(name) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let currentName = name;\n            while(true){\n                if (currentName === \"\" || currentName === \".\") {\n                    return null;\n                }\n                // Optimization since the eth node cannot change and does\n                // not have a wildcard resolver\n                if (name !== \"eth\" && currentName === \"eth\") {\n                    return null;\n                }\n                // Check the current node for a resolver\n                const addr = yield this._getResolver(currentName, \"getResolver\");\n                // Found a resolver!\n                if (addr != null) {\n                    const resolver = new Resolver(this, addr, name);\n                    // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                    if (currentName !== name && !(yield resolver.supportsWildcard())) {\n                        return null;\n                    }\n                    return resolver;\n                }\n                // Get the parent node\n                currentName = currentName.split(\".\").slice(1).join(\".\");\n            }\n        });\n    }\n    _getResolver(name, operation) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (operation == null) {\n                operation = \"ENS\";\n            }\n            const network = yield this.getNetwork();\n            // No ENS...\n            if (!network.ensAddress) {\n                logger.throwError(\"network does not support ENS\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation,\n                    network: network.name\n                });\n            }\n            try {\n                // keccak256(\"resolver(bytes32)\")\n                const addrData = yield this.call({\n                    to: network.ensAddress,\n                    data: \"0x0178b8bf\" + (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.namehash)(name).substring(2)\n                });\n                return this.formatter.callAddress(addrData);\n            } catch (error) {\n            // ENS registry cannot throw errors on resolver(bytes32)\n            }\n            return null;\n        });\n    }\n    resolveName(name) {\n        return __awaiter(this, void 0, void 0, function*() {\n            name = yield name;\n            // If it is already an address, nothing to resolve\n            try {\n                return Promise.resolve(this.formatter.address(name));\n            } catch (error) {\n                // If is is a hexstring, the address is bad (See #694)\n                if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(name)) {\n                    throw error;\n                }\n            }\n            if (typeof name !== \"string\") {\n                logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n            }\n            // Get the addr from the resolver\n            const resolver = yield this.getResolver(name);\n            if (!resolver) {\n                return null;\n            }\n            return yield resolver.getAddress();\n        });\n    }\n    lookupAddress(address) {\n        return __awaiter(this, void 0, void 0, function*() {\n            address = yield address;\n            address = this.formatter.address(address);\n            const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n            const resolverAddr = yield this._getResolver(node, \"lookupAddress\");\n            if (resolverAddr == null) {\n                return null;\n            }\n            // keccak(\"name(bytes32)\")\n            const name = _parseString((yield this.call({\n                to: resolverAddr,\n                data: \"0x691f3431\" + (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.namehash)(node).substring(2)\n            })), 0);\n            const addr = yield this.resolveName(name);\n            if (addr != address) {\n                return null;\n            }\n            return name;\n        });\n    }\n    getAvatar(nameOrAddress) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let resolver = null;\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(nameOrAddress)) {\n                // Address; reverse lookup\n                const address = this.formatter.address(nameOrAddress);\n                const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n                const resolverAddress = yield this._getResolver(node, \"getAvatar\");\n                if (!resolverAddress) {\n                    return null;\n                }\n                // Try resolving the avatar against the addr.reverse resolver\n                resolver = new Resolver(this, resolverAddress, node);\n                try {\n                    const avatar = yield resolver.getAvatar();\n                    if (avatar) {\n                        return avatar.url;\n                    }\n                } catch (error) {\n                    if (error.code !== _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {\n                        throw error;\n                    }\n                }\n                // Try getting the name and performing forward lookup; allowing wildcards\n                try {\n                    // keccak(\"name(bytes32)\")\n                    const name = _parseString((yield this.call({\n                        to: resolverAddress,\n                        data: \"0x691f3431\" + (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.namehash)(node).substring(2)\n                    })), 0);\n                    resolver = yield this.getResolver(name);\n                } catch (error) {\n                    if (error.code !== _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {\n                        throw error;\n                    }\n                    return null;\n                }\n            } else {\n                // ENS name; forward lookup with wildcard\n                resolver = yield this.getResolver(nameOrAddress);\n                if (!resolver) {\n                    return null;\n                }\n            }\n            const avatar = yield resolver.getAvatar();\n            if (avatar == null) {\n                return null;\n            }\n            return avatar.url;\n        });\n    }\n    perform(method, params) {\n        return logger.throwError(method + \" not implemented\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NOT_IMPLEMENTED, {\n            operation: method\n        });\n    }\n    _startEvent(event) {\n        this.polling = this._events.filter((e)=>e.pollable()).length > 0;\n    }\n    _stopEvent(event) {\n        this.polling = this._events.filter((e)=>e.pollable()).length > 0;\n    }\n    _addEventListener(eventName, listener, once) {\n        const event = new Event(getEventTag(eventName), listener, once);\n        this._events.push(event);\n        this._startEvent(event);\n        return this;\n    }\n    on(eventName, listener) {\n        return this._addEventListener(eventName, listener, false);\n    }\n    once(eventName, listener) {\n        return this._addEventListener(eventName, listener, true);\n    }\n    emit(eventName, ...args) {\n        let result = false;\n        let stopped = [];\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event)=>{\n            if (event.tag !== eventTag) {\n                return true;\n            }\n            setTimeout(()=>{\n                event.listener.apply(this, args);\n            }, 0);\n            result = true;\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n            return true;\n        });\n        stopped.forEach((event)=>{\n            this._stopEvent(event);\n        });\n        return result;\n    }\n    listenerCount(eventName) {\n        if (!eventName) {\n            return this._events.length;\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event)=>{\n            return event.tag === eventTag;\n        }).length;\n    }\n    listeners(eventName) {\n        if (eventName == null) {\n            return this._events.map((event)=>event.listener);\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event)=>event.tag === eventTag).map((event)=>event.listener);\n    }\n    off(eventName, listener) {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n        const stopped = [];\n        let found = false;\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event)=>{\n            if (event.tag !== eventTag || event.listener != listener) {\n                return true;\n            }\n            if (found) {\n                return true;\n            }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n        stopped.forEach((event)=>{\n            this._stopEvent(event);\n        });\n        return this;\n    }\n    removeAllListeners(eventName) {\n        let stopped = [];\n        if (eventName == null) {\n            stopped = this._events;\n            this._events = [];\n        } else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event)=>{\n                if (event.tag !== eventTag) {\n                    return true;\n                }\n                stopped.push(event);\n                return false;\n            });\n        }\n        stopped.forEach((event)=>{\n            this._stopEvent(event);\n        });\n        return this;\n    }\n} //# sourceMappingURL=base-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9iYXNlLXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWE7QUFDYixJQUFJQSxZQUFZLFNBQUssSUFBSSxTQUFJLENBQUNBLFNBQVMsSUFBSyxTQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ25GLFNBQVNDLE1BQU1DLEtBQUs7UUFBSSxPQUFPQSxpQkFBaUJILElBQUlHLFFBQVEsSUFBSUgsRUFBRSxTQUFVSSxPQUFPO1lBQUlBLFFBQVFEO1FBQVE7SUFBSTtJQUMzRyxPQUFPLElBQUtILENBQUFBLEtBQU1BLENBQUFBLElBQUlLLE9BQU0sQ0FBQyxFQUFHLFNBQVVELE9BQU8sRUFBRUUsTUFBTTtRQUNyRCxTQUFTQyxVQUFVSixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsVUFBVVEsSUFBSSxDQUFDTjtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzFGLFNBQVNDLFNBQVNSLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxTQUFTLENBQUMsUUFBUSxDQUFDRTtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzdGLFNBQVNGLEtBQUtJLE1BQU07WUFBSUEsT0FBT0MsSUFBSSxHQUFHVCxRQUFRUSxPQUFPVCxLQUFLLElBQUlELE1BQU1VLE9BQU9ULEtBQUssRUFBRVcsSUFBSSxDQUFDUCxXQUFXSTtRQUFXO1FBQzdHSCxLQUFLLENBQUNQLFlBQVlBLFVBQVVjLEtBQUssQ0FBQ2pCLFNBQVNDLGNBQWMsRUFBRSxHQUFHVSxJQUFJO0lBQ3RFO0FBQ0o7QUFDdUU7QUFDUjtBQUNqQjtBQUNPO0FBQ3VGO0FBQ3hGO0FBQ007QUFDTDtBQUNvQztBQUM1QztBQUNzQjtBQUNkO0FB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L25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9iYXNlLXByb3ZpZGVyLmpzP2UyYTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IEZvcmtFdmVudCwgUHJvdmlkZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWJzdHJhY3QtcHJvdmlkZXJcIjtcbmltcG9ydCB7IGVuY29kZSBhcyBiYXNlNjRFbmNvZGUgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmFzZTY0XCI7XG5pbXBvcnQgeyBCYXNlNTggfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmFzZXhcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGFycmF5aWZ5LCBjb25jYXQsIGhleENvbmNhdCwgaGV4RGF0YUxlbmd0aCwgaGV4RGF0YVNsaWNlLCBoZXhsaWZ5LCBoZXhWYWx1ZSwgaGV4WmVyb1BhZCwgaXNIZXhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IEhhc2haZXJvIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgZG5zRW5jb2RlLCBuYW1laGFzaCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9oYXNoXCI7XG5pbXBvcnQgeyBnZXROZXR3b3JrIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L25ldHdvcmtzXCI7XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSwgZ2V0U3RhdGljLCByZXNvbHZlUHJvcGVydGllcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvc2hhMlwiO1xuaW1wb3J0IHsgdG9VdGY4Qnl0ZXMsIHRvVXRmOFN0cmluZyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9zdHJpbmdzXCI7XG5pbXBvcnQgeyBmZXRjaEpzb24sIHBvbGwgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvd2ViXCI7XG5pbXBvcnQgYmVjaDMyIGZyb20gXCJiZWNoMzJcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IEZvcm1hdHRlciB9IGZyb20gXCIuL2Zvcm1hdHRlclwiO1xuY29uc3QgTUFYX0NDSVBfUkVESVJFQ1RTID0gMTA7XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEV2ZW50IFNlcmlhbGl6ZWluZ1xuZnVuY3Rpb24gY2hlY2tUb3BpYyh0b3BpYykge1xuICAgIGlmICh0b3BpYyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICB9XG4gICAgaWYgKGhleERhdGFMZW5ndGgodG9waWMpICE9PSAzMikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0b3BpY1wiLCBcInRvcGljXCIsIHRvcGljKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvcGljLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVUb3BpY3ModG9waWNzKSB7XG4gICAgLy8gUmVtb3ZlIHRyYWlsaW5nIG51bGwgQU5ELXRvcGljczsgdGhleSBhcmUgcmVkdW5kYW50XG4gICAgdG9waWNzID0gdG9waWNzLnNsaWNlKCk7XG4gICAgd2hpbGUgKHRvcGljcy5sZW5ndGggPiAwICYmIHRvcGljc1t0b3BpY3MubGVuZ3RoIC0gMV0gPT0gbnVsbCkge1xuICAgICAgICB0b3BpY3MucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiB0b3BpY3MubWFwKCh0b3BpYykgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0b3BpYykpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgdHJhY2sgdW5pcXVlIE9SLXRvcGljc1xuICAgICAgICAgICAgY29uc3QgdW5pcXVlID0ge307XG4gICAgICAgICAgICB0b3BpYy5mb3JFYWNoKCh0b3BpYykgPT4ge1xuICAgICAgICAgICAgICAgIHVuaXF1ZVtjaGVja1RvcGljKHRvcGljKV0gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBUaGUgb3JkZXIgb2YgT1ItdG9waWNzIGRvZXMgbm90IG1hdHRlclxuICAgICAgICAgICAgY29uc3Qgc29ydGVkID0gT2JqZWN0LmtleXModW5pcXVlKTtcbiAgICAgICAgICAgIHNvcnRlZC5zb3J0KCk7XG4gICAgICAgICAgICByZXR1cm4gc29ydGVkLmpvaW4oXCJ8XCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrVG9waWModG9waWMpO1xuICAgICAgICB9XG4gICAgfSkuam9pbihcIiZcIik7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVRvcGljcyhkYXRhKSB7XG4gICAgaWYgKGRhdGEgPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YS5zcGxpdCgvJi9nKS5tYXAoKHRvcGljKSA9PiB7XG4gICAgICAgIGlmICh0b3BpYyA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBzID0gdG9waWMuc3BsaXQoXCJ8XCIpLm1hcCgodG9waWMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoKHRvcGljID09PSBcIm51bGxcIikgPyBudWxsIDogdG9waWMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgoY29tcHMubGVuZ3RoID09PSAxKSA/IGNvbXBzWzBdIDogY29tcHMpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKSB7XG4gICAgaWYgKHR5cGVvZiAoZXZlbnROYW1lKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGhleERhdGFMZW5ndGgoZXZlbnROYW1lKSA9PT0gMzIpIHtcbiAgICAgICAgICAgIHJldHVybiBcInR4OlwiICsgZXZlbnROYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudE5hbWUuaW5kZXhPZihcIjpcIikgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnROYW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnROYW1lKSkge1xuICAgICAgICByZXR1cm4gXCJmaWx0ZXI6KjpcIiArIHNlcmlhbGl6ZVRvcGljcyhldmVudE5hbWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChGb3JrRXZlbnQuaXNGb3JrRXZlbnQoZXZlbnROYW1lKSkge1xuICAgICAgICBsb2dnZXIud2FybihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudE5hbWUgJiYgdHlwZW9mIChldmVudE5hbWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBcImZpbHRlcjpcIiArIChldmVudE5hbWUuYWRkcmVzcyB8fCBcIipcIikgKyBcIjpcIiArIHNlcmlhbGl6ZVRvcGljcyhldmVudE5hbWUudG9waWNzIHx8IFtdKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBldmVudCAtIFwiICsgZXZlbnROYW1lKTtcbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSGVscGVyIE9iamVjdFxuZnVuY3Rpb24gZ2V0VGltZSgpIHtcbiAgICByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbn1cbmZ1bmN0aW9uIHN0YWxsKGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pO1xuICAgIH0pO1xufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBQcm92aWRlciBPYmplY3Rcbi8qKlxuICogIEV2ZW50VHlwZVxuICogICAtIFwiYmxvY2tcIlxuICogICAtIFwicG9sbFwiXG4gKiAgIC0gXCJkaWRQb2xsXCJcbiAqICAgLSBcInBlbmRpbmdcIlxuICogICAtIFwiZXJyb3JcIlxuICogICAtIFwibmV0d29ya1wiXG4gKiAgIC0gZmlsdGVyXG4gKiAgIC0gdG9waWNzIGFycmF5XG4gKiAgIC0gdHJhbnNhY3Rpb24gaGFzaFxuICovXG5jb25zdCBQb2xsYWJsZUV2ZW50cyA9IFtcImJsb2NrXCIsIFwibmV0d29ya1wiLCBcInBlbmRpbmdcIiwgXCJwb2xsXCJdO1xuZXhwb3J0IGNsYXNzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih0YWcsIGxpc3RlbmVyLCBvbmNlKSB7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwidGFnXCIsIHRhZyk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwibGlzdGVuZXJcIiwgbGlzdGVuZXIpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIm9uY2VcIiwgb25jZSk7XG4gICAgICAgIHRoaXMuX2xhc3RCbG9ja051bWJlciA9IC0yO1xuICAgICAgICB0aGlzLl9pbmZsaWdodCA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgZXZlbnQoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidHhcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNoO1xuICAgICAgICAgICAgY2FzZSBcImZpbHRlclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50YWc7XG4gICAgfVxuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWcuc3BsaXQoXCI6XCIpWzBdO1xuICAgIH1cbiAgICBnZXQgaGFzaCgpIHtcbiAgICAgICAgY29uc3QgY29tcHMgPSB0aGlzLnRhZy5zcGxpdChcIjpcIik7XG4gICAgICAgIGlmIChjb21wc1swXSAhPT0gXCJ0eFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcHNbMV07XG4gICAgfVxuICAgIGdldCBmaWx0ZXIoKSB7XG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy50YWcuc3BsaXQoXCI6XCIpO1xuICAgICAgICBpZiAoY29tcHNbMF0gIT09IFwiZmlsdGVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBjb21wc1sxXTtcbiAgICAgICAgY29uc3QgdG9waWNzID0gZGVzZXJpYWxpemVUb3BpY3MoY29tcHNbMl0pO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7fTtcbiAgICAgICAgaWYgKHRvcGljcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmaWx0ZXIudG9waWNzID0gdG9waWNzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRyZXNzICYmIGFkZHJlc3MgIT09IFwiKlwiKSB7XG4gICAgICAgICAgICBmaWx0ZXIuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbHRlcjtcbiAgICB9XG4gICAgcG9sbGFibGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50YWcuaW5kZXhPZihcIjpcIikgPj0gMCB8fCBQb2xsYWJsZUV2ZW50cy5pbmRleE9mKHRoaXMudGFnKSA+PSAwKTtcbiAgICB9XG59XG47XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2F0b3NoaWxhYnMvc2xpcHMvYmxvYi9tYXN0ZXIvc2xpcC0wMDQ0Lm1kXG5jb25zdCBjb2luSW5mb3MgPSB7XG4gICAgXCIwXCI6IHsgc3ltYm9sOiBcImJ0Y1wiLCBwMnBraDogMHgwMCwgcDJzaDogMHgwNSwgcHJlZml4OiBcImJjXCIgfSxcbiAgICBcIjJcIjogeyBzeW1ib2w6IFwibHRjXCIsIHAycGtoOiAweDMwLCBwMnNoOiAweDMyLCBwcmVmaXg6IFwibHRjXCIgfSxcbiAgICBcIjNcIjogeyBzeW1ib2w6IFwiZG9nZVwiLCBwMnBraDogMHgxZSwgcDJzaDogMHgxNiB9LFxuICAgIFwiNjBcIjogeyBzeW1ib2w6IFwiZXRoXCIsIGlsazogXCJldGhcIiB9LFxuICAgIFwiNjFcIjogeyBzeW1ib2w6IFwiZXRjXCIsIGlsazogXCJldGhcIiB9LFxuICAgIFwiNzAwXCI6IHsgc3ltYm9sOiBcInhkYWlcIiwgaWxrOiBcImV0aFwiIH0sXG59O1xuZnVuY3Rpb24gYnl0ZXMzMmlmeSh2YWx1ZSkge1xuICAgIHJldHVybiBoZXhaZXJvUGFkKEJpZ051bWJlci5mcm9tKHZhbHVlKS50b0hleFN0cmluZygpLCAzMik7XG59XG4vLyBDb21wdXRlIHRoZSBCYXNlNThDaGVjayBlbmNvZGVkIGRhdGEgKGNoZWNrc3VtIGlzIGZpcnN0IDQgYnl0ZXMgb2Ygc2hhMjU2ZClcbmZ1bmN0aW9uIGJhc2U1OEVuY29kZShkYXRhKSB7XG4gICAgcmV0dXJuIEJhc2U1OC5lbmNvZGUoY29uY2F0KFtkYXRhLCBoZXhEYXRhU2xpY2Uoc2hhMjU2KHNoYTI1NihkYXRhKSksIDAsIDQpXSkpO1xufVxuY29uc3QgbWF0Y2hlcklwZnMgPSBuZXcgUmVnRXhwKFwiXihpcGZzKTovXFwvKC4qKSRcIiwgXCJpXCIpO1xuY29uc3QgbWF0Y2hlcnMgPSBbXG4gICAgbmV3IFJlZ0V4cChcIl4oaHR0cHMpOi9cXC8oLiopJFwiLCBcImlcIiksXG4gICAgbmV3IFJlZ0V4cChcIl4oZGF0YSk6KC4qKSRcIiwgXCJpXCIpLFxuICAgIG1hdGNoZXJJcGZzLFxuICAgIG5ldyBSZWdFeHAoXCJeZWlwMTU1OlswLTldKy8oZXJjWzAtOV0rKTooLiopJFwiLCBcImlcIiksXG5dO1xuZnVuY3Rpb24gX3BhcnNlU3RyaW5nKHJlc3VsdCwgc3RhcnQpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdG9VdGY4U3RyaW5nKF9wYXJzZUJ5dGVzKHJlc3VsdCwgc3RhcnQpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIF9wYXJzZUJ5dGVzKHJlc3VsdCwgc3RhcnQpIHtcbiAgICBpZiAocmVzdWx0ID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG9mZnNldCA9IEJpZ051bWJlci5mcm9tKGhleERhdGFTbGljZShyZXN1bHQsIHN0YXJ0LCBzdGFydCArIDMyKSkudG9OdW1iZXIoKTtcbiAgICBjb25zdCBsZW5ndGggPSBCaWdOdW1iZXIuZnJvbShoZXhEYXRhU2xpY2UocmVzdWx0LCBvZmZzZXQsIG9mZnNldCArIDMyKSkudG9OdW1iZXIoKTtcbiAgICByZXR1cm4gaGV4RGF0YVNsaWNlKHJlc3VsdCwgb2Zmc2V0ICsgMzIsIG9mZnNldCArIDMyICsgbGVuZ3RoKTtcbn1cbi8vIFRyaW0gb2ZmIHRoZSBpcGZzOi8vIHByZWZpeCBhbmQgcmV0dXJuIHRoZSBkZWZhdWx0IGdhdGV3YXkgVVJMXG5mdW5jdGlvbiBnZXRJcGZzTGluayhsaW5rKSB7XG4gICAgaWYgKGxpbmsubWF0Y2goL15pcGZzOlxcL1xcL2lwZnNcXC8vaSkpIHtcbiAgICAgICAgbGluayA9IGxpbmsuc3Vic3RyaW5nKDEyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGluay5tYXRjaCgvXmlwZnM6XFwvXFwvL2kpKSB7XG4gICAgICAgIGxpbmsgPSBsaW5rLnN1YnN0cmluZyg3KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBJUEZTIGZvcm1hdFwiLCBcImxpbmtcIiwgbGluayk7XG4gICAgfVxuICAgIHJldHVybiBgaHR0cHM6L1xcL2dhdGV3YXkuaXBmcy5pby9pcGZzLyR7bGlua31gO1xufVxuZnVuY3Rpb24gbnVtUGFkKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXJyYXlpZnkodmFsdWUpO1xuICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW50ZXJuYWw7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgIH1cbiAgICBjb25zdCBwYWRkZWQgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgcGFkZGVkLnNldChyZXN1bHQsIDMyIC0gcmVzdWx0Lmxlbmd0aCk7XG4gICAgcmV0dXJuIHBhZGRlZDtcbn1cbmZ1bmN0aW9uIGJ5dGVzUGFkKHZhbHVlKSB7XG4gICAgaWYgKCh2YWx1ZS5sZW5ndGggJSAzMikgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShNYXRoLmNlaWwodmFsdWUubGVuZ3RoIC8gMzIpICogMzIpO1xuICAgIHJlc3VsdC5zZXQodmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBBQkkgRW5jb2RlcyBhIHNlcmllcyBvZiAoYnl0ZXMsIGJ5dGVzLCAuLi4pXG5mdW5jdGlvbiBlbmNvZGVCeXRlcyhkYXRhcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBieXRlQ291bnQgPSAwO1xuICAgIC8vIEFkZCBwbGFjZS1ob2xkZXJzIGZvciBwb2ludGVycyBhcyB3ZSBhZGQgaXRlbXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG51bGwpO1xuICAgICAgICBieXRlQ291bnQgKz0gMzI7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGFycmF5aWZ5KGRhdGFzW2ldKTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBieXRlcyBvZmZzZXRcbiAgICAgICAgcmVzdWx0W2ldID0gbnVtUGFkKGJ5dGVDb3VudCk7XG4gICAgICAgIC8vIFRoZSBsZW5ndGggYW5kIHBhZGRlZCB2YWx1ZSBvZiBkYXRhXG4gICAgICAgIHJlc3VsdC5wdXNoKG51bVBhZChkYXRhLmxlbmd0aCkpO1xuICAgICAgICByZXN1bHQucHVzaChieXRlc1BhZChkYXRhKSk7XG4gICAgICAgIGJ5dGVDb3VudCArPSAzMiArIE1hdGguY2VpbChkYXRhLmxlbmd0aCAvIDMyKSAqIDMyO1xuICAgIH1cbiAgICByZXR1cm4gaGV4Q29uY2F0KHJlc3VsdCk7XG59XG5leHBvcnQgY2xhc3MgUmVzb2x2ZXIge1xuICAgIC8vIFRoZSByZXNvbHZlZEFkZHJlc3MgaXMgb25seSBmb3IgY3JlYXRpbmcgYSBSZXZlcnNlTG9va3VwIHJlc29sdmVyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGFkZHJlc3MsIG5hbWUsIHJlc29sdmVkQWRkcmVzcykge1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImFkZHJlc3NcIiwgcHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoYWRkcmVzcykpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9yZXNvbHZlZEFkZHJlc3NcIiwgcmVzb2x2ZWRBZGRyZXNzKTtcbiAgICB9XG4gICAgc3VwcG9ydHNXaWxkY2FyZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zdXBwb3J0c0VpcDI1NDQpIHtcbiAgICAgICAgICAgIC8vIHN1cHBvcnRzSW50ZXJmYWNlKGJ5dGVzNCA9IHNlbGVjdG9yKFwicmVzb2x2ZShieXRlcyxieXRlcylcIikpXG4gICAgICAgICAgICB0aGlzLl9zdXBwb3J0c0VpcDI1NDQgPSB0aGlzLnByb3ZpZGVyLmNhbGwoe1xuICAgICAgICAgICAgICAgIHRvOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgZGF0YTogXCIweDAxZmZjOWE3OTA2MWI5MjMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiXG4gICAgICAgICAgICB9KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20ocmVzdWx0KS5lcSgxKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmV0aHJvdyB0aGUgZXJyb3I6IGxpbmsgaXMgZG93biwgZXRjLiBMZXQgZnV0dXJlIGF0dGVtcHRzIHJldHJ5LlxuICAgICAgICAgICAgICAgIHRoaXMuX3N1cHBvcnRzRWlwMjU0NCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3VwcG9ydHNFaXAyNTQ0O1xuICAgIH1cbiAgICBfZmV0Y2goc2VsZWN0b3IsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIGUuZy4ga2VjY2FrMjU2KFwiYWRkcihieXRlczMyLHVpbnQyNTYpXCIpXG4gICAgICAgICAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgICAgICAgICB0bzogdGhpcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgIGNjaXBSZWFkRW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBoZXhDb25jYXQoW3NlbGVjdG9yLCBuYW1laGFzaCh0aGlzLm5hbWUpLCAocGFyYW1ldGVycyB8fCBcIjB4XCIpXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBXaWxkY2FyZCBzdXBwb3J0OyB1c2UgRUlQLTI1NDQgdG8gcmVzb2x2ZSB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgbGV0IHBhcnNlQnl0ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh5aWVsZCB0aGlzLnN1cHBvcnRzV2lsZGNhcmQoKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlQnl0ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIHNlbGVjdG9yKFwicmVzb2x2ZShieXRlcyxieXRlcylcIilcbiAgICAgICAgICAgICAgICB0eC5kYXRhID0gaGV4Q29uY2F0KFtcIjB4OTA2MWI5MjNcIiwgZW5jb2RlQnl0ZXMoW2Ruc0VuY29kZSh0aGlzLm5hbWUpLCB0eC5kYXRhXSldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHlpZWxkIHRoaXMucHJvdmlkZXIuY2FsbCh0eCk7XG4gICAgICAgICAgICAgICAgaWYgKChhcnJheWlmeShyZXN1bHQpLmxlbmd0aCAlIDMyKSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInJlc29sdmVyIHRocmV3IGVycm9yXCIsIExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0eCwgZGF0YTogcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VCeXRlcykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfcGFyc2VCeXRlcyhyZXN1bHQsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2ZldGNoQnl0ZXMoc2VsZWN0b3IsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMuX2ZldGNoKHNlbGVjdG9yLCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcGFyc2VCeXRlcyhyZXN1bHQsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0QWRkcmVzcyhjb2luVHlwZSwgaGV4Qnl0ZXMpIHtcbiAgICAgICAgY29uc3QgY29pbkluZm8gPSBjb2luSW5mb3NbU3RyaW5nKGNvaW5UeXBlKV07XG4gICAgICAgIGlmIChjb2luSW5mbyA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihgdW5zdXBwb3J0ZWQgY29pbiB0eXBlOiAke2NvaW5UeXBlfWAsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBgZ2V0QWRkcmVzcygke2NvaW5UeXBlfSlgXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29pbkluZm8uaWxrID09PSBcImV0aFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhoZXhCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnl0ZXMgPSBhcnJheWlmeShoZXhCeXRlcyk7XG4gICAgICAgIC8vIFAyUEtIOiBPUF9EVVAgT1BfSEFTSDE2MCA8cHViS2V5SGFzaD4gT1BfRVFVQUxWRVJJRlkgT1BfQ0hFQ0tTSUdcbiAgICAgICAgaWYgKGNvaW5JbmZvLnAycGtoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHAycGtoID0gaGV4Qnl0ZXMubWF0Y2goL14weDc2YTkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl0qKTg4YWMkLyk7XG4gICAgICAgICAgICBpZiAocDJwa2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChwMnBraFsxXSwgMTYpO1xuICAgICAgICAgICAgICAgIGlmIChwMnBraFsyXS5sZW5ndGggPT09IGxlbmd0aCAqIDIgJiYgbGVuZ3RoID49IDEgJiYgbGVuZ3RoIDw9IDc1KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlNThFbmNvZGUoY29uY2F0KFtbY29pbkluZm8ucDJwa2hdLCAoXCIweFwiICsgcDJwa2hbMl0pXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBQMlNIOiBPUF9IQVNIMTYwIDxzY3JpcHRIYXNoPiBPUF9FUVVBTFxuICAgICAgICBpZiAoY29pbkluZm8ucDJzaCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBwMnNoID0gaGV4Qnl0ZXMubWF0Y2goL14weGE5KFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdKik4NyQvKTtcbiAgICAgICAgICAgIGlmIChwMnNoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQocDJzaFsxXSwgMTYpO1xuICAgICAgICAgICAgICAgIGlmIChwMnNoWzJdLmxlbmd0aCA9PT0gbGVuZ3RoICogMiAmJiBsZW5ndGggPj0gMSAmJiBsZW5ndGggPD0gNzUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U1OEVuY29kZShjb25jYXQoW1tjb2luSW5mby5wMnNoXSwgKFwiMHhcIiArIHAyc2hbMl0pXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBCZWNoMzJcbiAgICAgICAgaWYgKGNvaW5JbmZvLnByZWZpeCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBieXRlc1sxXTtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAxNDEubWVkaWF3aWtpI3dpdG5lc3MtcHJvZ3JhbVxuICAgICAgICAgICAgbGV0IHZlcnNpb24gPSBieXRlc1swXTtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAweDAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCAhPT0gMjAgJiYgbGVuZ3RoICE9PSAzMikge1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZlcnNpb24gPj0gMCAmJiBieXRlcy5sZW5ndGggPT09IDIgKyBsZW5ndGggJiYgbGVuZ3RoID49IDEgJiYgbGVuZ3RoIDw9IDc1KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd29yZHMgPSBiZWNoMzIudG9Xb3JkcyhieXRlcy5zbGljZSgyKSk7XG4gICAgICAgICAgICAgICAgd29yZHMudW5zaGlmdCh2ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVjaDMyLmVuY29kZShjb2luSW5mby5wcmVmaXgsIHdvcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0QWRkcmVzcyhjb2luVHlwZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKGNvaW5UeXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb2luVHlwZSA9IDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgRXRoZXJldW0sIHVzZSB0aGUgc3RhbmRhcmQgYGFkZHIoYnl0ZXMzMilgXG4gICAgICAgICAgICBpZiAoY29pblR5cGUgPT09IDYwKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8ga2VjY2FrMjU2KFwiYWRkcihieXRlczMyKVwiKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLl9mZXRjaChcIjB4M2IzYjU3ZGVcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gXCIweFwiIHx8IHJlc3VsdCA9PT0gSGFzaFplcm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5jYWxsQWRkcmVzcyhyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGtlY2NhazI1NihcImFkZHIoYnl0ZXMzMix1aW50MjU2XCIpXG4gICAgICAgICAgICBjb25zdCBoZXhCeXRlcyA9IHlpZWxkIHRoaXMuX2ZldGNoQnl0ZXMoXCIweGYxY2I3ZTA2XCIsIGJ5dGVzMzJpZnkoY29pblR5cGUpKTtcbiAgICAgICAgICAgIC8vIE5vIGFkZHJlc3NcbiAgICAgICAgICAgIGlmIChoZXhCeXRlcyA9PSBudWxsIHx8IGhleEJ5dGVzID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGFkZHJlc3NcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLl9nZXRBZGRyZXNzKGNvaW5UeXBlLCBoZXhCeXRlcyk7XG4gICAgICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoYGludmFsaWQgb3IgdW5zdXBwb3J0ZWQgY29pbiBkYXRhYCwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBgZ2V0QWRkcmVzcygke2NvaW5UeXBlfSlgLFxuICAgICAgICAgICAgICAgICAgICBjb2luVHlwZTogY29pblR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGhleEJ5dGVzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEF2YXRhcigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmthZ2UgPSBbeyB0eXBlOiBcIm5hbWVcIiwgY29udGVudDogdGhpcy5uYW1lIH1dO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyB0ZXN0IGRhdGEgZm9yIHJpY21vby5ldGhcbiAgICAgICAgICAgICAgICAvL2NvbnN0IGF2YXRhciA9IFwiZWlwMTU1OjEvZXJjNzIxOjB4MjY1Mzg1YzdmNDEzMjIyOEEwZDU0RUIxQTllNzQ2MGI5MWMwY0M2OC8yOTIzM1wiO1xuICAgICAgICAgICAgICAgIGNvbnN0IGF2YXRhciA9IHlpZWxkIHRoaXMuZ2V0VGV4dChcImF2YXRhclwiKTtcbiAgICAgICAgICAgICAgICBpZiAoYXZhdGFyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBhdmF0YXIubWF0Y2gobWF0Y2hlcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1lID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzY2hlbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJodHRwc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwidXJsXCIsIGNvbnRlbnQ6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IGF2YXRhciB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImRhdGFcIiwgY29udGVudDogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybDogYXZhdGFyIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaXBmc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiaXBmc1wiLCBjb250ZW50OiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBnZXRJcGZzTGluayhhdmF0YXIpIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXJjNzIxXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXJjMTE1NVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIHRoZSBFUkMgdHlwZSwgdXNlIHRva2VuVVJJKHVpbnQyNTYpIG9yIHVybCh1aW50MjU2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gKHNjaGVtZSA9PT0gXCJlcmM3MjFcIikgPyBcIjB4Yzg3YjU2ZGRcIiA6IFwiMHgwZTg5MzQxY1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IHNjaGVtZSwgY29udGVudDogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvd25lciBvZiB0aGlzIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvd25lciA9ICh0aGlzLl9yZXNvbHZlZEFkZHJlc3MgfHwgKHlpZWxkIHRoaXMuZ2V0QWRkcmVzcygpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcHMgPSAobWF0Y2hbMl0gfHwgXCJcIikuc3BsaXQoXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZHIgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5hZGRyZXNzKGNvbXBzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbklkID0gaGV4WmVyb1BhZChCaWdOdW1iZXIuZnJvbShjb21wc1sxXSkudG9IZXhTdHJpbmcoKSwgMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhpcyBhY2NvdW50IG93bnMgdGhlIHRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtZSA9PT0gXCJlcmM3MjFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvd25lck9mKHVpbnQyNTYgdG9rZW5JZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5Pd25lciA9IHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmNhbGxBZGRyZXNzKHlpZWxkIHRoaXMucHJvdmlkZXIuY2FsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogYWRkciwgZGF0YTogaGV4Q29uY2F0KFtcIjB4NjM1MjIxMWVcIiwgdG9rZW5JZF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG93bmVyICE9PSB0b2tlbk93bmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm93bmVyXCIsIGNvbnRlbnQ6IHRva2VuT3duZXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaGVtZSA9PT0gXCJlcmMxMTU1XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmFsYW5jZU9mKGFkZHJlc3Mgb3duZXIsIHVpbnQyNTYgdG9rZW5JZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IEJpZ051bWJlci5mcm9tKHlpZWxkIHRoaXMucHJvdmlkZXIuY2FsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogYWRkciwgZGF0YTogaGV4Q29uY2F0KFtcIjB4MDBmZGQ1OGVcIiwgaGV4WmVyb1BhZChvd25lciwgMzIpLCB0b2tlbklkXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFsYW5jZS5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJiYWxhbmNlXCIsIGNvbnRlbnQ6IGJhbGFuY2UudG9TdHJpbmcoKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCB0aGUgdG9rZW4gY29udHJhY3QgZm9yIHRoZSBtZXRhZGF0YSBVUkxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoY29tcHNbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBoZXhDb25jYXQoW3NlbGVjdG9yLCB0b2tlbklkXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YVVybCA9IF9wYXJzZVN0cmluZyh5aWVsZCB0aGlzLnByb3ZpZGVyLmNhbGwodHgpLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGFVcmwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmwtYmFzZVwiLCBjb250ZW50OiBtZXRhZGF0YVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFUkMtMTE1NSBhbGxvd3MgYSBnZW5lcmljIHtpZH0gaW4gdGhlIFVSTFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWUgPT09IFwiZXJjMTE1NVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhVXJsID0gbWV0YWRhdGFVcmwucmVwbGFjZShcIntpZH1cIiwgdG9rZW5JZC5zdWJzdHJpbmcoMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhLXVybC1leHBhbmRlZFwiLCBjb250ZW50OiBtZXRhZGF0YVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIElQRlMgbWV0YWRhdGEgbGlua3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGFVcmwubWF0Y2goL15pcGZzOi9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YVVybCA9IGdldElwZnNMaW5rKG1ldGFkYXRhVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmxcIiwgY29udGVudDogbWV0YWRhdGFVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB0b2tlbiBtZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0geWllbGQgZmV0Y2hKc29uKG1ldGFkYXRhVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhXCIsIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQdWxsIHRoZSBpbWFnZSBVUkwgb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltYWdlVXJsID0gbWV0YWRhdGEuaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoaW1hZ2VVcmwpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VVcmwubWF0Y2goL14oaHR0cHM6XFwvXFwvfGRhdGE6KS9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIElQRlMgbGluayB0byBnYXRld2F5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlwZnMgPSBpbWFnZVVybC5tYXRjaChtYXRjaGVySXBmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcGZzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwidXJsLWlwZnNcIiwgY29udGVudDogaW1hZ2VVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlVXJsID0gZ2V0SXBmc0xpbmsoaW1hZ2VVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCBjb250ZW50OiBpbWFnZVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IGltYWdlVXJsIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDb250ZW50SGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIGtlY2NhazI1NihcImNvbnRlbnRoYXNoKClcIilcbiAgICAgICAgICAgIGNvbnN0IGhleEJ5dGVzID0geWllbGQgdGhpcy5fZmV0Y2hCeXRlcyhcIjB4YmMxYzU4ZDFcIik7XG4gICAgICAgICAgICAvLyBObyBjb250ZW50aGFzaFxuICAgICAgICAgICAgaWYgKGhleEJ5dGVzID09IG51bGwgfHwgaGV4Qnl0ZXMgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSVBGUyAoQ0lEOiAxLCBUeXBlOiBEQUctUEIpXG4gICAgICAgICAgICBjb25zdCBpcGZzID0gaGV4Qnl0ZXMubWF0Y2goL14weGUzMDEwMTcwKChbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXSopKSQvKTtcbiAgICAgICAgICAgIGlmIChpcGZzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQoaXBmc1szXSwgMTYpO1xuICAgICAgICAgICAgICAgIGlmIChpcGZzWzRdLmxlbmd0aCA9PT0gbGVuZ3RoICogMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpcGZzOi9cXC9cIiArIEJhc2U1OC5lbmNvZGUoXCIweFwiICsgaXBmc1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSVBOUyAoQ0lEOiAxLCBUeXBlOiBsaWJwMnAta2V5KVxuICAgICAgICAgICAgY29uc3QgaXBucyA9IGhleEJ5dGVzLm1hdGNoKC9eMHhlNTAxMDE3MigoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl0qKSkkLyk7XG4gICAgICAgICAgICBpZiAoaXBucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KGlwbnNbM10sIDE2KTtcbiAgICAgICAgICAgICAgICBpZiAoaXBuc1s0XS5sZW5ndGggPT09IGxlbmd0aCAqIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaXBuczovXFwvXCIgKyBCYXNlNTguZW5jb2RlKFwiMHhcIiArIGlwbnNbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN3YXJtIChDSUQ6IDEsIFR5cGU6IHN3YXJtLW1hbmlmZXN0OyBoYXNoL2xlbmd0aCBoYXJkLWNvZGVkIHRvIGtlY2NhazI1Ni8zMilcbiAgICAgICAgICAgIGNvbnN0IHN3YXJtID0gaGV4Qnl0ZXMubWF0Y2goL14weGU0MDEwMWZhMDExYjIwKFswLTlhLWZdKikkLyk7XG4gICAgICAgICAgICBpZiAoc3dhcm0pIHtcbiAgICAgICAgICAgICAgICBpZiAoc3dhcm1bMV0ubGVuZ3RoID09PSAoMzIgKiAyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJieno6L1xcL1wiICsgc3dhcm1bMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2t5bmV0ID0gaGV4Qnl0ZXMubWF0Y2goL14weDkwYjJjNjA1KFswLTlhLWZdKikkLyk7XG4gICAgICAgICAgICBpZiAoc2t5bmV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNreW5ldFsxXS5sZW5ndGggPT09ICgzNCAqIDIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVSTCBTYWZlIGJhc2U2NDsgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM0NjQ4I3NlY3Rpb24tNVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmxTYWZlID0geyBcIj1cIjogXCJcIiwgXCIrXCI6IFwiLVwiLCBcIi9cIjogXCJfXCIgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzaCA9IGJhc2U2NEVuY29kZShcIjB4XCIgKyBza3luZXRbMV0pLnJlcGxhY2UoL1s9K1xcL10vZywgKGEpID0+ICh1cmxTYWZlW2FdKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInNpYTovXFwvXCIgKyBoYXNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihgaW52YWxpZCBvciB1bnN1cHBvcnRlZCBjb250ZW50IGhhc2ggZGF0YWAsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldENvbnRlbnRIYXNoKClcIixcbiAgICAgICAgICAgICAgICBkYXRhOiBoZXhCeXRlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRUZXh0KGtleSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gVGhlIGtleSBlbmNvZGVkIGFzIHBhcmFtZXRlciB0byBmZXRjaEJ5dGVzXG4gICAgICAgICAgICBsZXQga2V5Qnl0ZXMgPSB0b1V0ZjhCeXRlcyhrZXkpO1xuICAgICAgICAgICAgLy8gVGhlIG5vZGVoYXNoIGNvbnN1bWVzIHRoZSBmaXJzdCBzbG90LCBzbyB0aGUgc3RyaW5nIHBvaW50ZXIgdGFyZ2V0c1xuICAgICAgICAgICAgLy8gb2Zmc2V0IDY0LCB3aXRoIHRoZSBsZW5ndGggYXQgb2Zmc2V0IDY0IGFuZCBkYXRhIHN0YXJ0aW5nIGF0IG9mZnNldCA5NlxuICAgICAgICAgICAga2V5Qnl0ZXMgPSBjb25jYXQoW2J5dGVzMzJpZnkoNjQpLCBieXRlczMyaWZ5KGtleUJ5dGVzLmxlbmd0aCksIGtleUJ5dGVzXSk7XG4gICAgICAgICAgICAvLyBQYWQgdG8gd29yZC1zaXplICgzMiBieXRlcylcbiAgICAgICAgICAgIGlmICgoa2V5Qnl0ZXMubGVuZ3RoICUgMzIpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAga2V5Qnl0ZXMgPSBjb25jYXQoW2tleUJ5dGVzLCBoZXhaZXJvUGFkKFwiMHhcIiwgMzIgLSAoa2V5Lmxlbmd0aCAlIDMyKSldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhleEJ5dGVzID0geWllbGQgdGhpcy5fZmV0Y2hCeXRlcyhcIjB4NTlkMWQ0M2NcIiwgaGV4bGlmeShrZXlCeXRlcykpO1xuICAgICAgICAgICAgaWYgKGhleEJ5dGVzID09IG51bGwgfHwgaGV4Qnl0ZXMgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvVXRmOFN0cmluZyhoZXhCeXRlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmxldCBkZWZhdWx0Rm9ybWF0dGVyID0gbnVsbDtcbmxldCBuZXh0UG9sbElkID0gMTtcbmV4cG9ydCBjbGFzcyBCYXNlUHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogIHJlYWR5XG4gICAgICpcbiAgICAgKiAgQSBQcm9taXNlPE5ldHdvcms+IHRoYXQgcmVzb2x2ZXMgb25seSBvbmNlIHRoZSBwcm92aWRlciBpcyByZWFkeS5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyB0aGF0IGNhbGwgdGhlIHN1cGVyIHdpdGggYSBuZXR3b3JrIHdpdGhvdXQgYSBjaGFpbklkXG4gICAgICogIE1VU1Qgc2V0IHRoaXMuIFN0YW5kYXJkIG5hbWVkIG5ldHdvcmtzIGhhdmUgYSBrbm93biBjaGFpbklkLlxuICAgICAqXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmV0d29yaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBFdmVudHMgYmVpbmcgbGlzdGVuZWQgdG9cbiAgICAgICAgdGhpcy5fZXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuX2VtaXR0ZWQgPSB7IGJsb2NrOiAtMiB9O1xuICAgICAgICB0aGlzLmRpc2FibGVDY2lwUmVhZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZvcm1hdHRlciA9IG5ldy50YXJnZXQuZ2V0Rm9ybWF0dGVyKCk7XG4gICAgICAgIC8vIElmIG5ldHdvcmsgaXMgYW55LCB0aGlzIFByb3ZpZGVyIGFsbG93cyB0aGUgdW5kZXJseWluZ1xuICAgICAgICAvLyBuZXR3b3JrIHRvIGNoYW5nZSBkeW5hbWljYWxseSwgYW5kIHdlIGF1dG8tZGV0ZWN0IHRoZVxuICAgICAgICAvLyBjdXJyZW50IG5ldHdvcmtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhbnlOZXR3b3JrXCIsIChuZXR3b3JrID09PSBcImFueVwiKSk7XG4gICAgICAgIGlmICh0aGlzLmFueU5ldHdvcmspIHtcbiAgICAgICAgICAgIG5ldHdvcmsgPSB0aGlzLmRldGVjdE5ldHdvcmsoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV0d29yayBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX25ldHdvcmtQcm9taXNlID0gbmV0d29yaztcbiAgICAgICAgICAgIC8vIFNxdWFzaCBhbnkgXCJ1bmhhbmRsZWQgcHJvbWlzZVwiIGVycm9yczsgdGhhdCBkbyBub3QgbmVlZCB0byBiZSBoYW5kbGVkXG4gICAgICAgICAgICBuZXR3b3JrLmNhdGNoKChlcnJvcikgPT4geyB9KTtcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgaW5pdGlhbCBuZXR3b3JrIHNldHRpbmcgKGFzeW5jKVxuICAgICAgICAgICAgdGhpcy5fcmVhZHkoKS5jYXRjaCgoZXJyb3IpID0+IHsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBrbm93bk5ldHdvcmsgPSBnZXRTdGF0aWMobmV3LnRhcmdldCwgXCJnZXROZXR3b3JrXCIpKG5ldHdvcmspO1xuICAgICAgICAgICAgaWYgKGtub3duTmV0d29yaykge1xuICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX25ldHdvcmtcIiwga25vd25OZXR3b3JrKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIGtub3duTmV0d29yaywgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyID0gLTEwMjQ7XG4gICAgICAgIHRoaXMuX2xhc3RCbG9ja051bWJlciA9IC0yO1xuICAgICAgICB0aGlzLl9tYXhGaWx0ZXJCbG9ja1JhbmdlID0gMTA7XG4gICAgICAgIHRoaXMuX3BvbGxpbmdJbnRlcnZhbCA9IDQwMDA7XG4gICAgICAgIHRoaXMuX2Zhc3RRdWVyeURhdGUgPSAwO1xuICAgIH1cbiAgICBfcmVhZHkoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ldHdvcmsgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9uZXR3b3JrUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29yayA9IHlpZWxkIHRoaXMuX25ldHdvcmtQcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRyeSB0aGUgUHJvdmlkZXIncyBuZXR3b3JrIGRldGVjdGlvbiAodGhpcyBNVVNUIHRocm93IGlmIGl0IGNhbm5vdClcbiAgICAgICAgICAgICAgICBpZiAobmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcmsgPSB5aWVsZCB0aGlzLmRldGVjdE5ldHdvcmsoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuOyBldmVyeSBQcm92aWRlciBzdWItY2xhc3Mgc2hvdWxkIGhhdmVcbiAgICAgICAgICAgICAgICAvLyBzdWdnZXN0ZWQgYSBuZXR3b3JrIGJ5IGhlcmUgKG9yIGhhdmUgdGhyb3duKS5cbiAgICAgICAgICAgICAgICBpZiAoIW5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJubyBuZXR3b3JrIGRldGVjdGVkXCIsIExvZ2dlci5lcnJvcnMuVU5LTk9XTl9FUlJPUiwge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQb3NzaWJsZSB0aGlzIGNhbGwgc3RhY2tlZCBzbyBkbyBub3QgY2FsbCBkZWZpbmVSZWFkT25seSBhZ2FpblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9uZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYW55TmV0d29yaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmV0d29yayA9IG5ldHdvcms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9uZXR3b3JrXCIsIG5ldHdvcmspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgbmV0d29yaywgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25ldHdvcms7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUaGlzIHdpbGwgYWx3YXlzIHJldHVybiB0aGUgbW9zdCByZWNlbnRseSBlc3RhYmxpc2hlZCBuZXR3b3JrLlxuICAgIC8vIEZvciBcImFueVwiLCB0aGlzIGNhbiBjaGFuZ2UgKGEgXCJuZXR3b3JrXCIgZXZlbnQgaXMgZW1pdHRlZCBiZWZvcmVcbiAgICAvLyBhbnkgY2hhbmdlIGlzIHJlZmxlY3RlZCk7IG90aGVyd2lzZSB0aGlzIGNhbm5vdCBjaGFuZ2VcbiAgICBnZXQgcmVhZHkoKSB7XG4gICAgICAgIHJldHVybiBwb2xsKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkeSgpLnRoZW4oKG5ldHdvcmspID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBuZXR3b3JrIGlzbid0IHJ1bm5pbmcgeWV0LCB3ZSB3aWxsIHdhaXRcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SICYmIGVycm9yLmV2ZW50ID09PSBcIm5vTmV0d29ya1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBAVE9ETzogUmVtb3ZlIHRoaXMgYW5kIGp1c3QgY3JlYXRlIGEgc2luZ2xldG9uIGZvcm1hdHRlclxuICAgIHN0YXRpYyBnZXRGb3JtYXR0ZXIoKSB7XG4gICAgICAgIGlmIChkZWZhdWx0Rm9ybWF0dGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlZmF1bHRGb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRGb3JtYXR0ZXI7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBSZW1vdmUgdGhpcyBhbmQganVzdCB1c2UgZ2V0TmV0d29ya1xuICAgIHN0YXRpYyBnZXROZXR3b3JrKG5ldHdvcmspIHtcbiAgICAgICAgcmV0dXJuIGdldE5ldHdvcmsoKG5ldHdvcmsgPT0gbnVsbCkgPyBcImhvbWVzdGVhZFwiIDogbmV0d29yayk7XG4gICAgfVxuICAgIGNjaXBSZWFkRmV0Y2godHgsIGNhbGxkYXRhLCB1cmxzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlQ2NpcFJlYWQgfHwgdXJscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlbmRlciA9IHR4LnRvLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gY2FsbGRhdGEudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXJscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IHVybHNbaV07XG4gICAgICAgICAgICAgICAgLy8gVVJMIGV4cGFuc2lvblxuICAgICAgICAgICAgICAgIGNvbnN0IGhyZWYgPSB1cmwucmVwbGFjZShcIntzZW5kZXJ9XCIsIHNlbmRlcikucmVwbGFjZShcIntkYXRhfVwiLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAvLyBJZiBubyB7ZGF0YX0gaXMgcHJlc2VudCwgdXNlIFBPU1Q7IG90aGVyd2lzZSBHRVRcbiAgICAgICAgICAgICAgICBjb25zdCBqc29uID0gKHVybC5pbmRleE9mKFwie2RhdGF9XCIpID49IDApID8gbnVsbCA6IEpTT04uc3RyaW5naWZ5KHsgZGF0YSwgc2VuZGVyIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIGZldGNoSnNvbih7IHVybDogaHJlZiwgZXJyb3JQYXNzVGhyb3VnaDogdHJ1ZSB9LCBqc29uLCAodmFsdWUsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSAocmVzdWx0Lm1lc3NhZ2UgfHwgXCJ1bmtub3duIGVycm9yXCIpO1xuICAgICAgICAgICAgICAgIC8vIDR4eCBpbmRpY2F0ZXMgdGhlIHJlc3VsdCBpcyBub3QgcHJlc2VudDsgc3RvcFxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID49IDQwMCAmJiByZXN1bHQuc3RhdHVzIDwgNTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihgcmVzcG9uc2Ugbm90IGZvdW5kIGR1cmluZyBDQ0lQIGZldGNoOiAke2Vycm9yTWVzc2FnZX1gLCBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwgeyB1cmwsIGVycm9yTWVzc2FnZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gNXh4IGluZGljYXRlcyBzZXJ2ZXIgaXNzdWU7IHRyeSB0aGUgbmV4dCB1cmxcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2VzLnB1c2goZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihgZXJyb3IgZW5jb3VudGVyZWQgZHVyaW5nIENDSVAgZmV0Y2g6ICR7ZXJyb3JNZXNzYWdlcy5tYXAoKG0pID0+IEpTT04uc3RyaW5naWZ5KG0pKS5qb2luKFwiLCBcIil9YCwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICB1cmxzLCBlcnJvck1lc3NhZ2VzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEZldGNoZXMgdGhlIGJsb2NrTnVtYmVyLCBidXQgd2lsbCByZXVzZSBhbnkgcmVzdWx0IHRoYXQgaXMgbGVzc1xuICAgIC8vIHRoYW4gbWF4QWdlIG9sZCBvciBoYXMgYmVlbiByZXF1ZXN0ZWQgc2luY2UgdGhlIGxhc3QgcmVxdWVzdFxuICAgIF9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKG1heEFnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5fcmVhZHkoKTtcbiAgICAgICAgICAgIC8vIEFsbG93aW5nIHN0YWxlIGRhdGEgdXAgdG8gbWF4QWdlIG9sZFxuICAgICAgICAgICAgaWYgKG1heEFnZSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXaGlsZSB0aGVyZSBhcmUgcGVuZGluZyBpbnRlcm5hbCBibG9jayByZXF1ZXN0cy4uLlxuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLlwicmVtZW1iZXJcIiB3aGljaCBmZXRjaCB3ZSBzdGFydGVkIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW50ZXJuYWxCbG9ja051bWJlciA9IHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgcmVzdWx0IGlzIG5vdCB0b28gc3RhbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIGludGVybmFsQmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGdldFRpbWUoKSAtIHJlc3VsdC5yZXNwVGltZSkgPD0gbWF4QWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5ibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvbyBvbGQ7IGZldGNoIGEgbmV3IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmZXRjaCByZWplY3RlZDsgaWYgd2UgYXJlIHRoZSBmaXJzdCB0byBnZXQgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWplY3Rpb24sIGRyb3AgdGhyb3VnaCBzbyB3ZSByZXBsYWNlIGl0IHdpdGggYSBuZXdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZldGNoOyBhbGwgb3RoZXJzIGJsb2NrZWQgd2lsbCB0aGVuIGdldCB0aGF0IGZldGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCB3b24ndCBtYXRjaCB0aGUgb25lIHRoZXkgXCJyZW1lbWJlcmVkXCIgYW5kIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID09PSBpbnRlcm5hbEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXFUaW1lID0gZ2V0VGltZSgpO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyID0gcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0aGlzLnBlcmZvcm0oXCJnZXRCbG9ja051bWJlclwiLCB7fSksXG4gICAgICAgICAgICAgICAgbmV0d29ya0Vycm9yOiB0aGlzLmdldE5ldHdvcmsoKS50aGVuKChuZXR3b3JrKSA9PiAobnVsbCksIChlcnJvcikgPT4gKGVycm9yKSlcbiAgICAgICAgICAgIH0pLnRoZW4oKHsgYmxvY2tOdW1iZXIsIG5ldHdvcmtFcnJvciB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5ldHdvcmtFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBVbnJlbWVtYmVyIHRoaXMgYmFkIGludGVybmFsIGJsb2NrIG51bWJlclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9PT0gY2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXR3b3JrRXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BUaW1lID0gZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gQmlnTnVtYmVyLmZyb20oYmxvY2tOdW1iZXIpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyIDwgdGhpcy5fbWF4SW50ZXJuYWxCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IHRoaXMuX21heEludGVybmFsQmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX21heEludGVybmFsQmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRGYXN0QmxvY2tOdW1iZXIoYmxvY2tOdW1iZXIpOyAvLyBAVE9ETzogU3RpbGwgbmVlZCB0aGlzP1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGJsb2NrTnVtYmVyLCByZXFUaW1lLCByZXNwVGltZSB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID0gY2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgLy8gU3dhbGxvdyB1bmhhbmRsZWQgZXhjZXB0aW9uczsgaWYgbmVlZGVkIHRoZXkgYXJlIGhhbmRsZWQgZWxzZSB3aGVyZVxuICAgICAgICAgICAgY2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIERvbid0IG51bGwgdGhlIGRlYWQgKHJlamVjdGVkKSBmZXRjaCwgaWYgaXQgaGFzIGFscmVhZHkgYmVlbiB1cGRhdGVkXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIgPT09IGNoZWNrSW50ZXJuYWxCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAoeWllbGQgY2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyKS5ibG9ja051bWJlcjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBvbGwoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwb2xsSWQgPSBuZXh0UG9sbElkKys7XG4gICAgICAgICAgICAvLyBUcmFjayBhbGwgcnVubmluZyBwcm9taXNlcywgc28gd2UgY2FuIHRyaWdnZXIgYSBwb3N0LXBvbGwgb25jZSB0aGV5IGFyZSBjb21wbGV0ZVxuICAgICAgICAgICAgY29uc3QgcnVubmVycyA9IFtdO1xuICAgICAgICAgICAgbGV0IGJsb2NrTnVtYmVyID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIHRoaXMucG9sbGluZ0ludGVydmFsIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2V0RmFzdEJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgIC8vIEVtaXQgYSBwb2xsIGV2ZW50IGFmdGVyIHdlIGhhdmUgdGhlIGxhdGVzdCAoZmFzdCkgYmxvY2sgbnVtYmVyXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJwb2xsXCIsIHBvbGxJZCwgYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGJsb2NrIGhhcyBub3QgY2hhbmdlZCwgbWVoLlxuICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09PSB0aGlzLl9sYXN0QmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkaWRQb2xsXCIsIHBvbGxJZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmlyc3QgcG9sbGluZyBjeWNsZSwgdHJpZ2dlciBhIFwiYmxvY2tcIiBldmVudHNcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVkLmJsb2NrID09PSAtMikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWQuYmxvY2sgPSBibG9ja051bWJlciAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoKHRoaXMuX2VtaXR0ZWQuYmxvY2spIC0gYmxvY2tOdW1iZXIpID4gMTAwMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBuZXR3b3JrIGJsb2NrIHNrZXcgZGV0ZWN0ZWQ7IHNraXBwaW5nIGJsb2NrIGV2ZW50cyAoZW1pdHRlZD0ke3RoaXMuX2VtaXR0ZWQuYmxvY2t9IGJsb2NrTnVtYmVyJHtibG9ja051bWJlcn0pYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgbG9nZ2VyLm1ha2VFcnJvcihcIm5ldHdvcmsgYmxvY2sgc2tldyBkZXRlY3RlZFwiLCBMb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXI6IGJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBldmVudDogXCJibG9ja1NrZXdcIixcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNCbG9ja051bWJlcjogdGhpcy5fZW1pdHRlZC5ibG9ja1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJibG9ja1wiLCBibG9ja051bWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RpZnkgYWxsIGxpc3RlbmVyIGZvciBlYWNoIGJsb2NrIHRoYXQgaGFzIHBhc3NlZFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9lbWl0dGVkLmJsb2NrICsgMTsgaSA8PSBibG9ja051bWJlcjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImJsb2NrXCIsIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBlbWl0dGVkIGJsb2NrIHdhcyB1cGRhdGVkLCBjaGVjayBmb3Igb2Jzb2xldGUgZXZlbnRzXG4gICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlZC5ibG9jayAhPT0gYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVkLmJsb2NrID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5fZW1pdHRlZCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBibG9jayBldmVudCBkb2VzIG5vdCBleHBpcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJibG9ja1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGJsb2NrIHdlIHdlcmUgYXQgd2hlbiB3ZSBlbWl0dGVkIHRoaXMgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRCbG9ja051bWJlciA9IHRoaXMuX2VtaXR0ZWRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2Fubm90IGdhcmJhZ2UgY29sbGVjdCBwZW5kaW5nIHRyYW5zYWN0aW9ucyBvciBibG9ja3MgaGVyZVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGV5IHNob3VsZCBiZSBnYXJiYWdlIGNvbGxlY3RlZCBieSB0aGUgUHJvdmlkZXIgd2hlbiBzZXR0aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIFwicGVuZGluZ1wiIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRCbG9ja051bWJlciA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBFdmljdCBhbnkgdHJhbnNhY3Rpb24gaGFzaGVzIG9yIGJsb2NrIGhhc2hlcyBvdmVyIDEyIGJsb2Nrc1xuICAgICAgICAgICAgICAgICAgICAvLyBvbGQsIHNpbmNlIHRoZXkgc2hvdWxkIG5vdCByZXR1cm4gbnVsbCBhbnl3YXlzXG4gICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciAtIGV2ZW50QmxvY2tOdW1iZXIgPiAxMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2VtaXR0ZWRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmlyc3QgcG9sbGluZyBjeWNsZVxuICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3RCbG9ja051bWJlciA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlciAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaW5kIGFsbCB0cmFuc2FjdGlvbiBoYXNoZXMgd2UgYXJlIHdhaXRpbmcgb25cbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidHhcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzaCA9IGV2ZW50Lmhhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcnVubmVyID0gdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCkudGhlbigocmVjZWlwdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVjZWlwdCB8fCByZWNlaXB0LmJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWRbXCJ0OlwiICsgaGFzaF0gPSByZWNlaXB0LmJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChoYXNoLCByZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4geyB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmVycy5wdXNoKHJ1bm5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmlsdGVyXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgYWxsb3cgYSBzaW5nbGUgZ2V0TG9ncyB0byBiZSBpbi1mbGlnaHQgYXQgYSB0aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50Ll9pbmZsaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Ll9pbmZsaWdodCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgZmlsdGVyIGZvciB0aGlzIGV2ZW50LCBzbyB3ZSB3YW50IHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzdHJpY3QgZXZlbnRzIHRvIGV2ZW50cyB0aGF0IGhhcHBlbmVkIG5vIGVhcmxpZXIgdGhhbiBub3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuX2xhc3RCbG9ja051bWJlciA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuX2xhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlsdGVyIGZyb20gdGhlIGxhc3QgKmtub3duKiBldmVudDsgZHVlIHRvIGxvYWQtYmFsYW5jaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHNvbWUgbm9kZXMgcmV0dXJuaW5nIHVwZGF0ZWQgYmxvY2sgbnVtYmVycyBiZWZvcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmRleGluZyBldmVudHMsIGEgbG9ncyByZXN1bHQgd2l0aCAwIGVudHJpZXMgY2Fubm90IGJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1c3RlZCBhbmQgd2UgbXVzdCByZXRyeSBhIHJhbmdlIHdoaWNoIGluY2x1ZGVzIGl0IGFnYWluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyID0gZXZlbnQuZmlsdGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlci5mcm9tQmxvY2sgPSBldmVudC5fbGFzdEJsb2NrTnVtYmVyICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIudG9CbG9jayA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgZml0bGVyIHJhbmdlcyBmcm9tIGdyb3dpbmcgdG9vIHdpbGQsIHNpbmNlIGl0IGlzIHF1aXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGlrZWx5IHRoZXJlIGp1c3QgaGF2ZW4ndCBiZWVuIGFueSBldmVudHMgdG8gbW92ZSB0aGUgbGFzdEJsb2NrTnVtYmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1pbkZyb21CbG9jayA9IGZpbHRlci50b0Jsb2NrIC0gdGhpcy5fbWF4RmlsdGVyQmxvY2tSYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluRnJvbUJsb2NrID4gZmlsdGVyLmZyb21CbG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIuZnJvbUJsb2NrID0gbWluRnJvbUJsb2NrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyLmZyb21CbG9jayA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyLmZyb21CbG9jayA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ1bm5lciA9IHRoaXMuZ2V0TG9ncyhmaWx0ZXIpLnRoZW4oKGxvZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgdGhlIG5leHQgZ2V0TG9nc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5faW5mbGlnaHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9ncy5mb3JFYWNoKChsb2cpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgd2hlbiB3ZSBnZXQgYW4gZXZlbnQgZm9yIGEgZ2l2ZW4gYmxvY2sgbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW4gd2UgdHJ1c3QgdGhlIGV2ZW50cyBhcmUgaW5kZXhlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZy5ibG9ja051bWJlciA+IGV2ZW50Ll9sYXN0QmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5fbGFzdEJsb2NrTnVtYmVyID0gbG9nLmJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHN0YWxsIHJlcXVlc3RzIHRvIGZldGNoIGJsb2NrcyBhbmQgdHhzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVkW1wiYjpcIiArIGxvZy5ibG9ja0hhc2hdID0gbG9nLmJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZFtcInQ6XCIgKyBsb2cudHJhbnNhY3Rpb25IYXNoXSA9IGxvZy5ibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChmaWx0ZXIsIGxvZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IGFub3RoZXIgZ2V0TG9ncyAodGhlIHJhbmdlIHdhcyBub3QgdXBkYXRlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuX2luZmxpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVubmVycy5wdXNoKHJ1bm5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAvLyBPbmNlIGFsbCBldmVudHMgZm9yIHRoaXMgbG9vcCBoYXZlIGJlZW4gcHJvY2Vzc2VkLCBlbWl0IFwiZGlkUG9sbFwiXG4gICAgICAgICAgICBQcm9taXNlLmFsbChydW5uZXJzKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkaWRQb2xsXCIsIHBvbGxJZCk7XG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHsgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpOyB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIERlcHJlY2F0ZWQ7IGRvIG5vdCB1c2UgdGhpc1xuICAgIHJlc2V0RXZlbnRzQmxvY2soYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXIgLSAxO1xuICAgICAgICBpZiAodGhpcy5wb2xsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ldHdvcms7XG4gICAgfVxuICAgIC8vIFRoaXMgbWV0aG9kIHNob3VsZCBxdWVyeSB0aGUgbmV0d29yayBpZiB0aGUgdW5kZXJseWluZyBuZXR3b3JrXG4gICAgLy8gY2FuIGNoYW5nZSwgc3VjaCBhcyB3aGVuIGNvbm5lY3RlZCB0byBhIEpTT04tUlBDIGJhY2tlbmRcbiAgICBkZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwicHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBuZXR3b3JrIGRldGVjdGlvblwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJwcm92aWRlci5kZXRlY3ROZXR3b3JrXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0TmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSB5aWVsZCB0aGlzLl9yZWFkeSgpO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGFyZSBzdGlsbCBjb25uZWN0ZWQgdG8gdGhlIHNhbWUgbmV0d29yazsgdGhpcyBpc1xuICAgICAgICAgICAgLy8gb25seSBhbiBleHRlcm5hbCBjYWxsIGZvciBiYWNrZW5kcyB3aGljaCBjYW4gaGF2ZSB0aGUgdW5kZXJseWluZ1xuICAgICAgICAgICAgLy8gbmV0d29yayBjaGFuZ2Ugc3BvbnRhbmVvdXNseVxuICAgICAgICAgICAgY29uc3QgY3VycmVudE5ldHdvcmsgPSB5aWVsZCB0aGlzLmRldGVjdE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGlmIChuZXR3b3JrLmNoYWluSWQgIT09IGN1cnJlbnROZXR3b3JrLmNoYWluSWQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgYWxsb3dpbmcgbmV0d29yayBjaGFuZ2VzLCB0aGluZ3MgY2FuIGdldCBjb21wbGV4IGZhc3Q7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZyBpZiB5b3UgdXNlIFwiYW55XCJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbnlOZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25ldHdvcmsgPSBjdXJyZW50TmV0d29yaztcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgYWxsIGludGVybmFsIGJsb2NrIG51bWJlciBndWFyZHMgYW5kIGNhY2hlc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSAtMjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmFzdEJsb2NrTnVtYmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmFzdEJsb2NrTnVtYmVyUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Zhc3RRdWVyeURhdGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVkLmJsb2NrID0gLTI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21heEludGVybmFsQmxvY2tOdW1iZXIgPSAtMTAyNDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBcIm5ldHdvcmtcIiBldmVudCBNVVNUIGhhcHBlbiBiZWZvcmUgdGhpcyBtZXRob2QgcmVzb2x2ZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gYW55IGV2ZW50cyBoYXZlIGEgY2hhbmNlIHRvIHVucmVnaXN0ZXIsIHNvIHdlIHN0YWxsIGFuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZGl0aW9uYWwgZXZlbnQgbG9vcCBiZWZvcmUgcmV0dXJuaW5nIGZyb20gL3RoaXMvIGNhbGxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBjdXJyZW50TmV0d29yaywgbmV0d29yayk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHN0YWxsKDApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbmV0d29yaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBsb2dnZXIubWFrZUVycm9yKFwidW5kZXJseWluZyBuZXR3b3JrIGNoYW5nZWRcIiwgTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImNoYW5nZWRcIixcbiAgICAgICAgICAgICAgICAgICAgbmV0d29yazogbmV0d29yayxcbiAgICAgICAgICAgICAgICAgICAgZGV0ZWN0ZWROZXR3b3JrOiBjdXJyZW50TmV0d29ya1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXR3b3JrO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGJsb2NrTnVtYmVyKCkge1xuICAgICAgICB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIHRoaXMucG9sbGluZ0ludGVydmFsIC8gMikudGhlbigoYmxvY2tOdW1iZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3NldEZhc3RCbG9ja051bWJlcihibG9ja051bWJlcik7XG4gICAgICAgIH0sIChlcnJvcikgPT4geyB9KTtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9mYXN0QmxvY2tOdW1iZXIgIT0gbnVsbCkgPyB0aGlzLl9mYXN0QmxvY2tOdW1iZXIgOiAtMTtcbiAgICB9XG4gICAgZ2V0IHBvbGxpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fcG9sbGVyICE9IG51bGwpO1xuICAgIH1cbiAgICBzZXQgcG9sbGluZyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgIXRoaXMuX3BvbGxlcikge1xuICAgICAgICAgICAgdGhpcy5fcG9sbGVyID0gc2V0SW50ZXJ2YWwoKCkgPT4geyB0aGlzLnBvbGwoKTsgfSwgdGhpcy5wb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9ib290c3RyYXBQb2xsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYm9vdHN0cmFwUG9sbCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgYmxvY2sgYWRkaXRpb25hbCBwb2xscyB1bnRpbCB0aGUgcG9sbGluZyBpbnRlcnZhbFxuICAgICAgICAgICAgICAgICAgICAvLyBpcyBkb25lLCB0byBwcmV2ZW50IG92ZXJ3aGVsbWluZyB0aGUgcG9sbCBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ib290c3RyYXBQb2xsID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBwb2xsaW5nIHdhcyBkaXNhYmxlZCwgc29tZXRoaW5nIG1heSByZXF1aXJlIGEgcG9rZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luY2Ugc3RhcnRpbmcgdGhlIGJvb3RzdHJhcCBwb2xsIGFuZCBpdCB3YXMgZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcG9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDbGVhciBvdXQgdGhlIGJvb3RzdHJhcCBzbyB3ZSBjYW4gZG8gYW5vdGhlclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYm9vdHN0cmFwUG9sbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdmFsdWUgJiYgdGhpcy5fcG9sbGVyKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX3BvbGxlcik7XG4gICAgICAgICAgICB0aGlzLl9wb2xsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBwb2xsaW5nSW50ZXJ2YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2xsaW5nSW50ZXJ2YWw7XG4gICAgfVxuICAgIHNldCBwb2xsaW5nSW50ZXJ2YWwodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcIm51bWJlclwiIHx8IHZhbHVlIDw9IDAgfHwgcGFyc2VJbnQoU3RyaW5nKHZhbHVlKSkgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9sbGluZyBpbnRlcnZhbFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3BvbGxlcikge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9wb2xsZXIpO1xuICAgICAgICAgICAgdGhpcy5fcG9sbGVyID0gc2V0SW50ZXJ2YWwoKCkgPT4geyB0aGlzLnBvbGwoKTsgfSwgdGhpcy5fcG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0RmFzdEJsb2NrTnVtYmVyKCkge1xuICAgICAgICBjb25zdCBub3cgPSBnZXRUaW1lKCk7XG4gICAgICAgIC8vIFN0YWxlIGJsb2NrIG51bWJlciwgcmVxdWVzdCBhIG5ld2VyIHZhbHVlXG4gICAgICAgIGlmICgobm93IC0gdGhpcy5fZmFzdFF1ZXJ5RGF0ZSkgPiAyICogdGhpcy5fcG9sbGluZ0ludGVydmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9mYXN0UXVlcnlEYXRlID0gbm93O1xuICAgICAgICAgICAgdGhpcy5fZmFzdEJsb2NrTnVtYmVyUHJvbWlzZSA9IHRoaXMuZ2V0QmxvY2tOdW1iZXIoKS50aGVuKChibG9ja051bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9mYXN0QmxvY2tOdW1iZXIgPT0gbnVsbCB8fCBibG9ja051bWJlciA+IHRoaXMuX2Zhc3RCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Zhc3RCbG9ja051bWJlcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9mYXN0QmxvY2tOdW1iZXJQcm9taXNlO1xuICAgIH1cbiAgICBfc2V0RmFzdEJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIC8vIE9sZGVyIGJsb2NrLCBtYXliZSBhIHN0YWxlIHJlcXVlc3RcbiAgICAgICAgaWYgKHRoaXMuX2Zhc3RCbG9ja051bWJlciAhPSBudWxsICYmIGJsb2NrTnVtYmVyIDwgdGhpcy5fZmFzdEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSB0aW1lIHdlIHVwZGF0ZWQgdGhlIGJsb2NrbnVtYmVyXG4gICAgICAgIHRoaXMuX2Zhc3RRdWVyeURhdGUgPSBnZXRUaW1lKCk7XG4gICAgICAgIC8vIE5ld2VyIGJsb2NrIG51bWJlciwgdXNlICBpdFxuICAgICAgICBpZiAodGhpcy5fZmFzdEJsb2NrTnVtYmVyID09IG51bGwgfHwgYmxvY2tOdW1iZXIgPiB0aGlzLl9mYXN0QmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgdGhpcy5fZmFzdEJsb2NrTnVtYmVyUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShibG9ja051bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2FpdEZvclRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCwgY29uZmlybWF0aW9ucywgdGltZW91dCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dhaXRGb3JUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gsIChjb25maXJtYXRpb25zID09IG51bGwpID8gMSA6IGNvbmZpcm1hdGlvbnMsIHRpbWVvdXQgfHwgMCwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfd2FpdEZvclRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCwgY29uZmlybWF0aW9ucywgdGltZW91dCwgcmVwbGFjZWFibGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSB5aWVsZCB0aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICAgICAgLy8gUmVjZWlwdCBpcyBhbHJlYWR5IGdvb2RcbiAgICAgICAgICAgIGlmICgocmVjZWlwdCA/IHJlY2VpcHQuY29uZmlybWF0aW9ucyA6IDApID49IGNvbmZpcm1hdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjZWlwdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBvbGwgdW50aWwgdGhlIHJlY2VpcHQgaXMgZ29vZC4uLlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxGdW5jcyA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxyZWFkeURvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsRnVuY3MuZm9yRWFjaCgoZnVuYykgPT4geyBmdW5jKCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBtaW5lZEhhbmRsZXIgPSAocmVjZWlwdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWlwdC5jb25maXJtYXRpb25zIDwgY29uZmlybWF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHJlYWR5RG9uZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZWNlaXB0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMub24odHJhbnNhY3Rpb25IYXNoLCBtaW5lZEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIGNhbmNlbEZ1bmNzLnB1c2goKCkgPT4geyB0aGlzLnJlbW92ZUxpc3RlbmVyKHRyYW5zYWN0aW9uSGFzaCwgbWluZWRIYW5kbGVyKTsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXN0QmxvY2tOdW1iZXIgPSByZXBsYWNlYWJsZS5zdGFydEJsb2NrO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2Nhbm5lZEJsb2NrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZUhhbmRsZXIgPSAoYmxvY2tOdW1iZXIpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2FpdCAxIHNlY29uZDsgdGhpcyBpcyBvbmx5IHVzZWQgaW4gdGhlIGNhc2Ugb2YgYSBmYXVsdCwgc29cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHdpbGwgdHJhZGUgb2ZmIGEgbGl0dGxlIGJpdCBvZiBsYXRlbmN5IGZvciBtb3JlIGNvbnNpc3RlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc3VsdHMgYW5kIGZld2VyIEpTT04tUlBDIGNhbGxzXG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBzdGFsbCgxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0VHJhbnNhY3Rpb25Db3VudChyZXBsYWNlYWJsZS5mcm9tKS50aGVuKChub25jZSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vbmNlIDw9IHJlcGxhY2VhYmxlLm5vbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlIHRyYW5zYWN0aW9uIHdhcyBtaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtaW5lZCA9IHlpZWxkIHRoaXMuZ2V0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW5lZCAmJiBtaW5lZC5ibG9ja051bWJlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IHRpbWUgc2Nhbm5pbmcuIFdlIHN0YXJ0IGEgbGl0dGxlIGVhcmxpZXIgZm9yIHNvbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lnZ2xlIHJvb20gaGVyZSB0byBoYW5kbGUgdGhlIGV2ZW50dWFsbHkgY29uc2lzdGVudCBuYXR1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgYmxvY2tjaGFpbiAoZS5nLiB0aGUgZ2V0VHJhbnNhY3Rpb25Db3VudCB3YXMgZm9yIGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlmZmVyZW50IGJsb2NrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Nhbm5lZEJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYW5uZWRCbG9jayA9IGxhc3RCbG9ja051bWJlciAtIDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Nhbm5lZEJsb2NrIDwgcmVwbGFjZWFibGUuc3RhcnRCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYW5uZWRCbG9jayA9IHJlcGxhY2VhYmxlLnN0YXJ0QmxvY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHNjYW5uZWRCbG9jayA8PSBibG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9jayA9IHlpZWxkIHRoaXMuZ2V0QmxvY2tXaXRoVHJhbnNhY3Rpb25zKHNjYW5uZWRCbG9jayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0aSA9IDA7IHRpIDwgYmxvY2sudHJhbnNhY3Rpb25zLmxlbmd0aDsgdGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gYmxvY2sudHJhbnNhY3Rpb25zW3RpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWNjZXNzZnVsbHkgbWluZWQhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lmhhc2ggPT09IHRyYW5zYWN0aW9uSGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoZXMgb3VyIHRyYW5zYWN0aW9uIGZyb20gYW5kIG5vbmNlOyBpdHMgYSByZXBsYWNlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5mcm9tID09PSByZXBsYWNlYWJsZS5mcm9tICYmIHR4Lm5vbmNlID09PSByZXBsYWNlYWJsZS5ub25jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcmVjZWlwdCBvZiB0aGUgcmVwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IHlpZWxkIHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKHR4Lmhhc2gsIGNvbmZpcm1hdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IHJlc29sdmVkIG9yIHJlamVjdGVkIChwcm9sbHkgYSB0aW1lb3V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxyZWFkeURvbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZWFzb24gd2Ugd2VyZSByZXBsYWNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVhc29uID0gXCJyZXBsYWNlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguZGF0YSA9PT0gcmVwbGFjZWFibGUuZGF0YSAmJiB0eC50byA9PT0gcmVwbGFjZWFibGUudG8gJiYgdHgudmFsdWUuZXEocmVwbGFjZWFibGUudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcInJlcHJpY2VkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHguZGF0YSA9PT0gXCIweFwiICYmIHR4LmZyb20gPT09IHR4LnRvICYmIHR4LnZhbHVlLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcImNhbmNlbGxlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4cGxhaW4gd2h5IHdlIHdlcmUgcmVwbGFjZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGxvZ2dlci5tYWtlRXJyb3IoXCJ0cmFuc2FjdGlvbiB3YXMgcmVwbGFjZWRcIiwgTG9nZ2VyLmVycm9ycy5UUkFOU0FDVElPTl9SRVBMQUNFRCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGVkOiAocmVhc29uID09PSBcInJlcGxhY2VkXCIgfHwgcmVhc29uID09PSBcImNhbmNlbGxlZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50OiB0aGlzLl93cmFwVHJhbnNhY3Rpb24odHgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaDogdHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWlwdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FubmVkQmxvY2srKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25jZShcImJsb2NrXCIsIHJlcGxhY2VIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25jZShcImJsb2NrXCIsIHJlcGxhY2VIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJibG9ja1wiLCByZXBsYWNlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEZ1bmNzLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihcImJsb2NrXCIsIHJlcGxhY2VIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHRpbWVvdXQpID09PSBcIm51bWJlclwiICYmIHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxyZWFkeURvbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChsb2dnZXIubWFrZUVycm9yKFwidGltZW91dCBleGNlZWRlZFwiLCBMb2dnZXIuZXJyb3JzLlRJTUVPVVQsIHsgdGltZW91dDogdGltZW91dCB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIudW5yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyLnVucmVmKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsRnVuY3MucHVzaCgoKSA9PiB7IGNsZWFyVGltZW91dCh0aW1lcik7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0QmxvY2tOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEdhc1ByaWNlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRHYXNQcmljZVwiLCB7fSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldEdhc1ByaWNlXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCwgZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEJhbGFuY2UoYWRkcmVzc09yTmFtZSwgYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0geWllbGQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuX2dldEFkZHJlc3MoYWRkcmVzc09yTmFtZSksXG4gICAgICAgICAgICAgICAgYmxvY2tUYWc6IHRoaXMuX2dldEJsb2NrVGFnKGJsb2NrVGFnKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRCYWxhbmNlXCIsIHBhcmFtcyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldEJhbGFuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLCByZXN1bHQsIGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRUcmFuc2FjdGlvbkNvdW50KGFkZHJlc3NPck5hbWUsIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLl9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpLFxuICAgICAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiLCBwYXJhbXMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20ocmVzdWx0KS50b051bWJlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uQ291bnRcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLCByZXN1bHQsIGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDb2RlKGFkZHJlc3NPck5hbWUsIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLl9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpLFxuICAgICAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0Q29kZVwiLCBwYXJhbXMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4bGlmeShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldENvZGVcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLCByZXN1bHQsIGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRTdG9yYWdlQXQoYWRkcmVzc09yTmFtZSwgcG9zaXRpb24sIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLl9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpLFxuICAgICAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZyksXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IFByb21pc2UucmVzb2x2ZShwb3NpdGlvbikudGhlbigocCkgPT4gaGV4VmFsdWUocCkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMucGVyZm9ybShcImdldFN0b3JhZ2VBdFwiLCBwYXJhbXMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4bGlmeShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldFN0b3JhZ2VBdFwiLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMsIHJlc3VsdCwgZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBieSBhbnkgc3ViY2xhc3Mgd3JhcHBpbmcgYSBUcmFuc2FjdGlvblJlc3BvbnNlXG4gICAgX3dyYXBUcmFuc2FjdGlvbih0eCwgaGFzaCwgc3RhcnRCbG9jaykge1xuICAgICAgICBpZiAoaGFzaCAhPSBudWxsICYmIGhleERhdGFMZW5ndGgoaGFzaCkgIT09IDMyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJlc3BvbnNlIC0gc2VuZFRyYW5zYWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHR4O1xuICAgICAgICAvLyBDaGVjayB0aGUgaGFzaCB3ZSBleHBlY3QgaXMgdGhlIHNhbWUgYXMgdGhlIGhhc2ggdGhlIHNlcnZlciByZXBvcnRlZFxuICAgICAgICBpZiAoaGFzaCAhPSBudWxsICYmIHR4Lmhhc2ggIT09IGhhc2gpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiVHJhbnNhY3Rpb24gaGFzaCBtaXNtYXRjaCBmcm9tIFByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbi5cIiwgTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SLCB7IGV4cGVjdGVkSGFzaDogdHguaGFzaCwgcmV0dXJuZWRIYXNoOiBoYXNoIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC53YWl0ID0gKGNvbmZpcm1zLCB0aW1lb3V0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlybXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpcm1zID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aW1lb3V0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCB0aGUgZGV0YWlscyB0byBkZXRlY3QgcmVwbGFjZW1lbnRcbiAgICAgICAgICAgIGxldCByZXBsYWNlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChjb25maXJtcyAhPT0gMCAmJiBzdGFydEJsb2NrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogdHguZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgbm9uY2U6IHR4Lm5vbmNlLFxuICAgICAgICAgICAgICAgICAgICB0bzogdHgudG8sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0eC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRCbG9ja1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWNlaXB0ID0geWllbGQgdGhpcy5fd2FpdEZvclRyYW5zYWN0aW9uKHR4Lmhhc2gsIGNvbmZpcm1zLCB0aW1lb3V0LCByZXBsYWNlbWVudCk7XG4gICAgICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsICYmIGNvbmZpcm1zID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBObyBsb25nZXIgcGVuZGluZywgYWxsb3cgdGhlIHBvbGxpbmcgbG9vcCB0byBnYXJiYWdlIGNvbGxlY3QgdGhpc1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlZFtcInQ6XCIgKyB0eC5oYXNoXSA9IHJlY2VpcHQuYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICBpZiAocmVjZWlwdC5zdGF0dXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInRyYW5zYWN0aW9uIGZhaWxlZFwiLCBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogdHguaGFzaCxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHR4LFxuICAgICAgICAgICAgICAgICAgICByZWNlaXB0OiByZWNlaXB0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjZWlwdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHNlbmRUcmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCBoZXhUeCA9IHlpZWxkIFByb21pc2UucmVzb2x2ZShzaWduZWRUcmFuc2FjdGlvbikudGhlbih0ID0+IGhleGxpZnkodCkpO1xuICAgICAgICAgICAgY29uc3QgdHggPSB0aGlzLmZvcm1hdHRlci50cmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbik7XG4gICAgICAgICAgICBpZiAodHguY29uZmlybWF0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IHlpZWxkIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzaCA9IHlpZWxkIHRoaXMucGVyZm9ybShcInNlbmRUcmFuc2FjdGlvblwiLCB7IHNpZ25lZFRyYW5zYWN0aW9uOiBoZXhUeCB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uKHR4LCBoYXNoLCBibG9ja051bWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvci50cmFuc2FjdGlvbiA9IHR4O1xuICAgICAgICAgICAgICAgIGVycm9yLnRyYW5zYWN0aW9uSGFzaCA9IHR4Lmhhc2g7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSB5aWVsZCB0cmFuc2FjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0ge307XG4gICAgICAgICAgICBbXCJmcm9tXCIsIFwidG9cIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlc1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0eFtrZXldID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlc1trZXldKS50aGVuKCh2KSA9PiAodiA/IHRoaXMuX2dldEFkZHJlc3ModikgOiBudWxsKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFtcImdhc0xpbWl0XCIsIFwiZ2FzUHJpY2VcIiwgXCJtYXhGZWVQZXJHYXNcIiwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcInZhbHVlXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHhba2V5XSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZXNba2V5XSkudGhlbigodikgPT4gKHYgPyBCaWdOdW1iZXIuZnJvbSh2KSA6IG51bGwpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgW1widHlwZVwiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR4W2tleV0gPSBQcm9taXNlLnJlc29sdmUodmFsdWVzW2tleV0pLnRoZW4oKHYpID0+ICgodiAhPSBudWxsKSA/IHYgOiBudWxsKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMuYWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgICAgIHR4LmFjY2Vzc0xpc3QgPSB0aGlzLmZvcm1hdHRlci5hY2Nlc3NMaXN0KHZhbHVlcy5hY2Nlc3NMaXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFtcImRhdGFcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlc1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0eFtrZXldID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlc1trZXldKS50aGVuKCh2KSA9PiAodiA/IGhleGxpZnkodikgOiBudWxsKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci50cmFuc2FjdGlvblJlcXVlc3QoeWllbGQgcmVzb2x2ZVByb3BlcnRpZXModHgpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRGaWx0ZXIoZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBmaWx0ZXIgPSB5aWVsZCBmaWx0ZXI7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChmaWx0ZXIuYWRkcmVzcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFkZHJlc3MgPSB0aGlzLl9nZXRBZGRyZXNzKGZpbHRlci5hZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFtcImJsb2NrSGFzaFwiLCBcInRvcGljc1wiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gZmlsdGVyW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFtcImZyb21CbG9ja1wiLCBcInRvQmxvY2tcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHRoaXMuX2dldEJsb2NrVGFnKGZpbHRlcltrZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVyLmZpbHRlcih5aWVsZCByZXNvbHZlUHJvcGVydGllcyhyZXN1bHQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9jYWxsKHRyYW5zYWN0aW9uLCBibG9ja1RhZywgYXR0ZW1wdCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKGF0dGVtcHQgPj0gTUFYX0NDSVBfUkVESVJFQ1RTKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJDQ0lQIHJlYWQgZXhjZWVkZWQgbWF4aW11bSByZWRpcmVjdGlvbnNcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RzOiBhdHRlbXB0LCB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHhTZW5kZXIgPSB0cmFuc2FjdGlvbi50bztcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMucGVyZm9ybShcImNhbGxcIiwgeyB0cmFuc2FjdGlvbiwgYmxvY2tUYWcgfSk7XG4gICAgICAgICAgICAvLyBDQ0lQIFJlYWQgcmVxdWVzdCB2aWEgT2ZmY2hhaW5Mb29rdXAoYWRkcmVzcyxzdHJpbmdbXSxieXRlcyxieXRlczQsYnl0ZXMpXG4gICAgICAgICAgICBpZiAoYXR0ZW1wdCA+PSAwICYmIGJsb2NrVGFnID09PSBcImxhdGVzdFwiICYmIHR4U2VuZGVyICE9IG51bGwgJiYgcmVzdWx0LnN1YnN0cmluZygwLCAxMCkgPT09IFwiMHg1NTZmMTgzMFwiICYmIChoZXhEYXRhTGVuZ3RoKHJlc3VsdCkgJSAzMiA9PT0gNCkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gaGV4RGF0YVNsaWNlKHJlc3VsdCwgNCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSBzZW5kZXIgb2YgdGhlIE9mZmNoYWluTG9va3VwIG1hdGNoZXMgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbmRlciA9IGhleERhdGFTbGljZShkYXRhLCAwLCAzMik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghQmlnTnVtYmVyLmZyb20oc2VuZGVyKS5lcSh0eFNlbmRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiQ0NJUCBSZWFkIHNlbmRlciBkaWQgbm90IG1hdGNoXCIsIExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIk9mZmNoYWluTG9va3VwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIk9mZmNoYWluTG9va3VwKGFkZHJlc3Msc3RyaW5nW10sYnl0ZXMsYnl0ZXM0LGJ5dGVzKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLCBkYXRhOiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlYWQgdGhlIFVSTHMgZnJvbSB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJscyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmxzT2Zmc2V0ID0gQmlnTnVtYmVyLmZyb20oaGV4RGF0YVNsaWNlKGRhdGEsIDMyLCA2NCkpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybHNMZW5ndGggPSBCaWdOdW1iZXIuZnJvbShoZXhEYXRhU2xpY2UoZGF0YSwgdXJsc09mZnNldCwgdXJsc09mZnNldCArIDMyKSkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsc0RhdGEgPSBoZXhEYXRhU2xpY2UoZGF0YSwgdXJsc09mZnNldCArIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdSA9IDA7IHUgPCB1cmxzTGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IF9wYXJzZVN0cmluZyh1cmxzRGF0YSwgdSAqIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cmwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiQ0NJUCBSZWFkIGNvbnRhaW5lZCBjb3JydXB0IFVSTCBzdHJpbmdcIiwgTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIk9mZmNoYWluTG9va3VwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJPZmZjaGFpbkxvb2t1cChhZGRyZXNzLHN0cmluZ1tdLGJ5dGVzLGJ5dGVzNCxieXRlcylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24sIGRhdGE6IHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdXJscy5wdXNoKHVybCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBDQ0lQIGNhbGxkYXRhIHRvIGZvcndhcmRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGRhdGEgPSBfcGFyc2VCeXRlcyhkYXRhLCA2NCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgY2FsbGJhY2tTZWxlY3RvciAoYnl0ZXM0KVxuICAgICAgICAgICAgICAgICAgICBpZiAoIUJpZ051bWJlci5mcm9tKGhleERhdGFTbGljZShkYXRhLCAxMDAsIDEyOCkpLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkNDSVAgUmVhZCBjYWxsYmFjayBzZWxlY3RvciBpbmNsdWRlZCBqdW5rXCIsIExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIk9mZmNoYWluTG9va3VwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIk9mZmNoYWluTG9va3VwKGFkZHJlc3Msc3RyaW5nW10sYnl0ZXMsYnl0ZXM0LGJ5dGVzKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLCBkYXRhOiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrU2VsZWN0b3IgPSBoZXhEYXRhU2xpY2UoZGF0YSwgOTYsIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZXh0cmEgZGF0YSB0byBzZW5kIGJhY2sgdG8gdGhlIGNvbnRyYWN0IGFzIGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXh0cmFEYXRhID0gX3BhcnNlQnl0ZXMoZGF0YSwgMTI4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2NpcFJlc3VsdCA9IHlpZWxkIHRoaXMuY2NpcFJlYWRGZXRjaCh0cmFuc2FjdGlvbiwgY2FsbGRhdGEsIHVybHMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2NpcFJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkNDSVAgUmVhZCBkaXNhYmxlZCBvciBwcm92aWRlZCBubyBVUkxzXCIsIExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIk9mZmNoYWluTG9va3VwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIk9mZmNoYWluTG9va3VwKGFkZHJlc3Msc3RyaW5nW10sYnl0ZXMsYnl0ZXM0LGJ5dGVzKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLCBkYXRhOiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG86IHR4U2VuZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogaGV4Q29uY2F0KFtjYWxsYmFja1NlbGVjdG9yLCBlbmNvZGVCeXRlcyhbY2NpcFJlc3VsdCwgZXh0cmFEYXRhXSldKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsbCh0eCwgYmxvY2tUYWcsIGF0dGVtcHQgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLCBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiY2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHsgdHJhbnNhY3Rpb24sIGJsb2NrVGFnIH0sIHJlc3VsdCwgZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhbGwodHJhbnNhY3Rpb24sIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0geWllbGQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0aGlzLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QodHJhbnNhY3Rpb24pLFxuICAgICAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZyksXG4gICAgICAgICAgICAgICAgY2NpcFJlYWRFbmFibGVkOiBQcm9taXNlLnJlc29sdmUodHJhbnNhY3Rpb24uY2NpcFJlYWRFbmFibGVkKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsbChyZXNvbHZlZC50cmFuc2FjdGlvbiwgcmVzb2x2ZWQuYmxvY2tUYWcsIHJlc29sdmVkLmNjaXBSZWFkRW5hYmxlZCA/IDAgOiAtMSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlc3RpbWF0ZUdhcyh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRoaXMuX2dldFRyYW5zYWN0aW9uUmVxdWVzdCh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZXN0aW1hdGVHYXNcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLCBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXN0aW1hdGVHYXNcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLCByZXN1bHQsIGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBhZGRyZXNzT3JOYW1lID0geWllbGQgYWRkcmVzc09yTmFtZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGFkZHJlc3NPck5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzcyBvciBFTlMgbmFtZVwiLCBcIm5hbWVcIiwgYWRkcmVzc09yTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0geWllbGQgdGhpcy5yZXNvbHZlTmFtZShhZGRyZXNzT3JOYW1lKTtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkVOUyBuYW1lIG5vdCBjb25maWd1cmVkXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogYHJlc29sdmVOYW1lKCR7SlNPTi5zdHJpbmdpZnkoYWRkcmVzc09yTmFtZSl9KWBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldEJsb2NrKGJsb2NrSGFzaE9yQmxvY2tUYWcsIGluY2x1ZGVUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgYmxvY2tIYXNoT3JCbG9ja1RhZyA9IHlpZWxkIGJsb2NrSGFzaE9yQmxvY2tUYWc7XG4gICAgICAgICAgICAvLyBJZiBibG9ja1RhZyBpcyBhIG51bWJlciAobm90IFwibGF0ZXN0XCIsIGV0YyksIHRoaXMgaXMgdGhlIGJsb2NrIG51bWJlclxuICAgICAgICAgICAgbGV0IGJsb2NrTnVtYmVyID0gLTEyODtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBpbmNsdWRlVHJhbnNhY3Rpb25zOiAhIWluY2x1ZGVUcmFuc2FjdGlvbnNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoYmxvY2tIYXNoT3JCbG9ja1RhZywgMzIpKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmJsb2NrSGFzaCA9IGJsb2NrSGFzaE9yQmxvY2tUYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuYmxvY2tUYWcgPSB5aWVsZCB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja0hhc2hPckJsb2NrVGFnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKHBhcmFtcy5ibG9ja1RhZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gcGFyc2VJbnQocGFyYW1zLmJsb2NrVGFnLnN1YnN0cmluZygyKSwgMTYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBibG9jayBoYXNoIG9yIGJsb2NrIHRhZ1wiLCBcImJsb2NrSGFzaE9yQmxvY2tUYWdcIiwgYmxvY2tIYXNoT3JCbG9ja1RhZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvbGwoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0QmxvY2tcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAvLyBCbG9jayB3YXMgbm90IGZvdW5kXG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGJsb2NraGFzaGVzLCBpZiB3ZSBkaWRuJ3Qgc2F5IGl0IGV4aXN0ZWQsIHRoYXQgYmxvY2toYXNoIG1heVxuICAgICAgICAgICAgICAgICAgICAvLyBub3QgZXhpc3QuIElmIHdlIGRpZCBzZWUgaXQgdGhvdWdoLCBwZXJoYXBzIGZyb20gYSBsb2csIHdlIGtub3dcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgZXhpc3RzLCBhbmQgdGhpcyBub2RlIGlzIGp1c3Qgbm90IGNhdWdodCB1cCB5ZXQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmxvY2tIYXNoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVkW1wiYjpcIiArIHBhcmFtcy5ibG9ja0hhc2hdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgYmxvY2sgdGFncywgaWYgd2UgYXJlIGFza2luZyBmb3IgYSBmdXR1cmUgYmxvY2ssIHdlIHJldHVybiBudWxsXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmxvY2tUYWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyID4gdGhpcy5fZW1pdHRlZC5ibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHJ5IG9uIHRoZSBuZXh0IGJsb2NrXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFkZCB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZVRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYmxvY2tOdW1iZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrLnRyYW5zYWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHggPSBibG9jay50cmFuc2FjdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LmNvbmZpcm1hdGlvbnMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHguY29uZmlybWF0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY29uZmlybWF0aW9ucyB1c2luZyB0aGUgZmFzdCBibG9jayBudW1iZXIgKHBlc3NpbWlzdGljKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb25maXJtYXRpb25zID0gKGJsb2NrTnVtYmVyIC0gdHguYmxvY2tOdW1iZXIpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9ucyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnMgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gY29uZmlybWF0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9ja1dpdGhUeHMgPSB0aGlzLmZvcm1hdHRlci5ibG9ja1dpdGhUcmFuc2FjdGlvbnMoYmxvY2spO1xuICAgICAgICAgICAgICAgICAgICBibG9ja1dpdGhUeHMudHJhbnNhY3Rpb25zID0gYmxvY2tXaXRoVHhzLnRyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB0aGlzLl93cmFwVHJhbnNhY3Rpb24odHgpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrV2l0aFR4cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVyLmJsb2NrKGJsb2NrKTtcbiAgICAgICAgICAgIH0pLCB7IG9uY2VQb2xsOiB0aGlzIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0QmxvY2soYmxvY2tIYXNoT3JCbG9ja1RhZykge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2dldEJsb2NrKGJsb2NrSGFzaE9yQmxvY2tUYWcsIGZhbHNlKSk7XG4gICAgfVxuICAgIGdldEJsb2NrV2l0aFRyYW5zYWN0aW9ucyhibG9ja0hhc2hPckJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fZ2V0QmxvY2soYmxvY2tIYXNoT3JCbG9ja1RhZywgdHJ1ZSkpO1xuICAgIH1cbiAgICBnZXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoID0geWllbGQgdHJhbnNhY3Rpb25IYXNoO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0geyB0cmFuc2FjdGlvbkhhc2g6IHRoaXMuZm9ybWF0dGVyLmhhc2godHJhbnNhY3Rpb25IYXNoLCB0cnVlKSB9O1xuICAgICAgICAgICAgcmV0dXJuIHBvbGwoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMucGVyZm9ybShcImdldFRyYW5zYWN0aW9uXCIsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVkW1widDpcIiArIHRyYW5zYWN0aW9uSGFzaF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdHggPSB0aGlzLmZvcm1hdHRlci50cmFuc2FjdGlvblJlc3BvbnNlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgaWYgKHR4LmJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR4LmNvbmZpcm1hdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IHlpZWxkIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBjb25maXJtYXRpb25zIHVzaW5nIHRoZSBmYXN0IGJsb2NrIG51bWJlciAocGVzc2ltaXN0aWMpXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb25maXJtYXRpb25zID0gKGJsb2NrTnVtYmVyIC0gdHguYmxvY2tOdW1iZXIpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvbnMgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9ucyA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IGNvbmZpcm1hdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93cmFwVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICAgICAgfSksIHsgb25jZVBvbGw6IHRoaXMgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRUcmFuc2FjdGlvblJlY2VpcHQodHJhbnNhY3Rpb25IYXNoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaCA9IHlpZWxkIHRyYW5zYWN0aW9uSGFzaDtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHsgdHJhbnNhY3Rpb25IYXNoOiB0aGlzLmZvcm1hdHRlci5oYXNoKHRyYW5zYWN0aW9uSGFzaCwgdHJ1ZSkgfTtcbiAgICAgICAgICAgIHJldHVybiBwb2xsKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZWRbXCJ0OlwiICsgdHJhbnNhY3Rpb25IYXNoXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBcImdldGgtZXRjXCIgcmV0dXJucyByZWNlaXB0cyBiZWZvcmUgdGhleSBhcmUgcmVhZHlcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmJsb2NrSGFzaCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSB0aGlzLmZvcm1hdHRlci5yZWNlaXB0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQuYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZWNlaXB0LmNvbmZpcm1hdGlvbnMgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWNlaXB0LmNvbmZpcm1hdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IHlpZWxkIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBjb25maXJtYXRpb25zIHVzaW5nIHRoZSBmYXN0IGJsb2NrIG51bWJlciAocGVzc2ltaXN0aWMpXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb25maXJtYXRpb25zID0gKGJsb2NrTnVtYmVyIC0gcmVjZWlwdC5ibG9ja051bWJlcikgKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9ucyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZWNlaXB0LmNvbmZpcm1hdGlvbnMgPSBjb25maXJtYXRpb25zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjZWlwdDtcbiAgICAgICAgICAgIH0pLCB7IG9uY2VQb2xsOiB0aGlzIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0TG9ncyhmaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0geWllbGQgcmVzb2x2ZVByb3BlcnRpZXMoeyBmaWx0ZXI6IHRoaXMuX2dldEZpbHRlcihmaWx0ZXIpIH0pO1xuICAgICAgICAgICAgY29uc3QgbG9ncyA9IHlpZWxkIHRoaXMucGVyZm9ybShcImdldExvZ3NcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgIGxvZ3MuZm9yRWFjaCgobG9nKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZy5yZW1vdmVkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLnJlbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBGb3JtYXR0ZXIuYXJyYXlPZih0aGlzLmZvcm1hdHRlci5maWx0ZXJMb2cuYmluZCh0aGlzLmZvcm1hdHRlcikpKGxvZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0RXRoZXJQcmljZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVyZm9ybShcImdldEV0aGVyUHJpY2VcIiwge30pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldEJsb2NrVGFnKGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBibG9ja1RhZyA9IHlpZWxkIGJsb2NrVGFnO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoYmxvY2tUYWcpID09PSBcIm51bWJlclwiICYmIGJsb2NrVGFnIDwgMCkge1xuICAgICAgICAgICAgICAgIGlmIChibG9ja1RhZyAlIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgQmxvY2tUYWdcIiwgXCJibG9ja1RhZ1wiLCBibG9ja1RhZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBibG9ja051bWJlciA9IHlpZWxkIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICBibG9ja051bWJlciArPSBibG9ja1RhZztcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVyLmJsb2NrVGFnKGJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci5ibG9ja1RhZyhibG9ja1RhZyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRSZXNvbHZlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudE5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5hbWUgPT09IFwiXCIgfHwgY3VycmVudE5hbWUgPT09IFwiLlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPcHRpbWl6YXRpb24gc2luY2UgdGhlIGV0aCBub2RlIGNhbm5vdCBjaGFuZ2UgYW5kIGRvZXNcbiAgICAgICAgICAgICAgICAvLyBub3QgaGF2ZSBhIHdpbGRjYXJkIHJlc29sdmVyXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgIT09IFwiZXRoXCIgJiYgY3VycmVudE5hbWUgPT09IFwiZXRoXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSBjdXJyZW50IG5vZGUgZm9yIGEgcmVzb2x2ZXJcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRyID0geWllbGQgdGhpcy5fZ2V0UmVzb2x2ZXIoY3VycmVudE5hbWUsIFwiZ2V0UmVzb2x2ZXJcIik7XG4gICAgICAgICAgICAgICAgLy8gRm91bmQgYSByZXNvbHZlciFcbiAgICAgICAgICAgICAgICBpZiAoYWRkciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gbmV3IFJlc29sdmVyKHRoaXMsIGFkZHIsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBMZWdhY3kgcmVzb2x2ZXIgZm91bmQsIHVzaW5nIEVJUC0yNTQ0IHNvIGl0IGlzbid0IHNhZmUgdG8gdXNlXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TmFtZSAhPT0gbmFtZSAmJiAhKHlpZWxkIHJlc29sdmVyLnN1cHBvcnRzV2lsZGNhcmQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBwYXJlbnQgbm9kZVxuICAgICAgICAgICAgICAgIGN1cnJlbnROYW1lID0gY3VycmVudE5hbWUuc3BsaXQoXCIuXCIpLnNsaWNlKDEpLmpvaW4oXCIuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldFJlc29sdmVyKG5hbWUsIG9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uID0gXCJFTlNcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIC8vIE5vIEVOUy4uLlxuICAgICAgICAgICAgaWYgKCFuZXR3b3JrLmVuc0FkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBFTlNcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgb3BlcmF0aW9uLCBuZXR3b3JrOiBuZXR3b3JrLm5hbWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIGtlY2NhazI1NihcInJlc29sdmVyKGJ5dGVzMzIpXCIpXG4gICAgICAgICAgICAgICAgY29uc3QgYWRkckRhdGEgPSB5aWVsZCB0aGlzLmNhbGwoe1xuICAgICAgICAgICAgICAgICAgICB0bzogbmV0d29yay5lbnNBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiAoXCIweDAxNzhiOGJmXCIgKyBuYW1laGFzaChuYW1lKS5zdWJzdHJpbmcoMikpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVyLmNhbGxBZGRyZXNzKGFkZHJEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIEVOUyByZWdpc3RyeSBjYW5ub3QgdGhyb3cgZXJyb3JzIG9uIHJlc29sdmVyKGJ5dGVzMzIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc29sdmVOYW1lKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIG5hbWUgPSB5aWVsZCBuYW1lO1xuICAgICAgICAgICAgLy8gSWYgaXQgaXMgYWxyZWFkeSBhbiBhZGRyZXNzLCBub3RoaW5nIHRvIHJlc29sdmVcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmZvcm1hdHRlci5hZGRyZXNzKG5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIElmIGlzIGlzIGEgaGV4c3RyaW5nLCB0aGUgYWRkcmVzcyBpcyBiYWQgKFNlZSAjNjk0KVxuICAgICAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIChuYW1lKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEVOUyBuYW1lXCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCB0aGUgYWRkciBmcm9tIHRoZSByZXNvbHZlclxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSB5aWVsZCB0aGlzLmdldFJlc29sdmVyKG5hbWUpO1xuICAgICAgICAgICAgaWYgKCFyZXNvbHZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc29sdmVyLmdldEFkZHJlc3MoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxvb2t1cEFkZHJlc3MoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgYWRkcmVzcyA9IHlpZWxkIGFkZHJlc3M7XG4gICAgICAgICAgICBhZGRyZXNzID0gdGhpcy5mb3JtYXR0ZXIuYWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBhZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpICsgXCIuYWRkci5yZXZlcnNlXCI7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlckFkZHIgPSB5aWVsZCB0aGlzLl9nZXRSZXNvbHZlcihub2RlLCBcImxvb2t1cEFkZHJlc3NcIik7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZXJBZGRyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGtlY2NhayhcIm5hbWUoYnl0ZXMzMilcIilcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBfcGFyc2VTdHJpbmcoeWllbGQgdGhpcy5jYWxsKHtcbiAgICAgICAgICAgICAgICB0bzogcmVzb2x2ZXJBZGRyLFxuICAgICAgICAgICAgICAgIGRhdGE6IChcIjB4NjkxZjM0MzFcIiArIG5hbWVoYXNoKG5vZGUpLnN1YnN0cmluZygyKSlcbiAgICAgICAgICAgIH0pLCAwKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHIgPSB5aWVsZCB0aGlzLnJlc29sdmVOYW1lKG5hbWUpO1xuICAgICAgICAgICAgaWYgKGFkZHIgIT0gYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRBdmF0YXIobmFtZU9yQWRkcmVzcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IHJlc29sdmVyID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhuYW1lT3JBZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIC8vIEFkZHJlc3M7IHJldmVyc2UgbG9va3VwXG4gICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHRoaXMuZm9ybWF0dGVyLmFkZHJlc3MobmFtZU9yQWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGFkZHJlc3Muc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCkgKyBcIi5hZGRyLnJldmVyc2VcIjtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlckFkZHJlc3MgPSB5aWVsZCB0aGlzLl9nZXRSZXNvbHZlcihub2RlLCBcImdldEF2YXRhclwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc29sdmVyQWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHJlc29sdmluZyB0aGUgYXZhdGFyIGFnYWluc3QgdGhlIGFkZHIucmV2ZXJzZSByZXNvbHZlclxuICAgICAgICAgICAgICAgIHJlc29sdmVyID0gbmV3IFJlc29sdmVyKHRoaXMsIHJlc29sdmVyQWRkcmVzcywgbm9kZSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXZhdGFyID0geWllbGQgcmVzb2x2ZXIuZ2V0QXZhdGFyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdmF0YXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdmF0YXIudXJsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSAhPT0gTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVHJ5IGdldHRpbmcgdGhlIG5hbWUgYW5kIHBlcmZvcm1pbmcgZm9yd2FyZCBsb29rdXA7IGFsbG93aW5nIHdpbGRjYXJkc1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGtlY2NhayhcIm5hbWUoYnl0ZXMzMilcIilcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IF9wYXJzZVN0cmluZyh5aWVsZCB0aGlzLmNhbGwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG86IHJlc29sdmVyQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IChcIjB4NjkxZjM0MzFcIiArIG5hbWVoYXNoKG5vZGUpLnN1YnN0cmluZygyKSlcbiAgICAgICAgICAgICAgICAgICAgfSksIDApO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlciA9IHlpZWxkIHRoaXMuZ2V0UmVzb2x2ZXIobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSAhPT0gTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRU5TIG5hbWU7IGZvcndhcmQgbG9va3VwIHdpdGggd2lsZGNhcmRcbiAgICAgICAgICAgICAgICByZXNvbHZlciA9IHlpZWxkIHRoaXMuZ2V0UmVzb2x2ZXIobmFtZU9yQWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhdmF0YXIgPSB5aWVsZCByZXNvbHZlci5nZXRBdmF0YXIoKTtcbiAgICAgICAgICAgIGlmIChhdmF0YXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF2YXRhci51cmw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwZXJmb3JtKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihtZXRob2QgKyBcIiBub3QgaW1wbGVtZW50ZWRcIiwgTG9nZ2VyLmVycm9ycy5OT1RfSU1QTEVNRU5URUQsIHsgb3BlcmF0aW9uOiBtZXRob2QgfSk7XG4gICAgfVxuICAgIF9zdGFydEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHRoaXMucG9sbGluZyA9ICh0aGlzLl9ldmVudHMuZmlsdGVyKChlKSA9PiBlLnBvbGxhYmxlKCkpLmxlbmd0aCA+IDApO1xuICAgIH1cbiAgICBfc3RvcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHRoaXMucG9sbGluZyA9ICh0aGlzLl9ldmVudHMuZmlsdGVyKChlKSA9PiBlLnBvbGxhYmxlKCkpLmxlbmd0aCA+IDApO1xuICAgIH1cbiAgICBfYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvbmNlKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KGdldEV2ZW50VGFnKGV2ZW50TmFtZSksIGxpc3RlbmVyLCBvbmNlKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2goZXZlbnQpO1xuICAgICAgICB0aGlzLl9zdGFydEV2ZW50KGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH1cbiAgICBvbmNlKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfVxuICAgIGVtaXQoZXZlbnROYW1lLCAuLi5hcmdzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHN0b3BwZWQgPSBbXTtcbiAgICAgICAgbGV0IGV2ZW50VGFnID0gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzLmZpbHRlcigoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC50YWcgIT09IGV2ZW50VGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBldmVudC5saXN0ZW5lci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChldmVudC5vbmNlKSB7XG4gICAgICAgICAgICAgICAgc3RvcHBlZC5wdXNoKGV2ZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0b3BwZWQuZm9yRWFjaCgoZXZlbnQpID0+IHsgdGhpcy5fc3RvcEV2ZW50KGV2ZW50KTsgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGxpc3RlbmVyQ291bnQoZXZlbnROYW1lKSB7XG4gICAgICAgIGlmICghZXZlbnROYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXZlbnRUYWcgPSBnZXRFdmVudFRhZyhldmVudE5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLmZpbHRlcigoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoZXZlbnQudGFnID09PSBldmVudFRhZyk7XG4gICAgICAgIH0pLmxlbmd0aDtcbiAgICB9XG4gICAgbGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgICAgICBpZiAoZXZlbnROYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMubWFwKChldmVudCkgPT4gZXZlbnQubGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBldmVudFRhZyA9IGdldEV2ZW50VGFnKGV2ZW50TmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudHNcbiAgICAgICAgICAgIC5maWx0ZXIoKGV2ZW50KSA9PiAoZXZlbnQudGFnID09PSBldmVudFRhZykpXG4gICAgICAgICAgICAubWFwKChldmVudCkgPT4gZXZlbnQubGlzdGVuZXIpO1xuICAgIH1cbiAgICBvZmYoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RvcHBlZCA9IFtdO1xuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGV2ZW50VGFnID0gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzLmZpbHRlcigoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC50YWcgIT09IGV2ZW50VGFnIHx8IGV2ZW50Lmxpc3RlbmVyICE9IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0b3BwZWQucHVzaChldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBzdG9wcGVkLmZvckVhY2goKGV2ZW50KSA9PiB7IHRoaXMuX3N0b3BFdmVudChldmVudCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgICAgICBsZXQgc3RvcHBlZCA9IFtdO1xuICAgICAgICBpZiAoZXZlbnROYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0b3BwZWQgPSB0aGlzLl9ldmVudHM7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50VGFnID0gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cy5maWx0ZXIoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnRhZyAhPT0gZXZlbnRUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0b3BwZWQucHVzaChldmVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcHBlZC5mb3JFYWNoKChldmVudCkgPT4geyB0aGlzLl9zdG9wRXZlbnQoZXZlbnQpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiRm9ya0V2ZW50IiwiUHJvdmlkZXIiLCJlbmNvZGUiLCJiYXNlNjRFbmNvZGUiLCJCYXNlNTgiLCJCaWdOdW1iZXIiLCJhcnJheWlmeSIsImNvbmNhdCIsImhleENvbmNhdCIsImhleERhdGFMZW5ndGgiLCJoZXhEYXRhU2xpY2UiLCJoZXhsaWZ5IiwiaGV4VmFsdWUiLCJoZXhaZXJvUGFkIiwiaXNIZXhTdHJpbmciLCJIYXNoWmVybyIsImRuc0VuY29kZSIsIm5hbWVoYXNoIiwiZ2V0TmV0d29yayIsImRlZmluZVJlYWRPbmx5IiwiZ2V0U3RhdGljIiwicmVzb2x2ZVByb3BlcnRpZXMiLCJzaGEyNTYiLCJ0b1V0ZjhCeXRlcyIsInRvVXRmOFN0cmluZyIsImZldGNoSnNvbiIsInBvbGwiLCJiZWNoMzIiLCJMb2dnZXIiLCJ2ZXJzaW9uIiwibG9nZ2VyIiwiRm9ybWF0dGVyIiwiTUFYX0NDSVBfUkVESVJFQ1RTIiwiY2hlY2tUb3BpYyIsInRvcGljIiwidGhyb3dBcmd1bWVudEVycm9yIiwidG9Mb3dlckNhc2UiLCJzZXJpYWxpemVUb3BpY3MiLCJ0b3BpY3MiLCJzbGljZSIsImxlbmd0aCIsInBvcCIsIm1hcCIsIkFycmF5IiwiaXNBcnJheSIsInVuaXF1ZSIsImZvckVhY2giLCJzb3J0ZWQiLCJPYmplY3QiLCJrZXlzIiwic29ydCIsImpvaW4iLCJkZXNlcmlhbGl6ZVRvcGljcyIsImRhdGEiLCJzcGxpdCIsImNvbXBzIiwiZ2V0RXZlbnRUYWciLCJldmVudE5hbWUiLCJpbmRleE9mIiwiaXNGb3JrRXZlbnQiLCJ3YXJuIiwiRXJyb3IiLCJhZGRyZXNzIiwiZ2V0VGltZSIsIkRhdGUiLCJzdGFsbCIsImR1cmF0aW9uIiwic2V0VGltZW91dCIsIlBvbGxhYmxlRXZlbnRzIiwiRXZlbnQiLCJjb25zdHJ1Y3RvciIsInRhZyIsImxpc3RlbmVyIiwib25jZSIsIl9sYXN0QmxvY2tOdW1iZXIiLCJfaW5mbGlnaHQiLCJldmVudCIsInR5cGUiLCJoYXNoIiwiZmlsdGVyIiwicG9sbGFibGUiLCJjb2luSW5mb3MiLCJzeW1ib2wiLCJwMnBraCIsInAyc2giLCJwcmVmaXgiLCJpbGsiLCJieXRlczMyaWZ5IiwiZnJvbSIsInRvSGV4U3RyaW5nIiwiYmFzZTU4RW5jb2RlIiwibWF0Y2hlcklwZnMiLCJSZWdFeHAiLCJtYXRjaGVycyIsIl9wYXJzZVN0cmluZyIsInN0YXJ0IiwiX3BhcnNlQnl0ZXMiLCJlcnJvciIsIm9mZnNldCIsInRvTnVtYmVyIiwiZ2V0SXBmc0xpbmsiLCJsaW5rIiwibWF0Y2giLCJzdWJzdHJpbmciLCJudW1QYWQiLCJwYWRkZWQiLCJVaW50OEFycmF5Iiwic2V0IiwiYnl0ZXNQYWQiLCJNYXRoIiwiY2VpbCIsImVuY29kZUJ5dGVzIiwiZGF0YXMiLCJieXRlQ291bnQiLCJpIiwicHVzaCIsIlJlc29sdmVyIiwicHJvdmlkZXIiLCJuYW1lIiwicmVzb2x2ZWRBZGRyZXNzIiwiZm9ybWF0dGVyIiwic3VwcG9ydHNXaWxkY2FyZCIsIl9zdXBwb3J0c0VpcDI1NDQiLCJjYWxsIiwidG8iLCJlcSIsImNhdGNoIiwiY29kZSIsImVycm9ycyIsIkNBTExfRVhDRVBUSU9OIiwiX2ZldGNoIiwic2VsZWN0b3IiLCJwYXJhbWV0ZXJzIiwidHgiLCJjY2lwUmVhZEVuYWJsZWQiLCJwYXJzZUJ5dGVzIiwidGhyb3dFcnJvciIsInRyYW5zYWN0aW9uIiwiX2ZldGNoQnl0ZXMiLCJfZ2V0QWRkcmVzcyIsImNvaW5UeXBlIiwiaGV4Qnl0ZXMiLCJjb2luSW5mbyIsIlN0cmluZyIsIlVOU1VQUE9SVEVEX09QRVJBVElPTiIsIm9wZXJhdGlvbiIsImJ5dGVzIiwicGFyc2VJbnQiLCJ3b3JkcyIsInRvV29yZHMiLCJ1bnNoaWZ0IiwiZ2V0QWRkcmVzcyIsImNhbGxBZGRyZXNzIiwiZ2V0QXZhdGFyIiwibGlua2FnZSIsImNvbnRlbnQiLCJhdmF0YXIiLCJnZXRUZXh0Iiwic2NoZW1lIiwidXJsIiwib3duZXIiLCJfcmVzb2x2ZWRBZGRyZXNzIiwiYWRkciIsInRva2VuSWQiLCJ0b2tlbk93bmVyIiwiYmFsYW5jZSIsImlzWmVybyIsInRvU3RyaW5nIiwibWV0YWRhdGFVcmwiLCJyZXBsYWNlIiwibWV0YWRhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwiaW1hZ2VVcmwiLCJpbWFnZSIsImlwZnMiLCJnZXRDb250ZW50SGFzaCIsImlwbnMiLCJzd2FybSIsInNreW5ldCIsInVybFNhZmUiLCJhIiwia2V5Iiwia2V5Qnl0ZXMiLCJkZWZhdWx0Rm9ybWF0dGVyIiwibmV4dFBvbGxJZCIsIkJhc2VQcm92aWRlciIsIm5ldHdvcmsiLCJfZXZlbnRzIiwiX2VtaXR0ZWQiLCJibG9jayIsImRpc2FibGVDY2lwUmVhZCIsImdldEZvcm1hdHRlciIsImFueU5ldHdvcmsiLCJkZXRlY3ROZXR3b3JrIiwiX25ldHdvcmtQcm9taXNlIiwiX3JlYWR5Iiwia25vd25OZXR3b3JrIiwiZW1pdCIsIl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyIiwiX21heEZpbHRlckJsb2NrUmFuZ2UiLCJfcG9sbGluZ0ludGVydmFsIiwiX2Zhc3RRdWVyeURhdGUiLCJfbmV0d29yayIsIlVOS05PV05fRVJST1IiLCJyZWFkeSIsIk5FVFdPUktfRVJST1IiLCJ1bmRlZmluZWQiLCJjY2lwUmVhZEZldGNoIiwiY2FsbGRhdGEiLCJ1cmxzIiwic2VuZGVyIiwiZXJyb3JNZXNzYWdlcyIsImhyZWYiLCJqc29uIiwiZXJyb3JQYXNzVGhyb3VnaCIsInJlc3BvbnNlIiwic3RhdHVzIiwic3RhdHVzQ29kZSIsImVycm9yTWVzc2FnZSIsIm1lc3NhZ2UiLCJTRVJWRVJfRVJST1IiLCJtIiwiX2dldEludGVybmFsQmxvY2tOdW1iZXIiLCJtYXhBZ2UiLCJfaW50ZXJuYWxCbG9ja051bWJlciIsImludGVybmFsQmxvY2tOdW1iZXIiLCJyZXNwVGltZSIsImJsb2NrTnVtYmVyIiwicmVxVGltZSIsImNoZWNrSW50ZXJuYWxCbG9ja051bWJlciIsInBlcmZvcm0iLCJuZXR3b3JrRXJyb3IiLCJfc2V0RmFzdEJsb2NrTnVtYmVyIiwicG9sbElkIiwicnVubmVycyIsInBvbGxpbmdJbnRlcnZhbCIsImFicyIsIm1ha2VFcnJvciIsInByZXZpb3VzQmxvY2tOdW1iZXIiLCJldmVudEJsb2NrTnVtYmVyIiwicnVubmVyIiwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0IiwicmVjZWlwdCIsImZyb21CbG9jayIsInRvQmxvY2siLCJtaW5Gcm9tQmxvY2siLCJnZXRMb2dzIiwibG9ncyIsImxvZyIsImJsb2NrSGFzaCIsInRyYW5zYWN0aW9uSGFzaCIsImFsbCIsInJlc2V0RXZlbnRzQmxvY2siLCJwb2xsaW5nIiwiY3VycmVudE5ldHdvcmsiLCJjaGFpbklkIiwiX2Zhc3RCbG9ja051bWJlciIsIl9mYXN0QmxvY2tOdW1iZXJQcm9taXNlIiwiZGV0ZWN0ZWROZXR3b3JrIiwiX3BvbGxlciIsInNldEludGVydmFsIiwiX2Jvb3RzdHJhcFBvbGwiLCJjbGVhckludGVydmFsIiwiX2dldEZhc3RCbG9ja051bWJlciIsIm5vdyIsImdldEJsb2NrTnVtYmVyIiwid2FpdEZvclRyYW5zYWN0aW9uIiwiY29uZmlybWF0aW9ucyIsInRpbWVvdXQiLCJfd2FpdEZvclRyYW5zYWN0aW9uIiwicmVwbGFjZWFibGUiLCJjYW5jZWxGdW5jcyIsImFscmVhZHlEb25lIiwiZnVuYyIsIm1pbmVkSGFuZGxlciIsIm9uIiwicmVtb3ZlTGlzdGVuZXIiLCJsYXN0QmxvY2tOdW1iZXIiLCJzdGFydEJsb2NrIiwic2Nhbm5lZEJsb2NrIiwicmVwbGFjZUhhbmRsZXIiLCJnZXRUcmFuc2FjdGlvbkNvdW50Iiwibm9uY2UiLCJtaW5lZCIsImdldFRyYW5zYWN0aW9uIiwiZ2V0QmxvY2tXaXRoVHJhbnNhY3Rpb25zIiwidGkiLCJ0cmFuc2FjdGlvbnMiLCJyZWFzb24iLCJUUkFOU0FDVElPTl9SRVBMQUNFRCIsImNhbmNlbGxlZCIsInJlcGxhY2VtZW50IiwiX3dyYXBUcmFuc2FjdGlvbiIsInRpbWVyIiwiVElNRU9VVCIsInVucmVmIiwiY2xlYXJUaW1lb3V0IiwiZ2V0R2FzUHJpY2UiLCJtZXRob2QiLCJnZXRCYWxhbmNlIiwiYWRkcmVzc09yTmFtZSIsImJsb2NrVGFnIiwicGFyYW1zIiwiX2dldEJsb2NrVGFnIiwiZ2V0Q29kZSIsImdldFN0b3JhZ2VBdCIsInBvc2l0aW9uIiwicCIsImV4cGVjdGVkSGFzaCIsInJldHVybmVkSGFzaCIsIndhaXQiLCJjb25maXJtcyIsInNlbmRUcmFuc2FjdGlvbiIsInNpZ25lZFRyYW5zYWN0aW9uIiwiaGV4VHgiLCJ0IiwiX2dldFRyYW5zYWN0aW9uUmVxdWVzdCIsInZhbHVlcyIsInYiLCJhY2Nlc3NMaXN0IiwidHJhbnNhY3Rpb25SZXF1ZXN0IiwiX2dldEZpbHRlciIsIl9jYWxsIiwiYXR0ZW1wdCIsInJlZGlyZWN0cyIsInR4U2VuZGVyIiwic2lnbmF0dXJlIiwidXJsc09mZnNldCIsInVybHNMZW5ndGgiLCJ1cmxzRGF0YSIsInUiLCJjYWxsYmFja1NlbGVjdG9yIiwiZXh0cmFEYXRhIiwiY2NpcFJlc3VsdCIsInJlc29sdmVkIiwiZXN0aW1hdGVHYXMiLCJyZXNvbHZlTmFtZSIsIl9nZXRCbG9jayIsImJsb2NrSGFzaE9yQmxvY2tUYWciLCJpbmNsdWRlVHJhbnNhY3Rpb25zIiwiYmxvY2tXaXRoVHhzIiwiYmxvY2tXaXRoVHJhbnNhY3Rpb25zIiwib25jZVBvbGwiLCJnZXRCbG9jayIsInRyYW5zYWN0aW9uUmVzcG9uc2UiLCJyZW1vdmVkIiwiYXJyYXlPZiIsImZpbHRlckxvZyIsImJpbmQiLCJnZXRFdGhlclByaWNlIiwiZ2V0UmVzb2x2ZXIiLCJjdXJyZW50TmFtZSIsIl9nZXRSZXNvbHZlciIsInJlc29sdmVyIiwiZW5zQWRkcmVzcyIsImFkZHJEYXRhIiwibG9va3VwQWRkcmVzcyIsIm5vZGUiLCJyZXNvbHZlckFkZHIiLCJuYW1lT3JBZGRyZXNzIiwicmVzb2x2ZXJBZGRyZXNzIiwiTk9UX0lNUExFTUVOVEVEIiwiX3N0YXJ0RXZlbnQiLCJfc3RvcEV2ZW50IiwiX2FkZEV2ZW50TGlzdGVuZXIiLCJhcmdzIiwic3RvcHBlZCIsImV2ZW50VGFnIiwibGlzdGVuZXJDb3VudCIsImxpc3RlbmVycyIsIm9mZiIsInJlbW92ZUFsbExpc3RlbmVycyIsImZvdW5kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/base-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/formatter.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/formatter.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Formatter: () => (/* binding */ Formatter),\n/* harmony export */   isCommunityResourcable: () => (/* binding */ isCommunityResourcable),\n/* harmony export */   isCommunityResource: () => (/* binding */ isCommunityResource),\n/* harmony export */   showThrottleMessage: () => (/* binding */ showThrottleMessage)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/constants */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib.esm/addresses.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/transactions */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/transactions/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/_version.js\");\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nclass Formatter {\n    constructor(){\n        this.formats = this.getDefaultFormats();\n    }\n    getDefaultFormats() {\n        const formats = {};\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n        const strictData = (v)=>{\n            return this.data(v, true);\n        };\n        formats.transaction = {\n            hash: hash,\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n            confirmations: Formatter.allowNull(number, null),\n            from: address,\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n            creates: Formatter.allowNull(address, null),\n            raw: Formatter.allowNull(data)\n        };\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null)\n        };\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash\n        };\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n        formats.block = {\n            hash: Formatter.allowNull(hash),\n            parentHash: hash,\n            number: number,\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n            miner: Formatter.allowNull(address),\n            extraData: data,\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n        formats.blockWithTransactions = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.shallowCopy)(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined)\n        };\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n            topics: Formatter.arrayOf(hash),\n            transactionHash: hash,\n            logIndex: number\n        };\n        return formats;\n    }\n    accessList(accessList) {\n        return (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_3__.accessListify)(accessList || []);\n    }\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number) {\n        if (number === \"0x\") {\n            return 0;\n        }\n        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(number).toNumber();\n    }\n    type(number) {\n        if (number === \"0x\" || number == null) {\n            return 0;\n        }\n        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(number).toNumber();\n    }\n    // Strict! Used on input.\n    bigNumber(value) {\n        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value);\n    }\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value) {\n        if (typeof value === \"boolean\") {\n            return value;\n        }\n        if (typeof value === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") {\n                return true;\n            }\n            if (value === \"false\") {\n                return false;\n            }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n    hex(value, strict) {\n        if (typeof value === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") {\n                value = \"0x\" + value;\n            }\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(value)) {\n                return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n    data(value, strict) {\n        const result = this.hex(value, strict);\n        if (result.length % 2 !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n    // Requires an address\n    // Strict! Used on input.\n    address(value) {\n        return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_6__.getAddress)(value);\n    }\n    callAddress(value) {\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(value, 32)) {\n            return null;\n        }\n        const address = (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_6__.getAddress)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexDataSlice)(value, 12));\n        return address === _ethersproject_constants__WEBPACK_IMPORTED_MODULE_7__.AddressZero ? null : address;\n    }\n    contractAddress(value) {\n        return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_6__.getContractAddress)(value);\n    }\n    // Strict! Used on input.\n    blockTag(blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        if (blockTag === \"earliest\") {\n            return \"0x0\";\n        }\n        switch(blockTag){\n            case \"earliest\":\n                return \"0x0\";\n            case \"latest\":\n            case \"pending\":\n            case \"safe\":\n            case \"finalized\":\n                return blockTag;\n        }\n        if (typeof blockTag === \"number\" || (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(blockTag)) {\n            return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexValue)(blockTag);\n        }\n        throw new Error(\"invalid blockTag\");\n    }\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value, strict) {\n        const result = this.hex(value, strict);\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexDataLength)(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value) {\n        if (value == null) {\n            return null;\n        }\n        const v = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value);\n        try {\n            return v.toNumber();\n        } catch (error) {}\n        return null;\n    }\n    uint256(value) {\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexZeroPad)(value, 32);\n    }\n    _block(value, format) {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;\n        const result = Formatter.check(format, value);\n        result._difficulty = difficulty == null ? null : _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(difficulty);\n        return result;\n    }\n    block(value) {\n        return this._block(value, this.formats.block);\n    }\n    blockWithTransactions(value) {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n    // Strict! Used on input.\n    transactionRequest(value) {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n    transactionResponse(transaction) {\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {\n            transaction.accessList = [];\n        }\n        const result = Formatter.check(this.formats.transaction, transaction);\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(chainId)) {\n                chainId = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(chainId).toNumber();\n            }\n            result.chainId = chainId;\n        } else {\n            let chainId = transaction.networkId;\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(chainId)) {\n                chainId = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(chainId).toNumber();\n            }\n            if (typeof chainId !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) {\n                    chainId = 0;\n                }\n                chainId = parseInt(chainId);\n            }\n            if (typeof chainId !== \"number\") {\n                chainId = 0;\n            }\n            result.chainId = chainId;\n        }\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n        return result;\n    }\n    transaction(value) {\n        return (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_3__.parse)(value);\n    }\n    receiptLog(value) {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n    receipt(value) {\n        const result = Formatter.check(this.formats.receipt, value);\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && result.status !== value) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", {\n                            root: result.root,\n                            status: result.status\n                        });\n                    }\n                    result.status = value;\n                    delete result.root;\n                } else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            } else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n        return result;\n    }\n    topics(value) {\n        if (Array.isArray(value)) {\n            return value.map((v)=>this.topics(v));\n        } else if (value != null) {\n            return this.hash(value, true);\n        }\n        return null;\n    }\n    filter(value) {\n        return Formatter.check(this.formats.filter, value);\n    }\n    filterLog(value) {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n    static check(format, object) {\n        const result = {};\n        for(const key in format){\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) {\n                    result[key] = value;\n                }\n            } catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n    // if value is null-ish, nullValue is returned\n    static allowNull(format, nullValue) {\n        return function(value) {\n            if (value == null) {\n                return nullValue;\n            }\n            return format(value);\n        };\n    }\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format, replaceValue) {\n        return function(value) {\n            if (!value) {\n                return replaceValue;\n            }\n            return format(value);\n        };\n    }\n    // Requires an Array satisfying check\n    static arrayOf(format) {\n        return function(array) {\n            if (!Array.isArray(array)) {\n                throw new Error(\"not an array\");\n            }\n            const result = [];\n            array.forEach(function(value) {\n                result.push(format(value));\n            });\n            return result;\n        };\n    }\n}\nfunction isCommunityResourcable(value) {\n    return value && typeof value.isCommunityResource === \"function\";\n}\nfunction isCommunityResource(value) {\n    return isCommunityResourcable(value) && value.isCommunityResource();\n}\n// Show the throttle message only once\nlet throttleMessage = false;\nfunction showThrottleMessage() {\n    if (throttleMessage) {\n        return;\n    }\n    throttleMessage = true;\n    console.log(\"========= NOTICE =========\");\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https://docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n} //# sourceMappingURL=formatter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9mb3JtYXR0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQWE7QUFDMkQ7QUFDbkI7QUFDaUQ7QUFDL0M7QUFDQztBQUMrQjtBQUN4QztBQUNWO0FBQ3JDLE1BQU1lLFNBQVMsSUFBSUYseURBQU1BLENBQUNDLDZDQUFPQTtBQUMxQixNQUFNRTtJQUNUQyxhQUFjO1FBQ1YsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSSxDQUFDQyxpQkFBaUI7SUFDekM7SUFDQUEsb0JBQW9CO1FBQ2hCLE1BQU1ELFVBQVcsQ0FBQztRQUNsQixNQUFNRSxVQUFVLElBQUksQ0FBQ0EsT0FBTyxDQUFDQyxJQUFJLENBQUMsSUFBSTtRQUN0QyxNQUFNQyxZQUFZLElBQUksQ0FBQ0EsU0FBUyxDQUFDRCxJQUFJLENBQUMsSUFBSTtRQUMxQyxNQUFNRSxXQUFXLElBQUksQ0FBQ0EsUUFBUSxDQUFDRixJQUFJLENBQUMsSUFBSTtRQUN4QyxNQUFNRyxPQUFPLElBQUksQ0FBQ0EsSUFBSSxDQUFDSCxJQUFJLENBQUMsSUFBSTtRQUNoQyxNQUFNSSxPQUFPLElBQUksQ0FBQ0EsSUFBSSxDQUFDSixJQUFJLENBQUMsSUFBSTtRQUNoQyxNQUFNSyxNQUFNLElBQUksQ0FBQ0EsR0FBRyxDQUFDTCxJQUFJLENBQUMsSUFBSTtRQUM5QixNQUFNTSxTQUFTLElBQUksQ0FBQ0EsTUFBTSxDQUFDTixJQUFJLENBQUMsSUFBSTtRQUNwQyxNQUFNTyxPQUFPLElBQUksQ0FBQ0EsSUFBSSxDQUFDUCxJQUFJLENBQUMsSUFBSTtRQUNoQyxNQUFNUSxhQUFhLENBQUNDO1lBQVEsT0FBTyxJQUFJLENBQUNOLElBQUksQ0FBQ00sR0FBRztRQUFPO1FBQ3ZEWixRQUFRYSxXQUFXLEdBQUc7WUFDbEJOLE1BQU1BO1lBQ05HLE1BQU1BO1lBQ05JLFlBQVloQixVQUFV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QyxHQUFHLENBQUM7SUFDWkQsUUFBUUMsR0FBRyxDQUFDO0lBQ1pELFFBQVFDLEdBQUcsQ0FBQztJQUNaRCxRQUFRQyxHQUFHLENBQUM7SUFDWkQsUUFBUUMsR0FBRyxDQUFDO0FBQ2hCLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2xpbWUtYmV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vZm9ybWF0dGVyLmpzPzc5OWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzLCBnZXRDb250cmFjdEFkZHJlc3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWRkcmVzc1wiO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsgaGV4RGF0YUxlbmd0aCwgaGV4RGF0YVNsaWNlLCBoZXhWYWx1ZSwgaGV4WmVyb1BhZCwgaXNIZXhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IEFkZHJlc3NaZXJvIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgc2hhbGxvd0NvcHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSwgcGFyc2UgYXMgcGFyc2VUcmFuc2FjdGlvbiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC90cmFuc2FjdGlvbnNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmV4cG9ydCBjbGFzcyBGb3JtYXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmZvcm1hdHMgPSB0aGlzLmdldERlZmF1bHRGb3JtYXRzKCk7XG4gICAgfVxuICAgIGdldERlZmF1bHRGb3JtYXRzKCkge1xuICAgICAgICBjb25zdCBmb3JtYXRzID0gKHt9KTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IHRoaXMuYWRkcmVzcy5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBiaWdOdW1iZXIgPSB0aGlzLmJpZ051bWJlci5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBibG9ja1RhZyA9IHRoaXMuYmxvY2tUYWcuYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YS5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBoYXNoID0gdGhpcy5oYXNoLmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IGhleCA9IHRoaXMuaGV4LmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IG51bWJlciA9IHRoaXMubnVtYmVyLmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLnR5cGUuYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3Qgc3RyaWN0RGF0YSA9ICh2KSA9PiB7IHJldHVybiB0aGlzLmRhdGEodiwgdHJ1ZSk7IH07XG4gICAgICAgIGZvcm1hdHMudHJhbnNhY3Rpb24gPSB7XG4gICAgICAgICAgICBoYXNoOiBoYXNoLFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGFjY2Vzc0xpc3Q6IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy5hY2Nlc3NMaXN0LmJpbmQodGhpcyksIG51bGwpLFxuICAgICAgICAgICAgYmxvY2tIYXNoOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGhhc2gsIG51bGwpLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyLCBudWxsKSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyLCBudWxsKSxcbiAgICAgICAgICAgIGNvbmZpcm1hdGlvbnM6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyLCBudWxsKSxcbiAgICAgICAgICAgIGZyb206IGFkZHJlc3MsXG4gICAgICAgICAgICAvLyBlaXRoZXIgKGdhc1ByaWNlKSBvciAobWF4UHJpb3JpdHlGZWVQZXJHYXMgKyBtYXhGZWVQZXJHYXMpXG4gICAgICAgICAgICAvLyBtdXN0IGJlIHNldFxuICAgICAgICAgICAgZ2FzUHJpY2U6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiBiaWdOdW1iZXIsXG4gICAgICAgICAgICB0bzogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzLCBudWxsKSxcbiAgICAgICAgICAgIHZhbHVlOiBiaWdOdW1iZXIsXG4gICAgICAgICAgICBub25jZTogbnVtYmVyLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIHI6IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy51aW50MjU2KSxcbiAgICAgICAgICAgIHM6IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy51aW50MjU2KSxcbiAgICAgICAgICAgIHY6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyKSxcbiAgICAgICAgICAgIGNyZWF0ZXM6IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgbnVsbCksXG4gICAgICAgICAgICByYXc6IEZvcm1hdHRlci5hbGxvd051bGwoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGZvcm1hdHMudHJhbnNhY3Rpb25SZXF1ZXN0ID0ge1xuICAgICAgICAgICAgZnJvbTogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzKSxcbiAgICAgICAgICAgIG5vbmNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG4gICAgICAgICAgICBnYXNMaW1pdDogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuICAgICAgICAgICAgZ2FzUHJpY2U6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIHRvOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MpLFxuICAgICAgICAgICAgdmFsdWU6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIGRhdGE6IEZvcm1hdHRlci5hbGxvd051bGwoc3RyaWN0RGF0YSksXG4gICAgICAgICAgICB0eXBlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG4gICAgICAgICAgICBhY2Nlc3NMaXN0OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYWNjZXNzTGlzdC5iaW5kKHRoaXMpLCBudWxsKSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9ybWF0cy5yZWNlaXB0TG9nID0ge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogbnVtYmVyLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IG51bWJlcixcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogaGFzaCxcbiAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgICB0b3BpY3M6IEZvcm1hdHRlci5hcnJheU9mKGhhc2gpLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIGxvZ0luZGV4OiBudW1iZXIsXG4gICAgICAgICAgICBibG9ja0hhc2g6IGhhc2gsXG4gICAgICAgIH07XG4gICAgICAgIGZvcm1hdHMucmVjZWlwdCA9IHtcbiAgICAgICAgICAgIHRvOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYWRkcmVzcywgbnVsbCksXG4gICAgICAgICAgICBmcm9tOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYWRkcmVzcywgbnVsbCksXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgbnVsbCksXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBudW1iZXIsXG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgYWxsb3dOdWxsKGhhc2gpLCBidXQgYnJva2VuLUVJUC02NTggc3VwcG9ydCBpcyBoYW5kbGVkIGluIHJlY2VpcHRcbiAgICAgICAgICAgIHJvb3Q6IEZvcm1hdHRlci5hbGxvd051bGwoaGV4KSxcbiAgICAgICAgICAgIGdhc1VzZWQ6IGJpZ051bWJlcixcbiAgICAgICAgICAgIGxvZ3NCbG9vbTogRm9ybWF0dGVyLmFsbG93TnVsbChkYXRhKSxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogaGFzaCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogaGFzaCxcbiAgICAgICAgICAgIGxvZ3M6IEZvcm1hdHRlci5hcnJheU9mKHRoaXMucmVjZWlwdExvZy5iaW5kKHRoaXMpKSxcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBudW1iZXIsXG4gICAgICAgICAgICBjb25maXJtYXRpb25zOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciwgbnVsbCksXG4gICAgICAgICAgICBjdW11bGF0aXZlR2FzVXNlZDogYmlnTnVtYmVyLFxuICAgICAgICAgICAgZWZmZWN0aXZlR2FzUHJpY2U6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIHN0YXR1czogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIpLFxuICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICB9O1xuICAgICAgICBmb3JtYXRzLmJsb2NrID0ge1xuICAgICAgICAgICAgaGFzaDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoKSxcbiAgICAgICAgICAgIHBhcmVudEhhc2g6IGhhc2gsXG4gICAgICAgICAgICBudW1iZXI6IG51bWJlcixcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbnVtYmVyLFxuICAgICAgICAgICAgbm9uY2U6IEZvcm1hdHRlci5hbGxvd051bGwoaGV4KSxcbiAgICAgICAgICAgIGRpZmZpY3VsdHk6IHRoaXMuZGlmZmljdWx0eS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IGJpZ051bWJlcixcbiAgICAgICAgICAgIGdhc1VzZWQ6IGJpZ051bWJlcixcbiAgICAgICAgICAgIG1pbmVyOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MpLFxuICAgICAgICAgICAgZXh0cmFEYXRhOiBkYXRhLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKEZvcm1hdHRlci5hcnJheU9mKGhhc2gpKSxcbiAgICAgICAgICAgIGJhc2VGZWVQZXJHYXM6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKVxuICAgICAgICB9O1xuICAgICAgICBmb3JtYXRzLmJsb2NrV2l0aFRyYW5zYWN0aW9ucyA9IHNoYWxsb3dDb3B5KGZvcm1hdHMuYmxvY2spO1xuICAgICAgICBmb3JtYXRzLmJsb2NrV2l0aFRyYW5zYWN0aW9ucy50cmFuc2FjdGlvbnMgPSBGb3JtYXR0ZXIuYWxsb3dOdWxsKEZvcm1hdHRlci5hcnJheU9mKHRoaXMudHJhbnNhY3Rpb25SZXNwb25zZS5iaW5kKHRoaXMpKSk7XG4gICAgICAgIGZvcm1hdHMuZmlsdGVyID0ge1xuICAgICAgICAgICAgZnJvbUJsb2NrOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJsb2NrVGFnLCB1bmRlZmluZWQpLFxuICAgICAgICAgICAgdG9CbG9jazogRm9ybWF0dGVyLmFsbG93TnVsbChibG9ja1RhZywgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoLCB1bmRlZmluZWQpLFxuICAgICAgICAgICAgYWRkcmVzczogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzLCB1bmRlZmluZWQpLFxuICAgICAgICAgICAgdG9waWNzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMudG9waWNzLmJpbmQodGhpcyksIHVuZGVmaW5lZCksXG4gICAgICAgIH07XG4gICAgICAgIGZvcm1hdHMuZmlsdGVyTG9nID0ge1xuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyKSxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoKSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IG51bWJlcixcbiAgICAgICAgICAgIHJlbW92ZWQ6IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy5ib29sZWFuLmJpbmQodGhpcykpLFxuICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgIGRhdGE6IEZvcm1hdHRlci5hbGxvd0ZhbHNpc2goZGF0YSwgXCIweFwiKSxcbiAgICAgICAgICAgIHRvcGljczogRm9ybWF0dGVyLmFycmF5T2YoaGFzaCksXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGhhc2gsXG4gICAgICAgICAgICBsb2dJbmRleDogbnVtYmVyLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZm9ybWF0cztcbiAgICB9XG4gICAgYWNjZXNzTGlzdChhY2Nlc3NMaXN0KSB7XG4gICAgICAgIHJldHVybiBhY2Nlc3NMaXN0aWZ5KGFjY2Vzc0xpc3QgfHwgW10pO1xuICAgIH1cbiAgICAvLyBSZXF1aXJlcyBhIEJpZ051bWJlcmlzaCB0aGF0IGlzIHdpdGhpbiB0aGUgSUVFRTc1NCBzYWZlIGludGVnZXIgcmFuZ2U7IHJldHVybnMgYSBudW1iZXJcbiAgICAvLyBTdHJpY3QhIFVzZWQgb24gaW5wdXQuXG4gICAgbnVtYmVyKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShudW1iZXIpLnRvTnVtYmVyKCk7XG4gICAgfVxuICAgIHR5cGUobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPT09IFwiMHhcIiB8fCBudW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKG51bWJlcikudG9OdW1iZXIoKTtcbiAgICB9XG4gICAgLy8gU3RyaWN0ISBVc2VkIG9uIGlucHV0LlxuICAgIGJpZ051bWJlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuICAgIH1cbiAgICAvLyBSZXF1aXJlcyBhIGJvb2xlYW4sIFwidHJ1ZVwiIG9yICBcImZhbHNlXCI7IHJldHVybnMgYSBib29sZWFuXG4gICAgYm9vbGVhbih2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJvb2xlYW4gLSBcIiArIHZhbHVlKTtcbiAgICB9XG4gICAgaGV4KHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhhc2hcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRhdGEodmFsdWUsIHN0cmljdCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmhleCh2YWx1ZSwgc3RyaWN0KTtcbiAgICAgICAgaWYgKChyZXN1bHQubGVuZ3RoICUgMikgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZGF0YTsgb2RkLWxlbmd0aCAtIFwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFJlcXVpcmVzIGFuIGFkZHJlc3NcbiAgICAvLyBTdHJpY3QhIFVzZWQgb24gaW5wdXQuXG4gICAgYWRkcmVzcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyh2YWx1ZSk7XG4gICAgfVxuICAgIGNhbGxBZGRyZXNzKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNIZXhTdHJpbmcodmFsdWUsIDMyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGdldEFkZHJlc3MoaGV4RGF0YVNsaWNlKHZhbHVlLCAxMikpO1xuICAgICAgICByZXR1cm4gKGFkZHJlc3MgPT09IEFkZHJlc3NaZXJvKSA/IG51bGwgOiBhZGRyZXNzO1xuICAgIH1cbiAgICBjb250cmFjdEFkZHJlc3ModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGdldENvbnRyYWN0QWRkcmVzcyh2YWx1ZSk7XG4gICAgfVxuICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cbiAgICBibG9ja1RhZyhibG9ja1RhZykge1xuICAgICAgICBpZiAoYmxvY2tUYWcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibGF0ZXN0XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2NrVGFnID09PSBcImVhcmxpZXN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjB4MFwiO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYmxvY2tUYWcpIHtcbiAgICAgICAgICAgIGNhc2UgXCJlYXJsaWVzdFwiOiByZXR1cm4gXCIweDBcIjtcbiAgICAgICAgICAgIGNhc2UgXCJsYXRlc3RcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgICAgICBjYXNlIFwic2FmZVwiOlxuICAgICAgICAgICAgY2FzZSBcImZpbmFsaXplZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBibG9ja1RhZztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChibG9ja1RhZykgPT09IFwibnVtYmVyXCIgfHwgaXNIZXhTdHJpbmcoYmxvY2tUYWcpKSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4VmFsdWUoYmxvY2tUYWcpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmxvY2tUYWdcIik7XG4gICAgfVxuICAgIC8vIFJlcXVpcmVzIGEgaGFzaCwgb3B0aW9uYWxseSByZXF1aXJlcyAweCBwcmVmaXg7IHJldHVybnMgcHJlZml4ZWQgbG93ZXJjYXNlIGhhc2guXG4gICAgaGFzaCh2YWx1ZSwgc3RyaWN0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuaGV4KHZhbHVlLCBzdHJpY3QpO1xuICAgICAgICBpZiAoaGV4RGF0YUxlbmd0aChyZXN1bHQpICE9PSAzMikge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhhc2hcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgZGlmZmljdWx0eSBhcyBhIG51bWJlciwgb3IgaWYgdG9vIGxhcmdlIChpLmUuIFBvQSBuZXR3b3JrKSBudWxsXG4gICAgZGlmZmljdWx0eSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdiA9IEJpZ051bWJlci5mcm9tKHZhbHVlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB2LnRvTnVtYmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHVpbnQyNTYodmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdWludDI1NlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4WmVyb1BhZCh2YWx1ZSwgMzIpO1xuICAgIH1cbiAgICBfYmxvY2sodmFsdWUsIGZvcm1hdCkge1xuICAgICAgICBpZiAodmFsdWUuYXV0aG9yICE9IG51bGwgJiYgdmFsdWUubWluZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsdWUubWluZXIgPSB2YWx1ZS5hdXRob3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGRpZmZpY3VsdHkgbWF5IG5lZWQgdG8gY29tZSBmcm9tIF9kaWZmaWN1bHR5IGluIHJlY3Vyc2VkIGJsb2Nrc1xuICAgICAgICBjb25zdCBkaWZmaWN1bHR5ID0gKHZhbHVlLl9kaWZmaWN1bHR5ICE9IG51bGwpID8gdmFsdWUuX2RpZmZpY3VsdHkgOiB2YWx1ZS5kaWZmaWN1bHR5O1xuICAgICAgICBjb25zdCByZXN1bHQgPSBGb3JtYXR0ZXIuY2hlY2soZm9ybWF0LCB2YWx1ZSk7XG4gICAgICAgIHJlc3VsdC5fZGlmZmljdWx0eSA9ICgoZGlmZmljdWx0eSA9PSBudWxsKSA/IG51bGwgOiBCaWdOdW1iZXIuZnJvbShkaWZmaWN1bHR5KSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGJsb2NrKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ibG9jayh2YWx1ZSwgdGhpcy5mb3JtYXRzLmJsb2NrKTtcbiAgICB9XG4gICAgYmxvY2tXaXRoVHJhbnNhY3Rpb25zKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ibG9jayh2YWx1ZSwgdGhpcy5mb3JtYXRzLmJsb2NrV2l0aFRyYW5zYWN0aW9ucyk7XG4gICAgfVxuICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cbiAgICB0cmFuc2FjdGlvblJlcXVlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMudHJhbnNhY3Rpb25SZXF1ZXN0LCB2YWx1ZSk7XG4gICAgfVxuICAgIHRyYW5zYWN0aW9uUmVzcG9uc2UodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgLy8gUmVuYW1lIGdhcyB0byBnYXNMaW1pdFxuICAgICAgICBpZiAodHJhbnNhY3Rpb24uZ2FzICE9IG51bGwgJiYgdHJhbnNhY3Rpb24uZ2FzTGltaXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uZ2FzTGltaXQgPSB0cmFuc2FjdGlvbi5nYXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZSBjbGllbnRzIChUZXN0UlBDKSBkbyBzdHJhbmdlIHRoaW5ncyBsaWtlIHJldHVybiAweDAgZm9yIHRoZVxuICAgICAgICAvLyAwIGFkZHJlc3M7IGNvcnJlY3QgdGhpcyB0byBiZSBhIHJlYWwgYWRkcmVzc1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24udG8gJiYgQmlnTnVtYmVyLmZyb20odHJhbnNhY3Rpb24udG8pLmlzWmVybygpKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi50byA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuYW1lIGlucHV0IHRvIGRhdGFcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmlucHV0ICE9IG51bGwgJiYgdHJhbnNhY3Rpb24uZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5kYXRhID0gdHJhbnNhY3Rpb24uaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdG8gYW5kIGNyZWF0ZXMgYXJlIGVtcHR5LCBwb3B1bGF0ZSB0aGUgY3JlYXRlcyBmcm9tIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICBpZiAodHJhbnNhY3Rpb24udG8gPT0gbnVsbCAmJiB0cmFuc2FjdGlvbi5jcmVhdGVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmNyZWF0ZXMgPSB0aGlzLmNvbnRyYWN0QWRkcmVzcyh0cmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0cmFuc2FjdGlvbi50eXBlID09PSAxIHx8IHRyYW5zYWN0aW9uLnR5cGUgPT09IDIpICYmIHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uYWNjZXNzTGlzdCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMudHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGNoYWluSWQgPSB0cmFuc2FjdGlvbi5jaGFpbklkO1xuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGNoYWluSWQpKSB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZCA9IEJpZ051bWJlci5mcm9tKGNoYWluSWQpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY2hhaW5JZCA9IHRyYW5zYWN0aW9uLm5ldHdvcmtJZDtcbiAgICAgICAgICAgIC8vIGdldGgtZXRjIHJldHVybnMgY2hhaW5JZFxuICAgICAgICAgICAgaWYgKGNoYWluSWQgPT0gbnVsbCAmJiByZXN1bHQudiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZCA9IHRyYW5zYWN0aW9uLmNoYWluSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoY2hhaW5JZCkpIHtcbiAgICAgICAgICAgICAgICBjaGFpbklkID0gQmlnTnVtYmVyLmZyb20oY2hhaW5JZCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGNoYWluSWQpICE9PSBcIm51bWJlclwiICYmIHJlc3VsdC52ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjaGFpbklkID0gKHJlc3VsdC52IC0gMzUpIC8gMjtcbiAgICAgICAgICAgICAgICBpZiAoY2hhaW5JZCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoYWluSWQgPSBwYXJzZUludChjaGFpbklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGNoYWluSWQpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMHgwMDAwLi4uIHNob3VsZCBhY3R1YWxseSBiZSBudWxsXG4gICAgICAgIGlmIChyZXN1bHQuYmxvY2tIYXNoICYmIHJlc3VsdC5ibG9ja0hhc2gucmVwbGFjZSgvMC9nLCBcIlwiKSA9PT0gXCJ4XCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ibG9ja0hhc2ggPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRyYW5zYWN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVRyYW5zYWN0aW9uKHZhbHVlKTtcbiAgICB9XG4gICAgcmVjZWlwdExvZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5yZWNlaXB0TG9nLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJlY2VpcHQodmFsdWUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5yZWNlaXB0LCB2YWx1ZSk7XG4gICAgICAgIC8vIFJTSyBpbmNvcnJlY3RseSBpbXBsZW1lbnRlZCBFSVAtNjU4LCBzbyB3ZSBtdW5nZSB0aGluZ3MgYSBiaXQgaGVyZSBmb3IgaXRcbiAgICAgICAgaWYgKHJlc3VsdC5yb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucm9vdC5sZW5ndGggPD0gNCkge1xuICAgICAgICAgICAgICAgIC8vIENvdWxkIGJlIDB4MDAsIDB4MCwgMHgwMSBvciAweDFcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IEJpZ051bWJlci5mcm9tKHJlc3VsdC5yb290KS50b051bWJlcigpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMCB8fCB2YWx1ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgaWYgYm90aCBhcmUgc3BlY2lmaWVkLCB0aGV5IG1hdGNoXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzICE9IG51bGwgJiYgKHJlc3VsdC5zdGF0dXMgIT09IHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFsdC1yb290LXN0YXR1cy9zdGF0dXMgbWlzbWF0Y2hcIiwgXCJ2YWx1ZVwiLCB7IHJvb3Q6IHJlc3VsdC5yb290LCBzdGF0dXM6IHJlc3VsdC5zdGF0dXMgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXR1cyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVzdWx0LnJvb3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhbHQtcm9vdC1zdGF0dXNcIiwgXCJ2YWx1ZS5yb290XCIsIHJlc3VsdC5yb290KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQucm9vdC5sZW5ndGggIT09IDY2KSB7XG4gICAgICAgICAgICAgICAgLy8gTXVzdCBiZSBhIHZhbGlkIGJ5dGVzMzJcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCByb290IGhhc2hcIiwgXCJ2YWx1ZS5yb290XCIsIHJlc3VsdC5yb290KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuYnl6YW50aXVtID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0b3BpY3ModmFsdWUpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2KSA9PiB0aGlzLnRvcGljcyh2KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzaCh2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZpbHRlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5maWx0ZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgZmlsdGVyTG9nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBGb3JtYXR0ZXIuY2hlY2sodGhpcy5mb3JtYXRzLmZpbHRlckxvZywgdmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgY2hlY2soZm9ybWF0LCBvYmplY3QpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGZvcm1hdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGZvcm1hdFtrZXldKG9iamVjdFtrZXldKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9yLmNoZWNrS2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgIGVycm9yLmNoZWNrVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBpZiB2YWx1ZSBpcyBudWxsLWlzaCwgbnVsbFZhbHVlIGlzIHJldHVybmVkXG4gICAgc3RhdGljIGFsbG93TnVsbChmb3JtYXQsIG51bGxWYWx1ZSkge1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBJZiB2YWx1ZSBpcyBmYWxzZS1pc2gsIHJlcGxhY2VWYWx1ZSBpcyByZXR1cm5lZFxuICAgIHN0YXRpYyBhbGxvd0ZhbHNpc2goZm9ybWF0LCByZXBsYWNlVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBSZXF1aXJlcyBhbiBBcnJheSBzYXRpc2Z5aW5nIGNoZWNrXG4gICAgc3RhdGljIGFycmF5T2YoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGFuIGFycmF5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZvcm1hdCh2YWx1ZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNDb21tdW5pdHlSZXNvdXJjYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5pc0NvbW11bml0eVJlc291cmNlKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbW11bml0eVJlc291cmNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpc0NvbW11bml0eVJlc291cmNhYmxlKHZhbHVlKSAmJiB2YWx1ZS5pc0NvbW11bml0eVJlc291cmNlKCkpO1xufVxuLy8gU2hvdyB0aGUgdGhyb3R0bGUgbWVzc2FnZSBvbmx5IG9uY2VcbmxldCB0aHJvdHRsZU1lc3NhZ2UgPSBmYWxzZTtcbmV4cG9ydCBmdW5jdGlvbiBzaG93VGhyb3R0bGVNZXNzYWdlKCkge1xuICAgIGlmICh0aHJvdHRsZU1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdHRsZU1lc3NhZ2UgPSB0cnVlO1xuICAgIGNvbnNvbGUubG9nKFwiPT09PT09PT09IE5PVElDRSA9PT09PT09PT1cIik7XG4gICAgY29uc29sZS5sb2coXCJSZXF1ZXN0LVJhdGUgRXhjZWVkZWQgICh0aGlzIG1lc3NhZ2Ugd2lsbCBub3QgYmUgcmVwZWF0ZWQpXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiVGhlIGRlZmF1bHQgQVBJIGtleXMgZm9yIGVhY2ggc2VydmljZSBhcmUgcHJvdmlkZWQgYXMgYSBoaWdobHktdGhyb3R0bGVkLFwiKTtcbiAgICBjb25zb2xlLmxvZyhcImNvbW11bml0eSByZXNvdXJjZSBmb3IgbG93LXRyYWZmaWMgcHJvamVjdHMgYW5kIGVhcmx5IHByb3RvdHlwaW5nLlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIldoaWxlIHlvdXIgYXBwbGljYXRpb24gd2lsbCBjb250aW51ZSB0byBmdW5jdGlvbiwgd2UgaGlnaGx5IHJlY29tbWVuZGVkXCIpO1xuICAgIGNvbnNvbGUubG9nKFwic2lnbmluZyB1cCBmb3IgeW91ciBvd24gQVBJIGtleXMgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSwgaW5jcmVhc2UgeW91clwiKTtcbiAgICBjb25zb2xlLmxvZyhcInJlcXVlc3QgcmF0ZS9saW1pdCBhbmQgZW5hYmxlIG90aGVyIHBlcmtzLCBzdWNoIGFzIG1ldHJpY3MgYW5kIGFkdmFuY2VkIEFQSXMuXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiRm9yIG1vcmUgZGV0YWlsczogaHR0cHM6L1xcL2RvY3MuZXRoZXJzLmlvL2FwaS1rZXlzL1wiKTtcbiAgICBjb25zb2xlLmxvZyhcIj09PT09PT09PT09PT09PT09PT09PT09PT09XCIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBZGRyZXNzIiwiZ2V0Q29udHJhY3RBZGRyZXNzIiwiQmlnTnVtYmVyIiwiaGV4RGF0YUxlbmd0aCIsImhleERhdGFTbGljZSIsImhleFZhbHVlIiwiaGV4WmVyb1BhZCIsImlzSGV4U3RyaW5nIiwiQWRkcmVzc1plcm8iLCJzaGFsbG93Q29weSIsImFjY2Vzc0xpc3RpZnkiLCJwYXJzZSIsInBhcnNlVHJhbnNhY3Rpb24iLCJMb2dnZXIiLCJ2ZXJzaW9uIiwibG9nZ2VyIiwiRm9ybWF0dGVyIiwiY29uc3RydWN0b3IiLCJmb3JtYXRzIiwiZ2V0RGVmYXVsdEZvcm1hdHMiLCJhZGRyZXNzIiwiYmluZCIsImJpZ051bWJlciIsImJsb2NrVGFnIiwiZGF0YSIsImhhc2giLCJoZXgiLCJudW1iZXIiLCJ0eXBlIiwic3RyaWN0RGF0YSIsInYiLCJ0cmFuc2FjdGlvbiIsImFjY2Vzc0xpc3QiLCJhbGxvd051bGwiLCJibG9ja0hhc2giLCJibG9ja051bWJlciIsInRyYW5zYWN0aW9uSW5kZXgiLCJjb25maXJtYXRpb25zIiwiZnJvbSIsImdhc1ByaWNlIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJtYXhGZWVQZXJHYXMiLCJnYXNMaW1pdCIsInRvIiwidmFsdWUiLCJub25jZSIsInIiLCJ1aW50MjU2IiwicyIsImNyZWF0ZXMiLCJyYXciLCJ0cmFuc2FjdGlvblJlcXVlc3QiLCJyZWNlaXB0TG9nIiwidHJhbnNhY3Rpb25IYXNoIiwidG9waWNzIiwiYXJyYXlPZiIsImxvZ0luZGV4IiwicmVjZWlwdCIsImNvbnRyYWN0QWRkcmVzcyIsInJvb3QiLCJnYXNVc2VkIiwibG9nc0Jsb29tIiwibG9ncyIsImN1bXVsYXRpdmVHYXNVc2VkIiwiZWZmZWN0aXZlR2FzUHJpY2UiLCJzdGF0dXMiLCJibG9jayIsInBhcmVudEhhc2giLCJ0aW1lc3RhbXAiLCJkaWZmaWN1bHR5IiwibWluZXIiLCJleHRyYURhdGEiLCJ0cmFuc2FjdGlvbnMiLCJiYXNlRmVlUGVyR2FzIiwiYmxvY2tXaXRoVHJhbnNhY3Rpb25zIiwidHJhbnNhY3Rpb25SZXNwb25zZSIsImZpbHRlciIsImZyb21CbG9jayIsInVuZGVmaW5lZCIsInRvQmxvY2siLCJmaWx0ZXJMb2ciLCJyZW1vdmVkIiwiYm9vbGVhbiIsImFsbG93RmFsc2lzaCIsInRvTnVtYmVyIiwidG9Mb3dlckNhc2UiLCJFcnJvciIsInN0cmljdCIsInN1YnN0cmluZyIsInRocm93QXJndW1lbnRFcnJvciIsInJlc3VsdCIsImxlbmd0aCIsImNhbGxBZGRyZXNzIiwiZXJyb3IiLCJfYmxvY2siLCJmb3JtYXQiLCJhdXRob3IiLCJfZGlmZmljdWx0eSIsImNoZWNrIiwiZ2FzIiwiaXNaZXJvIiwiaW5wdXQiLCJjaGFpbklkIiwibmV0d29ya0lkIiwicGFyc2VJbnQiLCJyZXBsYWNlIiwiYnl6YW50aXVtIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwib2JqZWN0Iiwia2V5IiwiY2hlY2tLZXkiLCJjaGVja1ZhbHVlIiwibnVsbFZhbHVlIiwicmVwbGFjZVZhbHVlIiwiYXJyYXkiLCJmb3JFYWNoIiwicHVzaCIsImlzQ29tbXVuaXR5UmVzb3VyY2FibGUiLCJpc0NvbW11bml0eVJlc291cmNlIiwidGhyb3R0bGVNZXNzYWdlIiwic2hvd1Rocm90dGxlTWVzc2FnZSIsImNvbnNvbGUiLCJsb2ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/formatter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonRpcProvider: () => (/* binding */ JsonRpcProvider),\n/* harmony export */   JsonRpcSigner: () => (/* binding */ JsonRpcSigner)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/abstract-signer */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-signer/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/hash */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/typed-data.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/transactions */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/transactions/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/web */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/web/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* harmony import */ var _base_provider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./base-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/base-provider.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nconst errorGas = [\n    \"call\",\n    \"estimateGas\"\n];\nfunction spelunk(value, requireData) {\n    if (value == null) {\n        return null;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof value.message === \"string\" && value.message.match(\"reverted\")) {\n        const data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isHexString)(value.data) ? value.data : null;\n        if (!requireData || data) {\n            return {\n                message: value.message,\n                data\n            };\n        }\n    }\n    // Spelunk further...\n    if (typeof value === \"object\") {\n        for(const key in value){\n            const result = spelunk(value[key], requireData);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof value === \"string\") {\n        try {\n            return spelunk(JSON.parse(value), requireData);\n        } catch (error) {}\n    }\n    return null;\n}\nfunction checkError(method, error, params) {\n    const transaction = params.transaction || params.signedTransaction;\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\") {\n        const result = spelunk(error, true);\n        if (result) {\n            return result.data;\n        }\n        // Nothing descriptive..\n        logger.throwError(\"missing revert data in call exception; Transaction reverted without a reason string\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.CALL_EXCEPTION, {\n            data: \"0x\",\n            transaction,\n            error\n        });\n    }\n    if (method === \"estimateGas\") {\n        // Try to find something, with a preference on SERVER_ERROR body\n        let result = spelunk(error.body, false);\n        if (result == null) {\n            result = spelunk(error, false);\n        }\n        // Found \"reverted\", this is a CALL_EXCEPTION\n        if (result) {\n            logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                reason: result.message,\n                method,\n                transaction,\n                error\n            });\n        }\n    }\n    // @TODO: Should we spelunk for message too?\n    let message = error.message;\n    if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === \"string\") {\n        message = error.error.message;\n    } else if (typeof error.body === \"string\") {\n        message = error.body;\n    } else if (typeof error.responseText === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INSUFFICIENT_FUNDS, {\n            error,\n            method,\n            transaction\n        });\n    }\n    // \"nonce too low\"\n    if (message.match(/nonce (is )?too low/i)) {\n        logger.throwError(\"nonce has already been used\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NONCE_EXPIRED, {\n            error,\n            method,\n            transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {\n        logger.throwError(\"replacement fee too low\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error,\n            method,\n            transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/i)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            error,\n            method,\n            transaction\n        });\n    }\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error,\n            method,\n            transaction\n        });\n    }\n    throw error;\n}\nfunction timer(timeout) {\n    return new Promise(function(resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\nfunction getResult(payload) {\n    if (payload.error) {\n        // @TODO: not any\n        const error = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n    return payload.result;\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nconst _constructorGuard = {};\nclass JsonRpcSigner extends _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_3__.Signer {\n    constructor(constructorGuard, provider, addressOrIndex){\n        super();\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"provider\", provider);\n        if (addressOrIndex == null) {\n            addressOrIndex = 0;\n        }\n        if (typeof addressOrIndex === \"string\") {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"_index\", null);\n        } else if (typeof addressOrIndex === \"number\") {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"_index\", addressOrIndex);\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"_address\", null);\n        } else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n    connect(provider) {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n    connectUnchecked() {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    }\n    getAddress() {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n        return this.provider.send(\"eth_accounts\", []).then((accounts)=>{\n            if (accounts.length <= this._index) {\n                logger.throwError(\"unknown account #\" + this._index, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index]);\n        });\n    }\n    sendUncheckedTransaction(transaction) {\n        transaction = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(transaction);\n        const fromAddress = this.getAddress().then((address)=>{\n            if (address) {\n                address = address.toLowerCase();\n            }\n            return address;\n        });\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then((to)=>__awaiter(this, void 0, void 0, function*() {\n                    if (to == null) {\n                        return null;\n                    }\n                    const address = yield this.provider.resolveName(to);\n                    if (address == null) {\n                        logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                    }\n                    return address;\n                }));\n        }\n        return (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.resolveProperties)({\n            tx: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.resolveProperties)(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender })=>{\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            } else {\n                tx.from = sender;\n            }\n            const hexTx = this.provider.constructor.hexlifyTransaction(tx, {\n                from: true\n            });\n            return this.provider.send(\"eth_sendTransaction\", [\n                hexTx\n            ]).then((hash)=>{\n                return hash;\n            }, (error)=>{\n                if (typeof error.message === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected transaction\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.ACTION_REJECTED, {\n                        action: \"sendTransaction\",\n                        transaction: tx\n                    });\n                }\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n    signTransaction(transaction) {\n        return logger.throwError(\"signing transactions is unsupported\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n    sendTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // This cannot be mined any earlier than any recent block\n            const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n            // Send the transaction\n            const hash = yield this.sendUncheckedTransaction(transaction);\n            try {\n                // Unfortunately, JSON-RPC only provides and opaque transaction hash\n                // for a response, and we need the actual transaction, so we poll\n                // for it; it should show up very quickly\n                return yield (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_5__.poll)(()=>__awaiter(this, void 0, void 0, function*() {\n                        const tx = yield this.provider.getTransaction(hash);\n                        if (tx === null) {\n                            return undefined;\n                        }\n                        return this.provider._wrapTransaction(tx, hash, blockNumber);\n                    }), {\n                    oncePoll: this.provider\n                });\n            } catch (error) {\n                error.transactionHash = hash;\n                throw error;\n            }\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const data = typeof message === \"string\" ? (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_6__.toUtf8Bytes)(message) : message;\n            const address = yield this.getAddress();\n            try {\n                return yield this.provider.send(\"personal_sign\", [\n                    (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data),\n                    address.toLowerCase()\n                ]);\n            } catch (error) {\n                if (typeof error.message === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected signing\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.ACTION_REJECTED, {\n                        action: \"signMessage\",\n                        from: address,\n                        messageData: message\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    _legacySignMessage(message) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const data = typeof message === \"string\" ? (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_6__.toUtf8Bytes)(message) : message;\n            const address = yield this.getAddress();\n            try {\n                // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n                return yield this.provider.send(\"eth_sign\", [\n                    address.toLowerCase(),\n                    (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data)\n                ]);\n            } catch (error) {\n                if (typeof error.message === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected signing\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.ACTION_REJECTED, {\n                        action: \"_legacySignMessage\",\n                        from: address,\n                        messageData: message\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    _signTypedData(domain, types, value) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // Populate any ENS names (in-place)\n            const populated = yield _ethersproject_hash__WEBPACK_IMPORTED_MODULE_7__.TypedDataEncoder.resolveNames(domain, types, value, (name)=>{\n                return this.provider.resolveName(name);\n            });\n            const address = yield this.getAddress();\n            try {\n                return yield this.provider.send(\"eth_signTypedData_v4\", [\n                    address.toLowerCase(),\n                    JSON.stringify(_ethersproject_hash__WEBPACK_IMPORTED_MODULE_7__.TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n                ]);\n            } catch (error) {\n                if (typeof error.message === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected signing\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.ACTION_REJECTED, {\n                        action: \"_signTypedData\",\n                        from: address,\n                        messageData: {\n                            domain: populated.domain,\n                            types,\n                            value: populated.value\n                        }\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    unlock(password) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const provider = this.provider;\n            const address = yield this.getAddress();\n            return provider.send(\"personal_unlockAccount\", [\n                address.toLowerCase(),\n                password,\n                null\n            ]);\n        });\n    }\n}\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction) {\n        return this.sendUncheckedTransaction(transaction).then((hash)=>{\n            return {\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations)=>{\n                    return this.provider.waitForTransaction(hash, confirmations);\n                }\n            };\n        });\n    }\n}\nconst allowedTransactionKeys = {\n    chainId: true,\n    data: true,\n    gasLimit: true,\n    gasPrice: true,\n    nonce: true,\n    to: true,\n    value: true,\n    type: true,\n    accessList: true,\n    maxFeePerGas: true,\n    maxPriorityFeePerGas: true\n};\nclass JsonRpcProvider extends _base_provider__WEBPACK_IMPORTED_MODULE_8__.BaseProvider {\n    constructor(url, network){\n        let networkOrReady = network;\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject)=>{\n                setTimeout(()=>{\n                    this.detectNetwork().then((network)=>{\n                        resolve(network);\n                    }, (error)=>{\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Default URL\n        if (!url) {\n            url = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.getStatic)(this.constructor, \"defaultUrl\")();\n        }\n        if (typeof url === \"string\") {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"connection\", Object.freeze({\n                url: url\n            }));\n        } else {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"connection\", Object.freeze((0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(url)));\n        }\n        this._nextId = 42;\n    }\n    get _cache() {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = {};\n        }\n        return this._eventLoopCache;\n    }\n    static defaultUrl() {\n        return \"http://localhost:8545\";\n    }\n    detectNetwork() {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(()=>{\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n    _uncachedDetectNetwork() {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield timer(0);\n            let chainId = null;\n            try {\n                chainId = yield this.send(\"eth_chainId\", []);\n            } catch (error) {\n                try {\n                    chainId = yield this.send(\"net_version\", []);\n                } catch (error) {}\n            }\n            if (chainId != null) {\n                const getNetwork = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.getStatic)(this.constructor, \"getNetwork\");\n                try {\n                    return getNetwork(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_9__.BigNumber.from(chainId).toNumber());\n                } catch (error) {\n                    return logger.throwError(\"could not detect network\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NETWORK_ERROR, {\n                        chainId: chainId,\n                        event: \"invalidNetwork\",\n                        serverError: error\n                    });\n                }\n            }\n            return logger.throwError(\"could not detect network\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NETWORK_ERROR, {\n                event: \"noNetwork\"\n            });\n        });\n    }\n    getSigner(addressOrIndex) {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    }\n    getUncheckedSigner(addressOrIndex) {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n    listAccounts() {\n        return this.send(\"eth_accounts\", []).then((accounts)=>{\n            return accounts.map((a)=>this.formatter.address(a));\n        });\n    }\n    send(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: this._nextId++,\n            jsonrpc: \"2.0\"\n        };\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.deepCopy)(request),\n            provider: this\n        });\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = [\n            \"eth_chainId\",\n            \"eth_blockNumber\"\n        ].indexOf(method) >= 0;\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n        const result = (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_5__.fetchJson)(this.connection, JSON.stringify(request), getResult).then((result)=>{\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n            return result;\n        }, (error)=>{\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n            throw error;\n        });\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(()=>{\n                this._cache[method] = null;\n            }, 0);\n        }\n        return result;\n    }\n    prepareRequest(method, params) {\n        switch(method){\n            case \"getBlockNumber\":\n                return [\n                    \"eth_blockNumber\",\n                    []\n                ];\n            case \"getGasPrice\":\n                return [\n                    \"eth_gasPrice\",\n                    []\n                ];\n            case \"getBalance\":\n                return [\n                    \"eth_getBalance\",\n                    [\n                        getLowerCase(params.address),\n                        params.blockTag\n                    ]\n                ];\n            case \"getTransactionCount\":\n                return [\n                    \"eth_getTransactionCount\",\n                    [\n                        getLowerCase(params.address),\n                        params.blockTag\n                    ]\n                ];\n            case \"getCode\":\n                return [\n                    \"eth_getCode\",\n                    [\n                        getLowerCase(params.address),\n                        params.blockTag\n                    ]\n                ];\n            case \"getStorageAt\":\n                return [\n                    \"eth_getStorageAt\",\n                    [\n                        getLowerCase(params.address),\n                        (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexZeroPad)(params.position, 32),\n                        params.blockTag\n                    ]\n                ];\n            case \"sendTransaction\":\n                return [\n                    \"eth_sendRawTransaction\",\n                    [\n                        params.signedTransaction\n                    ]\n                ];\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [\n                        \"eth_getBlockByNumber\",\n                        [\n                            params.blockTag,\n                            !!params.includeTransactions\n                        ]\n                    ];\n                } else if (params.blockHash) {\n                    return [\n                        \"eth_getBlockByHash\",\n                        [\n                            params.blockHash,\n                            !!params.includeTransactions\n                        ]\n                    ];\n                }\n                return null;\n            case \"getTransaction\":\n                return [\n                    \"eth_getTransactionByHash\",\n                    [\n                        params.transactionHash\n                    ]\n                ];\n            case \"getTransactionReceipt\":\n                return [\n                    \"eth_getTransactionReceipt\",\n                    [\n                        params.transactionHash\n                    ]\n                ];\n            case \"call\":\n                {\n                    const hexlifyTransaction = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.getStatic)(this.constructor, \"hexlifyTransaction\");\n                    return [\n                        \"eth_call\",\n                        [\n                            hexlifyTransaction(params.transaction, {\n                                from: true\n                            }),\n                            params.blockTag\n                        ]\n                    ];\n                }\n            case \"estimateGas\":\n                {\n                    const hexlifyTransaction = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.getStatic)(this.constructor, \"hexlifyTransaction\");\n                    return [\n                        \"eth_estimateGas\",\n                        [\n                            hexlifyTransaction(params.transaction, {\n                                from: true\n                            })\n                        ]\n                    ];\n                }\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [\n                    \"eth_getLogs\",\n                    [\n                        params.filter\n                    ]\n                ];\n            default:\n                break;\n        }\n        return null;\n    }\n    perform(method, params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // Legacy networks do not like the type field being passed along (which\n            // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n            if (method === \"call\" || method === \"estimateGas\") {\n                const tx = params.transaction;\n                if (tx && tx.type != null && _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_9__.BigNumber.from(tx.type).isZero()) {\n                    // If there are no EIP-1559 properties, it might be non-EIP-1559\n                    if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                        const feeData = yield this.getFeeData();\n                        if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                            // Network doesn't know about EIP-1559 (and hence type)\n                            params = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(params);\n                            params.transaction = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(tx);\n                            delete params.transaction.type;\n                        }\n                    }\n                }\n            }\n            const args = this.prepareRequest(method, params);\n            if (args == null) {\n                logger.throwError(method + \" not implemented\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NOT_IMPLEMENTED, {\n                    operation: method\n                });\n            }\n            try {\n                return yield this.send(args[0], args[1]);\n            } catch (error) {\n                return checkError(method, error, params);\n            }\n        });\n    }\n    _startEvent(event) {\n        if (event.tag === \"pending\") {\n            this._startPending();\n        }\n        super._startEvent(event);\n    }\n    _startPending() {\n        if (this._pendingFilter != null) {\n            return;\n        }\n        const self = this;\n        const pendingFilter = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n        pendingFilter.then(function(filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [\n                    filterId\n                ]).then(function(hashes) {\n                    if (self._pendingFilter != pendingFilter) {\n                        return null;\n                    }\n                    let seq = Promise.resolve();\n                    hashes.forEach(function(hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function() {\n                            return self.getTransaction(hash).then(function(tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n                    return seq.then(function() {\n                        return timer(1000);\n                    });\n                }).then(function() {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [\n                            filterId\n                        ]);\n                        return;\n                    }\n                    setTimeout(function() {\n                        poll();\n                    }, 0);\n                    return null;\n                }).catch((error)=>{});\n            }\n            poll();\n            return filterId;\n        }).catch((error)=>{});\n    }\n    _stopEvent(event) {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction, allowExtra) {\n        // Check only allowed properties are given\n        const allowed = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(allowedTransactionKeys);\n        if (allowExtra) {\n            for(const key in allowExtra){\n                if (allowExtra[key]) {\n                    allowed[key] = true;\n                }\n            }\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.checkProperties)(transaction, allowed);\n        const result = {};\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\n            \"chainId\",\n            \"gasLimit\",\n            \"gasPrice\",\n            \"type\",\n            \"maxFeePerGas\",\n            \"maxPriorityFeePerGas\",\n            \"nonce\",\n            \"value\"\n        ].forEach(function(key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            const value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexValue)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_9__.BigNumber.from(transaction[key]));\n            if (key === \"gasLimit\") {\n                key = \"gas\";\n            }\n            result[key] = value;\n        });\n        [\n            \"from\",\n            \"to\",\n            \"data\"\n        ].forEach(function(key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            result[key] = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(transaction[key]);\n        });\n        if (transaction.accessList) {\n            result[\"accessList\"] = (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_10__.accessListify)(transaction.accessList);\n        }\n        return result;\n    }\n} //# sourceMappingURL=json-rpc-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9qc29uLXJwYy1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQWE7QUFDYixJQUFJQSxZQUFZLFNBQUssSUFBSSxTQUFJLENBQUNBLFNBQVMsSUFBSyxTQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ25GLFNBQVNDLE1BQU1DLEtBQUs7UUFBSSxPQUFPQSxpQkFBaUJILElBQUlHLFFBQVEsSUFBSUgsRUFBRSxTQUFVSSxPQUFPO1lBQUlBLFFBQVFEO1FBQVE7SUFBSTtJQUMzRyxPQUFPLElBQUtILENBQUFBLEtBQU1BLENBQUFBLElBQUlLLE9BQU0sQ0FBQyxFQUFHLFNBQVVELE9BQU8sRUFBRUUsTUFBTTtRQUNyRCxTQUFTQyxVQUFVSixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsVUFBVVEsSUFBSSxDQUFDTjtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzFGLFNBQVNDLFNBQVNSLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxTQUFTLENBQUMsUUFBUSxDQUFDRTtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzdGLFNBQVNGLEtBQUtJLE1BQU07WUFBSUEsT0FBT0MsSUFBSSxHQUFHVCxRQUFRUSxPQUFPVCxLQUFLLElBQUlELE1BQU1VLE9BQU9ULEtBQUssRUFBRVcsSUFBSSxDQUFDUCxXQUFXSTtRQUFXO1FBQzdHSCxLQUFLLENBQUNQLFlBQVlBLFVBQVVjLEtBQUssQ0FBQ2pCLFNBQVNDLGNBQWMsRUFBRSxHQUFHVSxJQUFJO0lBQ3RFO0FBQ0o7QUFDd0Q7QUFDSDtBQUM2QjtBQUMxQjtBQUN5RTtBQUM1RTtBQUNPO0FBQ1A7QUFDTjtBQUNWO0FBQ3JDLE1BQU0wQixTQUFT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QUFZO2dCQUNwQkEsTUFBTTtZQUNWO1lBQ0EvQixNQUFNLENBQUMrQixJQUFJLEdBQUd4QztRQUNsQjtRQUNBO1lBQUM7WUFBUTtZQUFNO1NBQU8sQ0FBQzZMLE9BQU8sQ0FBQyxTQUFVckosR0FBRztZQUN4QyxJQUFJTyxXQUFXLENBQUNQLElBQUksSUFBSSxNQUFNO2dCQUMxQjtZQUNKO1lBQ0EvQixNQUFNLENBQUMrQixJQUFJLEdBQUd6Qiw2REFBT0EsQ0FBQ2dDLFdBQVcsQ0FBQ1AsSUFBSTtRQUMxQztRQUNBLElBQUlPLFlBQVl5RixVQUFVLEVBQUU7WUFDeEIvSCxNQUFNLENBQUMsYUFBYSxHQUFHa0IsMkVBQWFBLENBQUNvQixZQUFZeUYsVUFBVTtRQUMvRDtRQUNBLE9BQU8vSDtJQUNYO0FBQ0osRUFDQSw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbGltZS1iZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9qc29uLXJwYy1wcm92aWRlci5qcz9kNDYzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBTaWduZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWJzdHJhY3Qtc2lnbmVyXCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBoZXhsaWZ5LCBoZXhWYWx1ZSwgaGV4WmVyb1BhZCwgaXNIZXhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IF9UeXBlZERhdGFFbmNvZGVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2hhc2hcIjtcbmltcG9ydCB7IGNoZWNrUHJvcGVydGllcywgZGVlcENvcHksIGRlZmluZVJlYWRPbmx5LCBnZXRTdGF0aWMsIHJlc29sdmVQcm9wZXJ0aWVzLCBzaGFsbG93Q29weSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9zdHJpbmdzXCI7XG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3RyYW5zYWN0aW9uc1wiO1xuaW1wb3J0IHsgZmV0Y2hKc29uLCBwb2xsIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3dlYlwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuaW1wb3J0IHsgQmFzZVByb3ZpZGVyIH0gZnJvbSBcIi4vYmFzZS1wcm92aWRlclwiO1xuY29uc3QgZXJyb3JHYXMgPSBbXCJjYWxsXCIsIFwiZXN0aW1hdGVHYXNcIl07XG5mdW5jdGlvbiBzcGVsdW5rKHZhbHVlLCByZXF1aXJlRGF0YSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBUaGVzZSAqYXJlKiB0aGUgZHJvaWRzIHdlJ3JlIGxvb2tpbmcgZm9yLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLm1lc3NhZ2UubWF0Y2goXCJyZXZlcnRlZFwiKSkge1xuICAgICAgICBjb25zdCBkYXRhID0gaXNIZXhTdHJpbmcodmFsdWUuZGF0YSkgPyB2YWx1ZS5kYXRhIDogbnVsbDtcbiAgICAgICAgaWYgKCFyZXF1aXJlRGF0YSB8fCBkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlOiB2YWx1ZS5tZXNzYWdlLCBkYXRhIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU3BlbHVuayBmdXJ0aGVyLi4uXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzcGVsdW5rKHZhbHVlW2tleV0sIHJlcXVpcmVEYXRhKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBNaWdodCBiZSBhIEpTT04gc3RyaW5nIHdlIGNhbiBmdXJ0aGVyIGRlc2NlbmQuLi5cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzcGVsdW5rKEpTT04ucGFyc2UodmFsdWUpLCByZXF1aXJlRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjaGVja0Vycm9yKG1ldGhvZCwgZXJyb3IsIHBhcmFtcykge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gcGFyYW1zLnRyYW5zYWN0aW9uIHx8IHBhcmFtcy5zaWduZWRUcmFuc2FjdGlvbjtcbiAgICAvLyBVbmRvIHRoZSBcImNvbnZlbmllbmNlXCIgc29tZSBub2RlcyBhcmUgYXR0ZW1wdGluZyB0byBwcmV2ZW50IGJhY2t3YXJkc1xuICAgIC8vIGluY29tcGF0aWJpbGl0eTsgbWF5YmUgZm9yIHY2IGNvbnNpZGVyIGZvcndhcmRpbmcgcmV2ZXJ0cyBhcyBlcnJvcnNcbiAgICBpZiAobWV0aG9kID09PSBcImNhbGxcIikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzcGVsdW5rKGVycm9yLCB0cnVlKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGhpbmcgZGVzY3JpcHRpdmUuLlxuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm1pc3NpbmcgcmV2ZXJ0IGRhdGEgaW4gY2FsbCBleGNlcHRpb247IFRyYW5zYWN0aW9uIHJldmVydGVkIHdpdGhvdXQgYSByZWFzb24gc3RyaW5nXCIsIExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgIGRhdGE6IFwiMHhcIiwgdHJhbnNhY3Rpb24sIGVycm9yXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobWV0aG9kID09PSBcImVzdGltYXRlR2FzXCIpIHtcbiAgICAgICAgLy8gVHJ5IHRvIGZpbmQgc29tZXRoaW5nLCB3aXRoIGEgcHJlZmVyZW5jZSBvbiBTRVJWRVJfRVJST1IgYm9keVxuICAgICAgICBsZXQgcmVzdWx0ID0gc3BlbHVuayhlcnJvci5ib2R5LCBmYWxzZSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3BlbHVuayhlcnJvciwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvdW5kIFwicmV2ZXJ0ZWRcIiwgdGhpcyBpcyBhIENBTExfRVhDRVBUSU9OXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGVzdGltYXRlIGdhczsgdHJhbnNhY3Rpb24gbWF5IGZhaWwgb3IgbWF5IHJlcXVpcmUgbWFudWFsIGdhcyBsaW1pdFwiLCBMb2dnZXIuZXJyb3JzLlVOUFJFRElDVEFCTEVfR0FTX0xJTUlULCB7XG4gICAgICAgICAgICAgICAgcmVhc29uOiByZXN1bHQubWVzc2FnZSwgbWV0aG9kLCB0cmFuc2FjdGlvbiwgZXJyb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEBUT0RPOiBTaG91bGQgd2Ugc3BlbHVuayBmb3IgbWVzc2FnZSB0b28/XG4gICAgbGV0IG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgIGlmIChlcnJvci5jb2RlID09PSBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiAmJiBlcnJvci5lcnJvciAmJiB0eXBlb2YgKGVycm9yLmVycm9yLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBlcnJvci5lcnJvci5tZXNzYWdlO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgKGVycm9yLmJvZHkpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBlcnJvci5ib2R5O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgKGVycm9yLnJlc3BvbnNlVGV4dCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbWVzc2FnZSA9IGVycm9yLnJlc3BvbnNlVGV4dDtcbiAgICB9XG4gICAgbWVzc2FnZSA9IChtZXNzYWdlIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gXCJpbnN1ZmZpY2llbnQgZnVuZHMgZm9yIGdhcyAqIHByaWNlICsgdmFsdWUgKyBjb3N0KGRhdGEpXCJcbiAgICBpZiAobWVzc2FnZS5tYXRjaCgvaW5zdWZmaWNpZW50IGZ1bmRzfGJhc2UgZmVlIGV4Y2VlZHMgZ2FzIGxpbWl0fEluc3VmZmljaWVudEZ1bmRzL2kpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiaW5zdWZmaWNpZW50IGZ1bmRzIGZvciBpbnRyaW5zaWMgdHJhbnNhY3Rpb24gY29zdFwiLCBMb2dnZXIuZXJyb3JzLklOU1VGRklDSUVOVF9GVU5EUywge1xuICAgICAgICAgICAgZXJyb3IsIG1ldGhvZCwgdHJhbnNhY3Rpb25cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFwibm9uY2UgdG9vIGxvd1wiXG4gICAgaWYgKG1lc3NhZ2UubWF0Y2goL25vbmNlIChpcyApP3RvbyBsb3cvaSkpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIiwgTG9nZ2VyLmVycm9ycy5OT05DRV9FWFBJUkVELCB7XG4gICAgICAgICAgICBlcnJvciwgbWV0aG9kLCB0cmFuc2FjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gXCJyZXBsYWNlbWVudCB0cmFuc2FjdGlvbiB1bmRlcnByaWNlZFwiXG4gICAgaWYgKG1lc3NhZ2UubWF0Y2goL3JlcGxhY2VtZW50IHRyYW5zYWN0aW9uIHVuZGVycHJpY2VkfHRyYW5zYWN0aW9uIGdhcyBwcmljZS4qdG9vIGxvdy9pKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsIExvZ2dlci5lcnJvcnMuUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQsIHtcbiAgICAgICAgICAgIGVycm9yLCBtZXRob2QsIHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBcInJlcGxhY2VtZW50IHRyYW5zYWN0aW9uIHVuZGVycHJpY2VkXCJcbiAgICBpZiAobWVzc2FnZS5tYXRjaCgvb25seSByZXBsYXktcHJvdGVjdGVkL2kpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibGVnYWN5IHByZS1laXAtMTU1IHRyYW5zYWN0aW9ucyBub3Qgc3VwcG9ydGVkXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICBlcnJvciwgbWV0aG9kLCB0cmFuc2FjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVycm9yR2FzLmluZGV4T2YobWV0aG9kKSA+PSAwICYmIG1lc3NhZ2UubWF0Y2goL2dhcyByZXF1aXJlZCBleGNlZWRzIGFsbG93YW5jZXxhbHdheXMgZmFpbGluZyB0cmFuc2FjdGlvbnxleGVjdXRpb24gcmV2ZXJ0ZWR8cmV2ZXJ0LykpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgZXN0aW1hdGUgZ2FzOyB0cmFuc2FjdGlvbiBtYXkgZmFpbCBvciBtYXkgcmVxdWlyZSBtYW51YWwgZ2FzIGxpbWl0XCIsIExvZ2dlci5lcnJvcnMuVU5QUkVESUNUQUJMRV9HQVNfTElNSVQsIHtcbiAgICAgICAgICAgIGVycm9yLCBtZXRob2QsIHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbn1cbmZ1bmN0aW9uIHRpbWVyKHRpbWVvdXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFJlc3VsdChwYXlsb2FkKSB7XG4gICAgaWYgKHBheWxvYWQuZXJyb3IpIHtcbiAgICAgICAgLy8gQFRPRE86IG5vdCBhbnlcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IocGF5bG9hZC5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgZXJyb3IuY29kZSA9IHBheWxvYWQuZXJyb3IuY29kZTtcbiAgICAgICAgZXJyb3IuZGF0YSA9IHBheWxvYWQuZXJyb3IuZGF0YTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBwYXlsb2FkLnJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldExvd2VyQ2FzZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgX2NvbnN0cnVjdG9yR3VhcmQgPSB7fTtcbmV4cG9ydCBjbGFzcyBKc29uUnBjU2lnbmVyIGV4dGVuZHMgU2lnbmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvckd1YXJkLCBwcm92aWRlciwgYWRkcmVzc09ySW5kZXgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yR3VhcmQgIT09IF9jb25zdHJ1Y3Rvckd1YXJkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkbyBub3QgY2FsbCB0aGUgSnNvblJwY1NpZ25lciBjb25zdHJ1Y3RvciBkaXJlY3RseTsgdXNlIHByb3ZpZGVyLmdldFNpZ25lclwiKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyKTtcbiAgICAgICAgaWYgKGFkZHJlc3NPckluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgIGFkZHJlc3NPckluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChhZGRyZXNzT3JJbmRleCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2FkZHJlc3NcIiwgdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhhZGRyZXNzT3JJbmRleCkpO1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfaW5kZXhcIiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIChhZGRyZXNzT3JJbmRleCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2luZGV4XCIsIGFkZHJlc3NPckluZGV4KTtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2FkZHJlc3NcIiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzIG9yIGluZGV4XCIsIFwiYWRkcmVzc09ySW5kZXhcIiwgYWRkcmVzc09ySW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGFsdGVyIEpTT04tUlBDIFNpZ25lciBjb25uZWN0aW9uXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiY29ubmVjdFwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25uZWN0VW5jaGVja2VkKCkge1xuICAgICAgICByZXR1cm4gbmV3IFVuY2hlY2tlZEpzb25ScGNTaWduZXIoX2NvbnN0cnVjdG9yR3VhcmQsIHRoaXMucHJvdmlkZXIsIHRoaXMuX2FkZHJlc3MgfHwgdGhpcy5faW5kZXgpO1xuICAgIH1cbiAgICBnZXRBZGRyZXNzKCkge1xuICAgICAgICBpZiAodGhpcy5fYWRkcmVzcykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9hZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX2FjY291bnRzXCIsIFtdKS50aGVuKChhY2NvdW50cykgPT4ge1xuICAgICAgICAgICAgaWYgKGFjY291bnRzLmxlbmd0aCA8PSB0aGlzLl9pbmRleCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5rbm93biBhY2NvdW50ICNcIiArIHRoaXMuX2luZGV4LCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0QWRkcmVzc1wiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhhY2NvdW50c1t0aGlzLl9pbmRleF0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uID0gc2hhbGxvd0NvcHkodHJhbnNhY3Rpb24pO1xuICAgICAgICBjb25zdCBmcm9tQWRkcmVzcyA9IHRoaXMuZ2V0QWRkcmVzcygpLnRoZW4oKGFkZHJlc3MpID0+IHtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhlIEpTT04tUlBDIGZvciBldGhfc2VuZFRyYW5zYWN0aW9uIHVzZXMgOTAwMDAgZ2FzOyBpZiB0aGUgdXNlclxuICAgICAgICAvLyB3aXNoZXMgdG8gdXNlIHRoaXMsIGl0IGlzIGVhc3kgdG8gc3BlY2lmeSBleHBsaWNpdGx5LCBvdGhlcndpc2VcbiAgICAgICAgLy8gd2UgbG9vayBpdCB1cCBmb3IgdGhlbS5cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlID0gc2hhbGxvd0NvcHkodHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgZXN0aW1hdGUuZnJvbSA9IGZyb21BZGRyZXNzO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uZ2FzTGltaXQgPSB0aGlzLnByb3ZpZGVyLmVzdGltYXRlR2FzKGVzdGltYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNhY3Rpb24udG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24udG8gPSBQcm9taXNlLnJlc29sdmUodHJhbnNhY3Rpb24udG8pLnRoZW4oKHRvKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLnJlc29sdmVOYW1lKHRvKTtcbiAgICAgICAgICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJwcm92aWRlZCBFTlMgbmFtZSByZXNvbHZlcyB0byBudWxsXCIsIFwidHgudG9cIiwgdG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgdHg6IHJlc29sdmVQcm9wZXJ0aWVzKHRyYW5zYWN0aW9uKSxcbiAgICAgICAgICAgIHNlbmRlcjogZnJvbUFkZHJlc3NcbiAgICAgICAgfSkudGhlbigoeyB0eCwgc2VuZGVyIH0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eC5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHguZnJvbS50b0xvd2VyQ2FzZSgpICE9PSBzZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0eC5mcm9tID0gc2VuZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGV4VHggPSB0aGlzLnByb3ZpZGVyLmNvbnN0cnVjdG9yLmhleGxpZnlUcmFuc2FjdGlvbih0eCwgeyBmcm9tOiB0cnVlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zZW5kVHJhbnNhY3Rpb25cIiwgW2hleFR4XSkudGhlbigoaGFzaCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoZXJyb3IubWVzc2FnZSkgPT09IFwic3RyaW5nXCIgJiYgZXJyb3IubWVzc2FnZS5tYXRjaCgvdXNlciBkZW5pZWQvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1c2VyIHJlamVjdGVkIHRyYW5zYWN0aW9uXCIsIExvZ2dlci5lcnJvcnMuQUNUSU9OX1JFSkVDVEVELCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwic2VuZFRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja0Vycm9yKFwic2VuZFRyYW5zYWN0aW9uXCIsIGVycm9yLCBoZXhUeCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJzaWduaW5nIHRyYW5zYWN0aW9ucyBpcyB1bnN1cHBvcnRlZFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNpZ25UcmFuc2FjdGlvblwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2Fubm90IGJlIG1pbmVkIGFueSBlYXJsaWVyIHRoYW4gYW55IHJlY2VudCBibG9ja1xuICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnByb3ZpZGVyLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAvLyBTZW5kIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICAgICAgY29uc3QgaGFzaCA9IHlpZWxkIHRoaXMuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgSlNPTi1SUEMgb25seSBwcm92aWRlcyBhbmQgb3BhcXVlIHRyYW5zYWN0aW9uIGhhc2hcbiAgICAgICAgICAgICAgICAvLyBmb3IgYSByZXNwb25zZSwgYW5kIHdlIG5lZWQgdGhlIGFjdHVhbCB0cmFuc2FjdGlvbiwgc28gd2UgcG9sbFxuICAgICAgICAgICAgICAgIC8vIGZvciBpdDsgaXQgc2hvdWxkIHNob3cgdXAgdmVyeSBxdWlja2x5XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHBvbGwoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IHlpZWxkIHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24oaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5fd3JhcFRyYW5zYWN0aW9uKHR4LCBoYXNoLCBibG9ja051bWJlcik7XG4gICAgICAgICAgICAgICAgfSksIHsgb25jZVBvbGw6IHRoaXMucHJvdmlkZXIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvci50cmFuc2FjdGlvbkhhc2ggPSBoYXNoO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9ICgodHlwZW9mIChtZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikgPyB0b1V0ZjhCeXRlcyhtZXNzYWdlKSA6IG1lc3NhZ2UpO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5zZW5kKFwicGVyc29uYWxfc2lnblwiLCBbaGV4bGlmeShkYXRhKSwgYWRkcmVzcy50b0xvd2VyQ2FzZSgpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChlcnJvci5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiBlcnJvci5tZXNzYWdlLm1hdGNoKC91c2VyIGRlbmllZC9pKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVzZXIgcmVqZWN0ZWQgc2lnbmluZ1wiLCBMb2dnZXIuZXJyb3JzLkFDVElPTl9SRUpFQ1RFRCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInNpZ25NZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZURhdGE6IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2xlZ2FjeVNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSAoKHR5cGVvZiAobWVzc2FnZSkgPT09IFwic3RyaW5nXCIpID8gdG9VdGY4Qnl0ZXMobWVzc2FnZSkgOiBtZXNzYWdlKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB5aWVsZCB0aGlzLmdldEFkZHJlc3MoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9KU09OLVJQQyNldGhfc2lnblxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2lnblwiLCBbYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBoZXhsaWZ5KGRhdGEpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChlcnJvci5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiBlcnJvci5tZXNzYWdlLm1hdGNoKC91c2VyIGRlbmllZC9pKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVzZXIgcmVqZWN0ZWQgc2lnbmluZ1wiLCBMb2dnZXIuZXJyb3JzLkFDVElPTl9SRUpFQ1RFRCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcIl9sZWdhY3lTaWduTWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VEYXRhOiBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9zaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBQb3B1bGF0ZSBhbnkgRU5TIG5hbWVzIChpbi1wbGFjZSlcbiAgICAgICAgICAgIGNvbnN0IHBvcHVsYXRlZCA9IHlpZWxkIF9UeXBlZERhdGFFbmNvZGVyLnJlc29sdmVOYW1lcyhkb21haW4sIHR5cGVzLCB2YWx1ZSwgKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5yZXNvbHZlTmFtZShuYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25UeXBlZERhdGFfdjRcIiwgW1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KF9UeXBlZERhdGFFbmNvZGVyLmdldFBheWxvYWQocG9wdWxhdGVkLmRvbWFpbiwgdHlwZXMsIHBvcHVsYXRlZC52YWx1ZSkpXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChlcnJvci5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiBlcnJvci5tZXNzYWdlLm1hdGNoKC91c2VyIGRlbmllZC9pKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVzZXIgcmVqZWN0ZWQgc2lnbmluZ1wiLCBMb2dnZXIuZXJyb3JzLkFDVElPTl9SRUpFQ1RFRCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcIl9zaWduVHlwZWREYXRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZURhdGE6IHsgZG9tYWluOiBwb3B1bGF0ZWQuZG9tYWluLCB0eXBlcywgdmFsdWU6IHBvcHVsYXRlZC52YWx1ZSB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVubG9jayhwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLnByb3ZpZGVyO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLnNlbmQoXCJwZXJzb25hbF91bmxvY2tBY2NvdW50XCIsIFthZGRyZXNzLnRvTG93ZXJDYXNlKCksIHBhc3N3b3JkLCBudWxsXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFVuY2hlY2tlZEpzb25ScGNTaWduZXIgZXh0ZW5kcyBKc29uUnBjU2lnbmVyIHtcbiAgICBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKS50aGVuKChoYXNoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGhhc2g6IGhhc2gsXG4gICAgICAgICAgICAgICAgbm9uY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgZ2FzTGltaXQ6IG51bGwsXG4gICAgICAgICAgICAgICAgZ2FzUHJpY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBudWxsLFxuICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnM6IDAsXG4gICAgICAgICAgICAgICAgZnJvbTogbnVsbCxcbiAgICAgICAgICAgICAgICB3YWl0OiAoY29uZmlybWF0aW9ucykgPT4geyByZXR1cm4gdGhpcy5wcm92aWRlci53YWl0Rm9yVHJhbnNhY3Rpb24oaGFzaCwgY29uZmlybWF0aW9ucyk7IH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNvbnN0IGFsbG93ZWRUcmFuc2FjdGlvbktleXMgPSB7XG4gICAgY2hhaW5JZDogdHJ1ZSwgZGF0YTogdHJ1ZSwgZ2FzTGltaXQ6IHRydWUsIGdhc1ByaWNlOiB0cnVlLCBub25jZTogdHJ1ZSwgdG86IHRydWUsIHZhbHVlOiB0cnVlLFxuICAgIHR5cGU6IHRydWUsIGFjY2Vzc0xpc3Q6IHRydWUsXG4gICAgbWF4RmVlUGVyR2FzOiB0cnVlLCBtYXhQcmlvcml0eUZlZVBlckdhczogdHJ1ZVxufTtcbmV4cG9ydCBjbGFzcyBKc29uUnBjUHJvdmlkZXIgZXh0ZW5kcyBCYXNlUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgbmV0d29yaykge1xuICAgICAgICBsZXQgbmV0d29ya09yUmVhZHkgPSBuZXR3b3JrO1xuICAgICAgICAvLyBUaGUgbmV0d29yayBpcyB1bmtub3duLCBxdWVyeSB0aGUgSlNPTi1SUEMgZm9yIGl0XG4gICAgICAgIGlmIChuZXR3b3JrT3JSZWFkeSA9PSBudWxsKSB7XG4gICAgICAgICAgICBuZXR3b3JrT3JSZWFkeSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXRlY3ROZXR3b3JrKCkudGhlbigobmV0d29yaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKG5ldHdvcmtPclJlYWR5KTtcbiAgICAgICAgLy8gRGVmYXVsdCBVUkxcbiAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgIHVybCA9IGdldFN0YXRpYyh0aGlzLmNvbnN0cnVjdG9yLCBcImRlZmF1bHRVcmxcIikoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh1cmwpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImNvbm5lY3Rpb25cIiwgT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiY29ubmVjdGlvblwiLCBPYmplY3QuZnJlZXplKHNoYWxsb3dDb3B5KHVybCkpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9uZXh0SWQgPSA0MjtcbiAgICB9XG4gICAgZ2V0IF9jYWNoZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50TG9vcENhY2hlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50TG9vcENhY2hlID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50TG9vcENhY2hlO1xuICAgIH1cbiAgICBzdGF0aWMgZGVmYXVsdFVybCgpIHtcbiAgICAgICAgcmV0dXJuIFwiaHR0cDovXFwvbG9jYWxob3N0Ojg1NDVcIjtcbiAgICB9XG4gICAgZGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZVtcImRldGVjdE5ldHdvcmtcIl0pIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlW1wiZGV0ZWN0TmV0d29ya1wiXSA9IHRoaXMuX3VuY2FjaGVkRGV0ZWN0TmV0d29yaygpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhpcyBjYWNoZSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXh0IGV2ZW50IGxvb3BcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlW1wiZGV0ZWN0TmV0d29ya1wiXSA9IG51bGw7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVbXCJkZXRlY3ROZXR3b3JrXCJdO1xuICAgIH1cbiAgICBfdW5jYWNoZWREZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGltZXIoMCk7XG4gICAgICAgICAgICBsZXQgY2hhaW5JZCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSB5aWVsZCB0aGlzLnNlbmQoXCJldGhfY2hhaW5JZFwiLCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjaGFpbklkID0geWllbGQgdGhpcy5zZW5kKFwibmV0X3ZlcnNpb25cIiwgW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdldE5ldHdvcmsgPSBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJnZXROZXR3b3JrXCIpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXROZXR3b3JrKEJpZ051bWJlci5mcm9tKGNoYWluSWQpLnRvTnVtYmVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY291bGQgbm90IGRldGVjdCBuZXR3b3JrXCIsIExvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogY2hhaW5JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImludmFsaWROZXR3b3JrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJFcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY291bGQgbm90IGRldGVjdCBuZXR3b3JrXCIsIExvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiwge1xuICAgICAgICAgICAgICAgIGV2ZW50OiBcIm5vTmV0d29ya1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFNpZ25lcihhZGRyZXNzT3JJbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IEpzb25ScGNTaWduZXIoX2NvbnN0cnVjdG9yR3VhcmQsIHRoaXMsIGFkZHJlc3NPckluZGV4KTtcbiAgICB9XG4gICAgZ2V0VW5jaGVja2VkU2lnbmVyKGFkZHJlc3NPckluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNpZ25lcihhZGRyZXNzT3JJbmRleCkuY29ubmVjdFVuY2hlY2tlZCgpO1xuICAgIH1cbiAgICBsaXN0QWNjb3VudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pLnRoZW4oKGFjY291bnRzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYWNjb3VudHMubWFwKChhKSA9PiB0aGlzLmZvcm1hdHRlci5hZGRyZXNzKGEpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICBpZDogKHRoaXMuX25leHRJZCsrKSxcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCJcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RcIixcbiAgICAgICAgICAgIHJlcXVlc3Q6IGRlZXBDb3B5KHJlcXVlc3QpLFxuICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdlIGNhbiBleHBhbmQgdGhpcyBpbiB0aGUgZnV0dXJlIHRvIGFueSBjYWxsLCBidXQgZm9yIG5vdyB0aGVzZVxuICAgICAgICAvLyBhcmUgdGhlIGJpZ2dlc3Qgd2lucyBhbmQgZG8gbm90IHJlcXVpcmUgYW55IHNlcmlhbGl6aW5nIHBhcmFtZXRlcnMuXG4gICAgICAgIGNvbnN0IGNhY2hlID0gKFtcImV0aF9jaGFpbklkXCIsIFwiZXRoX2Jsb2NrTnVtYmVyXCJdLmluZGV4T2YobWV0aG9kKSA+PSAwKTtcbiAgICAgICAgaWYgKGNhY2hlICYmIHRoaXMuX2NhY2hlW21ldGhvZF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZVttZXRob2RdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGZldGNoSnNvbih0aGlzLmNvbm5lY3Rpb24sIEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpLCBnZXRSZXN1bHQpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENhY2hlIHRoZSBmZXRjaCwgYnV0IGNsZWFyIGl0IG9uIHRoZSBuZXh0IGV2ZW50IGxvb3BcbiAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZVttZXRob2RdID0gcmVzdWx0O1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVbbWV0aG9kXSA9IG51bGw7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBwcmVwYXJlUmVxdWVzdChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrTnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9ibG9ja051bWJlclwiLCBbXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0R2FzUHJpY2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dhc1ByaWNlXCIsIFtdXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRCYWxhbmNlXCIsIFtnZXRMb3dlckNhc2UocGFyYW1zLmFkZHJlc3MpLCBwYXJhbXMuYmxvY2tUYWddXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvbkNvdW50XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRUcmFuc2FjdGlvbkNvdW50XCIsIFtnZXRMb3dlckNhc2UocGFyYW1zLmFkZHJlc3MpLCBwYXJhbXMuYmxvY2tUYWddXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRDb2RlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRDb2RlXCIsIFtnZXRMb3dlckNhc2UocGFyYW1zLmFkZHJlc3MpLCBwYXJhbXMuYmxvY2tUYWddXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlQXRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldFN0b3JhZ2VBdFwiLCBbZ2V0TG93ZXJDYXNlKHBhcmFtcy5hZGRyZXNzKSwgaGV4WmVyb1BhZChwYXJhbXMucG9zaXRpb24sIDMyKSwgcGFyYW1zLmJsb2NrVGFnXV07XG4gICAgICAgICAgICBjYXNlIFwic2VuZFRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIiwgW3BhcmFtcy5zaWduZWRUcmFuc2FjdGlvbl1dO1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrXCI6XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5ibG9ja1RhZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldEJsb2NrQnlOdW1iZXJcIiwgW3BhcmFtcy5ibG9ja1RhZywgISFwYXJhbXMuaW5jbHVkZVRyYW5zYWN0aW9uc11dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbXMuYmxvY2tIYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0QmxvY2tCeUhhc2hcIiwgW3BhcmFtcy5ibG9ja0hhc2gsICEhcGFyYW1zLmluY2x1ZGVUcmFuc2FjdGlvbnNdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoXCIsIFtwYXJhbXMudHJhbnNhY3Rpb25IYXNoXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHRcIiwgW3BhcmFtcy50cmFuc2FjdGlvbkhhc2hdXTtcbiAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZXhsaWZ5VHJhbnNhY3Rpb24gPSBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJoZXhsaWZ5VHJhbnNhY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9jYWxsXCIsIFtoZXhsaWZ5VHJhbnNhY3Rpb24ocGFyYW1zLnRyYW5zYWN0aW9uLCB7IGZyb206IHRydWUgfSksIHBhcmFtcy5ibG9ja1RhZ11dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImVzdGltYXRlR2FzXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZXhsaWZ5VHJhbnNhY3Rpb24gPSBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJoZXhsaWZ5VHJhbnNhY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9lc3RpbWF0ZUdhc1wiLCBbaGV4bGlmeVRyYW5zYWN0aW9uKHBhcmFtcy50cmFuc2FjdGlvbiwgeyBmcm9tOiB0cnVlIH0pXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOlxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyICYmIHBhcmFtcy5maWx0ZXIuYWRkcmVzcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5maWx0ZXIuYWRkcmVzcyA9IGdldExvd2VyQ2FzZShwYXJhbXMuZmlsdGVyLmFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldExvZ3NcIiwgW3BhcmFtcy5maWx0ZXJdXTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBlcmZvcm0obWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIExlZ2FjeSBuZXR3b3JrcyBkbyBub3QgbGlrZSB0aGUgdHlwZSBmaWVsZCBiZWluZyBwYXNzZWQgYWxvbmcgKHdoaWNoXG4gICAgICAgICAgICAvLyBpcyBmYWlyKSwgc28gd2UgZGVsZXRlIHR5cGUgaWYgaXQgaXMgMCBhbmQgYSBub24tRUlQLTE1NTkgbmV0d29ya1xuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJjYWxsXCIgfHwgbWV0aG9kID09PSBcImVzdGltYXRlR2FzXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0eCA9IHBhcmFtcy50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAodHggJiYgdHgudHlwZSAhPSBudWxsICYmIEJpZ051bWJlci5mcm9tKHR4LnR5cGUpLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBFSVAtMTU1OSBwcm9wZXJ0aWVzLCBpdCBtaWdodCBiZSBub24tRUlQLTE1NTlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lm1heEZlZVBlckdhcyA9PSBudWxsICYmIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSB5aWVsZCB0aGlzLmdldEZlZURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZWVEYXRhLm1heEZlZVBlckdhcyA9PSBudWxsICYmIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldHdvcmsgZG9lc24ndCBrbm93IGFib3V0IEVJUC0xNTU5IChhbmQgaGVuY2UgdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBzaGFsbG93Q29weShwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy50cmFuc2FjdGlvbiA9IHNoYWxsb3dDb3B5KHR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGFyYW1zLnRyYW5zYWN0aW9uLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5wcmVwYXJlUmVxdWVzdChtZXRob2QsIHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoYXJncyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IobWV0aG9kICsgXCIgbm90IGltcGxlbWVudGVkXCIsIExvZ2dlci5lcnJvcnMuTk9UX0lNUExFTUVOVEVELCB7IG9wZXJhdGlvbjogbWV0aG9kIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5zZW5kKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrRXJyb3IobWV0aG9kLCBlcnJvciwgcGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9zdGFydEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50YWcgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFBlbmRpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5fc3RhcnRFdmVudChldmVudCk7XG4gICAgfVxuICAgIF9zdGFydFBlbmRpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wZW5kaW5nRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgcGVuZGluZ0ZpbHRlciA9IHRoaXMuc2VuZChcImV0aF9uZXdQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXJcIiwgW10pO1xuICAgICAgICB0aGlzLl9wZW5kaW5nRmlsdGVyID0gcGVuZGluZ0ZpbHRlcjtcbiAgICAgICAgcGVuZGluZ0ZpbHRlci50aGVuKGZ1bmN0aW9uIChmaWx0ZXJJZCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gcG9sbCgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNlbmQoXCJldGhfZ2V0RmlsdGVyQ2hhbmdlc1wiLCBbZmlsdGVySWRdKS50aGVuKGZ1bmN0aW9uIChoYXNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX3BlbmRpbmdGaWx0ZXIgIT0gcGVuZGluZ0ZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlcSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBoYXNoZXMuZm9yRWFjaChmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IFRoaXMgc2hvdWxkIGJlIGdhcmJhZ2UgY29sbGVjdGVkIGF0IHNvbWUgcG9pbnQuLi4gSG93PyBXaGVuP1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fZW1pdHRlZFtcInQ6XCIgKyBoYXNoLnRvTG93ZXJDYXNlKCldID0gXCJwZW5kaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXEgPSBzZXEudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0VHJhbnNhY3Rpb24oaGFzaCkudGhlbihmdW5jdGlvbiAodHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwicGVuZGluZ1wiLCB0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VxLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVyKDEwMDApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX3BlbmRpbmdGaWx0ZXIgIT0gcGVuZGluZ0ZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZW5kKFwiZXRoX3VuaW5zdGFsbEZpbHRlclwiLCBbZmlsdGVySWRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcG9sbCgpOyB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9sbCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcklkO1xuICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHsgfSk7XG4gICAgfVxuICAgIF9zdG9wRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnRhZyA9PT0gXCJwZW5kaW5nXCIgJiYgdGhpcy5saXN0ZW5lckNvdW50KFwicGVuZGluZ1wiKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0ZpbHRlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuX3N0b3BFdmVudChldmVudCk7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgYW4gZXRoZXJzLmpzIHRyYW5zYWN0aW9uIGludG8gYSBKU09OLVJQQyB0cmFuc2FjdGlvblxuICAgIC8vICAtIGdhc0xpbWl0ID0+IGdhc1xuICAgIC8vICAtIEFsbCB2YWx1ZXMgaGV4bGlmaWVkXG4gICAgLy8gIC0gQWxsIG51bWVyaWMgdmFsdWVzIHplcm8tc3RyaXBlZFxuICAgIC8vICAtIEFsbCBhZGRyZXNzZXMgYXJlIGxvd2VyY2FzZWRcbiAgICAvLyBOT1RFOiBUaGlzIGFsbG93cyBhIFRyYW5zYWN0aW9uUmVxdWVzdCwgYnV0IGFsbCB2YWx1ZXMgc2hvdWxkIGJlIHJlc29sdmVkXG4gICAgLy8gICAgICAgYmVmb3JlIHRoaXMgaXMgY2FsbGVkXG4gICAgLy8gQFRPRE86IFRoaXMgd2lsbCBsaWtlbHkgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMgYW5kIHByZXBhcmVSZXF1ZXN0XG4gICAgLy8gICAgICAgIHdpbGwgYmUgdGhlIHByZWZlcnJlZCBtZXRob2QgZm9yIHRoaXMuXG4gICAgc3RhdGljIGhleGxpZnlUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgYWxsb3dFeHRyYSkge1xuICAgICAgICAvLyBDaGVjayBvbmx5IGFsbG93ZWQgcHJvcGVydGllcyBhcmUgZ2l2ZW5cbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IHNoYWxsb3dDb3B5KGFsbG93ZWRUcmFuc2FjdGlvbktleXMpO1xuICAgICAgICBpZiAoYWxsb3dFeHRyYSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYWxsb3dFeHRyYSkge1xuICAgICAgICAgICAgICAgIGlmIChhbGxvd0V4dHJhW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dlZFtrZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tQcm9wZXJ0aWVzKHRyYW5zYWN0aW9uLCBhbGxvd2VkKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIC8vIEpTT04tUlBDIG5vdyByZXF1aXJlcyBudW1lcmljIHZhbHVlcyB0byBiZSBcInF1YW50aXR5XCIgdmFsdWVzXG4gICAgICAgIFtcImNoYWluSWRcIiwgXCJnYXNMaW1pdFwiLCBcImdhc1ByaWNlXCIsIFwidHlwZVwiLCBcIm1heEZlZVBlckdhc1wiLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwibm9uY2VcIiwgXCJ2YWx1ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGhleFZhbHVlKEJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uW2tleV0pKTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwiZ2FzTGltaXRcIikge1xuICAgICAgICAgICAgICAgIGtleSA9IFwiZ2FzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgW1wiZnJvbVwiLCBcInRvXCIsIFwiZGF0YVwiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGhleGxpZnkodHJhbnNhY3Rpb25ba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24uYWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgcmVzdWx0W1wiYWNjZXNzTGlzdFwiXSA9IGFjY2Vzc0xpc3RpZnkodHJhbnNhY3Rpb24uYWNjZXNzTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29uLXJwYy1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiU2lnbmVyIiwiQmlnTnVtYmVyIiwiaGV4bGlmeSIsImhleFZhbHVlIiwiaGV4WmVyb1BhZCIsImlzSGV4U3RyaW5nIiwiX1R5cGVkRGF0YUVuY29kZXIiLCJjaGVja1Byb3BlcnRpZXMiLCJkZWVwQ29weSIsImRlZmluZVJlYWRPbmx5IiwiZ2V0U3RhdGljIiwicmVzb2x2ZVByb3BlcnRpZXMiLCJzaGFsbG93Q29weSIsInRvVXRmOEJ5dGVzIiwiYWNjZXNzTGlzdGlmeSIsImZldGNoSnNvbiIsInBvbGwiLCJMb2dnZXIiLCJ2ZXJzaW9uIiwibG9nZ2VyIiwiQmFzZVByb3ZpZGVyIiwiZXJyb3JHYXMiLCJzcGVsdW5rIiwicmVxdWlyZURhdGEiLCJtZXNzYWdlIiwibWF0Y2giLCJkYXRhIiwia2V5IiwiSlNPTiIsInBhcnNlIiwiZXJyb3IiLCJjaGVja0Vycm9yIiwibWV0aG9kIiwicGFyYW1zIiwidHJhbnNhY3Rpb24iLCJzaWduZWRUcmFuc2FjdGlvbiIsInRocm93RXJyb3IiLCJlcnJvcnMiLCJDQUxMX0VYQ0VQVElPTiIsImJvZHkiLCJVTlBSRURJQ1RBQkxFX0dBU19MSU1JVCIsInJlYXNvbiIsImNvZGUiLCJTRVJWRVJfRVJST1IiLCJyZXNwb25zZVRleHQiLCJ0b0xvd2VyQ2FzZSIsIklOU1VGRklDSUVOVF9GVU5EUyIsIk5PTkNFX0VYUElSRUQiLCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCIsIlVOU1VQUE9SVEVEX09QRVJBVElPTiIsImluZGV4T2YiLCJ0aW1lciIsInRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZ2V0UmVzdWx0IiwicGF5bG9hZCIsIkVycm9yIiwiZ2V0TG93ZXJDYXNlIiwiX2NvbnN0cnVjdG9yR3VhcmQiLCJKc29uUnBjU2lnbmVyIiwiY29uc3RydWN0b3IiLCJjb25zdHJ1Y3Rvckd1YXJkIiwicHJvdmlkZXIiLCJhZGRyZXNzT3JJbmRleCIsImZvcm1hdHRlciIsImFkZHJlc3MiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJjb25uZWN0Iiwib3BlcmF0aW9uIiwiY29ubmVjdFVuY2hlY2tlZCIsIlVuY2hlY2tlZEpzb25ScGNTaWduZXIiLCJfYWRkcmVzcyIsIl9pbmRleCIsImdldEFkZHJlc3MiLCJzZW5kIiwiYWNjb3VudHMiLCJsZW5ndGgiLCJzZW5kVW5jaGVja2VkVHJhbnNhY3Rpb24iLCJmcm9tQWRkcmVzcyIsImdhc0xpbWl0IiwiZXN0aW1hdGUiLCJmcm9tIiwiZXN0aW1hdGVHYXMiLCJ0byIsInJlc29sdmVOYW1lIiwidHgiLCJzZW5kZXIiLCJoZXhUeCIsImhleGxpZnlUcmFuc2FjdGlvbiIsImhhc2giLCJBQ1RJT05fUkVKRUNURUQiLCJhY3Rpb24iLCJzaWduVHJhbnNhY3Rpb24iLCJzZW5kVHJhbnNhY3Rpb24iLCJibG9ja051bWJlciIsIl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyIiwicG9sbGluZ0ludGVydmFsIiwiZ2V0VHJhbnNhY3Rpb24iLCJ1bmRlZmluZWQiLCJfd3JhcFRyYW5zYWN0aW9uIiwib25jZVBvbGwiLCJ0cmFuc2FjdGlvbkhhc2giLCJzaWduTWVzc2FnZSIsIm1lc3NhZ2VEYXRhIiwiX2xlZ2FjeVNpZ25NZXNzYWdlIiwiX3NpZ25UeXBlZERhdGEiLCJkb21haW4iLCJ0eXBlcyIsInBvcHVsYXRlZCIsInJlc29sdmVOYW1lcyIsIm5hbWUiLCJzdHJpbmdpZnkiLCJnZXRQYXlsb2FkIiwidW5sb2NrIiwicGFzc3dvcmQiLCJub25jZSIsImdhc1ByaWNlIiwiY2hhaW5JZCIsImNvbmZpcm1hdGlvbnMiLCJ3YWl0Iiwid2FpdEZvclRyYW5zYWN0aW9uIiwiYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyIsInR5cGUiLCJhY2Nlc3NMaXN0IiwibWF4RmVlUGVyR2FzIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJKc29uUnBjUHJvdmlkZXIiLCJ1cmwiLCJuZXR3b3JrIiwibmV0d29ya09yUmVhZHkiLCJkZXRlY3ROZXR3b3JrIiwiT2JqZWN0IiwiZnJlZXplIiwiX25leHRJZCIsIl9jYWNoZSIsIl9ldmVudExvb3BDYWNoZSIsImRlZmF1bHRVcmwiLCJfdW5jYWNoZWREZXRlY3ROZXR3b3JrIiwiZ2V0TmV0d29yayIsInRvTnVtYmVyIiwiTkVUV09SS19FUlJPUiIsImV2ZW50Iiwic2VydmVyRXJyb3IiLCJnZXRTaWduZXIiLCJnZXRVbmNoZWNrZWRTaWduZXIiLCJsaXN0QWNjb3VudHMiLCJtYXAiLCJhIiwicmVxdWVzdCIsImlkIiwianNvbnJwYyIsImVtaXQiLCJjYWNoZSIsImNvbm5lY3Rpb24iLCJyZXNwb25zZSIsInByZXBhcmVSZXF1ZXN0IiwiYmxvY2tUYWciLCJwb3NpdGlvbiIsImluY2x1ZGVUcmFuc2FjdGlvbnMiLCJibG9ja0hhc2giLCJmaWx0ZXIiLCJwZXJmb3JtIiwiaXNaZXJvIiwiZmVlRGF0YSIsImdldEZlZURhdGEiLCJhcmdzIiwiTk9UX0lNUExFTUVOVEVEIiwiX3N0YXJ0RXZlbnQiLCJ0YWciLCJfc3RhcnRQZW5kaW5nIiwiX3BlbmRpbmdGaWx0ZXIiLCJzZWxmIiwicGVuZGluZ0ZpbHRlciIsImZpbHRlcklkIiwiaGFzaGVzIiwic2VxIiwiZm9yRWFjaCIsIl9lbWl0dGVkIiwiY2F0Y2giLCJfc3RvcEV2ZW50IiwibGlzdGVuZXJDb3VudCIsImFsbG93RXh0cmEiLCJhbGxvd2VkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/web3-provider.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/web3-provider.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Web3Provider: () => (/* binding */ Web3Provider)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* harmony import */ var _json_rpc_provider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./json-rpc-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js\");\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nlet _nextId = 1;\nfunction buildWeb3LegacyFetcher(provider, sendFunc) {\n    const fetcher = \"Web3LegacyFetcher\";\n    return function(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: _nextId++,\n            jsonrpc: \"2.0\"\n        };\n        return new Promise((resolve, reject)=>{\n            this.emit(\"debug\", {\n                action: \"request\",\n                fetcher,\n                request: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.deepCopy)(request),\n                provider: this\n            });\n            sendFunc(request, (error, response)=>{\n                if (error) {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        fetcher,\n                        error,\n                        request,\n                        provider: this\n                    });\n                    return reject(error);\n                }\n                this.emit(\"debug\", {\n                    action: \"response\",\n                    fetcher,\n                    request,\n                    response,\n                    provider: this\n                });\n                if (response.error) {\n                    const error = new Error(response.error.message);\n                    error.code = response.error.code;\n                    error.data = response.error.data;\n                    return reject(error);\n                }\n                resolve(response.result);\n            });\n        });\n    };\n}\nfunction buildEip1193Fetcher(provider) {\n    return function(method, params) {\n        if (params == null) {\n            params = [];\n        }\n        const request = {\n            method,\n            params\n        };\n        this.emit(\"debug\", {\n            action: \"request\",\n            fetcher: \"Eip1193Fetcher\",\n            request: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.deepCopy)(request),\n            provider: this\n        });\n        return provider.request(request).then((response)=>{\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                response,\n                provider: this\n            });\n            return response;\n        }, (error)=>{\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                error,\n                provider: this\n            });\n            throw error;\n        });\n    };\n}\nclass Web3Provider extends _json_rpc_provider__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider {\n    constructor(provider, network){\n        if (provider == null) {\n            logger.throwArgumentError(\"missing provider\", \"provider\", provider);\n        }\n        let path = null;\n        let jsonRpcFetchFunc = null;\n        let subprovider = null;\n        if (typeof provider === \"function\") {\n            path = \"unknown:\";\n            jsonRpcFetchFunc = provider;\n        } else {\n            path = provider.host || provider.path || \"\";\n            if (!path && provider.isMetaMask) {\n                path = \"metamask\";\n            }\n            subprovider = provider;\n            if (provider.request) {\n                if (path === \"\") {\n                    path = \"eip-1193:\";\n                }\n                jsonRpcFetchFunc = buildEip1193Fetcher(provider);\n            } else if (provider.sendAsync) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));\n            } else if (provider.send) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));\n            } else {\n                logger.throwArgumentError(\"unsupported provider\", \"provider\", provider);\n            }\n            if (!path) {\n                path = \"unknown:\";\n            }\n        }\n        super(path, network);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"jsonRpcFetchFunc\", jsonRpcFetchFunc);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"provider\", subprovider);\n    }\n    send(method, params) {\n        return this.jsonRpcFetchFunc(method, params);\n    }\n} //# sourceMappingURL=web3-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS93ZWIzLXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWE7QUFDd0Q7QUFDdEI7QUFDVjtBQUNyQyxNQUFNSSxTQUFTLElBQUlGLHlEQUFNQSxDQUFDQyw2Q0FBT0E7QUFDcUI7QUFDdEQsSUFBSUcsVUFBVTtBQUNkLFNBQVNDLHVCQUF1QkMsUUFBUSxFQUFFQyxRQUFRO0lBQzlDLE1BQU1DLFVBQVU7SUFDaEIsT0FBTyxTQUFVQyxNQUFNLEVBQUVDLE1BQU07UUFDM0IsTUFBTUMsVUFBVTtZQUNaRixRQUFRQTtZQUNSQyxRQUFRQTtZQUNSRSxJQUFLUjtZQUNMUyxTQUFTO1FBQ2I7UUFDQSxPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDekIsSUFBSSxDQUFDQyxJQUFJLENBQUMsU0FBUztnQkFDZkMsUUFBUTtnQkFDUlY7Z0JBQ0FHLFNBQVNiLG1FQUFRQSxDQUFDYTtnQkFDbEJMLFVBQVUsSUFBSTtZQUNsQjtZQUNBQyxTQUFTSSxTQUFTLENBQUNRLE9BQU9DO2dCQUN0QixJQUFJRCxPQUFPO29CQUNQLElBQUksQ0FBQ0YsSUFBSSxDQUFDLFNBQVM7d0JBQ2ZDLFFBQVE7d0JBQ1JWO3dCQUNBVzt3QkFDQVI7d0JBQ0FMLFVBQVUsSUFBSTtvQkFDbEI7b0JBQ0EsT0FBT1UsT0FBT0c7Z0JBQ2xCO2dCQUNBLElBQUksQ0FBQ0YsSUFBSSxDQUFDLFNBQVM7b0JBQ2ZDLFFBQVE7b0JBQ1JWO29CQUNBRztvQkFDQVM7b0JBQ0FkLFVBQVUsSUFBSTtnQkFDbEI7Z0JBQ0EsSUFBSWMsU0FBU0QsS0FBSyxFQUFFO29CQUNoQixNQUFNQSxRQUFRLElBQUlFLE1BQU1ELFNBQVNELEtBQUssQ0FBQ0csT0FBTztvQkFDOUNILE1BQU1JLElBQUksR0FBR0gsU0FBU0QsS0FBSyxDQUFDSSxJQUFJO29CQUNoQ0osTUFBTUssSUFBSSxHQUFHSixTQUFTRCxLQUFLLENBQUNLLElBQUk7b0JBQ2hDLE9BQU9SLE9BQU9HO2dCQUNsQjtnQkFDQUosUUFBUUssU0FBU0ssTUFBTTtZQUMzQjtRQUNKO0lBQ0o7QUFDSjtBQUNBLFNBQVNDLG9CQUFvQnBCLFFBQVE7SUFDakMsT0FBTyxTQUFVRyxNQUFNLEVBQUVDLE1BQU07UUFDM0IsSUFBSUEsVUFBVSxNQUFNO1lBQ2hCQSxTQUFTLEVBQUU7UUFDZjtRQUNBLE1BQU1DLFVBQVU7WUFBRUY7WUFBUUM7UUFBTztRQUNqQyxJQUFJLENBQUNPLElBQUksQ0FBQyxTQUFTO1lBQ2ZDLFFBQVE7WUFDUlYsU0FBUztZQUNURyxTQUFTYixtRUFBUUEsQ0FBQ2E7WUFDbEJMLFVBQVUsSUFBSTtRQUNsQjtRQUNBLE9BQU9BLFNBQVNLLE9BQU8sQ0FBQ0EsU0FBU2dCLElBQUksQ0FBQyxDQUFDUDtZQUNuQyxJQUFJLENBQUNILElBQUksQ0FBQyxTQUFTO2dCQUNmQyxRQUFRO2dCQUNSVixTQUFTO2dCQUNURztnQkFDQVM7Z0JBQ0FkLFVBQVUsSUFBSTtZQUNsQjtZQUNBLE9BQU9jO1FBQ1gsR0FBRyxDQUFDRDtZQUNBLElBQUksQ0FBQ0YsSUFBSSxDQUFDLFNBQVM7Z0JBQ2ZDLFFBQVE7Z0JBQ1JWLFNBQVM7Z0JBQ1RHO2dCQUNBUTtnQkFDQWIsVUFBVSxJQUFJO1lBQ2xCO1lBQ0EsTUFBTWE7UUFDVjtJQUNKO0FBQ0o7QUFDTyxNQUFNUyxxQkFBcUJ6QiwrREFBZUE7SUFDN0MwQixZQUFZdkIsUUFBUSxFQUFFd0IsT0FBTyxDQUFFO1FBQzNCLElBQUl4QixZQUFZLE1BQU07WUFDbEJKLE9BQU82QixrQkFBa0IsQ0FBQyxvQkFBb0IsWUFBWXpCO1FBQzlEO1FBQ0EsSUFBSTBCLE9BQU87UUFDWCxJQUFJQyxtQkFBbUI7UUFDdkIsSUFBSUMsY0FBYztRQUNsQixJQUFJLE9BQVE1QixhQUFjLFlBQVk7WUFDbEMwQixPQUFPO1lBQ1BDLG1CQUFtQjNCO1FBQ3ZCLE9BQ0s7WUFDRDBCLE9BQU8xQixTQUFTNkIsSUFBSSxJQUFJN0IsU0FBUzBCLElBQUksSUFBSTtZQUN6QyxJQUFJLENBQUNBLFFBQVExQixTQUFTOEIsVUFBVSxFQUFFO2dCQUM5QkosT0FBTztZQUNYO1lBQ0FFLGNBQWM1QjtZQUNkLElBQUlBLFNBQVNLLE9BQU8sRUFBRTtnQkFDbEIsSUFBSXFCLFNBQVMsSUFBSTtvQkFDYkEsT0FBTztnQkFDWDtnQkFDQUMsbUJBQW1CUCxvQkFBb0JwQjtZQUMzQyxPQUNLLElBQUlBLFNBQVMrQixTQUFTLEVBQUU7Z0JBQ3pCSixtQkFBbUI1Qix1QkFBdUJDLFVBQVVBLFNBQVMrQixTQUFTLENBQUNDLElBQUksQ0FBQ2hDO1lBQ2hGLE9BQ0ssSUFBSUEsU0FBU2lDLElBQUksRUFBRTtnQkFDcEJOLG1CQUFtQjVCLHVCQUF1QkMsVUFBVUEsU0FBU2lDLElBQUksQ0FBQ0QsSUFBSSxDQUFDaEM7WUFDM0UsT0FDSztnQkFDREosT0FBTzZCLGtCQUFrQixDQUFDLHdCQUF3QixZQUFZekI7WUFDbEU7WUFDQSxJQUFJLENBQUMwQixNQUFNO2dCQUNQQSxPQUFPO1lBQ1g7UUFDSjtRQUNBLEtBQUssQ0FBQ0EsTUFBTUY7UUFDWi9CLHlFQUFjQSxDQUFDLElBQUksRUFBRSxvQkFBb0JrQztRQUN6Q2xDLHlFQUFjQSxDQUFDLElBQUksRUFBRSxZQUFZbUM7SUFDckM7SUFDQUssS0FBSzlCLE1BQU0sRUFBRUMsTUFBTSxFQUFFO1FBQ2pCLE9BQU8sSUFBSSxDQUFDdUIsZ0JBQWdCLENBQUN4QixRQUFRQztJQUN6QztBQUNKLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2xpbWUtYmV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vd2ViMy1wcm92aWRlci5qcz8wNTExIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgZGVlcENvcHksIGRlZmluZVJlYWRPbmx5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IEpzb25ScGNQcm92aWRlciB9IGZyb20gXCIuL2pzb24tcnBjLXByb3ZpZGVyXCI7XG5sZXQgX25leHRJZCA9IDE7XG5mdW5jdGlvbiBidWlsZFdlYjNMZWdhY3lGZXRjaGVyKHByb3ZpZGVyLCBzZW5kRnVuYykge1xuICAgIGNvbnN0IGZldGNoZXIgPSBcIldlYjNMZWdhY3lGZXRjaGVyXCI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgIGlkOiAoX25leHRJZCsrKSxcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCJcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgIGZldGNoZXIsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogZGVlcENvcHkocmVxdWVzdCksXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VuZEZ1bmMocmVxdWVzdCwgKGVycm9yLCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgICAgIGZldGNoZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihyZXNwb25zZS5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9IHJlc3BvbnNlLmVycm9yLmNvZGU7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmRhdGEgPSByZXNwb25zZS5lcnJvci5kYXRhO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZEVpcDExOTNGZXRjaGVyKHByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IG1ldGhvZCwgcGFyYW1zIH07XG4gICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG4gICAgICAgICAgICBmZXRjaGVyOiBcIkVpcDExOTNGZXRjaGVyXCIsXG4gICAgICAgICAgICByZXF1ZXN0OiBkZWVwQ29weShyZXF1ZXN0KSxcbiAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvdmlkZXIucmVxdWVzdChyZXF1ZXN0KS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgIGZldGNoZXI6IFwiRWlwMTE5M0ZldGNoZXJcIixcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgZmV0Y2hlcjogXCJFaXAxMTkzRmV0Y2hlclwiLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5leHBvcnQgY2xhc3MgV2ViM1Byb3ZpZGVyIGV4dGVuZHMgSnNvblJwY1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgbmV0d29yaykge1xuICAgICAgICBpZiAocHJvdmlkZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgcHJvdmlkZXJcIiwgXCJwcm92aWRlclwiLCBwcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhdGggPSBudWxsO1xuICAgICAgICBsZXQganNvblJwY0ZldGNoRnVuYyA9IG51bGw7XG4gICAgICAgIGxldCBzdWJwcm92aWRlciA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgKHByb3ZpZGVyKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBwYXRoID0gXCJ1bmtub3duOlwiO1xuICAgICAgICAgICAganNvblJwY0ZldGNoRnVuYyA9IHByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF0aCA9IHByb3ZpZGVyLmhvc3QgfHwgcHJvdmlkZXIucGF0aCB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKCFwYXRoICYmIHByb3ZpZGVyLmlzTWV0YU1hc2spIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gXCJtZXRhbWFza1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VicHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgICAgIGlmIChwcm92aWRlci5yZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGggPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFwiZWlwLTExOTM6XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGpzb25ScGNGZXRjaEZ1bmMgPSBidWlsZEVpcDExOTNGZXRjaGVyKHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLnNlbmRBc3luYykge1xuICAgICAgICAgICAgICAgIGpzb25ScGNGZXRjaEZ1bmMgPSBidWlsZFdlYjNMZWdhY3lGZXRjaGVyKHByb3ZpZGVyLCBwcm92aWRlci5zZW5kQXN5bmMuYmluZChwcm92aWRlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIuc2VuZCkge1xuICAgICAgICAgICAgICAgIGpzb25ScGNGZXRjaEZ1bmMgPSBidWlsZFdlYjNMZWdhY3lGZXRjaGVyKHByb3ZpZGVyLCBwcm92aWRlci5zZW5kLmJpbmQocHJvdmlkZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBwcm92aWRlclwiLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBcInVua25vd246XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIocGF0aCwgbmV0d29yayk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwianNvblJwY0ZldGNoRnVuY1wiLCBqc29uUnBjRmV0Y2hGdW5jKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBzdWJwcm92aWRlcik7XG4gICAgfVxuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuanNvblJwY0ZldGNoRnVuYyhtZXRob2QsIHBhcmFtcyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViMy1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOlsiZGVlcENvcHkiLCJkZWZpbmVSZWFkT25seSIsIkxvZ2dlciIsInZlcnNpb24iLCJsb2dnZXIiLCJKc29uUnBjUHJvdmlkZXIiLCJfbmV4dElkIiwiYnVpbGRXZWIzTGVnYWN5RmV0Y2hlciIsInByb3ZpZGVyIiwic2VuZEZ1bmMiLCJmZXRjaGVyIiwibWV0aG9kIiwicGFyYW1zIiwicmVxdWVzdCIsImlkIiwianNvbnJwYyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZW1pdCIsImFjdGlvbiIsImVycm9yIiwicmVzcG9uc2UiLCJFcnJvciIsIm1lc3NhZ2UiLCJjb2RlIiwiZGF0YSIsInJlc3VsdCIsImJ1aWxkRWlwMTE5M0ZldGNoZXIiLCJ0aGVuIiwiV2ViM1Byb3ZpZGVyIiwiY29uc3RydWN0b3IiLCJuZXR3b3JrIiwidGhyb3dBcmd1bWVudEVycm9yIiwicGF0aCIsImpzb25ScGNGZXRjaEZ1bmMiLCJzdWJwcm92aWRlciIsImhvc3QiLCJpc01ldGFNYXNrIiwic2VuZEFzeW5jIiwiYmluZCIsInNlbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/web3-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/rlp/lib.esm/_version.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/rlp/lib.esm/_version.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"rlp/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9ybHAvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsVUFBVSxZQUFZLENBQ25DLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NsaW1lLWJldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3JscC9saWIuZXNtL192ZXJzaW9uLmpzP2Y3NDAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcInJscC81LjcuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/rlp/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/rlp/lib.esm/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/rlp/lib.esm/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/rlp/lib.esm/_version.js\");\n\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nfunction arrayifyInteger(value) {\n    const result = [];\n    while(value){\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n    let result = 0;\n    for(let i = 0; i < length; i++){\n        result = result * 256 + data[offset + i];\n    }\n    return result;\n}\nfunction _encode(object) {\n    if (Array.isArray(object)) {\n        let payload = [];\n        object.forEach(function(child) {\n            payload = payload.concat(_encode(child));\n        });\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length);\n            return payload;\n        }\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n        return length.concat(payload);\n    }\n    if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isBytesLike)(object)) {\n        logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n    }\n    const data = Array.prototype.slice.call((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(object));\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n    } else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n    return length.concat(data);\n}\nfunction encode(object) {\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(_encode(object));\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n    const result = [];\n    while(childOffset < offset + 1 + length){\n        const decoded = _decode(data, childOffset);\n        result.push(decoded.result);\n        childOffset += decoded.consumed;\n        if (childOffset > offset + 1 + length) {\n            logger.throwError(\"child data too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n    }\n    return {\n        consumed: 1 + length,\n        result: result\n    };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n    if (data.length === 0) {\n        logger.throwError(\"data too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n    }\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data short segment too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data long segment too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n    } else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data array too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        return _decodeChildren(data, offset, offset + 1, length);\n    } else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data array too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data array too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const result = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return {\n            consumed: 1 + lengthLength + length,\n            result: result\n        };\n    } else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const result = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data.slice(offset + 1, offset + 1 + length));\n        return {\n            consumed: 1 + length,\n            result: result\n        };\n    }\n    return {\n        consumed: 1,\n        result: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data[offset])\n    };\n}\nfunction decode(data) {\n    const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(data);\n    const decoded = _decode(bytes, 0);\n    if (decoded.consumed !== bytes.length) {\n        logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n    }\n    return decoded.result;\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9ybHAvbGliLmVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFhO0FBQ2IsZ0RBQWdEO0FBQ3NCO0FBQ3ZCO0FBQ1Y7QUFDckMsTUFBTUssU0FBUyxJQUFJRix5REFBTUEsQ0FBQ0MsNkNBQU9BO0FBQ2pDLFNBQVNFLGdCQUFnQkMsS0FBSztJQUMxQixNQUFNQyxTQUFTLEVBQUU7SUFDakIsTUFBT0QsTUFBTztRQUNWQyxPQUFPQyxPQUFPLENBQUNGLFFBQVE7UUFDdkJBLFVBQVU7SUFDZDtJQUNBLE9BQU9DO0FBQ1g7QUFDQSxTQUFTRSxrQkFBa0JDLElBQUksRUFBRUMsTUFBTSxFQUFFQyxNQUFNO0lBQzNDLElBQUlMLFNBQVM7SUFDYixJQUFLLElBQUlNLElBQUksR0FBR0EsSUFBSUQsUUFBUUMsSUFBSztRQUM3Qk4sU0FBUyxTQUFVLE1BQU9HLElBQUksQ0FBQ0MsU0FBU0UsRUFBRTtJQUM5QztJQUNBLE9BQU9OO0FBQ1g7QUFDQSxTQUFTTyxRQUFRQyxNQUFNO0lBQ25CLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0YsU0FBUztRQUN2QixJQUFJRyxVQUFVLEVBQUU7UUFDaEJILE9BQU9JLE9BQU8sQ0FBQyxTQUFVQyxLQUFLO1lBQzFCRixVQUFVQSxRQUFRRyxNQUFNLENBQUNQLFFBQVFNO1FBQ3JDO1FBQ0EsSUFBSUYsUUFBUU4sTUFBTSxJQUFJLElBQUk7WUFDdEJNLFFBQVFWLE9BQU8sQ0FBQyxPQUFPVSxRQUFRTixNQUFNO1lBQ3JDLE9BQU9NO1FBQ1g7UUFDQSxNQUFNTixTQUFTUCxnQkFBZ0JhLFFBQVFOLE1BQU07UUFDN0NBLE9BQU9KLE9BQU8sQ0FBQyxPQUFPSSxPQUFPQSxNQUFNO1FBQ25DLE9BQU9BLE9BQU9TLE1BQU0sQ0FBQ0g7SUFDekI7SUFDQSxJQUFJLENBQUNqQixpRUFBV0EsQ0FBQ2MsU0FBUztRQUN0QlgsT0FBT2tCLGtC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Qy9CLElBQUlULFFBQVFHLFFBQVEsS0FBS00sTUFBTTFCLE1BQU0sRUFBRTtRQUNuQ1IsT0FBT2tCLGtCQUFrQixDQUFDLG9CQUFvQixRQUFRWjtJQUMxRDtJQUNBLE9BQU9tQixRQUFRdEIsTUFBTTtBQUN6QixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NsaW1lLWJldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3JscC9saWIuZXNtL2luZGV4LmpzP2YzNmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vL1NlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9STFBcbmltcG9ydCB7IGFycmF5aWZ5LCBoZXhsaWZ5LCBpc0J5dGVzTGlrZSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuZnVuY3Rpb24gYXJyYXlpZnlJbnRlZ2VyKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KHZhbHVlICYgMHhmZik7XG4gICAgICAgIHZhbHVlID4+PSA4O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IChyZXN1bHQgKiAyNTYpICsgZGF0YVtvZmZzZXQgKyBpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIF9lbmNvZGUob2JqZWN0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICBsZXQgcGF5bG9hZCA9IFtdO1xuICAgICAgICBvYmplY3QuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHBheWxvYWQgPSBwYXlsb2FkLmNvbmNhdChfZW5jb2RlKGNoaWxkKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGF5bG9hZC5sZW5ndGggPD0gNTUpIHtcbiAgICAgICAgICAgIHBheWxvYWQudW5zaGlmdCgweGMwICsgcGF5bG9hZC5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYXJyYXlpZnlJbnRlZ2VyKHBheWxvYWQubGVuZ3RoKTtcbiAgICAgICAgbGVuZ3RoLnVuc2hpZnQoMHhmNyArIGxlbmd0aC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gbGVuZ3RoLmNvbmNhdChwYXlsb2FkKTtcbiAgICB9XG4gICAgaWYgKCFpc0J5dGVzTGlrZShvYmplY3QpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJSTFAgb2JqZWN0IG11c3QgYmUgQnl0ZXNMaWtlXCIsIFwib2JqZWN0XCIsIG9iamVjdCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnJheWlmeShvYmplY3QpKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDEgJiYgZGF0YVswXSA8PSAweDdmKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhLmxlbmd0aCA8PSA1NSkge1xuICAgICAgICBkYXRhLnVuc2hpZnQoMHg4MCArIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5aWZ5SW50ZWdlcihkYXRhLmxlbmd0aCk7XG4gICAgbGVuZ3RoLnVuc2hpZnQoMHhiNyArIGxlbmd0aC5sZW5ndGgpO1xuICAgIHJldHVybiBsZW5ndGguY29uY2F0KGRhdGEpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShvYmplY3QpIHtcbiAgICByZXR1cm4gaGV4bGlmeShfZW5jb2RlKG9iamVjdCkpO1xufVxuZnVuY3Rpb24gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgY2hpbGRPZmZzZXQsIGxlbmd0aCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlIChjaGlsZE9mZnNldCA8IG9mZnNldCArIDEgKyBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IF9kZWNvZGUoZGF0YSwgY2hpbGRPZmZzZXQpO1xuICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkLnJlc3VsdCk7XG4gICAgICAgIGNoaWxkT2Zmc2V0ICs9IGRlY29kZWQuY29uc3VtZWQ7XG4gICAgICAgIGlmIChjaGlsZE9mZnNldCA+IG9mZnNldCArIDEgKyBsZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2hpbGQgZGF0YSB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG59XG4vLyByZXR1cm5zIHsgY29uc3VtZWQ6IG51bWJlciwgcmVzdWx0OiBPYmplY3QgfVxuZnVuY3Rpb24gX2RlY29kZShkYXRhLCBvZmZzZXQpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIHRvbyBzaG9ydFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgfVxuICAgIC8vIEFycmF5IHdpdGggZXh0cmEgbGVuZ3RoIHByZWZpeFxuICAgIGlmIChkYXRhW29mZnNldF0gPj0gMHhmOCkge1xuICAgICAgICBjb25zdCBsZW5ndGhMZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGY3O1xuICAgICAgICBpZiAob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImRhdGEgc2hvcnQgc2VnbWVudCB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHVuYXJyYXlpZnlJbnRlZ2VyKGRhdGEsIG9mZnNldCArIDEsIGxlbmd0aExlbmd0aCk7XG4gICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSBsb25nIHNlZ21lbnQgdG9vIHNob3J0XCIsIExvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgb2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCwgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4YzApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhjMDtcbiAgICAgICAgaWYgKG9mZnNldCArIDEgKyBsZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIGFycmF5IHRvbyBzaG9ydFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9kZWNvZGVDaGlsZHJlbihkYXRhLCBvZmZzZXQsIG9mZnNldCArIDEsIGxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweGI4KSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aExlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4Yjc7XG4gICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSBhcnJheSB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHVuYXJyYXlpZnlJbnRlZ2VyKGRhdGEsIG9mZnNldCArIDEsIGxlbmd0aExlbmd0aCk7XG4gICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSBhcnJheSB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhleGxpZnkoZGF0YS5zbGljZShvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoLCBvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweDgwKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4ODA7XG4gICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhleGxpZnkoZGF0YS5zbGljZShvZmZzZXQgKyAxLCBvZmZzZXQgKyAxICsgbGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnN1bWVkOiAxLCByZXN1bHQ6IGhleGxpZnkoZGF0YVtvZmZzZXRdKSB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShkYXRhKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBhcnJheWlmeShkYXRhKTtcbiAgICBjb25zdCBkZWNvZGVkID0gX2RlY29kZShieXRlcywgMCk7XG4gICAgaWYgKGRlY29kZWQuY29uc3VtZWQgIT09IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBybHAgZGF0YVwiLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVkLnJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJhcnJheWlmeSIsImhleGxpZnkiLCJpc0J5dGVzTGlrZSIsIkxvZ2dlciIsInZlcnNpb24iLCJsb2dnZXIiLCJhcnJheWlmeUludGVnZXIiLCJ2YWx1ZSIsInJlc3VsdCIsInVuc2hpZnQiLCJ1bmFycmF5aWZ5SW50ZWdlciIsImRhdGEiLCJvZmZzZXQiLCJsZW5ndGgiLCJpIiwiX2VuY29kZSIsIm9iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsInBheWxvYWQiLCJmb3JFYWNoIiwiY2hpbGQiLCJjb25jYXQiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJlbmNvZGUiLCJfZGVjb2RlQ2hpbGRyZW4iLCJjaGlsZE9mZnNldCIsImRlY29kZWQiLCJfZGVjb2RlIiwicHVzaCIsImNvbnN1bWVkIiwidGhyb3dFcnJvciIsImVycm9ycyIsIkJVRkZFUl9PVkVSUlVOIiwibGVuZ3RoTGVuZ3RoIiwiZGVjb2RlIiwiYnl0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/rlp/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/sha2/lib.esm/_version.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/sha2/lib.esm/_version.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"sha2/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaGEyL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLFVBQVUsYUFBYSxDQUNwQyxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbGltZS1iZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaGEyL2xpYi5lc20vX3ZlcnNpb24uanM/Y2U5MiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwic2hhMi81LjcuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/sha2/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/sha2/lib.esm/sha2.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/sha2/lib.esm/sha2.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeHmac: () => (/* binding */ computeHmac),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   sha512: () => (/* binding */ sha512)\n/* harmony export */ });\n/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hash.js */ \"(ssr)/./node_modules/hash.js/lib/hash.js\");\n/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(hash_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/sha2/lib.esm/types.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/sha2/lib.esm/_version.js\");\n\n\n//const _ripemd160 = _hash.ripemd160;\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger(_version__WEBPACK_IMPORTED_MODULE_2__.version);\nfunction ripemd160(data) {\n    return \"0x\" + hash_js__WEBPACK_IMPORTED_MODULE_0___default().ripemd160().update((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(data)).digest(\"hex\");\n}\nfunction sha256(data) {\n    return \"0x\" + hash_js__WEBPACK_IMPORTED_MODULE_0___default().sha256().update((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(data)).digest(\"hex\");\n}\nfunction sha512(data) {\n    return \"0x\" + hash_js__WEBPACK_IMPORTED_MODULE_0___default().sha512().update((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(data)).digest(\"hex\");\n}\nfunction computeHmac(algorithm, key, data) {\n    if (!_types__WEBPACK_IMPORTED_MODULE_4__.SupportedAlgorithm[algorithm]) {\n        logger.throwError(\"unsupported algorithm \" + algorithm, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"hmac\",\n            algorithm: algorithm\n        });\n    }\n    return \"0x\" + hash_js__WEBPACK_IMPORTED_MODULE_0___default().hmac((hash_js__WEBPACK_IMPORTED_MODULE_0___default())[algorithm], (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(key)).update((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(data)).digest(\"hex\");\n} //# sourceMappingURL=sha2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaGEyL2xpYi5lc20vc2hhMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQWE7QUFDYztBQUMzQixxQ0FBcUM7QUFDVztBQUNIO0FBQ0U7QUFDVjtBQUNyQyxNQUFNSyxTQUFTLElBQUlGLHlEQUFNQSxDQUFDQyw2Q0FBT0E7QUFDMUIsU0FBU0UsVUFBVUMsSUFBSTtJQUMxQixPQUFPLE9BQVFQLHdEQUFjLEdBQUdRLE1BQU0sQ0FBQ1AsOERBQVFBLENBQUNNLE9BQU9FLE1BQU0sQ0FBQztBQUNsRTtBQUNPLFNBQVNDLE9BQU9ILElBQUk7SUFDdkIsT0FBTyxPQUFRUCxxREFBVyxHQUFHUSxNQUFNLENBQUNQLDhEQUFRQSxDQUFDTSxPQUFPRSxNQUFNLENBQUM7QUFDL0Q7QUFDTyxTQUFTRSxPQUFPSixJQUFJO0lBQ3ZCLE9BQU8sT0FBUVAscURBQVcsR0FBR1EsTUFBTSxDQUFDUCw4REFBUUEsQ0FBQ00sT0FBT0UsTUFBTSxDQUFDO0FBQy9EO0FBQ08sU0FBU0csWUFBWUMsU0FBUyxFQUFFQyxHQUFHLEVBQUVQLElBQUk7SUFDNUMsSUFBSSxDQUFDTCxzREFBa0IsQ0FBQ1csVUFBVSxFQUFFO1FBQ2hDUixPQUFPVSxVQUFVLENBQUMsMkJBQTJCRixXQUFXVix5REFBTUEsQ0FBQ2EsTUFBTSxDQUFDQyxxQkFBcUIsRUFBRTtZQUN6RkMsV0FBVztZQUNYTCxXQUFXQTtRQUNmO0lBQ0o7SUFDQSxPQUFPLE9BQU9iLG1EQUFTLENBQUNBLGdEQUFJLENBQUNhLFVBQVUsRUFBRVosOERBQVFBLENBQUNhLE1BQU1OLE1BQU0sQ0FBQ1AsOERBQVFBLENBQUNNLE9BQU9FLE1BQU0sQ0FBQztBQUMxRixFQUNBLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NsaW1lLWJldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3NoYTIvbGliLmVzbS9zaGEyLmpzP2MwNzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgaGFzaCBmcm9tIFwiaGFzaC5qc1wiO1xuLy9jb25zdCBfcmlwZW1kMTYwID0gX2hhc2gucmlwZW1kMTYwO1xuaW1wb3J0IHsgYXJyYXlpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IFN1cHBvcnRlZEFsZ29yaXRobSB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5leHBvcnQgZnVuY3Rpb24gcmlwZW1kMTYwKGRhdGEpIHtcbiAgICByZXR1cm4gXCIweFwiICsgKGhhc2gucmlwZW1kMTYwKCkudXBkYXRlKGFycmF5aWZ5KGRhdGEpKS5kaWdlc3QoXCJoZXhcIikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNoYTI1NihkYXRhKSB7XG4gICAgcmV0dXJuIFwiMHhcIiArIChoYXNoLnNoYTI1NigpLnVwZGF0ZShhcnJheWlmeShkYXRhKSkuZGlnZXN0KFwiaGV4XCIpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaGE1MTIoZGF0YSkge1xuICAgIHJldHVybiBcIjB4XCIgKyAoaGFzaC5zaGE1MTIoKS51cGRhdGUoYXJyYXlpZnkoZGF0YSkpLmRpZ2VzdChcImhleFwiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUhtYWMoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcbiAgICBpZiAoIVN1cHBvcnRlZEFsZ29yaXRobVthbGdvcml0aG1dKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtIFwiICsgYWxnb3JpdGhtLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImhtYWNcIixcbiAgICAgICAgICAgIGFsZ29yaXRobTogYWxnb3JpdGhtXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgaGFzaC5obWFjKGhhc2hbYWxnb3JpdGhtXSwgYXJyYXlpZnkoa2V5KSkudXBkYXRlKGFycmF5aWZ5KGRhdGEpKS5kaWdlc3QoXCJoZXhcIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyLmpzLm1hcCJdLCJuYW1lcyI6WyJoYXNoIiwiYXJyYXlpZnkiLCJTdXBwb3J0ZWRBbGdvcml0aG0iLCJMb2dnZXIiLCJ2ZXJzaW9uIiwibG9nZ2VyIiwicmlwZW1kMTYwIiwiZGF0YSIsInVwZGF0ZSIsImRpZ2VzdCIsInNoYTI1NiIsInNoYTUxMiIsImNvbXB1dGVIbWFjIiwiYWxnb3JpdGhtIiwia2V5IiwidGhyb3dFcnJvciIsImVycm9ycyIsIlVOU1VQUE9SVEVEX09QRVJBVElPTiIsIm9wZXJhdGlvbiIsImhtYWMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/sha2/lib.esm/sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/sha2/lib.esm/types.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/sha2/lib.esm/types.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SupportedAlgorithm: () => (/* binding */ SupportedAlgorithm)\n/* harmony export */ });\nvar SupportedAlgorithm;\n(function(SupportedAlgorithm) {\n    SupportedAlgorithm[\"sha256\"] = \"sha256\";\n    SupportedAlgorithm[\"sha512\"] = \"sha512\";\n})(SupportedAlgorithm || (SupportedAlgorithm = {}));\n; //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaGEyL2xpYi5lc20vdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLElBQUlBLG1CQUFtQjtBQUM3QixVQUFVQSxrQkFBa0I7SUFDekJBLGtCQUFrQixDQUFDLFNBQVMsR0FBRztJQUMvQkEsa0JBQWtCLENBQUMsU0FBUyxHQUFHO0FBQ25DLEdBQUdBLHNCQUF1QkEsQ0FBQUEscUJBQXFCLENBQUM7RUFFaEQsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2xpbWUtYmV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc2hhMi9saWIuZXNtL3R5cGVzLmpzPzViNDciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBTdXBwb3J0ZWRBbGdvcml0aG07XG4oZnVuY3Rpb24gKFN1cHBvcnRlZEFsZ29yaXRobSkge1xuICAgIFN1cHBvcnRlZEFsZ29yaXRobVtcInNoYTI1NlwiXSA9IFwic2hhMjU2XCI7XG4gICAgU3VwcG9ydGVkQWxnb3JpdGhtW1wic2hhNTEyXCJdID0gXCJzaGE1MTJcIjtcbn0pKFN1cHBvcnRlZEFsZ29yaXRobSB8fCAoU3VwcG9ydGVkQWxnb3JpdGhtID0ge30pKTtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJTdXBwb3J0ZWRBbGdvcml0aG0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/sha2/lib.esm/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/signing-key/lib.esm/_version.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/signing-key/lib.esm/_version.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"signing-key/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaWduaW5nLWtleS9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxNQUFNQSxVQUFVLG9CQUFvQixDQUMzQyxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbGltZS1iZXQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaWduaW5nLWtleS9saWIuZXNtL192ZXJzaW9uLmpzP2M4MGEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcInNpZ25pbmcta2V5LzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/signing-key/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EC: () => (/* binding */ EC$1)\n/* harmony export */ });\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hash.js */ \"(ssr)/./node_modules/hash.js/lib/hash.js\");\n/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(hash_js__WEBPACK_IMPORTED_MODULE_1__);\n\n\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis :  false ? 0 : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nfunction createCommonjsModule(fn, basedir, module) {\n    return module = {\n        path: basedir,\n        exports: {},\n        require: function(path, base) {\n            return commonjsRequire(path, base === undefined || base === null ? module.path : base);\n        }\n    }, fn(module, module.exports), module.exports;\n}\nfunction getDefaultExportFromNamespaceIfPresent(n) {\n    return n && Object.prototype.hasOwnProperty.call(n, \"default\") ? n[\"default\"] : n;\n}\nfunction getDefaultExportFromNamespaceIfNotNamed(n) {\n    return n && Object.prototype.hasOwnProperty.call(n, \"default\") && Object.keys(n).length === 1 ? n[\"default\"] : n;\n}\nfunction getAugmentedNamespace(n) {\n    if (n.__esModule) return n;\n    var a = Object.defineProperty({}, \"__esModule\", {\n        value: true\n    });\n    Object.keys(n).forEach(function(k) {\n        var d = Object.getOwnPropertyDescriptor(n, k);\n        Object.defineProperty(a, k, d.get ? d : {\n            enumerable: true,\n            get: function() {\n                return n[k];\n            }\n        });\n    });\n    return a;\n}\nfunction commonjsRequire() {\n    throw new Error(\"Dynamic requires are not currently supported by @rollup/plugin-commonjs\");\n}\nvar minimalisticAssert = assert;\nfunction assert(val, msg) {\n    if (!val) throw new Error(msg || \"Assertion failed\");\n}\nassert.equal = function assertEqual(l, r, msg) {\n    if (l != r) throw new Error(msg || \"Assertion failed: \" + l + \" != \" + r);\n};\nvar utils_1 = createCommonjsModule(function(module, exports) {\n    \"use strict\";\n    var utils = exports;\n    function toArray(msg, enc) {\n        if (Array.isArray(msg)) return msg.slice();\n        if (!msg) return [];\n        var res = [];\n        if (typeof msg !== \"string\") {\n            for(var i = 0; i < msg.length; i++)res[i] = msg[i] | 0;\n            return res;\n        }\n        if (enc === \"hex\") {\n            msg = msg.replace(/[^a-z0-9]+/ig, \"\");\n            if (msg.length % 2 !== 0) msg = \"0\" + msg;\n            for(var i = 0; i < msg.length; i += 2)res.push(parseInt(msg[i] + msg[i + 1], 16));\n        } else {\n            for(var i = 0; i < msg.length; i++){\n                var c = msg.charCodeAt(i);\n                var hi = c >> 8;\n                var lo = c & 0xff;\n                if (hi) res.push(hi, lo);\n                else res.push(lo);\n            }\n        }\n        return res;\n    }\n    utils.toArray = toArray;\n    function zero2(word) {\n        if (word.length === 1) return \"0\" + word;\n        else return word;\n    }\n    utils.zero2 = zero2;\n    function toHex(msg) {\n        var res = \"\";\n        for(var i = 0; i < msg.length; i++)res += zero2(msg[i].toString(16));\n        return res;\n    }\n    utils.toHex = toHex;\n    utils.encode = function encode(arr, enc) {\n        if (enc === \"hex\") return toHex(arr);\n        else return arr;\n    };\n});\nvar utils_1$1 = createCommonjsModule(function(module, exports) {\n    \"use strict\";\n    var utils = exports;\n    utils.assert = minimalisticAssert;\n    utils.toArray = utils_1.toArray;\n    utils.zero2 = utils_1.zero2;\n    utils.toHex = utils_1.toHex;\n    utils.encode = utils_1.encode;\n    // Represent num in a w-NAF form\n    function getNAF(num, w, bits) {\n        var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n        naf.fill(0);\n        var ws = 1 << w + 1;\n        var k = num.clone();\n        for(var i = 0; i < naf.length; i++){\n            var z;\n            var mod = k.andln(ws - 1);\n            if (k.isOdd()) {\n                if (mod > (ws >> 1) - 1) z = (ws >> 1) - mod;\n                else z = mod;\n                k.isubn(z);\n            } else {\n                z = 0;\n            }\n            naf[i] = z;\n            k.iushrn(1);\n        }\n        return naf;\n    }\n    utils.getNAF = getNAF;\n    // Represent k1, k2 in a Joint Sparse Form\n    function getJSF(k1, k2) {\n        var jsf = [\n            [],\n            []\n        ];\n        k1 = k1.clone();\n        k2 = k2.clone();\n        var d1 = 0;\n        var d2 = 0;\n        var m8;\n        while(k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0){\n            // First phase\n            var m14 = k1.andln(3) + d1 & 3;\n            var m24 = k2.andln(3) + d2 & 3;\n            if (m14 === 3) m14 = -1;\n            if (m24 === 3) m24 = -1;\n            var u1;\n            if ((m14 & 1) === 0) {\n                u1 = 0;\n            } else {\n                m8 = k1.andln(7) + d1 & 7;\n                if ((m8 === 3 || m8 === 5) && m24 === 2) u1 = -m14;\n                else u1 = m14;\n            }\n            jsf[0].push(u1);\n            var u2;\n            if ((m24 & 1) === 0) {\n                u2 = 0;\n            } else {\n                m8 = k2.andln(7) + d2 & 7;\n                if ((m8 === 3 || m8 === 5) && m14 === 2) u2 = -m24;\n                else u2 = m24;\n            }\n            jsf[1].push(u2);\n            // Second phase\n            if (2 * d1 === u1 + 1) d1 = 1 - d1;\n            if (2 * d2 === u2 + 1) d2 = 1 - d2;\n            k1.iushrn(1);\n            k2.iushrn(1);\n        }\n        return jsf;\n    }\n    utils.getJSF = getJSF;\n    function cachedProperty(obj, name, computer) {\n        var key = \"_\" + name;\n        obj.prototype[name] = function cachedProperty() {\n            return this[key] !== undefined ? this[key] : this[key] = computer.call(this);\n        };\n    }\n    utils.cachedProperty = cachedProperty;\n    function parseBytes(bytes) {\n        return typeof bytes === \"string\" ? utils.toArray(bytes, \"hex\") : bytes;\n    }\n    utils.parseBytes = parseBytes;\n    function intFromLE(bytes) {\n        return new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(bytes, \"hex\", \"le\");\n    }\n    utils.intFromLE = intFromLE;\n});\n\"use strict\";\nvar getNAF = utils_1$1.getNAF;\nvar getJSF = utils_1$1.getJSF;\nvar assert$1 = utils_1$1.assert;\nfunction BaseCurve(type, conf) {\n    this.type = type;\n    this.p = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.p, 16);\n    // Use Montgomery, when there is no fast reduction for the prime\n    this.red = conf.prime ? bn_js__WEBPACK_IMPORTED_MODULE_0___default().red(conf.prime) : bn_js__WEBPACK_IMPORTED_MODULE_0___default().mont(this.p);\n    // Useful for many curves\n    this.zero = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(0).toRed(this.red);\n    this.one = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(1).toRed(this.red);\n    this.two = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(2).toRed(this.red);\n    // Curve configuration, optional\n    this.n = conf.n && new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.n, 16);\n    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n    // Temporary arrays\n    this._wnafT1 = new Array(4);\n    this._wnafT2 = new Array(4);\n    this._wnafT3 = new Array(4);\n    this._wnafT4 = new Array(4);\n    this._bitLength = this.n ? this.n.bitLength() : 0;\n    // Generalized Greg Maxwell's trick\n    var adjustCount = this.n && this.p.div(this.n);\n    if (!adjustCount || adjustCount.cmpn(100) > 0) {\n        this.redN = null;\n    } else {\n        this._maxwellTrick = true;\n        this.redN = this.n.toRed(this.red);\n    }\n}\nvar base = BaseCurve;\nBaseCurve.prototype.point = function point() {\n    throw new Error(\"Not implemented\");\n};\nBaseCurve.prototype.validate = function validate() {\n    throw new Error(\"Not implemented\");\n};\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n    assert$1(p.precomputed);\n    var doubles = p._getDoubles();\n    var naf = getNAF(k, 1, this._bitLength);\n    var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);\n    I /= 3;\n    // Translate into more windowed form\n    var repr = [];\n    var j;\n    var nafW;\n    for(j = 0; j < naf.length; j += doubles.step){\n        nafW = 0;\n        for(var l = j + doubles.step - 1; l >= j; l--)nafW = (nafW << 1) + naf[l];\n        repr.push(nafW);\n    }\n    var a = this.jpoint(null, null, null);\n    var b = this.jpoint(null, null, null);\n    for(var i = I; i > 0; i--){\n        for(j = 0; j < repr.length; j++){\n            nafW = repr[j];\n            if (nafW === i) b = b.mixedAdd(doubles.points[j]);\n            else if (nafW === -i) b = b.mixedAdd(doubles.points[j].neg());\n        }\n        a = a.add(b);\n    }\n    return a.toP();\n};\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n    var w = 4;\n    // Precompute window\n    var nafPoints = p._getNAFPoints(w);\n    w = nafPoints.wnd;\n    var wnd = nafPoints.points;\n    // Get NAF form\n    var naf = getNAF(k, w, this._bitLength);\n    // Add `this`*(N+1) for every w-NAF index\n    var acc = this.jpoint(null, null, null);\n    for(var i = naf.length - 1; i >= 0; i--){\n        // Count zeroes\n        for(var l = 0; i >= 0 && naf[i] === 0; i--)l++;\n        if (i >= 0) l++;\n        acc = acc.dblp(l);\n        if (i < 0) break;\n        var z = naf[i];\n        assert$1(z !== 0);\n        if (p.type === \"affine\") {\n            // J +- P\n            if (z > 0) acc = acc.mixedAdd(wnd[z - 1 >> 1]);\n            else acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());\n        } else {\n            // J +- J\n            if (z > 0) acc = acc.add(wnd[z - 1 >> 1]);\n            else acc = acc.add(wnd[-z - 1 >> 1].neg());\n        }\n    }\n    return p.type === \"affine\" ? acc.toP() : acc;\n};\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {\n    var wndWidth = this._wnafT1;\n    var wnd = this._wnafT2;\n    var naf = this._wnafT3;\n    // Fill all arrays\n    var max = 0;\n    var i;\n    var j;\n    var p;\n    for(i = 0; i < len; i++){\n        p = points[i];\n        var nafPoints = p._getNAFPoints(defW);\n        wndWidth[i] = nafPoints.wnd;\n        wnd[i] = nafPoints.points;\n    }\n    // Comb small window NAFs\n    for(i = len - 1; i >= 1; i -= 2){\n        var a = i - 1;\n        var b = i;\n        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n            naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n            naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n            max = Math.max(naf[a].length, max);\n            max = Math.max(naf[b].length, max);\n            continue;\n        }\n        var comb = [\n            points[a],\n            /* 1 */ null,\n            /* 3 */ null,\n            /* 5 */ points[b]\n        ];\n        // Try to avoid Projective points, if possible\n        if (points[a].y.cmp(points[b].y) === 0) {\n            comb[1] = points[a].add(points[b]);\n            comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n        } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n            comb[1] = points[a].toJ().mixedAdd(points[b]);\n            comb[2] = points[a].add(points[b].neg());\n        } else {\n            comb[1] = points[a].toJ().mixedAdd(points[b]);\n            comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n        }\n        var index = [\n            -3,\n            /* -1 -1 */ -1,\n            /* -1 0 */ -5,\n            /* -1 1 */ -7,\n            /* 0 -1 */ 0,\n            /* 0 0 */ 7,\n            /* 0 1 */ 5,\n            /* 1 -1 */ 1,\n            /* 1 0 */ 3\n        ];\n        var jsf = getJSF(coeffs[a], coeffs[b]);\n        max = Math.max(jsf[0].length, max);\n        naf[a] = new Array(max);\n        naf[b] = new Array(max);\n        for(j = 0; j < max; j++){\n            var ja = jsf[0][j] | 0;\n            var jb = jsf[1][j] | 0;\n            naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n            naf[b][j] = 0;\n            wnd[a] = comb;\n        }\n    }\n    var acc = this.jpoint(null, null, null);\n    var tmp = this._wnafT4;\n    for(i = max; i >= 0; i--){\n        var k = 0;\n        while(i >= 0){\n            var zero = true;\n            for(j = 0; j < len; j++){\n                tmp[j] = naf[j][i] | 0;\n                if (tmp[j] !== 0) zero = false;\n            }\n            if (!zero) break;\n            k++;\n            i--;\n        }\n        if (i >= 0) k++;\n        acc = acc.dblp(k);\n        if (i < 0) break;\n        for(j = 0; j < len; j++){\n            var z = tmp[j];\n            p;\n            if (z === 0) continue;\n            else if (z > 0) p = wnd[j][z - 1 >> 1];\n            else if (z < 0) p = wnd[j][-z - 1 >> 1].neg();\n            if (p.type === \"affine\") acc = acc.mixedAdd(p);\n            else acc = acc.add(p);\n        }\n    }\n    // Zeroify references\n    for(i = 0; i < len; i++)wnd[i] = null;\n    if (jacobianResult) return acc;\n    else return acc.toP();\n};\nfunction BasePoint(curve, type) {\n    this.curve = curve;\n    this.type = type;\n    this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\nBasePoint.prototype.eq = function eq() {\n    throw new Error(\"Not implemented\");\n};\nBasePoint.prototype.validate = function validate() {\n    return this.curve.validate(this);\n};\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n    bytes = utils_1$1.toArray(bytes, enc);\n    var len = this.p.byteLength();\n    // uncompressed, hybrid-odd, hybrid-even\n    if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) && bytes.length - 1 === 2 * len) {\n        if (bytes[0] === 0x06) assert$1(bytes[bytes.length - 1] % 2 === 0);\n        else if (bytes[0] === 0x07) assert$1(bytes[bytes.length - 1] % 2 === 1);\n        var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));\n        return res;\n    } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) && bytes.length - 1 === len) {\n        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n    }\n    throw new Error(\"Unknown point format\");\n};\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n    return this.encode(enc, true);\n};\nBasePoint.prototype._encode = function _encode(compact) {\n    var len = this.curve.p.byteLength();\n    var x = this.getX().toArray(\"be\", len);\n    if (compact) return [\n        this.getY().isEven() ? 0x02 : 0x03\n    ].concat(x);\n    return [\n        0x04\n    ].concat(x, this.getY().toArray(\"be\", len));\n};\nBasePoint.prototype.encode = function encode(enc, compact) {\n    return utils_1$1.encode(this._encode(compact), enc);\n};\nBasePoint.prototype.precompute = function precompute(power) {\n    if (this.precomputed) return this;\n    var precomputed = {\n        doubles: null,\n        naf: null,\n        beta: null\n    };\n    precomputed.naf = this._getNAFPoints(8);\n    precomputed.doubles = this._getDoubles(4, power);\n    precomputed.beta = this._getBeta();\n    this.precomputed = precomputed;\n    return this;\n};\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n    if (!this.precomputed) return false;\n    var doubles = this.precomputed.doubles;\n    if (!doubles) return false;\n    return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n    if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;\n    var doubles = [\n        this\n    ];\n    var acc = this;\n    for(var i = 0; i < power; i += step){\n        for(var j = 0; j < step; j++)acc = acc.dbl();\n        doubles.push(acc);\n    }\n    return {\n        step: step,\n        points: doubles\n    };\n};\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n    if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;\n    var res = [\n        this\n    ];\n    var max = (1 << wnd) - 1;\n    var dbl = max === 1 ? null : this.dbl();\n    for(var i = 1; i < max; i++)res[i] = res[i - 1].add(dbl);\n    return {\n        wnd: wnd,\n        points: res\n    };\n};\nBasePoint.prototype._getBeta = function _getBeta() {\n    return null;\n};\nBasePoint.prototype.dblp = function dblp(k) {\n    var r = this;\n    for(var i = 0; i < k; i++)r = r.dbl();\n    return r;\n};\nvar inherits_browser = createCommonjsModule(function(module) {\n    if (typeof Object.create === \"function\") {\n        // implementation from standard node.js 'util' module\n        module.exports = function inherits(ctor, superCtor) {\n            if (superCtor) {\n                ctor.super_ = superCtor;\n                ctor.prototype = Object.create(superCtor.prototype, {\n                    constructor: {\n                        value: ctor,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n            }\n        };\n    } else {\n        // old school shim for old browsers\n        module.exports = function inherits(ctor, superCtor) {\n            if (superCtor) {\n                ctor.super_ = superCtor;\n                var TempCtor = function() {};\n                TempCtor.prototype = superCtor.prototype;\n                ctor.prototype = new TempCtor();\n                ctor.prototype.constructor = ctor;\n            }\n        };\n    }\n});\n\"use strict\";\nvar assert$2 = utils_1$1.assert;\nfunction ShortCurve(conf) {\n    base.call(this, \"short\", conf);\n    this.a = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.a, 16).toRed(this.red);\n    this.b = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.b, 16).toRed(this.red);\n    this.tinv = this.two.redInvm();\n    this.zeroA = this.a.fromRed().cmpn(0) === 0;\n    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n    // If the curve is endomorphic, precalculate beta and lambda\n    this.endo = this._getEndomorphism(conf);\n    this._endoWnafT1 = new Array(4);\n    this._endoWnafT2 = new Array(4);\n}\ninherits_browser(ShortCurve, base);\nvar short_1 = ShortCurve;\nShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n    // No efficient endomorphism\n    if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1) return;\n    // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n    var beta;\n    var lambda;\n    if (conf.beta) {\n        beta = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.beta, 16).toRed(this.red);\n    } else {\n        var betas = this._getEndoRoots(this.p);\n        // Choose the smallest beta\n        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n        beta = beta.toRed(this.red);\n    }\n    if (conf.lambda) {\n        lambda = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.lambda, 16);\n    } else {\n        // Choose the lambda that is matching selected beta\n        var lambdas = this._getEndoRoots(this.n);\n        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n            lambda = lambdas[0];\n        } else {\n            lambda = lambdas[1];\n            assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n        }\n    }\n    // Get basis vectors, used for balanced length-two representation\n    var basis;\n    if (conf.basis) {\n        basis = conf.basis.map(function(vec) {\n            return {\n                a: new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(vec.a, 16),\n                b: new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(vec.b, 16)\n            };\n        });\n    } else {\n        basis = this._getEndoBasis(lambda);\n    }\n    return {\n        beta: beta,\n        lambda: lambda,\n        basis: basis\n    };\n};\nShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n    // Find roots of for x^2 + x + 1 in F\n    // Root = (-1 +- Sqrt(-3)) / 2\n    //\n    var red = num === this.p ? this.red : bn_js__WEBPACK_IMPORTED_MODULE_0___default().mont(num);\n    var tinv = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(2).toRed(red).redInvm();\n    var ntinv = tinv.redNeg();\n    var s = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n    var l1 = ntinv.redAdd(s).fromRed();\n    var l2 = ntinv.redSub(s).fromRed();\n    return [\n        l1,\n        l2\n    ];\n};\nShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n    // aprxSqrt >= sqrt(this.n)\n    var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n    // 3.74\n    // Run EGCD, until r(L + 1) < aprxSqrt\n    var u = lambda;\n    var v = this.n.clone();\n    var x1 = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(1);\n    var y1 = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(0);\n    var x2 = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(0);\n    var y2 = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(1);\n    // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n    var a0;\n    var b0;\n    // First vector\n    var a1;\n    var b1;\n    // Second vector\n    var a2;\n    var b2;\n    var prevR;\n    var i = 0;\n    var r;\n    var x;\n    while(u.cmpn(0) !== 0){\n        var q = v.div(u);\n        r = v.sub(q.mul(u));\n        x = x2.sub(q.mul(x1));\n        var y = y2.sub(q.mul(y1));\n        if (!a1 && r.cmp(aprxSqrt) < 0) {\n            a0 = prevR.neg();\n            b0 = x1;\n            a1 = r.neg();\n            b1 = x;\n        } else if (a1 && ++i === 2) {\n            break;\n        }\n        prevR = r;\n        v = u;\n        u = r;\n        x2 = x1;\n        x1 = x;\n        y2 = y1;\n        y1 = y;\n    }\n    a2 = r.neg();\n    b2 = x;\n    var len1 = a1.sqr().add(b1.sqr());\n    var len2 = a2.sqr().add(b2.sqr());\n    if (len2.cmp(len1) >= 0) {\n        a2 = a0;\n        b2 = b0;\n    }\n    // Normalize signs\n    if (a1.negative) {\n        a1 = a1.neg();\n        b1 = b1.neg();\n    }\n    if (a2.negative) {\n        a2 = a2.neg();\n        b2 = b2.neg();\n    }\n    return [\n        {\n            a: a1,\n            b: b1\n        },\n        {\n            a: a2,\n            b: b2\n        }\n    ];\n};\nShortCurve.prototype._endoSplit = function _endoSplit(k) {\n    var basis = this.endo.basis;\n    var v1 = basis[0];\n    var v2 = basis[1];\n    var c1 = v2.b.mul(k).divRound(this.n);\n    var c2 = v1.b.neg().mul(k).divRound(this.n);\n    var p1 = c1.mul(v1.a);\n    var p2 = c2.mul(v2.a);\n    var q1 = c1.mul(v1.b);\n    var q2 = c2.mul(v2.b);\n    // Calculate answer\n    var k1 = k.sub(p1).sub(p2);\n    var k2 = q1.add(q2).neg();\n    return {\n        k1: k1,\n        k2: k2\n    };\n};\nShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n    x = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(x, 16);\n    if (!x.red) x = x.toRed(this.red);\n    var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n    var y = y2.redSqrt();\n    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error(\"invalid point\");\n    // XXX Is there any way to tell if the number is odd without converting it\n    // to non-red form?\n    var isOdd = y.fromRed().isOdd();\n    if (odd && !isOdd || !odd && isOdd) y = y.redNeg();\n    return this.point(x, y);\n};\nShortCurve.prototype.validate = function validate(point) {\n    if (point.inf) return true;\n    var x = point.x;\n    var y = point.y;\n    var ax = this.a.redMul(x);\n    var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n    return y.redSqr().redISub(rhs).cmpn(0) === 0;\n};\nShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n    var npoints = this._endoWnafT1;\n    var ncoeffs = this._endoWnafT2;\n    for(var i = 0; i < points.length; i++){\n        var split = this._endoSplit(coeffs[i]);\n        var p = points[i];\n        var beta = p._getBeta();\n        if (split.k1.negative) {\n            split.k1.ineg();\n            p = p.neg(true);\n        }\n        if (split.k2.negative) {\n            split.k2.ineg();\n            beta = beta.neg(true);\n        }\n        npoints[i * 2] = p;\n        npoints[i * 2 + 1] = beta;\n        ncoeffs[i * 2] = split.k1;\n        ncoeffs[i * 2 + 1] = split.k2;\n    }\n    var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n    // Clean-up references to points and coefficients\n    for(var j = 0; j < i * 2; j++){\n        npoints[j] = null;\n        ncoeffs[j] = null;\n    }\n    return res;\n};\nfunction Point(curve, x, y, isRed) {\n    base.BasePoint.call(this, curve, \"affine\");\n    if (x === null && y === null) {\n        this.x = null;\n        this.y = null;\n        this.inf = true;\n    } else {\n        this.x = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(x, 16);\n        this.y = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(y, 16);\n        // Force redgomery representation when loading from JSON\n        if (isRed) {\n            this.x.forceRed(this.curve.red);\n            this.y.forceRed(this.curve.red);\n        }\n        if (!this.x.red) this.x = this.x.toRed(this.curve.red);\n        if (!this.y.red) this.y = this.y.toRed(this.curve.red);\n        this.inf = false;\n    }\n}\ninherits_browser(Point, base.BasePoint);\nShortCurve.prototype.point = function point(x, y, isRed) {\n    return new Point(this, x, y, isRed);\n};\nShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n    return Point.fromJSON(this, obj, red);\n};\nPoint.prototype._getBeta = function _getBeta() {\n    if (!this.curve.endo) return;\n    var pre = this.precomputed;\n    if (pre && pre.beta) return pre.beta;\n    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n    if (pre) {\n        var curve = this.curve;\n        var endoMul = function(p) {\n            return curve.point(p.x.redMul(curve.endo.beta), p.y);\n        };\n        pre.beta = beta;\n        beta.precomputed = {\n            beta: null,\n            naf: pre.naf && {\n                wnd: pre.naf.wnd,\n                points: pre.naf.points.map(endoMul)\n            },\n            doubles: pre.doubles && {\n                step: pre.doubles.step,\n                points: pre.doubles.points.map(endoMul)\n            }\n        };\n    }\n    return beta;\n};\nPoint.prototype.toJSON = function toJSON() {\n    if (!this.precomputed) return [\n        this.x,\n        this.y\n    ];\n    return [\n        this.x,\n        this.y,\n        this.precomputed && {\n            doubles: this.precomputed.doubles && {\n                step: this.precomputed.doubles.step,\n                points: this.precomputed.doubles.points.slice(1)\n            },\n            naf: this.precomputed.naf && {\n                wnd: this.precomputed.naf.wnd,\n                points: this.precomputed.naf.points.slice(1)\n            }\n        }\n    ];\n};\nPoint.fromJSON = function fromJSON(curve, obj, red) {\n    if (typeof obj === \"string\") obj = JSON.parse(obj);\n    var res = curve.point(obj[0], obj[1], red);\n    if (!obj[2]) return res;\n    function obj2point(obj) {\n        return curve.point(obj[0], obj[1], red);\n    }\n    var pre = obj[2];\n    res.precomputed = {\n        beta: null,\n        doubles: pre.doubles && {\n            step: pre.doubles.step,\n            points: [\n                res\n            ].concat(pre.doubles.points.map(obj2point))\n        },\n        naf: pre.naf && {\n            wnd: pre.naf.wnd,\n            points: [\n                res\n            ].concat(pre.naf.points.map(obj2point))\n        }\n    };\n    return res;\n};\nPoint.prototype.inspect = function inspect() {\n    if (this.isInfinity()) return \"<EC Point Infinity>\";\n    return \"<EC Point x: \" + this.x.fromRed().toString(16, 2) + \" y: \" + this.y.fromRed().toString(16, 2) + \">\";\n};\nPoint.prototype.isInfinity = function isInfinity() {\n    return this.inf;\n};\nPoint.prototype.add = function add(p) {\n    // O + P = P\n    if (this.inf) return p;\n    // P + O = P\n    if (p.inf) return this;\n    // P + P = 2P\n    if (this.eq(p)) return this.dbl();\n    // P + (-P) = O\n    if (this.neg().eq(p)) return this.curve.point(null, null);\n    // P + Q = O\n    if (this.x.cmp(p.x) === 0) return this.curve.point(null, null);\n    var c = this.y.redSub(p.y);\n    if (c.cmpn(0) !== 0) c = c.redMul(this.x.redSub(p.x).redInvm());\n    var nx = c.redSqr().redISub(this.x).redISub(p.x);\n    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n    return this.curve.point(nx, ny);\n};\nPoint.prototype.dbl = function dbl() {\n    if (this.inf) return this;\n    // 2P = O\n    var ys1 = this.y.redAdd(this.y);\n    if (ys1.cmpn(0) === 0) return this.curve.point(null, null);\n    var a = this.curve.a;\n    var x2 = this.x.redSqr();\n    var dyinv = ys1.redInvm();\n    var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n    var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n    return this.curve.point(nx, ny);\n};\nPoint.prototype.getX = function getX() {\n    return this.x.fromRed();\n};\nPoint.prototype.getY = function getY() {\n    return this.y.fromRed();\n};\nPoint.prototype.mul = function mul(k) {\n    k = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(k, 16);\n    if (this.isInfinity()) return this;\n    else if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);\n    else if (this.curve.endo) return this.curve._endoWnafMulAdd([\n        this\n    ], [\n        k\n    ]);\n    else return this.curve._wnafMul(this, k);\n};\nPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n    var points = [\n        this,\n        p2\n    ];\n    var coeffs = [\n        k1,\n        k2\n    ];\n    if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs);\n    else return this.curve._wnafMulAdd(1, points, coeffs, 2);\n};\nPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n    var points = [\n        this,\n        p2\n    ];\n    var coeffs = [\n        k1,\n        k2\n    ];\n    if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs, true);\n    else return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n};\nPoint.prototype.eq = function eq(p) {\n    return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n};\nPoint.prototype.neg = function neg(_precompute) {\n    if (this.inf) return this;\n    var res = this.curve.point(this.x, this.y.redNeg());\n    if (_precompute && this.precomputed) {\n        var pre = this.precomputed;\n        var negate = function(p) {\n            return p.neg();\n        };\n        res.precomputed = {\n            naf: pre.naf && {\n                wnd: pre.naf.wnd,\n                points: pre.naf.points.map(negate)\n            },\n            doubles: pre.doubles && {\n                step: pre.doubles.step,\n                points: pre.doubles.points.map(negate)\n            }\n        };\n    }\n    return res;\n};\nPoint.prototype.toJ = function toJ() {\n    if (this.inf) return this.curve.jpoint(null, null, null);\n    var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n    return res;\n};\nfunction JPoint(curve, x, y, z) {\n    base.BasePoint.call(this, curve, \"jacobian\");\n    if (x === null && y === null && z === null) {\n        this.x = this.curve.one;\n        this.y = this.curve.one;\n        this.z = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(0);\n    } else {\n        this.x = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(x, 16);\n        this.y = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(y, 16);\n        this.z = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(z, 16);\n    }\n    if (!this.x.red) this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red) this.y = this.y.toRed(this.curve.red);\n    if (!this.z.red) this.z = this.z.toRed(this.curve.red);\n    this.zOne = this.z === this.curve.one;\n}\ninherits_browser(JPoint, base.BasePoint);\nShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n    return new JPoint(this, x, y, z);\n};\nJPoint.prototype.toP = function toP() {\n    if (this.isInfinity()) return this.curve.point(null, null);\n    var zinv = this.z.redInvm();\n    var zinv2 = zinv.redSqr();\n    var ax = this.x.redMul(zinv2);\n    var ay = this.y.redMul(zinv2).redMul(zinv);\n    return this.curve.point(ax, ay);\n};\nJPoint.prototype.neg = function neg() {\n    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\nJPoint.prototype.add = function add(p) {\n    // O + P = P\n    if (this.isInfinity()) return p;\n    // P + O = P\n    if (p.isInfinity()) return this;\n    // 12M + 4S + 7A\n    var pz2 = p.z.redSqr();\n    var z2 = this.z.redSqr();\n    var u1 = this.x.redMul(pz2);\n    var u2 = p.x.redMul(z2);\n    var s1 = this.y.redMul(pz2.redMul(p.z));\n    var s2 = p.y.redMul(z2.redMul(this.z));\n    var h = u1.redSub(u2);\n    var r = s1.redSub(s2);\n    if (h.cmpn(0) === 0) {\n        if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);\n        else return this.dbl();\n    }\n    var h2 = h.redSqr();\n    var h3 = h2.redMul(h);\n    var v = u1.redMul(h2);\n    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n    var nz = this.z.redMul(p.z).redMul(h);\n    return this.curve.jpoint(nx, ny, nz);\n};\nJPoint.prototype.mixedAdd = function mixedAdd(p) {\n    // O + P = P\n    if (this.isInfinity()) return p.toJ();\n    // P + O = P\n    if (p.isInfinity()) return this;\n    // 8M + 3S + 7A\n    var z2 = this.z.redSqr();\n    var u1 = this.x;\n    var u2 = p.x.redMul(z2);\n    var s1 = this.y;\n    var s2 = p.y.redMul(z2).redMul(this.z);\n    var h = u1.redSub(u2);\n    var r = s1.redSub(s2);\n    if (h.cmpn(0) === 0) {\n        if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);\n        else return this.dbl();\n    }\n    var h2 = h.redSqr();\n    var h3 = h2.redMul(h);\n    var v = u1.redMul(h2);\n    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n    var nz = this.z.redMul(h);\n    return this.curve.jpoint(nx, ny, nz);\n};\nJPoint.prototype.dblp = function dblp(pow) {\n    if (pow === 0) return this;\n    if (this.isInfinity()) return this;\n    if (!pow) return this.dbl();\n    var i;\n    if (this.curve.zeroA || this.curve.threeA) {\n        var r = this;\n        for(i = 0; i < pow; i++)r = r.dbl();\n        return r;\n    }\n    // 1M + 2S + 1A + N * (4S + 5M + 8A)\n    // N = 1 => 6M + 6S + 9A\n    var a = this.curve.a;\n    var tinv = this.curve.tinv;\n    var jx = this.x;\n    var jy = this.y;\n    var jz = this.z;\n    var jz4 = jz.redSqr().redSqr();\n    // Reuse results\n    var jyd = jy.redAdd(jy);\n    for(i = 0; i < pow; i++){\n        var jx2 = jx.redSqr();\n        var jyd2 = jyd.redSqr();\n        var jyd4 = jyd2.redSqr();\n        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n        var t1 = jx.redMul(jyd2);\n        var nx = c.redSqr().redISub(t1.redAdd(t1));\n        var t2 = t1.redISub(nx);\n        var dny = c.redMul(t2);\n        dny = dny.redIAdd(dny).redISub(jyd4);\n        var nz = jyd.redMul(jz);\n        if (i + 1 < pow) jz4 = jz4.redMul(jyd4);\n        jx = nx;\n        jz = nz;\n        jyd = dny;\n    }\n    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n};\nJPoint.prototype.dbl = function dbl() {\n    if (this.isInfinity()) return this;\n    if (this.curve.zeroA) return this._zeroDbl();\n    else if (this.curve.threeA) return this._threeDbl();\n    else return this._dbl();\n};\nJPoint.prototype._zeroDbl = function _zeroDbl() {\n    var nx;\n    var ny;\n    var nz;\n    // Z = 1\n    if (this.zOne) {\n        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n        //     #doubling-mdbl-2007-bl\n        // 1M + 5S + 14A\n        // XX = X1^2\n        var xx = this.x.redSqr();\n        // YY = Y1^2\n        var yy = this.y.redSqr();\n        // YYYY = YY^2\n        var yyyy = yy.redSqr();\n        // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n        s = s.redIAdd(s);\n        // M = 3 * XX + a; a = 0\n        var m = xx.redAdd(xx).redIAdd(xx);\n        // T = M ^ 2 - 2*S\n        var t = m.redSqr().redISub(s).redISub(s);\n        // 8 * YYYY\n        var yyyy8 = yyyy.redIAdd(yyyy);\n        yyyy8 = yyyy8.redIAdd(yyyy8);\n        yyyy8 = yyyy8.redIAdd(yyyy8);\n        // X3 = T\n        nx = t;\n        // Y3 = M * (S - T) - 8 * YYYY\n        ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n        // Z3 = 2*Y1\n        nz = this.y.redAdd(this.y);\n    } else {\n        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n        //     #doubling-dbl-2009-l\n        // 2M + 5S + 13A\n        // A = X1^2\n        var a = this.x.redSqr();\n        // B = Y1^2\n        var b = this.y.redSqr();\n        // C = B^2\n        var c = b.redSqr();\n        // D = 2 * ((X1 + B)^2 - A - C)\n        var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n        d = d.redIAdd(d);\n        // E = 3 * A\n        var e = a.redAdd(a).redIAdd(a);\n        // F = E^2\n        var f = e.redSqr();\n        // 8 * C\n        var c8 = c.redIAdd(c);\n        c8 = c8.redIAdd(c8);\n        c8 = c8.redIAdd(c8);\n        // X3 = F - 2 * D\n        nx = f.redISub(d).redISub(d);\n        // Y3 = E * (D - X3) - 8 * C\n        ny = e.redMul(d.redISub(nx)).redISub(c8);\n        // Z3 = 2 * Y1 * Z1\n        nz = this.y.redMul(this.z);\n        nz = nz.redIAdd(nz);\n    }\n    return this.curve.jpoint(nx, ny, nz);\n};\nJPoint.prototype._threeDbl = function _threeDbl() {\n    var nx;\n    var ny;\n    var nz;\n    // Z = 1\n    if (this.zOne) {\n        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n        //     #doubling-mdbl-2007-bl\n        // 1M + 5S + 15A\n        // XX = X1^2\n        var xx = this.x.redSqr();\n        // YY = Y1^2\n        var yy = this.y.redSqr();\n        // YYYY = YY^2\n        var yyyy = yy.redSqr();\n        // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n        s = s.redIAdd(s);\n        // M = 3 * XX + a\n        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n        // T = M^2 - 2 * S\n        var t = m.redSqr().redISub(s).redISub(s);\n        // X3 = T\n        nx = t;\n        // Y3 = M * (S - T) - 8 * YYYY\n        var yyyy8 = yyyy.redIAdd(yyyy);\n        yyyy8 = yyyy8.redIAdd(yyyy8);\n        yyyy8 = yyyy8.redIAdd(yyyy8);\n        ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n        // Z3 = 2 * Y1\n        nz = this.y.redAdd(this.y);\n    } else {\n        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n        // 3M + 5S\n        // delta = Z1^2\n        var delta = this.z.redSqr();\n        // gamma = Y1^2\n        var gamma = this.y.redSqr();\n        // beta = X1 * gamma\n        var beta = this.x.redMul(gamma);\n        // alpha = 3 * (X1 - delta) * (X1 + delta)\n        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n        alpha = alpha.redAdd(alpha).redIAdd(alpha);\n        // X3 = alpha^2 - 8 * beta\n        var beta4 = beta.redIAdd(beta);\n        beta4 = beta4.redIAdd(beta4);\n        var beta8 = beta4.redAdd(beta4);\n        nx = alpha.redSqr().redISub(beta8);\n        // Z3 = (Y1 + Z1)^2 - gamma - delta\n        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n        // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n        var ggamma8 = gamma.redSqr();\n        ggamma8 = ggamma8.redIAdd(ggamma8);\n        ggamma8 = ggamma8.redIAdd(ggamma8);\n        ggamma8 = ggamma8.redIAdd(ggamma8);\n        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n    }\n    return this.curve.jpoint(nx, ny, nz);\n};\nJPoint.prototype._dbl = function _dbl() {\n    var a = this.curve.a;\n    // 4M + 6S + 10A\n    var jx = this.x;\n    var jy = this.y;\n    var jz = this.z;\n    var jz4 = jz.redSqr().redSqr();\n    var jx2 = jx.redSqr();\n    var jy2 = jy.redSqr();\n    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n    var jxd4 = jx.redAdd(jx);\n    jxd4 = jxd4.redIAdd(jxd4);\n    var t1 = jxd4.redMul(jy2);\n    var nx = c.redSqr().redISub(t1.redAdd(t1));\n    var t2 = t1.redISub(nx);\n    var jyd8 = jy2.redSqr();\n    jyd8 = jyd8.redIAdd(jyd8);\n    jyd8 = jyd8.redIAdd(jyd8);\n    jyd8 = jyd8.redIAdd(jyd8);\n    var ny = c.redMul(t2).redISub(jyd8);\n    var nz = jy.redAdd(jy).redMul(jz);\n    return this.curve.jpoint(nx, ny, nz);\n};\nJPoint.prototype.trpl = function trpl() {\n    if (!this.curve.zeroA) return this.dbl().add(this);\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n    // 5M + 10S + ...\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // ZZ = Z1^2\n    var zz = this.z.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // M = 3 * XX + a * ZZ2; a = 0\n    var m = xx.redAdd(xx).redIAdd(xx);\n    // MM = M^2\n    var mm = m.redSqr();\n    // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n    var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    e = e.redIAdd(e);\n    e = e.redAdd(e).redIAdd(e);\n    e = e.redISub(mm);\n    // EE = E^2\n    var ee = e.redSqr();\n    // T = 16*YYYY\n    var t = yyyy.redIAdd(yyyy);\n    t = t.redIAdd(t);\n    t = t.redIAdd(t);\n    t = t.redIAdd(t);\n    // U = (M + E)^2 - MM - EE - T\n    var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n    // X3 = 4 * (X1 * EE - 4 * YY * U)\n    var yyu4 = yy.redMul(u);\n    yyu4 = yyu4.redIAdd(yyu4);\n    yyu4 = yyu4.redIAdd(yyu4);\n    var nx = this.x.redMul(ee).redISub(yyu4);\n    nx = nx.redIAdd(nx);\n    nx = nx.redIAdd(nx);\n    // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n    var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n    ny = ny.redIAdd(ny);\n    ny = ny.redIAdd(ny);\n    ny = ny.redIAdd(ny);\n    // Z3 = (Z1 + E)^2 - ZZ - EE\n    var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n    return this.curve.jpoint(nx, ny, nz);\n};\nJPoint.prototype.mul = function mul(k, kbase) {\n    k = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(k, kbase);\n    return this.curve._wnafMul(this, k);\n};\nJPoint.prototype.eq = function eq(p) {\n    if (p.type === \"affine\") return this.eq(p.toJ());\n    if (this === p) return true;\n    // x1 * z2^2 == x2 * z1^2\n    var z2 = this.z.redSqr();\n    var pz2 = p.z.redSqr();\n    if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0) return false;\n    // y1 * z2^3 == y2 * z1^3\n    var z3 = z2.redMul(this.z);\n    var pz3 = pz2.redMul(p.z);\n    return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n};\nJPoint.prototype.eqXToP = function eqXToP(x) {\n    var zs = this.z.redSqr();\n    var rx = x.toRed(this.curve.red).redMul(zs);\n    if (this.x.cmp(rx) === 0) return true;\n    var xc = x.clone();\n    var t = this.curve.redN.redMul(zs);\n    for(;;){\n        xc.iadd(this.curve.n);\n        if (xc.cmp(this.curve.p) >= 0) return false;\n        rx.redIAdd(t);\n        if (this.x.cmp(rx) === 0) return true;\n    }\n};\nJPoint.prototype.inspect = function inspect() {\n    if (this.isInfinity()) return \"<EC JPoint Infinity>\";\n    return \"<EC JPoint x: \" + this.x.toString(16, 2) + \" y: \" + this.y.toString(16, 2) + \" z: \" + this.z.toString(16, 2) + \">\";\n};\nJPoint.prototype.isInfinity = function isInfinity() {\n    // XXX This code assumes that zero is always zero in red\n    return this.z.cmpn(0) === 0;\n};\nvar curve_1 = createCommonjsModule(function(module, exports) {\n    \"use strict\";\n    var curve = exports;\n    curve.base = base;\n    curve.short = short_1;\n    curve.mont = /*RicMoo:ethers:require(./mont)*/ null;\n    curve.edwards = /*RicMoo:ethers:require(./edwards)*/ null;\n});\nvar curves_1 = createCommonjsModule(function(module, exports) {\n    \"use strict\";\n    var curves = exports;\n    var assert = utils_1$1.assert;\n    function PresetCurve(options) {\n        if (options.type === \"short\") this.curve = new curve_1.short(options);\n        else if (options.type === \"edwards\") this.curve = new curve_1.edwards(options);\n        else this.curve = new curve_1.mont(options);\n        this.g = this.curve.g;\n        this.n = this.curve.n;\n        this.hash = options.hash;\n        assert(this.g.validate(), \"Invalid curve\");\n        assert(this.g.mul(this.n).isInfinity(), \"Invalid curve, G*N != O\");\n    }\n    curves.PresetCurve = PresetCurve;\n    function defineCurve(name, options) {\n        Object.defineProperty(curves, name, {\n            configurable: true,\n            enumerable: true,\n            get: function() {\n                var curve = new PresetCurve(options);\n                Object.defineProperty(curves, name, {\n                    configurable: true,\n                    enumerable: true,\n                    value: curve\n                });\n                return curve;\n            }\n        });\n    }\n    defineCurve(\"p192\", {\n        type: \"short\",\n        prime: \"p192\",\n        p: \"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff\",\n        a: \"ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc\",\n        b: \"64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1\",\n        n: \"ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831\",\n        hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),\n        gRed: false,\n        g: [\n            \"188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012\",\n            \"07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811\"\n        ]\n    });\n    defineCurve(\"p224\", {\n        type: \"short\",\n        prime: \"p224\",\n        p: \"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001\",\n        a: \"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe\",\n        b: \"b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4\",\n        n: \"ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d\",\n        hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),\n        gRed: false,\n        g: [\n            \"b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21\",\n            \"bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34\"\n        ]\n    });\n    defineCurve(\"p256\", {\n        type: \"short\",\n        prime: null,\n        p: \"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff\",\n        a: \"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc\",\n        b: \"5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b\",\n        n: \"ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551\",\n        hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),\n        gRed: false,\n        g: [\n            \"6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296\",\n            \"4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5\"\n        ]\n    });\n    defineCurve(\"p384\", {\n        type: \"short\",\n        prime: null,\n        p: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff \" + \"fffffffe ffffffff 00000000 00000000 ffffffff\",\n        a: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff \" + \"fffffffe ffffffff 00000000 00000000 fffffffc\",\n        b: \"b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f \" + \"5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef\",\n        n: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 \" + \"f4372ddf 581a0db2 48b0a77a ecec196a ccc52973\",\n        hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha384),\n        gRed: false,\n        g: [\n            \"aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 \" + \"5502f25d bf55296c 3a545e38 72760ab7\",\n            \"3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 \" + \"0a60b1ce 1d7e819d 7a431d7c 90ea0e5f\"\n        ]\n    });\n    defineCurve(\"p521\", {\n        type: \"short\",\n        prime: null,\n        p: \"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff \" + \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff \" + \"ffffffff ffffffff ffffffff ffffffff ffffffff\",\n        a: \"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff \" + \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff \" + \"ffffffff ffffffff ffffffff ffffffff fffffffc\",\n        b: \"00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b \" + \"99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd \" + \"3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00\",\n        n: \"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff \" + \"ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 \" + \"f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409\",\n        hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha512),\n        gRed: false,\n        g: [\n            \"000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 \" + \"053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 \" + \"a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66\",\n            \"00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 \" + \"579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 \" + \"3fad0761 353c7086 a272c240 88be9476 9fd16650\"\n        ]\n    });\n    defineCurve(\"curve25519\", {\n        type: \"mont\",\n        prime: \"p25519\",\n        p: \"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\",\n        a: \"76d06\",\n        b: \"1\",\n        n: \"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed\",\n        hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),\n        gRed: false,\n        g: [\n            \"9\"\n        ]\n    });\n    defineCurve(\"ed25519\", {\n        type: \"edwards\",\n        prime: \"p25519\",\n        p: \"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\",\n        a: \"-1\",\n        c: \"1\",\n        // -121665 * (121666^(-1)) (mod P)\n        d: \"52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3\",\n        n: \"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed\",\n        hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),\n        gRed: false,\n        g: [\n            \"216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a\",\n            // 4/5\n            \"6666666666666666666666666666666666666666666666666666666666666658\"\n        ]\n    });\n    var pre;\n    try {\n        pre = /*RicMoo:ethers:require(./precomputed/secp256k1)*/ null.crash();\n    } catch (e) {\n        pre = undefined;\n    }\n    defineCurve(\"secp256k1\", {\n        type: \"short\",\n        prime: \"k256\",\n        p: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f\",\n        a: \"0\",\n        b: \"7\",\n        n: \"ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141\",\n        h: \"1\",\n        hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),\n        // Precomputed endomorphism\n        beta: \"7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\",\n        lambda: \"5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72\",\n        basis: [\n            {\n                a: \"3086d221a7d46bcde86c90e49284eb15\",\n                b: \"-e4437ed6010e88286f547fa90abfe4c3\"\n            },\n            {\n                a: \"114ca50f7a8e2f3f657c1108d9d44cfd8\",\n                b: \"3086d221a7d46bcde86c90e49284eb15\"\n            }\n        ],\n        gRed: false,\n        g: [\n            \"79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\",\n            \"483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\",\n            pre\n        ]\n    });\n});\n\"use strict\";\nfunction HmacDRBG(options) {\n    if (!(this instanceof HmacDRBG)) return new HmacDRBG(options);\n    this.hash = options.hash;\n    this.predResist = !!options.predResist;\n    this.outLen = this.hash.outSize;\n    this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n    this._reseed = null;\n    this.reseedInterval = null;\n    this.K = null;\n    this.V = null;\n    var entropy = utils_1.toArray(options.entropy, options.entropyEnc || \"hex\");\n    var nonce = utils_1.toArray(options.nonce, options.nonceEnc || \"hex\");\n    var pers = utils_1.toArray(options.pers, options.persEnc || \"hex\");\n    minimalisticAssert(entropy.length >= this.minEntropy / 8, \"Not enough entropy. Minimum is: \" + this.minEntropy + \" bits\");\n    this._init(entropy, nonce, pers);\n}\nvar hmacDrbg = HmacDRBG;\nHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n    var seed = entropy.concat(nonce).concat(pers);\n    this.K = new Array(this.outLen / 8);\n    this.V = new Array(this.outLen / 8);\n    for(var i = 0; i < this.V.length; i++){\n        this.K[i] = 0x00;\n        this.V[i] = 0x01;\n    }\n    this._update(seed);\n    this._reseed = 1;\n    this.reseedInterval = 0x1000000000000; // 2^48\n};\nHmacDRBG.prototype._hmac = function hmac() {\n    return new (hash_js__WEBPACK_IMPORTED_MODULE_1___default().hmac)(this.hash, this.K);\n};\nHmacDRBG.prototype._update = function update(seed) {\n    var kmac = this._hmac().update(this.V).update([\n        0x00\n    ]);\n    if (seed) kmac = kmac.update(seed);\n    this.K = kmac.digest();\n    this.V = this._hmac().update(this.V).digest();\n    if (!seed) return;\n    this.K = this._hmac().update(this.V).update([\n        0x01\n    ]).update(seed).digest();\n    this.V = this._hmac().update(this.V).digest();\n};\nHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n    // Optional entropy enc\n    if (typeof entropyEnc !== \"string\") {\n        addEnc = add;\n        add = entropyEnc;\n        entropyEnc = null;\n    }\n    entropy = utils_1.toArray(entropy, entropyEnc);\n    add = utils_1.toArray(add, addEnc);\n    minimalisticAssert(entropy.length >= this.minEntropy / 8, \"Not enough entropy. Minimum is: \" + this.minEntropy + \" bits\");\n    this._update(entropy.concat(add || []));\n    this._reseed = 1;\n};\nHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n    if (this._reseed > this.reseedInterval) throw new Error(\"Reseed is required\");\n    // Optional encoding\n    if (typeof enc !== \"string\") {\n        addEnc = add;\n        add = enc;\n        enc = null;\n    }\n    // Optional additional data\n    if (add) {\n        add = utils_1.toArray(add, addEnc || \"hex\");\n        this._update(add);\n    }\n    var temp = [];\n    while(temp.length < len){\n        this.V = this._hmac().update(this.V).digest();\n        temp = temp.concat(this.V);\n    }\n    var res = temp.slice(0, len);\n    this._update(add);\n    this._reseed++;\n    return utils_1.encode(res, enc);\n};\n\"use strict\";\nvar assert$3 = utils_1$1.assert;\nfunction KeyPair(ec, options) {\n    this.ec = ec;\n    this.priv = null;\n    this.pub = null;\n    // KeyPair(ec, { priv: ..., pub: ... })\n    if (options.priv) this._importPrivate(options.priv, options.privEnc);\n    if (options.pub) this._importPublic(options.pub, options.pubEnc);\n}\nvar key = KeyPair;\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n    if (pub instanceof KeyPair) return pub;\n    return new KeyPair(ec, {\n        pub: pub,\n        pubEnc: enc\n    });\n};\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n    if (priv instanceof KeyPair) return priv;\n    return new KeyPair(ec, {\n        priv: priv,\n        privEnc: enc\n    });\n};\nKeyPair.prototype.validate = function validate() {\n    var pub = this.getPublic();\n    if (pub.isInfinity()) return {\n        result: false,\n        reason: \"Invalid public key\"\n    };\n    if (!pub.validate()) return {\n        result: false,\n        reason: \"Public key is not a point\"\n    };\n    if (!pub.mul(this.ec.curve.n).isInfinity()) return {\n        result: false,\n        reason: \"Public key * N != O\"\n    };\n    return {\n        result: true,\n        reason: null\n    };\n};\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n    // compact is optional argument\n    if (typeof compact === \"string\") {\n        enc = compact;\n        compact = null;\n    }\n    if (!this.pub) this.pub = this.ec.g.mul(this.priv);\n    if (!enc) return this.pub;\n    return this.pub.encode(enc, compact);\n};\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n    if (enc === \"hex\") return this.priv.toString(16, 2);\n    else return this.priv;\n};\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n    this.priv = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(key, enc || 16);\n    // Ensure that the priv won't be bigger than n, otherwise we may fail\n    // in fixed multiplication method\n    this.priv = this.priv.umod(this.ec.curve.n);\n};\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n    if (key.x || key.y) {\n        // Montgomery points only have an `x` coordinate.\n        // Weierstrass/Edwards points on the other hand have both `x` and\n        // `y` coordinates.\n        if (this.ec.curve.type === \"mont\") {\n            assert$3(key.x, \"Need x coordinate\");\n        } else if (this.ec.curve.type === \"short\" || this.ec.curve.type === \"edwards\") {\n            assert$3(key.x && key.y, \"Need both x and y coordinate\");\n        }\n        this.pub = this.ec.curve.point(key.x, key.y);\n        return;\n    }\n    this.pub = this.ec.curve.decodePoint(key, enc);\n};\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n    if (!pub.validate()) {\n        assert$3(pub.validate(), \"public point not validated\");\n    }\n    return pub.mul(this.priv).getX();\n};\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n    return this.ec.sign(msg, this, enc, options);\n};\nKeyPair.prototype.verify = function verify(msg, signature) {\n    return this.ec.verify(msg, signature, this);\n};\nKeyPair.prototype.inspect = function inspect() {\n    return \"<Key priv: \" + (this.priv && this.priv.toString(16, 2)) + \" pub: \" + (this.pub && this.pub.inspect()) + \" >\";\n};\n\"use strict\";\nvar assert$4 = utils_1$1.assert;\nfunction Signature(options, enc) {\n    if (options instanceof Signature) return options;\n    if (this._importDER(options, enc)) return;\n    assert$4(options.r && options.s, \"Signature without r or s\");\n    this.r = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(options.r, 16);\n    this.s = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(options.s, 16);\n    if (options.recoveryParam === undefined) this.recoveryParam = null;\n    else this.recoveryParam = options.recoveryParam;\n}\nvar signature = Signature;\nfunction Position() {\n    this.place = 0;\n}\nfunction getLength(buf, p) {\n    var initial = buf[p.place++];\n    if (!(initial & 0x80)) {\n        return initial;\n    }\n    var octetLen = initial & 0xf;\n    // Indefinite length or overflow\n    if (octetLen === 0 || octetLen > 4) {\n        return false;\n    }\n    var val = 0;\n    for(var i = 0, off = p.place; i < octetLen; i++, off++){\n        val <<= 8;\n        val |= buf[off];\n        val >>>= 0;\n    }\n    // Leading zeroes\n    if (val <= 0x7f) {\n        return false;\n    }\n    p.place = off;\n    return val;\n}\nfunction rmPadding(buf) {\n    var i = 0;\n    var len = buf.length - 1;\n    while(!buf[i] && !(buf[i + 1] & 0x80) && i < len){\n        i++;\n    }\n    if (i === 0) {\n        return buf;\n    }\n    return buf.slice(i);\n}\nSignature.prototype._importDER = function _importDER(data, enc) {\n    data = utils_1$1.toArray(data, enc);\n    var p = new Position();\n    if (data[p.place++] !== 0x30) {\n        return false;\n    }\n    var len = getLength(data, p);\n    if (len === false) {\n        return false;\n    }\n    if (len + p.place !== data.length) {\n        return false;\n    }\n    if (data[p.place++] !== 0x02) {\n        return false;\n    }\n    var rlen = getLength(data, p);\n    if (rlen === false) {\n        return false;\n    }\n    var r = data.slice(p.place, rlen + p.place);\n    p.place += rlen;\n    if (data[p.place++] !== 0x02) {\n        return false;\n    }\n    var slen = getLength(data, p);\n    if (slen === false) {\n        return false;\n    }\n    if (data.length !== slen + p.place) {\n        return false;\n    }\n    var s = data.slice(p.place, slen + p.place);\n    if (r[0] === 0) {\n        if (r[1] & 0x80) {\n            r = r.slice(1);\n        } else {\n            // Leading zeroes\n            return false;\n        }\n    }\n    if (s[0] === 0) {\n        if (s[1] & 0x80) {\n            s = s.slice(1);\n        } else {\n            // Leading zeroes\n            return false;\n        }\n    }\n    this.r = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(r);\n    this.s = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(s);\n    this.recoveryParam = null;\n    return true;\n};\nfunction constructLength(arr, len) {\n    if (len < 0x80) {\n        arr.push(len);\n        return;\n    }\n    var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n    arr.push(octets | 0x80);\n    while(--octets){\n        arr.push(len >>> (octets << 3) & 0xff);\n    }\n    arr.push(len);\n}\nSignature.prototype.toDER = function toDER(enc) {\n    var r = this.r.toArray();\n    var s = this.s.toArray();\n    // Pad values\n    if (r[0] & 0x80) r = [\n        0\n    ].concat(r);\n    // Pad values\n    if (s[0] & 0x80) s = [\n        0\n    ].concat(s);\n    r = rmPadding(r);\n    s = rmPadding(s);\n    while(!s[0] && !(s[1] & 0x80)){\n        s = s.slice(1);\n    }\n    var arr = [\n        0x02\n    ];\n    constructLength(arr, r.length);\n    arr = arr.concat(r);\n    arr.push(0x02);\n    constructLength(arr, s.length);\n    var backHalf = arr.concat(s);\n    var res = [\n        0x30\n    ];\n    constructLength(res, backHalf.length);\n    res = res.concat(backHalf);\n    return utils_1$1.encode(res, enc);\n};\n\"use strict\";\nvar rand = /*RicMoo:ethers:require(brorand)*/ function() {\n    throw new Error(\"unsupported\");\n};\nvar assert$5 = utils_1$1.assert;\nfunction EC(options) {\n    if (!(this instanceof EC)) return new EC(options);\n    // Shortcut `elliptic.ec(curve-name)`\n    if (typeof options === \"string\") {\n        assert$5(Object.prototype.hasOwnProperty.call(curves_1, options), \"Unknown curve \" + options);\n        options = curves_1[options];\n    }\n    // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n    if (options instanceof curves_1.PresetCurve) options = {\n        curve: options\n    };\n    this.curve = options.curve.curve;\n    this.n = this.curve.n;\n    this.nh = this.n.ushrn(1);\n    this.g = this.curve.g;\n    // Point on curve\n    this.g = options.curve.g;\n    this.g.precompute(options.curve.n.bitLength() + 1);\n    // Hash for function for DRBG\n    this.hash = options.hash || options.curve.hash;\n}\nvar ec = EC;\nEC.prototype.keyPair = function keyPair(options) {\n    return new key(this, options);\n};\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n    return key.fromPrivate(this, priv, enc);\n};\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n    return key.fromPublic(this, pub, enc);\n};\nEC.prototype.genKeyPair = function genKeyPair(options) {\n    if (!options) options = {};\n    // Instantiate Hmac_DRBG\n    var drbg = new hmacDrbg({\n        hash: this.hash,\n        pers: options.pers,\n        persEnc: options.persEnc || \"utf8\",\n        entropy: options.entropy || rand(this.hash.hmacStrength),\n        entropyEnc: options.entropy && options.entropyEnc || \"utf8\",\n        nonce: this.n.toArray()\n    });\n    var bytes = this.n.byteLength();\n    var ns2 = this.n.sub(new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(2));\n    for(;;){\n        var priv = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(drbg.generate(bytes));\n        if (priv.cmp(ns2) > 0) continue;\n        priv.iaddn(1);\n        return this.keyFromPrivate(priv);\n    }\n};\nEC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {\n    var delta = msg.byteLength() * 8 - this.n.bitLength();\n    if (delta > 0) msg = msg.ushrn(delta);\n    if (!truncOnly && msg.cmp(this.n) >= 0) return msg.sub(this.n);\n    else return msg;\n};\nEC.prototype.sign = function sign(msg, key, enc, options) {\n    if (typeof enc === \"object\") {\n        options = enc;\n        enc = null;\n    }\n    if (!options) options = {};\n    key = this.keyFromPrivate(key, enc);\n    msg = this._truncateToN(new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(msg, 16));\n    // Zero-extend key to provide enough entropy\n    var bytes = this.n.byteLength();\n    var bkey = key.getPrivate().toArray(\"be\", bytes);\n    // Zero-extend nonce to have the same byte size as N\n    var nonce = msg.toArray(\"be\", bytes);\n    // Instantiate Hmac_DRBG\n    var drbg = new hmacDrbg({\n        hash: this.hash,\n        entropy: bkey,\n        nonce: nonce,\n        pers: options.pers,\n        persEnc: options.persEnc || \"utf8\"\n    });\n    // Number of bytes to generate\n    var ns1 = this.n.sub(new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(1));\n    for(var iter = 0;; iter++){\n        var k = options.k ? options.k(iter) : new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(drbg.generate(this.n.byteLength()));\n        k = this._truncateToN(k, true);\n        if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0) continue;\n        var kp = this.g.mul(k);\n        if (kp.isInfinity()) continue;\n        var kpX = kp.getX();\n        var r = kpX.umod(this.n);\n        if (r.cmpn(0) === 0) continue;\n        var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n        s = s.umod(this.n);\n        if (s.cmpn(0) === 0) continue;\n        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);\n        // Use complement of `s`, if it is > `n / 2`\n        if (options.canonical && s.cmp(this.nh) > 0) {\n            s = this.n.sub(s);\n            recoveryParam ^= 1;\n        }\n        return new signature({\n            r: r,\n            s: s,\n            recoveryParam: recoveryParam\n        });\n    }\n};\nEC.prototype.verify = function verify(msg, signature$1, key, enc) {\n    msg = this._truncateToN(new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(msg, 16));\n    key = this.keyFromPublic(key, enc);\n    signature$1 = new signature(signature$1, \"hex\");\n    // Perform primitive values validation\n    var r = signature$1.r;\n    var s = signature$1.s;\n    if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0) return false;\n    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return false;\n    // Validate signature\n    var sinv = s.invm(this.n);\n    var u1 = sinv.mul(msg).umod(this.n);\n    var u2 = sinv.mul(r).umod(this.n);\n    var p;\n    if (!this.curve._maxwellTrick) {\n        p = this.g.mulAdd(u1, key.getPublic(), u2);\n        if (p.isInfinity()) return false;\n        return p.getX().umod(this.n).cmp(r) === 0;\n    }\n    // NOTE: Greg Maxwell's trick, inspired by:\n    // https://git.io/vad3K\n    p = this.g.jmulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity()) return false;\n    // Compare `p.x` of Jacobian point with `r`,\n    // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n    // inverse of `p.z^2`\n    return p.eqXToP(r);\n};\nEC.prototype.recoverPubKey = function(msg, signature$1, j, enc) {\n    assert$5((3 & j) === j, \"The recovery param is more than two bits\");\n    signature$1 = new signature(signature$1, enc);\n    var n = this.n;\n    var e = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(msg);\n    var r = signature$1.r;\n    var s = signature$1.s;\n    // A set LSB signifies that the y-coordinate is odd\n    var isYOdd = j & 1;\n    var isSecondKey = j >> 1;\n    if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey) throw new Error(\"Unable to find sencond key candinate\");\n    // 1.1. Let x = r + jn.\n    if (isSecondKey) r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n    else r = this.curve.pointFromX(r, isYOdd);\n    var rInv = signature$1.r.invm(n);\n    var s1 = n.sub(e).mul(rInv).umod(n);\n    var s2 = s.mul(rInv).umod(n);\n    // 1.6.1 Compute Q = r^-1 (sR -  eG)\n    //               Q = r^-1 (sR + -eG)\n    return this.g.mulAdd(s1, r, s2);\n};\nEC.prototype.getKeyRecoveryParam = function(e, signature$1, Q, enc) {\n    signature$1 = new signature(signature$1, enc);\n    if (signature$1.recoveryParam !== null) return signature$1.recoveryParam;\n    for(var i = 0; i < 4; i++){\n        var Qprime;\n        try {\n            Qprime = this.recoverPubKey(e, signature$1, i);\n        } catch (e) {\n            continue;\n        }\n        if (Qprime.eq(Q)) return i;\n    }\n    throw new Error(\"Unable to find valid recovery factor\");\n};\nvar elliptic_1 = createCommonjsModule(function(module, exports) {\n    \"use strict\";\n    var elliptic = exports;\n    elliptic.version = /*RicMoo:ethers*/ ({\n        version: \"6.5.4\"\n    }).version;\n    elliptic.utils = utils_1$1;\n    elliptic.rand = /*RicMoo:ethers:require(brorand)*/ function() {\n        throw new Error(\"unsupported\");\n    };\n    elliptic.curve = curve_1;\n    elliptic.curves = curves_1;\n    // Protocols\n    elliptic.ec = ec;\n    elliptic.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/ null;\n});\nvar EC$1 = elliptic_1.ec;\n //# sourceMappingURL=elliptic.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaWduaW5nLWtleS9saWIuZXNtL2VsbGlwdGljLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXVCO0FBQ0k7QUFFM0IsSUFBSUUsaUJBQWlCLE9BQU9DLGVBQWUsY0FBY0EsYUFBYSxNQUFrQixHQUFjQyxDQUFNQSxHQUFHLE9BQU9DLFdBQVcsY0FBY0EsU0FBUyxPQUFPQyxTQUFTLGNBQWNBLE9BQU8sQ0FBQztBQUU5TCxTQUFTQyx3QkFBeUJDLENBQUM7SUFDbEMsT0FBT0EsS0FBS0EsRUFBRUMsVUFBVSxJQUFJQyxPQUFPQyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDTCxHQUFHLGFBQWFBLENBQUMsQ0FBQyxVQUFVLEdBQUdBO0FBQ2pHO0FBRUEsU0FBU00scUJBQXFCQyxFQUFFLEVBQUVDLE9BQU8sRUFBRUMsTUFBTTtJQUNoRCxPQUFPQSxTQUFTO1FBQ2ZDLE1BQU1GO1FBQ05HLFNBQVMsQ0FBQztRQUNWQyxTQUFTLFNBQVVGLElBQUksRUFBRUcsSUFBSTtZQUM1QixPQUFPQyxnQkFBZ0JKLE1BQU0sU0FBVUssYUFBYUYsU0FBUyxPQUFRSixPQUFPQyxJQUFJLEdBQUdHO1FBQ3BGO0lBQ0QsR0FBR04sR0FBR0UsUUFBUUEsT0FBT0UsT0FBTyxHQUFHRixPQUFPRSxPQUFPO0FBQzlDO0FBRUEsU0FBU0ssdUNBQXdDQyxDQUFDO0lBQ2pELE9BQU9BLEtBQUtmLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNZLEdBQUcsYUFBYUEsQ0FBQyxDQUFDLFVBQVUsR0FBR0E7QUFDakY7QUFFQSxTQUFTQyx3Q0FBeUNELENBQUM7SUFDbEQsT0FBT0EsS0FBS2YsT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1ksR0FBRyxjQUFjZixPQUFPaUIsSUFBSSxDQUFDRixHQUFHRyxNQUFNLEtBQUssSUFBSUgsQ0FBQyxD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LE1BQU0sR0FBR0Q7SUFFbEIsWUFBWTtJQUNaOEcsU0FBU3JFLEVBQUUsR0FBR0E7SUFDZHFFLFNBQVNFLEtBQUssR0FBRyx5Q0FBeUMsR0FBRztBQUM3RDtBQUVBLElBQUlDLE9BQU9KLFdBQVdwRSxFQUFFO0FBRUYsQ0FDdEIsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2xpbWUtYmV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc2lnbmluZy1rZXkvbGliLmVzbS9lbGxpcHRpYy5qcz9mMjg5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCTiBmcm9tICdibi5qcyc7XG5pbXBvcnQgaGFzaCBmcm9tICdoYXNoLmpzJztcblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBiYXNlZGlyLCBtb2R1bGUpIHtcblx0cmV0dXJuIG1vZHVsZSA9IHtcblx0XHRwYXRoOiBiYXNlZGlyLFxuXHRcdGV4cG9ydHM6IHt9LFxuXHRcdHJlcXVpcmU6IGZ1bmN0aW9uIChwYXRoLCBiYXNlKSB7XG5cdFx0XHRyZXR1cm4gY29tbW9uanNSZXF1aXJlKHBhdGgsIChiYXNlID09PSB1bmRlZmluZWQgfHwgYmFzZSA9PT0gbnVsbCkgPyBtb2R1bGUucGF0aCA6IGJhc2UpO1xuXHRcdH1cblx0fSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbU5hbWVzcGFjZUlmUHJlc2VudCAobikge1xuXHRyZXR1cm4gbiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgJ2RlZmF1bHQnKSA/IG5bJ2RlZmF1bHQnXSA6IG47XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tTmFtZXNwYWNlSWZOb3ROYW1lZCAobikge1xuXHRyZXR1cm4gbiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgJ2RlZmF1bHQnKSAmJiBPYmplY3Qua2V5cyhuKS5sZW5ndGggPT09IDEgPyBuWydkZWZhdWx0J10gOiBuO1xufVxuXG5mdW5jdGlvbiBnZXRBdWdtZW50ZWROYW1lc3BhY2Uobikge1xuXHRpZiAobi5fX2VzTW9kdWxlKSByZXR1cm4gbjtcblx0dmFyIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdfX2VzTW9kdWxlJywge3ZhbHVlOiB0cnVlfSk7XG5cdE9iamVjdC5rZXlzKG4pLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0XHR2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobiwgayk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsIGssIGQuZ2V0ID8gZCA6IHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIG5ba107XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXHRyZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gY29tbW9uanNSZXF1aXJlICgpIHtcblx0dGhyb3cgbmV3IEVycm9yKCdEeW5hbWljIHJlcXVpcmVzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSBAcm9sbHVwL3BsdWdpbi1jb21tb25qcycpO1xufVxuXG52YXIgbWluaW1hbGlzdGljQXNzZXJ0ID0gYXNzZXJ0O1xuXG5mdW5jdGlvbiBhc3NlcnQodmFsLCBtc2cpIHtcbiAgaWYgKCF2YWwpXG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xufVxuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBhc3NlcnRFcXVhbChsLCByLCBtc2cpIHtcbiAgaWYgKGwgIT0gcilcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICgnQXNzZXJ0aW9uIGZhaWxlZDogJyArIGwgKyAnICE9ICcgKyByKSk7XG59O1xuXG52YXIgdXRpbHNfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gZXhwb3J0cztcblxuZnVuY3Rpb24gdG9BcnJheShtc2csIGVuYykge1xuICBpZiAoQXJyYXkuaXNBcnJheShtc2cpKVxuICAgIHJldHVybiBtc2cuc2xpY2UoKTtcbiAgaWYgKCFtc2cpXG4gICAgcmV0dXJuIFtdO1xuICB2YXIgcmVzID0gW107XG4gIGlmICh0eXBlb2YgbXNnICE9PSAnc3RyaW5nJykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgICAgcmVzW2ldID0gbXNnW2ldIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmIChlbmMgPT09ICdoZXgnKSB7XG4gICAgbXNnID0gbXNnLnJlcGxhY2UoL1teYS16MC05XSsvaWcsICcnKTtcbiAgICBpZiAobXNnLmxlbmd0aCAlIDIgIT09IDApXG4gICAgICBtc2cgPSAnMCcgKyBtc2c7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpICs9IDIpXG4gICAgICByZXMucHVzaChwYXJzZUludChtc2dbaV0gKyBtc2dbaSArIDFdLCAxNikpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IG1zZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgdmFyIGhpID0gYyA+PiA4O1xuICAgICAgdmFyIGxvID0gYyAmIDB4ZmY7XG4gICAgICBpZiAoaGkpXG4gICAgICAgIHJlcy5wdXNoKGhpLCBsbyk7XG4gICAgICBlbHNlXG4gICAgICAgIHJlcy5wdXNoKGxvKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbnV0aWxzLnRvQXJyYXkgPSB0b0FycmF5O1xuXG5mdW5jdGlvbiB6ZXJvMih3b3JkKSB7XG4gIGlmICh3b3JkLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gJzAnICsgd29yZDtcbiAgZWxzZVxuICAgIHJldHVybiB3b3JkO1xufVxudXRpbHMuemVybzIgPSB6ZXJvMjtcblxuZnVuY3Rpb24gdG9IZXgobXNnKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG4gICAgcmVzICs9IHplcm8yKG1zZ1tpXS50b1N0cmluZygxNikpO1xuICByZXR1cm4gcmVzO1xufVxudXRpbHMudG9IZXggPSB0b0hleDtcblxudXRpbHMuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGFyciwgZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB0b0hleChhcnIpO1xuICBlbHNlXG4gICAgcmV0dXJuIGFycjtcbn07XG59KTtcblxudmFyIHV0aWxzXzEkMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gZXhwb3J0cztcblxuXG5cblxudXRpbHMuYXNzZXJ0ID0gbWluaW1hbGlzdGljQXNzZXJ0O1xudXRpbHMudG9BcnJheSA9IHV0aWxzXzEudG9BcnJheTtcbnV0aWxzLnplcm8yID0gdXRpbHNfMS56ZXJvMjtcbnV0aWxzLnRvSGV4ID0gdXRpbHNfMS50b0hleDtcbnV0aWxzLmVuY29kZSA9IHV0aWxzXzEuZW5jb2RlO1xuXG4vLyBSZXByZXNlbnQgbnVtIGluIGEgdy1OQUYgZm9ybVxuZnVuY3Rpb24gZ2V0TkFGKG51bSwgdywgYml0cykge1xuICB2YXIgbmFmID0gbmV3IEFycmF5KE1hdGgubWF4KG51bS5iaXRMZW5ndGgoKSwgYml0cykgKyAxKTtcbiAgbmFmLmZpbGwoMCk7XG5cbiAgdmFyIHdzID0gMSA8PCAodyArIDEpO1xuICB2YXIgayA9IG51bS5jbG9uZSgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbmFmLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHo7XG4gICAgdmFyIG1vZCA9IGsuYW5kbG4od3MgLSAxKTtcbiAgICBpZiAoay5pc09kZCgpKSB7XG4gICAgICBpZiAobW9kID4gKHdzID4+IDEpIC0gMSlcbiAgICAgICAgeiA9ICh3cyA+PiAxKSAtIG1vZDtcbiAgICAgIGVsc2VcbiAgICAgICAgeiA9IG1vZDtcbiAgICAgIGsuaXN1Ym4oeik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHogPSAwO1xuICAgIH1cblxuICAgIG5hZltpXSA9IHo7XG4gICAgay5pdXNocm4oMSk7XG4gIH1cblxuICByZXR1cm4gbmFmO1xufVxudXRpbHMuZ2V0TkFGID0gZ2V0TkFGO1xuXG4vLyBSZXByZXNlbnQgazEsIGsyIGluIGEgSm9pbnQgU3BhcnNlIEZvcm1cbmZ1bmN0aW9uIGdldEpTRihrMSwgazIpIHtcbiAgdmFyIGpzZiA9IFtcbiAgICBbXSxcbiAgICBbXSxcbiAgXTtcblxuICBrMSA9IGsxLmNsb25lKCk7XG4gIGsyID0gazIuY2xvbmUoKTtcbiAgdmFyIGQxID0gMDtcbiAgdmFyIGQyID0gMDtcbiAgdmFyIG04O1xuICB3aGlsZSAoazEuY21wbigtZDEpID4gMCB8fCBrMi5jbXBuKC1kMikgPiAwKSB7XG4gICAgLy8gRmlyc3QgcGhhc2VcbiAgICB2YXIgbTE0ID0gKGsxLmFuZGxuKDMpICsgZDEpICYgMztcbiAgICB2YXIgbTI0ID0gKGsyLmFuZGxuKDMpICsgZDIpICYgMztcbiAgICBpZiAobTE0ID09PSAzKVxuICAgICAgbTE0ID0gLTE7XG4gICAgaWYgKG0yNCA9PT0gMylcbiAgICAgIG0yNCA9IC0xO1xuICAgIHZhciB1MTtcbiAgICBpZiAoKG0xNCAmIDEpID09PSAwKSB7XG4gICAgICB1MSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG04ID0gKGsxLmFuZGxuKDcpICsgZDEpICYgNztcbiAgICAgIGlmICgobTggPT09IDMgfHwgbTggPT09IDUpICYmIG0yNCA9PT0gMilcbiAgICAgICAgdTEgPSAtbTE0O1xuICAgICAgZWxzZVxuICAgICAgICB1MSA9IG0xNDtcbiAgICB9XG4gICAganNmWzBdLnB1c2godTEpO1xuXG4gICAgdmFyIHUyO1xuICAgIGlmICgobTI0ICYgMSkgPT09IDApIHtcbiAgICAgIHUyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgbTggPSAoazIuYW5kbG4oNykgKyBkMikgJiA3O1xuICAgICAgaWYgKChtOCA9PT0gMyB8fCBtOCA9PT0gNSkgJiYgbTE0ID09PSAyKVxuICAgICAgICB1MiA9IC1tMjQ7XG4gICAgICBlbHNlXG4gICAgICAgIHUyID0gbTI0O1xuICAgIH1cbiAgICBqc2ZbMV0ucHVzaCh1Mik7XG5cbiAgICAvLyBTZWNvbmQgcGhhc2VcbiAgICBpZiAoMiAqIGQxID09PSB1MSArIDEpXG4gICAgICBkMSA9IDEgLSBkMTtcbiAgICBpZiAoMiAqIGQyID09PSB1MiArIDEpXG4gICAgICBkMiA9IDEgLSBkMjtcbiAgICBrMS5pdXNocm4oMSk7XG4gICAgazIuaXVzaHJuKDEpO1xuICB9XG5cbiAgcmV0dXJuIGpzZjtcbn1cbnV0aWxzLmdldEpTRiA9IGdldEpTRjtcblxuZnVuY3Rpb24gY2FjaGVkUHJvcGVydHkob2JqLCBuYW1lLCBjb21wdXRlcikge1xuICB2YXIga2V5ID0gJ18nICsgbmFtZTtcbiAgb2JqLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uIGNhY2hlZFByb3BlcnR5KCkge1xuICAgIHJldHVybiB0aGlzW2tleV0gIT09IHVuZGVmaW5lZCA/IHRoaXNba2V5XSA6XG4gICAgICB0aGlzW2tleV0gPSBjb21wdXRlci5jYWxsKHRoaXMpO1xuICB9O1xufVxudXRpbHMuY2FjaGVkUHJvcGVydHkgPSBjYWNoZWRQcm9wZXJ0eTtcblxuZnVuY3Rpb24gcGFyc2VCeXRlcyhieXRlcykge1xuICByZXR1cm4gdHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJyA/IHV0aWxzLnRvQXJyYXkoYnl0ZXMsICdoZXgnKSA6XG4gICAgYnl0ZXM7XG59XG51dGlscy5wYXJzZUJ5dGVzID0gcGFyc2VCeXRlcztcblxuZnVuY3Rpb24gaW50RnJvbUxFKGJ5dGVzKSB7XG4gIHJldHVybiBuZXcgQk4oYnl0ZXMsICdoZXgnLCAnbGUnKTtcbn1cbnV0aWxzLmludEZyb21MRSA9IGludEZyb21MRTtcbn0pO1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG52YXIgZ2V0TkFGID0gdXRpbHNfMSQxLmdldE5BRjtcbnZhciBnZXRKU0YgPSB1dGlsc18xJDEuZ2V0SlNGO1xudmFyIGFzc2VydCQxID0gdXRpbHNfMSQxLmFzc2VydDtcblxuZnVuY3Rpb24gQmFzZUN1cnZlKHR5cGUsIGNvbmYpIHtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5wID0gbmV3IEJOKGNvbmYucCwgMTYpO1xuXG4gIC8vIFVzZSBNb250Z29tZXJ5LCB3aGVuIHRoZXJlIGlzIG5vIGZhc3QgcmVkdWN0aW9uIGZvciB0aGUgcHJpbWVcbiAgdGhpcy5yZWQgPSBjb25mLnByaW1lID8gQk4ucmVkKGNvbmYucHJpbWUpIDogQk4ubW9udCh0aGlzLnApO1xuXG4gIC8vIFVzZWZ1bCBmb3IgbWFueSBjdXJ2ZXNcbiAgdGhpcy56ZXJvID0gbmV3IEJOKDApLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5vbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLnR3byA9IG5ldyBCTigyKS50b1JlZCh0aGlzLnJlZCk7XG5cbiAgLy8gQ3VydmUgY29uZmlndXJhdGlvbiwgb3B0aW9uYWxcbiAgdGhpcy5uID0gY29uZi5uICYmIG5ldyBCTihjb25mLm4sIDE2KTtcbiAgdGhpcy5nID0gY29uZi5nICYmIHRoaXMucG9pbnRGcm9tSlNPTihjb25mLmcsIGNvbmYuZ1JlZCk7XG5cbiAgLy8gVGVtcG9yYXJ5IGFycmF5c1xuICB0aGlzLl93bmFmVDEgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX3duYWZUMiA9IG5ldyBBcnJheSg0KTtcbiAgdGhpcy5fd25hZlQzID0gbmV3IEFycmF5KDQpO1xuICB0aGlzLl93bmFmVDQgPSBuZXcgQXJyYXkoNCk7XG5cbiAgdGhpcy5fYml0TGVuZ3RoID0gdGhpcy5uID8gdGhpcy5uLmJpdExlbmd0aCgpIDogMDtcblxuICAvLyBHZW5lcmFsaXplZCBHcmVnIE1heHdlbGwncyB0cmlja1xuICB2YXIgYWRqdXN0Q291bnQgPSB0aGlzLm4gJiYgdGhpcy5wLmRpdih0aGlzLm4pO1xuICBpZiAoIWFkanVzdENvdW50IHx8IGFkanVzdENvdW50LmNtcG4oMTAwKSA+IDApIHtcbiAgICB0aGlzLnJlZE4gPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX21heHdlbGxUcmljayA9IHRydWU7XG4gICAgdGhpcy5yZWROID0gdGhpcy5uLnRvUmVkKHRoaXMucmVkKTtcbiAgfVxufVxudmFyIGJhc2UgPSBCYXNlQ3VydmU7XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUuX2ZpeGVkTmFmTXVsID0gZnVuY3Rpb24gX2ZpeGVkTmFmTXVsKHAsIGspIHtcbiAgYXNzZXJ0JDEocC5wcmVjb21wdXRlZCk7XG4gIHZhciBkb3VibGVzID0gcC5fZ2V0RG91YmxlcygpO1xuXG4gIHZhciBuYWYgPSBnZXROQUYoaywgMSwgdGhpcy5fYml0TGVuZ3RoKTtcbiAgdmFyIEkgPSAoMSA8PCAoZG91Ymxlcy5zdGVwICsgMSkpIC0gKGRvdWJsZXMuc3RlcCAlIDIgPT09IDAgPyAyIDogMSk7XG4gIEkgLz0gMztcblxuICAvLyBUcmFuc2xhdGUgaW50byBtb3JlIHdpbmRvd2VkIGZvcm1cbiAgdmFyIHJlcHIgPSBbXTtcbiAgdmFyIGo7XG4gIHZhciBuYWZXO1xuICBmb3IgKGogPSAwOyBqIDwgbmFmLmxlbmd0aDsgaiArPSBkb3VibGVzLnN0ZXApIHtcbiAgICBuYWZXID0gMDtcbiAgICBmb3IgKHZhciBsID0gaiArIGRvdWJsZXMuc3RlcCAtIDE7IGwgPj0gajsgbC0tKVxuICAgICAgbmFmVyA9IChuYWZXIDw8IDEpICsgbmFmW2xdO1xuICAgIHJlcHIucHVzaChuYWZXKTtcbiAgfVxuXG4gIHZhciBhID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIHZhciBiID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIGZvciAodmFyIGkgPSBJOyBpID4gMDsgaS0tKSB7XG4gICAgZm9yIChqID0gMDsgaiA8IHJlcHIubGVuZ3RoOyBqKyspIHtcbiAgICAgIG5hZlcgPSByZXByW2pdO1xuICAgICAgaWYgKG5hZlcgPT09IGkpXG4gICAgICAgIGIgPSBiLm1peGVkQWRkKGRvdWJsZXMucG9pbnRzW2pdKTtcbiAgICAgIGVsc2UgaWYgKG5hZlcgPT09IC1pKVxuICAgICAgICBiID0gYi5taXhlZEFkZChkb3VibGVzLnBvaW50c1tqXS5uZWcoKSk7XG4gICAgfVxuICAgIGEgPSBhLmFkZChiKTtcbiAgfVxuICByZXR1cm4gYS50b1AoKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUuX3duYWZNdWwgPSBmdW5jdGlvbiBfd25hZk11bChwLCBrKSB7XG4gIHZhciB3ID0gNDtcblxuICAvLyBQcmVjb21wdXRlIHdpbmRvd1xuICB2YXIgbmFmUG9pbnRzID0gcC5fZ2V0TkFGUG9pbnRzKHcpO1xuICB3ID0gbmFmUG9pbnRzLnduZDtcbiAgdmFyIHduZCA9IG5hZlBvaW50cy5wb2ludHM7XG5cbiAgLy8gR2V0IE5BRiBmb3JtXG4gIHZhciBuYWYgPSBnZXROQUYoaywgdywgdGhpcy5fYml0TGVuZ3RoKTtcblxuICAvLyBBZGQgYHRoaXNgKihOKzEpIGZvciBldmVyeSB3LU5BRiBpbmRleFxuICB2YXIgYWNjID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIGZvciAodmFyIGkgPSBuYWYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAvLyBDb3VudCB6ZXJvZXNcbiAgICBmb3IgKHZhciBsID0gMDsgaSA+PSAwICYmIG5hZltpXSA9PT0gMDsgaS0tKVxuICAgICAgbCsrO1xuICAgIGlmIChpID49IDApXG4gICAgICBsKys7XG4gICAgYWNjID0gYWNjLmRibHAobCk7XG5cbiAgICBpZiAoaSA8IDApXG4gICAgICBicmVhaztcbiAgICB2YXIgeiA9IG5hZltpXTtcbiAgICBhc3NlcnQkMSh6ICE9PSAwKTtcbiAgICBpZiAocC50eXBlID09PSAnYWZmaW5lJykge1xuICAgICAgLy8gSiArLSBQXG4gICAgICBpZiAoeiA+IDApXG4gICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZCh3bmRbKHogLSAxKSA+PiAxXSk7XG4gICAgICBlbHNlXG4gICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZCh3bmRbKC16IC0gMSkgPj4gMV0ubmVnKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBKICstIEpcbiAgICAgIGlmICh6ID4gMClcbiAgICAgICAgYWNjID0gYWNjLmFkZCh3bmRbKHogLSAxKSA+PiAxXSk7XG4gICAgICBlbHNlXG4gICAgICAgIGFjYyA9IGFjYy5hZGQod25kWygteiAtIDEpID4+IDFdLm5lZygpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHAudHlwZSA9PT0gJ2FmZmluZScgPyBhY2MudG9QKCkgOiBhY2M7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLl93bmFmTXVsQWRkID0gZnVuY3Rpb24gX3duYWZNdWxBZGQoZGVmVyxcbiAgcG9pbnRzLFxuICBjb2VmZnMsXG4gIGxlbixcbiAgamFjb2JpYW5SZXN1bHQpIHtcbiAgdmFyIHduZFdpZHRoID0gdGhpcy5fd25hZlQxO1xuICB2YXIgd25kID0gdGhpcy5fd25hZlQyO1xuICB2YXIgbmFmID0gdGhpcy5fd25hZlQzO1xuXG4gIC8vIEZpbGwgYWxsIGFycmF5c1xuICB2YXIgbWF4ID0gMDtcbiAgdmFyIGk7XG4gIHZhciBqO1xuICB2YXIgcDtcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcCA9IHBvaW50c1tpXTtcbiAgICB2YXIgbmFmUG9pbnRzID0gcC5fZ2V0TkFGUG9pbnRzKGRlZlcpO1xuICAgIHduZFdpZHRoW2ldID0gbmFmUG9pbnRzLnduZDtcbiAgICB3bmRbaV0gPSBuYWZQb2ludHMucG9pbnRzO1xuICB9XG5cbiAgLy8gQ29tYiBzbWFsbCB3aW5kb3cgTkFGc1xuICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDE7IGkgLT0gMikge1xuICAgIHZhciBhID0gaSAtIDE7XG4gICAgdmFyIGIgPSBpO1xuICAgIGlmICh3bmRXaWR0aFthXSAhPT0gMSB8fCB3bmRXaWR0aFtiXSAhPT0gMSkge1xuICAgICAgbmFmW2FdID0gZ2V0TkFGKGNvZWZmc1thXSwgd25kV2lkdGhbYV0sIHRoaXMuX2JpdExlbmd0aCk7XG4gICAgICBuYWZbYl0gPSBnZXROQUYoY29lZmZzW2JdLCB3bmRXaWR0aFtiXSwgdGhpcy5fYml0TGVuZ3RoKTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG5hZlthXS5sZW5ndGgsIG1heCk7XG4gICAgICBtYXggPSBNYXRoLm1heChuYWZbYl0ubGVuZ3RoLCBtYXgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGNvbWIgPSBbXG4gICAgICBwb2ludHNbYV0sIC8qIDEgKi9cbiAgICAgIG51bGwsIC8qIDMgKi9cbiAgICAgIG51bGwsIC8qIDUgKi9cbiAgICAgIHBvaW50c1tiXSwgLyogNyAqL1xuICAgIF07XG5cbiAgICAvLyBUcnkgdG8gYXZvaWQgUHJvamVjdGl2ZSBwb2ludHMsIGlmIHBvc3NpYmxlXG4gICAgaWYgKHBvaW50c1thXS55LmNtcChwb2ludHNbYl0ueSkgPT09IDApIHtcbiAgICAgIGNvbWJbMV0gPSBwb2ludHNbYV0uYWRkKHBvaW50c1tiXSk7XG4gICAgICBjb21iWzJdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXS5uZWcoKSk7XG4gICAgfSBlbHNlIGlmIChwb2ludHNbYV0ueS5jbXAocG9pbnRzW2JdLnkucmVkTmVnKCkpID09PSAwKSB7XG4gICAgICBjb21iWzFdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXSk7XG4gICAgICBjb21iWzJdID0gcG9pbnRzW2FdLmFkZChwb2ludHNbYl0ubmVnKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21iWzFdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXSk7XG4gICAgICBjb21iWzJdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXS5uZWcoKSk7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gW1xuICAgICAgLTMsIC8qIC0xIC0xICovXG4gICAgICAtMSwgLyogLTEgMCAqL1xuICAgICAgLTUsIC8qIC0xIDEgKi9cbiAgICAgIC03LCAvKiAwIC0xICovXG4gICAgICAwLCAvKiAwIDAgKi9cbiAgICAgIDcsIC8qIDAgMSAqL1xuICAgICAgNSwgLyogMSAtMSAqL1xuICAgICAgMSwgLyogMSAwICovXG4gICAgICAzLCAgLyogMSAxICovXG4gICAgXTtcblxuICAgIHZhciBqc2YgPSBnZXRKU0YoY29lZmZzW2FdLCBjb2VmZnNbYl0pO1xuICAgIG1heCA9IE1hdGgubWF4KGpzZlswXS5sZW5ndGgsIG1heCk7XG4gICAgbmFmW2FdID0gbmV3IEFycmF5KG1heCk7XG4gICAgbmFmW2JdID0gbmV3IEFycmF5KG1heCk7XG4gICAgZm9yIChqID0gMDsgaiA8IG1heDsgaisrKSB7XG4gICAgICB2YXIgamEgPSBqc2ZbMF1bal0gfCAwO1xuICAgICAgdmFyIGpiID0ganNmWzFdW2pdIHwgMDtcblxuICAgICAgbmFmW2FdW2pdID0gaW5kZXhbKGphICsgMSkgKiAzICsgKGpiICsgMSldO1xuICAgICAgbmFmW2JdW2pdID0gMDtcbiAgICAgIHduZFthXSA9IGNvbWI7XG4gICAgfVxuICB9XG5cbiAgdmFyIGFjYyA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICB2YXIgdG1wID0gdGhpcy5fd25hZlQ0O1xuICBmb3IgKGkgPSBtYXg7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGsgPSAwO1xuXG4gICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgdmFyIHplcm8gPSB0cnVlO1xuICAgICAgZm9yIChqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIHRtcFtqXSA9IG5hZltqXVtpXSB8IDA7XG4gICAgICAgIGlmICh0bXBbal0gIT09IDApXG4gICAgICAgICAgemVybyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF6ZXJvKVxuICAgICAgICBicmVhaztcbiAgICAgIGsrKztcbiAgICAgIGktLTtcbiAgICB9XG4gICAgaWYgKGkgPj0gMClcbiAgICAgIGsrKztcbiAgICBhY2MgPSBhY2MuZGJscChrKTtcbiAgICBpZiAoaSA8IDApXG4gICAgICBicmVhaztcblxuICAgIGZvciAoaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgdmFyIHogPSB0bXBbal07XG4gICAgICBwO1xuICAgICAgaWYgKHogPT09IDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgZWxzZSBpZiAoeiA+IDApXG4gICAgICAgIHAgPSB3bmRbal1bKHogLSAxKSA+PiAxXTtcbiAgICAgIGVsc2UgaWYgKHogPCAwKVxuICAgICAgICBwID0gd25kW2pdWygteiAtIDEpID4+IDFdLm5lZygpO1xuXG4gICAgICBpZiAocC50eXBlID09PSAnYWZmaW5lJylcbiAgICAgICAgYWNjID0gYWNjLm1peGVkQWRkKHApO1xuICAgICAgZWxzZVxuICAgICAgICBhY2MgPSBhY2MuYWRkKHApO1xuICAgIH1cbiAgfVxuICAvLyBaZXJvaWZ5IHJlZmVyZW5jZXNcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgIHduZFtpXSA9IG51bGw7XG5cbiAgaWYgKGphY29iaWFuUmVzdWx0KVxuICAgIHJldHVybiBhY2M7XG4gIGVsc2VcbiAgICByZXR1cm4gYWNjLnRvUCgpO1xufTtcblxuZnVuY3Rpb24gQmFzZVBvaW50KGN1cnZlLCB0eXBlKSB7XG4gIHRoaXMuY3VydmUgPSBjdXJ2ZTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5wcmVjb21wdXRlZCA9IG51bGw7XG59XG5CYXNlQ3VydmUuQmFzZVBvaW50ID0gQmFzZVBvaW50O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEoLypvdGhlciovKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gIHJldHVybiB0aGlzLmN1cnZlLnZhbGlkYXRlKHRoaXMpO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5kZWNvZGVQb2ludCA9IGZ1bmN0aW9uIGRlY29kZVBvaW50KGJ5dGVzLCBlbmMpIHtcbiAgYnl0ZXMgPSB1dGlsc18xJDEudG9BcnJheShieXRlcywgZW5jKTtcblxuICB2YXIgbGVuID0gdGhpcy5wLmJ5dGVMZW5ndGgoKTtcblxuICAvLyB1bmNvbXByZXNzZWQsIGh5YnJpZC1vZGQsIGh5YnJpZC1ldmVuXG4gIGlmICgoYnl0ZXNbMF0gPT09IDB4MDQgfHwgYnl0ZXNbMF0gPT09IDB4MDYgfHwgYnl0ZXNbMF0gPT09IDB4MDcpICYmXG4gICAgICBieXRlcy5sZW5ndGggLSAxID09PSAyICogbGVuKSB7XG4gICAgaWYgKGJ5dGVzWzBdID09PSAweDA2KVxuICAgICAgYXNzZXJ0JDEoYnl0ZXNbYnl0ZXMubGVuZ3RoIC0gMV0gJSAyID09PSAwKTtcbiAgICBlbHNlIGlmIChieXRlc1swXSA9PT0gMHgwNylcbiAgICAgIGFzc2VydCQxKGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdICUgMiA9PT0gMSk7XG5cbiAgICB2YXIgcmVzID0gIHRoaXMucG9pbnQoYnl0ZXMuc2xpY2UoMSwgMSArIGxlbiksXG4gICAgICBieXRlcy5zbGljZSgxICsgbGVuLCAxICsgMiAqIGxlbikpO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfSBlbHNlIGlmICgoYnl0ZXNbMF0gPT09IDB4MDIgfHwgYnl0ZXNbMF0gPT09IDB4MDMpICYmXG4gICAgICAgICAgICAgIGJ5dGVzLmxlbmd0aCAtIDEgPT09IGxlbikge1xuICAgIHJldHVybiB0aGlzLnBvaW50RnJvbVgoYnl0ZXMuc2xpY2UoMSwgMSArIGxlbiksIGJ5dGVzWzBdID09PSAweDAzKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcG9pbnQgZm9ybWF0Jyk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmVuY29kZUNvbXByZXNzZWQgPSBmdW5jdGlvbiBlbmNvZGVDb21wcmVzc2VkKGVuYykge1xuICByZXR1cm4gdGhpcy5lbmNvZGUoZW5jLCB0cnVlKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2VuY29kZSA9IGZ1bmN0aW9uIF9lbmNvZGUoY29tcGFjdCkge1xuICB2YXIgbGVuID0gdGhpcy5jdXJ2ZS5wLmJ5dGVMZW5ndGgoKTtcbiAgdmFyIHggPSB0aGlzLmdldFgoKS50b0FycmF5KCdiZScsIGxlbik7XG5cbiAgaWYgKGNvbXBhY3QpXG4gICAgcmV0dXJuIFsgdGhpcy5nZXRZKCkuaXNFdmVuKCkgPyAweDAyIDogMHgwMyBdLmNvbmNhdCh4KTtcblxuICByZXR1cm4gWyAweDA0IF0uY29uY2F0KHgsIHRoaXMuZ2V0WSgpLnRvQXJyYXkoJ2JlJywgbGVuKSk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShlbmMsIGNvbXBhY3QpIHtcbiAgcmV0dXJuIHV0aWxzXzEkMS5lbmNvZGUodGhpcy5fZW5jb2RlKGNvbXBhY3QpLCBlbmMpO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5wcmVjb21wdXRlID0gZnVuY3Rpb24gcHJlY29tcHV0ZShwb3dlcikge1xuICBpZiAodGhpcy5wcmVjb21wdXRlZClcbiAgICByZXR1cm4gdGhpcztcblxuICB2YXIgcHJlY29tcHV0ZWQgPSB7XG4gICAgZG91YmxlczogbnVsbCxcbiAgICBuYWY6IG51bGwsXG4gICAgYmV0YTogbnVsbCxcbiAgfTtcbiAgcHJlY29tcHV0ZWQubmFmID0gdGhpcy5fZ2V0TkFGUG9pbnRzKDgpO1xuICBwcmVjb21wdXRlZC5kb3VibGVzID0gdGhpcy5fZ2V0RG91Ymxlcyg0LCBwb3dlcik7XG4gIHByZWNvbXB1dGVkLmJldGEgPSB0aGlzLl9nZXRCZXRhKCk7XG4gIHRoaXMucHJlY29tcHV0ZWQgPSBwcmVjb21wdXRlZDtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2hhc0RvdWJsZXMgPSBmdW5jdGlvbiBfaGFzRG91YmxlcyhrKSB7XG4gIGlmICghdGhpcy5wcmVjb21wdXRlZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGRvdWJsZXMgPSB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXM7XG4gIGlmICghZG91YmxlcylcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIGRvdWJsZXMucG9pbnRzLmxlbmd0aCA+PSBNYXRoLmNlaWwoKGsuYml0TGVuZ3RoKCkgKyAxKSAvIGRvdWJsZXMuc3RlcCk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9nZXREb3VibGVzID0gZnVuY3Rpb24gX2dldERvdWJsZXMoc3RlcCwgcG93ZXIpIHtcbiAgaWYgKHRoaXMucHJlY29tcHV0ZWQgJiYgdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzKVxuICAgIHJldHVybiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXM7XG5cbiAgdmFyIGRvdWJsZXMgPSBbIHRoaXMgXTtcbiAgdmFyIGFjYyA9IHRoaXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG93ZXI7IGkgKz0gc3RlcCkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RlcDsgaisrKVxuICAgICAgYWNjID0gYWNjLmRibCgpO1xuICAgIGRvdWJsZXMucHVzaChhY2MpO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3RlcDogc3RlcCxcbiAgICBwb2ludHM6IGRvdWJsZXMsXG4gIH07XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9nZXROQUZQb2ludHMgPSBmdW5jdGlvbiBfZ2V0TkFGUG9pbnRzKHduZCkge1xuICBpZiAodGhpcy5wcmVjb21wdXRlZCAmJiB0aGlzLnByZWNvbXB1dGVkLm5hZilcbiAgICByZXR1cm4gdGhpcy5wcmVjb21wdXRlZC5uYWY7XG5cbiAgdmFyIHJlcyA9IFsgdGhpcyBdO1xuICB2YXIgbWF4ID0gKDEgPDwgd25kKSAtIDE7XG4gIHZhciBkYmwgPSBtYXggPT09IDEgPyBudWxsIDogdGhpcy5kYmwoKTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBtYXg7IGkrKylcbiAgICByZXNbaV0gPSByZXNbaSAtIDFdLmFkZChkYmwpO1xuICByZXR1cm4ge1xuICAgIHduZDogd25kLFxuICAgIHBvaW50czogcmVzLFxuICB9O1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0QmV0YSA9IGZ1bmN0aW9uIF9nZXRCZXRhKCkge1xuICByZXR1cm4gbnVsbDtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZGJscCA9IGZ1bmN0aW9uIGRibHAoaykge1xuICB2YXIgciA9IHRoaXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgazsgaSsrKVxuICAgIHIgPSByLmRibCgpO1xuICByZXR1cm4gcjtcbn07XG5cbnZhciBpbmhlcml0c19icm93c2VyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge307XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvcjtcbiAgICB9XG4gIH07XG59XG59KTtcblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cblxudmFyIGFzc2VydCQyID0gdXRpbHNfMSQxLmFzc2VydDtcblxuZnVuY3Rpb24gU2hvcnRDdXJ2ZShjb25mKSB7XG4gIGJhc2UuY2FsbCh0aGlzLCAnc2hvcnQnLCBjb25mKTtcblxuICB0aGlzLmEgPSBuZXcgQk4oY29uZi5hLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmIgPSBuZXcgQk4oY29uZi5iLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLnRpbnYgPSB0aGlzLnR3by5yZWRJbnZtKCk7XG5cbiAgdGhpcy56ZXJvQSA9IHRoaXMuYS5mcm9tUmVkKCkuY21wbigwKSA9PT0gMDtcbiAgdGhpcy50aHJlZUEgPSB0aGlzLmEuZnJvbVJlZCgpLnN1Yih0aGlzLnApLmNtcG4oLTMpID09PSAwO1xuXG4gIC8vIElmIHRoZSBjdXJ2ZSBpcyBlbmRvbW9ycGhpYywgcHJlY2FsY3VsYXRlIGJldGEgYW5kIGxhbWJkYVxuICB0aGlzLmVuZG8gPSB0aGlzLl9nZXRFbmRvbW9ycGhpc20oY29uZik7XG4gIHRoaXMuX2VuZG9XbmFmVDEgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX2VuZG9XbmFmVDIgPSBuZXcgQXJyYXkoNCk7XG59XG5pbmhlcml0c19icm93c2VyKFNob3J0Q3VydmUsIGJhc2UpO1xudmFyIHNob3J0XzEgPSBTaG9ydEN1cnZlO1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb21vcnBoaXNtID0gZnVuY3Rpb24gX2dldEVuZG9tb3JwaGlzbShjb25mKSB7XG4gIC8vIE5vIGVmZmljaWVudCBlbmRvbW9ycGhpc21cbiAgaWYgKCF0aGlzLnplcm9BIHx8ICF0aGlzLmcgfHwgIXRoaXMubiB8fCB0aGlzLnAubW9kbigzKSAhPT0gMSlcbiAgICByZXR1cm47XG5cbiAgLy8gQ29tcHV0ZSBiZXRhIGFuZCBsYW1iZGEsIHRoYXQgbGFtYmRhICogUCA9IChiZXRhICogUHg7IFB5KVxuICB2YXIgYmV0YTtcbiAgdmFyIGxhbWJkYTtcbiAgaWYgKGNvbmYuYmV0YSkge1xuICAgIGJldGEgPSBuZXcgQk4oY29uZi5iZXRhLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBiZXRhcyA9IHRoaXMuX2dldEVuZG9Sb290cyh0aGlzLnApO1xuICAgIC8vIENob29zZSB0aGUgc21hbGxlc3QgYmV0YVxuICAgIGJldGEgPSBiZXRhc1swXS5jbXAoYmV0YXNbMV0pIDwgMCA/IGJldGFzWzBdIDogYmV0YXNbMV07XG4gICAgYmV0YSA9IGJldGEudG9SZWQodGhpcy5yZWQpO1xuICB9XG4gIGlmIChjb25mLmxhbWJkYSkge1xuICAgIGxhbWJkYSA9IG5ldyBCTihjb25mLmxhbWJkYSwgMTYpO1xuICB9IGVsc2Uge1xuICAgIC8vIENob29zZSB0aGUgbGFtYmRhIHRoYXQgaXMgbWF0Y2hpbmcgc2VsZWN0ZWQgYmV0YVxuICAgIHZhciBsYW1iZGFzID0gdGhpcy5fZ2V0RW5kb1Jvb3RzKHRoaXMubik7XG4gICAgaWYgKHRoaXMuZy5tdWwobGFtYmRhc1swXSkueC5jbXAodGhpcy5nLngucmVkTXVsKGJldGEpKSA9PT0gMCkge1xuICAgICAgbGFtYmRhID0gbGFtYmRhc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFtYmRhID0gbGFtYmRhc1sxXTtcbiAgICAgIGFzc2VydCQyKHRoaXMuZy5tdWwobGFtYmRhKS54LmNtcCh0aGlzLmcueC5yZWRNdWwoYmV0YSkpID09PSAwKTtcbiAgICB9XG4gIH1cblxuICAvLyBHZXQgYmFzaXMgdmVjdG9ycywgdXNlZCBmb3IgYmFsYW5jZWQgbGVuZ3RoLXR3byByZXByZXNlbnRhdGlvblxuICB2YXIgYmFzaXM7XG4gIGlmIChjb25mLmJhc2lzKSB7XG4gICAgYmFzaXMgPSBjb25mLmJhc2lzLm1hcChmdW5jdGlvbih2ZWMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGE6IG5ldyBCTih2ZWMuYSwgMTYpLFxuICAgICAgICBiOiBuZXcgQk4odmVjLmIsIDE2KSxcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYmFzaXMgPSB0aGlzLl9nZXRFbmRvQmFzaXMobGFtYmRhKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmV0YTogYmV0YSxcbiAgICBsYW1iZGE6IGxhbWJkYSxcbiAgICBiYXNpczogYmFzaXMsXG4gIH07XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb1Jvb3RzID0gZnVuY3Rpb24gX2dldEVuZG9Sb290cyhudW0pIHtcbiAgLy8gRmluZCByb290cyBvZiBmb3IgeF4yICsgeCArIDEgaW4gRlxuICAvLyBSb290ID0gKC0xICstIFNxcnQoLTMpKSAvIDJcbiAgLy9cbiAgdmFyIHJlZCA9IG51bSA9PT0gdGhpcy5wID8gdGhpcy5yZWQgOiBCTi5tb250KG51bSk7XG4gIHZhciB0aW52ID0gbmV3IEJOKDIpLnRvUmVkKHJlZCkucmVkSW52bSgpO1xuICB2YXIgbnRpbnYgPSB0aW52LnJlZE5lZygpO1xuXG4gIHZhciBzID0gbmV3IEJOKDMpLnRvUmVkKHJlZCkucmVkTmVnKCkucmVkU3FydCgpLnJlZE11bCh0aW52KTtcblxuICB2YXIgbDEgPSBudGludi5yZWRBZGQocykuZnJvbVJlZCgpO1xuICB2YXIgbDIgPSBudGludi5yZWRTdWIocykuZnJvbVJlZCgpO1xuICByZXR1cm4gWyBsMSwgbDIgXTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvQmFzaXMgPSBmdW5jdGlvbiBfZ2V0RW5kb0Jhc2lzKGxhbWJkYSkge1xuICAvLyBhcHJ4U3FydCA+PSBzcXJ0KHRoaXMubilcbiAgdmFyIGFwcnhTcXJ0ID0gdGhpcy5uLnVzaHJuKE1hdGguZmxvb3IodGhpcy5uLmJpdExlbmd0aCgpIC8gMikpO1xuXG4gIC8vIDMuNzRcbiAgLy8gUnVuIEVHQ0QsIHVudGlsIHIoTCArIDEpIDwgYXByeFNxcnRcbiAgdmFyIHUgPSBsYW1iZGE7XG4gIHZhciB2ID0gdGhpcy5uLmNsb25lKCk7XG4gIHZhciB4MSA9IG5ldyBCTigxKTtcbiAgdmFyIHkxID0gbmV3IEJOKDApO1xuICB2YXIgeDIgPSBuZXcgQk4oMCk7XG4gIHZhciB5MiA9IG5ldyBCTigxKTtcblxuICAvLyBOT1RFOiBhbGwgdmVjdG9ycyBhcmUgcm9vdHMgb2Y6IGEgKyBiICogbGFtYmRhID0gMCAobW9kIG4pXG4gIHZhciBhMDtcbiAgdmFyIGIwO1xuICAvLyBGaXJzdCB2ZWN0b3JcbiAgdmFyIGExO1xuICB2YXIgYjE7XG4gIC8vIFNlY29uZCB2ZWN0b3JcbiAgdmFyIGEyO1xuICB2YXIgYjI7XG5cbiAgdmFyIHByZXZSO1xuICB2YXIgaSA9IDA7XG4gIHZhciByO1xuICB2YXIgeDtcbiAgd2hpbGUgKHUuY21wbigwKSAhPT0gMCkge1xuICAgIHZhciBxID0gdi5kaXYodSk7XG4gICAgciA9IHYuc3ViKHEubXVsKHUpKTtcbiAgICB4ID0geDIuc3ViKHEubXVsKHgxKSk7XG4gICAgdmFyIHkgPSB5Mi5zdWIocS5tdWwoeTEpKTtcblxuICAgIGlmICghYTEgJiYgci5jbXAoYXByeFNxcnQpIDwgMCkge1xuICAgICAgYTAgPSBwcmV2Ui5uZWcoKTtcbiAgICAgIGIwID0geDE7XG4gICAgICBhMSA9IHIubmVnKCk7XG4gICAgICBiMSA9IHg7XG4gICAgfSBlbHNlIGlmIChhMSAmJiArK2kgPT09IDIpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwcmV2UiA9IHI7XG5cbiAgICB2ID0gdTtcbiAgICB1ID0gcjtcbiAgICB4MiA9IHgxO1xuICAgIHgxID0geDtcbiAgICB5MiA9IHkxO1xuICAgIHkxID0geTtcbiAgfVxuICBhMiA9IHIubmVnKCk7XG4gIGIyID0geDtcblxuICB2YXIgbGVuMSA9IGExLnNxcigpLmFkZChiMS5zcXIoKSk7XG4gIHZhciBsZW4yID0gYTIuc3FyKCkuYWRkKGIyLnNxcigpKTtcbiAgaWYgKGxlbjIuY21wKGxlbjEpID49IDApIHtcbiAgICBhMiA9IGEwO1xuICAgIGIyID0gYjA7XG4gIH1cblxuICAvLyBOb3JtYWxpemUgc2lnbnNcbiAgaWYgKGExLm5lZ2F0aXZlKSB7XG4gICAgYTEgPSBhMS5uZWcoKTtcbiAgICBiMSA9IGIxLm5lZygpO1xuICB9XG4gIGlmIChhMi5uZWdhdGl2ZSkge1xuICAgIGEyID0gYTIubmVnKCk7XG4gICAgYjIgPSBiMi5uZWcoKTtcbiAgfVxuXG4gIHJldHVybiBbXG4gICAgeyBhOiBhMSwgYjogYjEgfSxcbiAgICB7IGE6IGEyLCBiOiBiMiB9LFxuICBdO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2VuZG9TcGxpdCA9IGZ1bmN0aW9uIF9lbmRvU3BsaXQoaykge1xuICB2YXIgYmFzaXMgPSB0aGlzLmVuZG8uYmFzaXM7XG4gIHZhciB2MSA9IGJhc2lzWzBdO1xuICB2YXIgdjIgPSBiYXNpc1sxXTtcblxuICB2YXIgYzEgPSB2Mi5iLm11bChrKS5kaXZSb3VuZCh0aGlzLm4pO1xuICB2YXIgYzIgPSB2MS5iLm5lZygpLm11bChrKS5kaXZSb3VuZCh0aGlzLm4pO1xuXG4gIHZhciBwMSA9IGMxLm11bCh2MS5hKTtcbiAgdmFyIHAyID0gYzIubXVsKHYyLmEpO1xuICB2YXIgcTEgPSBjMS5tdWwodjEuYik7XG4gIHZhciBxMiA9IGMyLm11bCh2Mi5iKTtcblxuICAvLyBDYWxjdWxhdGUgYW5zd2VyXG4gIHZhciBrMSA9IGsuc3ViKHAxKS5zdWIocDIpO1xuICB2YXIgazIgPSBxMS5hZGQocTIpLm5lZygpO1xuICByZXR1cm4geyBrMTogazEsIGsyOiBrMiB9O1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tWCA9IGZ1bmN0aW9uIHBvaW50RnJvbVgoeCwgb2RkKSB7XG4gIHggPSBuZXcgQk4oeCwgMTYpO1xuICBpZiAoIXgucmVkKVxuICAgIHggPSB4LnRvUmVkKHRoaXMucmVkKTtcblxuICB2YXIgeTIgPSB4LnJlZFNxcigpLnJlZE11bCh4KS5yZWRJQWRkKHgucmVkTXVsKHRoaXMuYSkpLnJlZElBZGQodGhpcy5iKTtcbiAgdmFyIHkgPSB5Mi5yZWRTcXJ0KCk7XG4gIGlmICh5LnJlZFNxcigpLnJlZFN1Yih5MikuY21wKHRoaXMuemVybykgIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50Jyk7XG5cbiAgLy8gWFhYIElzIHRoZXJlIGFueSB3YXkgdG8gdGVsbCBpZiB0aGUgbnVtYmVyIGlzIG9kZCB3aXRob3V0IGNvbnZlcnRpbmcgaXRcbiAgLy8gdG8gbm9uLXJlZCBmb3JtP1xuICB2YXIgaXNPZGQgPSB5LmZyb21SZWQoKS5pc09kZCgpO1xuICBpZiAob2RkICYmICFpc09kZCB8fCAhb2RkICYmIGlzT2RkKVxuICAgIHkgPSB5LnJlZE5lZygpO1xuXG4gIHJldHVybiB0aGlzLnBvaW50KHgsIHkpO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZShwb2ludCkge1xuICBpZiAocG9pbnQuaW5mKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIHZhciB4ID0gcG9pbnQueDtcbiAgdmFyIHkgPSBwb2ludC55O1xuXG4gIHZhciBheCA9IHRoaXMuYS5yZWRNdWwoeCk7XG4gIHZhciByaHMgPSB4LnJlZFNxcigpLnJlZE11bCh4KS5yZWRJQWRkKGF4KS5yZWRJQWRkKHRoaXMuYik7XG4gIHJldHVybiB5LnJlZFNxcigpLnJlZElTdWIocmhzKS5jbXBuKDApID09PSAwO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2VuZG9XbmFmTXVsQWRkID1cbiAgICBmdW5jdGlvbiBfZW5kb1duYWZNdWxBZGQocG9pbnRzLCBjb2VmZnMsIGphY29iaWFuUmVzdWx0KSB7XG4gICAgICB2YXIgbnBvaW50cyA9IHRoaXMuX2VuZG9XbmFmVDE7XG4gICAgICB2YXIgbmNvZWZmcyA9IHRoaXMuX2VuZG9XbmFmVDI7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3BsaXQgPSB0aGlzLl9lbmRvU3BsaXQoY29lZmZzW2ldKTtcbiAgICAgICAgdmFyIHAgPSBwb2ludHNbaV07XG4gICAgICAgIHZhciBiZXRhID0gcC5fZ2V0QmV0YSgpO1xuXG4gICAgICAgIGlmIChzcGxpdC5rMS5uZWdhdGl2ZSkge1xuICAgICAgICAgIHNwbGl0LmsxLmluZWcoKTtcbiAgICAgICAgICBwID0gcC5uZWcodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwbGl0LmsyLm5lZ2F0aXZlKSB7XG4gICAgICAgICAgc3BsaXQuazIuaW5lZygpO1xuICAgICAgICAgIGJldGEgPSBiZXRhLm5lZyh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5wb2ludHNbaSAqIDJdID0gcDtcbiAgICAgICAgbnBvaW50c1tpICogMiArIDFdID0gYmV0YTtcbiAgICAgICAgbmNvZWZmc1tpICogMl0gPSBzcGxpdC5rMTtcbiAgICAgICAgbmNvZWZmc1tpICogMiArIDFdID0gc3BsaXQuazI7XG4gICAgICB9XG4gICAgICB2YXIgcmVzID0gdGhpcy5fd25hZk11bEFkZCgxLCBucG9pbnRzLCBuY29lZmZzLCBpICogMiwgamFjb2JpYW5SZXN1bHQpO1xuXG4gICAgICAvLyBDbGVhbi11cCByZWZlcmVuY2VzIHRvIHBvaW50cyBhbmQgY29lZmZpY2llbnRzXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGkgKiAyOyBqKyspIHtcbiAgICAgICAgbnBvaW50c1tqXSA9IG51bGw7XG4gICAgICAgIG5jb2VmZnNbal0gPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG5mdW5jdGlvbiBQb2ludChjdXJ2ZSwgeCwgeSwgaXNSZWQpIHtcbiAgYmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLCBjdXJ2ZSwgJ2FmZmluZScpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsKSB7XG4gICAgdGhpcy54ID0gbnVsbDtcbiAgICB0aGlzLnkgPSBudWxsO1xuICAgIHRoaXMuaW5mID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSBuZXcgQk4oeCwgMTYpO1xuICAgIHRoaXMueSA9IG5ldyBCTih5LCAxNik7XG4gICAgLy8gRm9yY2UgcmVkZ29tZXJ5IHJlcHJlc2VudGF0aW9uIHdoZW4gbG9hZGluZyBmcm9tIEpTT05cbiAgICBpZiAoaXNSZWQpIHtcbiAgICAgIHRoaXMueC5mb3JjZVJlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgICB0aGlzLnkuZm9yY2VSZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMueC5yZWQpXG4gICAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICghdGhpcy55LnJlZClcbiAgICAgIHRoaXMueSA9IHRoaXMueS50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgdGhpcy5pbmYgPSBmYWxzZTtcbiAgfVxufVxuaW5oZXJpdHNfYnJvd3NlcihQb2ludCwgYmFzZS5CYXNlUG9pbnQpO1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uIHBvaW50KHgsIHksIGlzUmVkKSB7XG4gIHJldHVybiBuZXcgUG9pbnQodGhpcywgeCwgeSwgaXNSZWQpO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tSlNPTiA9IGZ1bmN0aW9uIHBvaW50RnJvbUpTT04ob2JqLCByZWQpIHtcbiAgcmV0dXJuIFBvaW50LmZyb21KU09OKHRoaXMsIG9iaiwgcmVkKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fZ2V0QmV0YSA9IGZ1bmN0aW9uIF9nZXRCZXRhKCkge1xuICBpZiAoIXRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm47XG5cbiAgdmFyIHByZSA9IHRoaXMucHJlY29tcHV0ZWQ7XG4gIGlmIChwcmUgJiYgcHJlLmJldGEpXG4gICAgcmV0dXJuIHByZS5iZXRhO1xuXG4gIHZhciBiZXRhID0gdGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngucmVkTXVsKHRoaXMuY3VydmUuZW5kby5iZXRhKSwgdGhpcy55KTtcbiAgaWYgKHByZSkge1xuICAgIHZhciBjdXJ2ZSA9IHRoaXMuY3VydmU7XG4gICAgdmFyIGVuZG9NdWwgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gY3VydmUucG9pbnQocC54LnJlZE11bChjdXJ2ZS5lbmRvLmJldGEpLCBwLnkpO1xuICAgIH07XG4gICAgcHJlLmJldGEgPSBiZXRhO1xuICAgIGJldGEucHJlY29tcHV0ZWQgPSB7XG4gICAgICBiZXRhOiBudWxsLFxuICAgICAgbmFmOiBwcmUubmFmICYmIHtcbiAgICAgICAgd25kOiBwcmUubmFmLnduZCxcbiAgICAgICAgcG9pbnRzOiBwcmUubmFmLnBvaW50cy5tYXAoZW5kb011bCksXG4gICAgICB9LFxuICAgICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuICAgICAgICBzdGVwOiBwcmUuZG91Ymxlcy5zdGVwLFxuICAgICAgICBwb2ludHM6IHByZS5kb3VibGVzLnBvaW50cy5tYXAoZW5kb011bCksXG4gICAgICB9LFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGJldGE7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICBpZiAoIXRoaXMucHJlY29tcHV0ZWQpXG4gICAgcmV0dXJuIFsgdGhpcy54LCB0aGlzLnkgXTtcblxuICByZXR1cm4gWyB0aGlzLngsIHRoaXMueSwgdGhpcy5wcmVjb21wdXRlZCAmJiB7XG4gICAgZG91YmxlczogdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzICYmIHtcbiAgICAgIHN0ZXA6IHRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcy5zdGVwLFxuICAgICAgcG9pbnRzOiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMucG9pbnRzLnNsaWNlKDEpLFxuICAgIH0sXG4gICAgbmFmOiB0aGlzLnByZWNvbXB1dGVkLm5hZiAmJiB7XG4gICAgICB3bmQ6IHRoaXMucHJlY29tcHV0ZWQubmFmLnduZCxcbiAgICAgIHBvaW50czogdGhpcy5wcmVjb21wdXRlZC5uYWYucG9pbnRzLnNsaWNlKDEpLFxuICAgIH0sXG4gIH0gXTtcbn07XG5cblBvaW50LmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04oY3VydmUsIG9iaiwgcmVkKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJylcbiAgICBvYmogPSBKU09OLnBhcnNlKG9iaik7XG4gIHZhciByZXMgPSBjdXJ2ZS5wb2ludChvYmpbMF0sIG9ialsxXSwgcmVkKTtcbiAgaWYgKCFvYmpbMl0pXG4gICAgcmV0dXJuIHJlcztcblxuICBmdW5jdGlvbiBvYmoycG9pbnQob2JqKSB7XG4gICAgcmV0dXJuIGN1cnZlLnBvaW50KG9ialswXSwgb2JqWzFdLCByZWQpO1xuICB9XG5cbiAgdmFyIHByZSA9IG9ialsyXTtcbiAgcmVzLnByZWNvbXB1dGVkID0ge1xuICAgIGJldGE6IG51bGwsXG4gICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuICAgICAgc3RlcDogcHJlLmRvdWJsZXMuc3RlcCxcbiAgICAgIHBvaW50czogWyByZXMgXS5jb25jYXQocHJlLmRvdWJsZXMucG9pbnRzLm1hcChvYmoycG9pbnQpKSxcbiAgICB9LFxuICAgIG5hZjogcHJlLm5hZiAmJiB7XG4gICAgICB3bmQ6IHByZS5uYWYud25kLFxuICAgICAgcG9pbnRzOiBbIHJlcyBdLmNvbmNhdChwcmUubmFmLnBvaW50cy5tYXAob2JqMnBvaW50KSksXG4gICAgfSxcbiAgfTtcbiAgcmV0dXJuIHJlcztcbn07XG5cblBvaW50LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiAnPEVDIFBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIFBvaW50IHg6ICcgKyB0aGlzLnguZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHk6ICcgKyB0aGlzLnkuZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArICc+Jztcbn07XG5cblBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcbiAgcmV0dXJuIHRoaXMuaW5mO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChwKSB7XG4gIC8vIE8gKyBQID0gUFxuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHA7XG5cbiAgLy8gUCArIE8gPSBQXG4gIGlmIChwLmluZilcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBQICsgUCA9IDJQXG4gIGlmICh0aGlzLmVxKHApKVxuICAgIHJldHVybiB0aGlzLmRibCgpO1xuXG4gIC8vIFAgKyAoLVApID0gT1xuICBpZiAodGhpcy5uZWcoKS5lcShwKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICAvLyBQICsgUSA9IE9cbiAgaWYgKHRoaXMueC5jbXAocC54KSA9PT0gMClcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICB2YXIgYyA9IHRoaXMueS5yZWRTdWIocC55KTtcbiAgaWYgKGMuY21wbigwKSAhPT0gMClcbiAgICBjID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihwLngpLnJlZEludm0oKSk7XG4gIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0aGlzLngpLnJlZElTdWIocC54KTtcbiAgdmFyIG55ID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihueCkpLnJlZElTdWIodGhpcy55KTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyAyUCA9IE9cbiAgdmFyIHlzMSA9IHRoaXMueS5yZWRBZGQodGhpcy55KTtcbiAgaWYgKHlzMS5jbXBuKDApID09PSAwKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuXG4gIHZhciBhID0gdGhpcy5jdXJ2ZS5hO1xuXG4gIHZhciB4MiA9IHRoaXMueC5yZWRTcXIoKTtcbiAgdmFyIGR5aW52ID0geXMxLnJlZEludm0oKTtcbiAgdmFyIGMgPSB4Mi5yZWRBZGQoeDIpLnJlZElBZGQoeDIpLnJlZElBZGQoYSkucmVkTXVsKGR5aW52KTtcblxuICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodGhpcy54LnJlZEFkZCh0aGlzLngpKTtcbiAgdmFyIG55ID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihueCkpLnJlZElTdWIodGhpcy55KTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gZ2V0WCgpIHtcbiAgcmV0dXJuIHRoaXMueC5mcm9tUmVkKCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uIGdldFkoKSB7XG4gIHJldHVybiB0aGlzLnkuZnJvbVJlZCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChrKSB7XG4gIGsgPSBuZXcgQk4oaywgMTYpO1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG4gIGVsc2UgaWYgKHRoaXMuX2hhc0RvdWJsZXMoaykpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX2ZpeGVkTmFmTXVsKHRoaXMsIGspO1xuICBlbHNlIGlmICh0aGlzLmN1cnZlLmVuZG8pXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKFsgdGhpcyBdLCBbIGsgXSk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bCh0aGlzLCBrKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWxBZGQgPSBmdW5jdGlvbiBtdWxBZGQoazEsIHAyLCBrMikge1xuICB2YXIgcG9pbnRzID0gWyB0aGlzLCBwMiBdO1xuICB2YXIgY29lZmZzID0gWyBrMSwgazIgXTtcbiAgaWYgKHRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQocG9pbnRzLCBjb2VmZnMpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWxBZGQoMSwgcG9pbnRzLCBjb2VmZnMsIDIpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmptdWxBZGQgPSBmdW5jdGlvbiBqbXVsQWRkKGsxLCBwMiwgazIpIHtcbiAgdmFyIHBvaW50cyA9IFsgdGhpcywgcDIgXTtcbiAgdmFyIGNvZWZmcyA9IFsgazEsIGsyIF07XG4gIGlmICh0aGlzLmN1cnZlLmVuZG8pXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKHBvaW50cywgY29lZmZzLCB0cnVlKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEsIHBvaW50cywgY29lZmZzLCAyLCB0cnVlKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKHApIHtcbiAgcmV0dXJuIHRoaXMgPT09IHAgfHxcbiAgICAgICAgIHRoaXMuaW5mID09PSBwLmluZiAmJlxuICAgICAgICAgICAgICh0aGlzLmluZiB8fCB0aGlzLnguY21wKHAueCkgPT09IDAgJiYgdGhpcy55LmNtcChwLnkpID09PSAwKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcoX3ByZWNvbXB1dGUpIHtcbiAgaWYgKHRoaXMuaW5mKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHZhciByZXMgPSB0aGlzLmN1cnZlLnBvaW50KHRoaXMueCwgdGhpcy55LnJlZE5lZygpKTtcbiAgaWYgKF9wcmVjb21wdXRlICYmIHRoaXMucHJlY29tcHV0ZWQpIHtcbiAgICB2YXIgcHJlID0gdGhpcy5wcmVjb21wdXRlZDtcbiAgICB2YXIgbmVnYXRlID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHAubmVnKCk7XG4gICAgfTtcbiAgICByZXMucHJlY29tcHV0ZWQgPSB7XG4gICAgICBuYWY6IHByZS5uYWYgJiYge1xuICAgICAgICB3bmQ6IHByZS5uYWYud25kLFxuICAgICAgICBwb2ludHM6IHByZS5uYWYucG9pbnRzLm1hcChuZWdhdGUpLFxuICAgICAgfSxcbiAgICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcbiAgICAgICAgc3RlcDogcHJlLmRvdWJsZXMuc3RlcCxcbiAgICAgICAgcG9pbnRzOiBwcmUuZG91Ymxlcy5wb2ludHMubWFwKG5lZ2F0ZSksXG4gICAgICB9LFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cblBvaW50LnByb3RvdHlwZS50b0ogPSBmdW5jdGlvbiB0b0ooKSB7XG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG5cbiAgdmFyIHJlcyA9IHRoaXMuY3VydmUuanBvaW50KHRoaXMueCwgdGhpcy55LCB0aGlzLmN1cnZlLm9uZSk7XG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBKUG9pbnQoY3VydmUsIHgsIHksIHopIHtcbiAgYmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLCBjdXJ2ZSwgJ2phY29iaWFuJyk7XG4gIGlmICh4ID09PSBudWxsICYmIHkgPT09IG51bGwgJiYgeiA9PT0gbnVsbCkge1xuICAgIHRoaXMueCA9IHRoaXMuY3VydmUub25lO1xuICAgIHRoaXMueSA9IHRoaXMuY3VydmUub25lO1xuICAgIHRoaXMueiA9IG5ldyBCTigwKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSBuZXcgQk4oeCwgMTYpO1xuICAgIHRoaXMueSA9IG5ldyBCTih5LCAxNik7XG4gICAgdGhpcy56ID0gbmV3IEJOKHosIDE2KTtcbiAgfVxuICBpZiAoIXRoaXMueC5yZWQpXG4gICAgdGhpcy54ID0gdGhpcy54LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgaWYgKCF0aGlzLnkucmVkKVxuICAgIHRoaXMueSA9IHRoaXMueS50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gIGlmICghdGhpcy56LnJlZClcbiAgICB0aGlzLnogPSB0aGlzLnoudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuXG4gIHRoaXMuek9uZSA9IHRoaXMueiA9PT0gdGhpcy5jdXJ2ZS5vbmU7XG59XG5pbmhlcml0c19icm93c2VyKEpQb2ludCwgYmFzZS5CYXNlUG9pbnQpO1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5qcG9pbnQgPSBmdW5jdGlvbiBqcG9pbnQoeCwgeSwgeikge1xuICByZXR1cm4gbmV3IEpQb2ludCh0aGlzLCB4LCB5LCB6KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUudG9QID0gZnVuY3Rpb24gdG9QKCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgdmFyIHppbnYgPSB0aGlzLnoucmVkSW52bSgpO1xuICB2YXIgemludjIgPSB6aW52LnJlZFNxcigpO1xuICB2YXIgYXggPSB0aGlzLngucmVkTXVsKHppbnYyKTtcbiAgdmFyIGF5ID0gdGhpcy55LnJlZE11bCh6aW52MikucmVkTXVsKHppbnYpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KGF4LCBheSk7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZygpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KHRoaXMueCwgdGhpcy55LnJlZE5lZygpLCB0aGlzLnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQocCkge1xuICAvLyBPICsgUCA9IFBcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBwO1xuXG4gIC8vIFAgKyBPID0gUFxuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gMTJNICsgNFMgKyA3QVxuICB2YXIgcHoyID0gcC56LnJlZFNxcigpO1xuICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciB1MSA9IHRoaXMueC5yZWRNdWwocHoyKTtcbiAgdmFyIHUyID0gcC54LnJlZE11bCh6Mik7XG4gIHZhciBzMSA9IHRoaXMueS5yZWRNdWwocHoyLnJlZE11bChwLnopKTtcbiAgdmFyIHMyID0gcC55LnJlZE11bCh6Mi5yZWRNdWwodGhpcy56KSk7XG5cbiAgdmFyIGggPSB1MS5yZWRTdWIodTIpO1xuICB2YXIgciA9IHMxLnJlZFN1YihzMik7XG4gIGlmIChoLmNtcG4oMCkgPT09IDApIHtcbiAgICBpZiAoci5jbXBuKDApICE9PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLmRibCgpO1xuICB9XG5cbiAgdmFyIGgyID0gaC5yZWRTcXIoKTtcbiAgdmFyIGgzID0gaDIucmVkTXVsKGgpO1xuICB2YXIgdiA9IHUxLnJlZE11bChoMik7XG5cbiAgdmFyIG54ID0gci5yZWRTcXIoKS5yZWRJQWRkKGgzKS5yZWRJU3ViKHYpLnJlZElTdWIodik7XG4gIHZhciBueSA9IHIucmVkTXVsKHYucmVkSVN1YihueCkpLnJlZElTdWIoczEucmVkTXVsKGgzKSk7XG4gIHZhciBueiA9IHRoaXMuei5yZWRNdWwocC56KS5yZWRNdWwoaCk7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5taXhlZEFkZCA9IGZ1bmN0aW9uIG1peGVkQWRkKHApIHtcbiAgLy8gTyArIFAgPSBQXG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gcC50b0ooKTtcblxuICAvLyBQICsgTyA9IFBcbiAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIDhNICsgM1MgKyA3QVxuICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciB1MSA9IHRoaXMueDtcbiAgdmFyIHUyID0gcC54LnJlZE11bCh6Mik7XG4gIHZhciBzMSA9IHRoaXMueTtcbiAgdmFyIHMyID0gcC55LnJlZE11bCh6MikucmVkTXVsKHRoaXMueik7XG5cbiAgdmFyIGggPSB1MS5yZWRTdWIodTIpO1xuICB2YXIgciA9IHMxLnJlZFN1YihzMik7XG4gIGlmIChoLmNtcG4oMCkgPT09IDApIHtcbiAgICBpZiAoci5jbXBuKDApICE9PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLmRibCgpO1xuICB9XG5cbiAgdmFyIGgyID0gaC5yZWRTcXIoKTtcbiAgdmFyIGgzID0gaDIucmVkTXVsKGgpO1xuICB2YXIgdiA9IHUxLnJlZE11bChoMik7XG5cbiAgdmFyIG54ID0gci5yZWRTcXIoKS5yZWRJQWRkKGgzKS5yZWRJU3ViKHYpLnJlZElTdWIodik7XG4gIHZhciBueSA9IHIucmVkTXVsKHYucmVkSVN1YihueCkpLnJlZElTdWIoczEucmVkTXVsKGgzKSk7XG4gIHZhciBueiA9IHRoaXMuei5yZWRNdWwoaCk7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5kYmxwID0gZnVuY3Rpb24gZGJscChwb3cpIHtcbiAgaWYgKHBvdyA9PT0gMClcbiAgICByZXR1cm4gdGhpcztcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuICBpZiAoIXBvdylcbiAgICByZXR1cm4gdGhpcy5kYmwoKTtcblxuICB2YXIgaTtcbiAgaWYgKHRoaXMuY3VydmUuemVyb0EgfHwgdGhpcy5jdXJ2ZS50aHJlZUEpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgZm9yIChpID0gMDsgaSA8IHBvdzsgaSsrKVxuICAgICAgciA9IHIuZGJsKCk7XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICAvLyAxTSArIDJTICsgMUEgKyBOICogKDRTICsgNU0gKyA4QSlcbiAgLy8gTiA9IDEgPT4gNk0gKyA2UyArIDlBXG4gIHZhciBhID0gdGhpcy5jdXJ2ZS5hO1xuICB2YXIgdGludiA9IHRoaXMuY3VydmUudGludjtcblxuICB2YXIganggPSB0aGlzLng7XG4gIHZhciBqeSA9IHRoaXMueTtcbiAgdmFyIGp6ID0gdGhpcy56O1xuICB2YXIgano0ID0ganoucmVkU3FyKCkucmVkU3FyKCk7XG5cbiAgLy8gUmV1c2UgcmVzdWx0c1xuICB2YXIganlkID0gankucmVkQWRkKGp5KTtcbiAgZm9yIChpID0gMDsgaSA8IHBvdzsgaSsrKSB7XG4gICAgdmFyIGp4MiA9IGp4LnJlZFNxcigpO1xuICAgIHZhciBqeWQyID0ganlkLnJlZFNxcigpO1xuICAgIHZhciBqeWQ0ID0ganlkMi5yZWRTcXIoKTtcbiAgICB2YXIgYyA9IGp4Mi5yZWRBZGQoangyKS5yZWRJQWRkKGp4MikucmVkSUFkZChhLnJlZE11bChqejQpKTtcblxuICAgIHZhciB0MSA9IGp4LnJlZE11bChqeWQyKTtcbiAgICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodDEucmVkQWRkKHQxKSk7XG4gICAgdmFyIHQyID0gdDEucmVkSVN1YihueCk7XG4gICAgdmFyIGRueSA9IGMucmVkTXVsKHQyKTtcbiAgICBkbnkgPSBkbnkucmVkSUFkZChkbnkpLnJlZElTdWIoanlkNCk7XG4gICAgdmFyIG56ID0ganlkLnJlZE11bChqeik7XG4gICAgaWYgKGkgKyAxIDwgcG93KVxuICAgICAgano0ID0gano0LnJlZE11bChqeWQ0KTtcblxuICAgIGp4ID0gbng7XG4gICAganogPSBuejtcbiAgICBqeWQgPSBkbnk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQoangsIGp5ZC5yZWRNdWwodGludiksIGp6KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24gZGJsKCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgaWYgKHRoaXMuY3VydmUuemVyb0EpXG4gICAgcmV0dXJuIHRoaXMuX3plcm9EYmwoKTtcbiAgZWxzZSBpZiAodGhpcy5jdXJ2ZS50aHJlZUEpXG4gICAgcmV0dXJuIHRoaXMuX3RocmVlRGJsKCk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5fZGJsKCk7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLl96ZXJvRGJsID0gZnVuY3Rpb24gX3plcm9EYmwoKSB7XG4gIHZhciBueDtcbiAgdmFyIG55O1xuICB2YXIgbno7XG4gIC8vIFogPSAxXG4gIGlmICh0aGlzLnpPbmUpIHtcbiAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbFxuICAgIC8vICAgICAjZG91YmxpbmctbWRibC0yMDA3LWJsXG4gICAgLy8gMU0gKyA1UyArIDE0QVxuXG4gICAgLy8gWFggPSBYMV4yXG4gICAgdmFyIHh4ID0gdGhpcy54LnJlZFNxcigpO1xuICAgIC8vIFlZID0gWTFeMlxuICAgIHZhciB5eSA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAvLyBZWVlZID0gWVleMlxuICAgIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gICAgLy8gUyA9IDIgKiAoKFgxICsgWVkpXjIgLSBYWCAtIFlZWVkpXG4gICAgdmFyIHMgPSB0aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO1xuICAgIHMgPSBzLnJlZElBZGQocyk7XG4gICAgLy8gTSA9IDMgKiBYWCArIGE7IGEgPSAwXG4gICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpO1xuICAgIC8vIFQgPSBNIF4gMiAtIDIqU1xuICAgIHZhciB0ID0gbS5yZWRTcXIoKS5yZWRJU3ViKHMpLnJlZElTdWIocyk7XG5cbiAgICAvLyA4ICogWVlZWVxuICAgIHZhciB5eXl5OCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG5cbiAgICAvLyBYMyA9IFRcbiAgICBueCA9IHQ7XG4gICAgLy8gWTMgPSBNICogKFMgLSBUKSAtIDggKiBZWVlZXG4gICAgbnkgPSBtLnJlZE11bChzLnJlZElTdWIodCkpLnJlZElTdWIoeXl5eTgpO1xuICAgIC8vIFozID0gMipZMVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMC5odG1sXG4gICAgLy8gICAgICNkb3VibGluZy1kYmwtMjAwOS1sXG4gICAgLy8gMk0gKyA1UyArIDEzQVxuXG4gICAgLy8gQSA9IFgxXjJcbiAgICB2YXIgYSA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICAvLyBCID0gWTFeMlxuICAgIHZhciBiID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIEMgPSBCXjJcbiAgICB2YXIgYyA9IGIucmVkU3FyKCk7XG4gICAgLy8gRCA9IDIgKiAoKFgxICsgQileMiAtIEEgLSBDKVxuICAgIHZhciBkID0gdGhpcy54LnJlZEFkZChiKS5yZWRTcXIoKS5yZWRJU3ViKGEpLnJlZElTdWIoYyk7XG4gICAgZCA9IGQucmVkSUFkZChkKTtcbiAgICAvLyBFID0gMyAqIEFcbiAgICB2YXIgZSA9IGEucmVkQWRkKGEpLnJlZElBZGQoYSk7XG4gICAgLy8gRiA9IEVeMlxuICAgIHZhciBmID0gZS5yZWRTcXIoKTtcblxuICAgIC8vIDggKiBDXG4gICAgdmFyIGM4ID0gYy5yZWRJQWRkKGMpO1xuICAgIGM4ID0gYzgucmVkSUFkZChjOCk7XG4gICAgYzggPSBjOC5yZWRJQWRkKGM4KTtcblxuICAgIC8vIFgzID0gRiAtIDIgKiBEXG4gICAgbnggPSBmLnJlZElTdWIoZCkucmVkSVN1YihkKTtcbiAgICAvLyBZMyA9IEUgKiAoRCAtIFgzKSAtIDggKiBDXG4gICAgbnkgPSBlLnJlZE11bChkLnJlZElTdWIobngpKS5yZWRJU3ViKGM4KTtcbiAgICAvLyBaMyA9IDIgKiBZMSAqIFoxXG4gICAgbnogPSB0aGlzLnkucmVkTXVsKHRoaXMueik7XG4gICAgbnogPSBuei5yZWRJQWRkKG56KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuX3RocmVlRGJsID0gZnVuY3Rpb24gX3RocmVlRGJsKCkge1xuICB2YXIgbng7XG4gIHZhciBueTtcbiAgdmFyIG56O1xuICAvLyBaID0gMVxuICBpZiAodGhpcy56T25lKSB7XG4gICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0zLmh0bWxcbiAgICAvLyAgICAgI2RvdWJsaW5nLW1kYmwtMjAwNy1ibFxuICAgIC8vIDFNICsgNVMgKyAxNUFcblxuICAgIC8vIFhYID0gWDFeMlxuICAgIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICAvLyBZWSA9IFkxXjJcbiAgICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgLy8gWVlZWSA9IFlZXjJcbiAgICB2YXIgeXl5eSA9IHl5LnJlZFNxcigpO1xuICAgIC8vIFMgPSAyICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKVxuICAgIHZhciBzID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgICBzID0gcy5yZWRJQWRkKHMpO1xuICAgIC8vIE0gPSAzICogWFggKyBhXG4gICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpLnJlZElBZGQodGhpcy5jdXJ2ZS5hKTtcbiAgICAvLyBUID0gTV4yIC0gMiAqIFNcbiAgICB2YXIgdCA9IG0ucmVkU3FyKCkucmVkSVN1YihzKS5yZWRJU3ViKHMpO1xuICAgIC8vIFgzID0gVFxuICAgIG54ID0gdDtcbiAgICAvLyBZMyA9IE0gKiAoUyAtIFQpIC0gOCAqIFlZWVlcbiAgICB2YXIgeXl5eTggPSB5eXl5LnJlZElBZGQoeXl5eSk7XG4gICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuICAgIG55ID0gbS5yZWRNdWwocy5yZWRJU3ViKHQpKS5yZWRJU3ViKHl5eXk4KTtcbiAgICAvLyBaMyA9IDIgKiBZMVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMy5odG1sI2RvdWJsaW5nLWRibC0yMDAxLWJcbiAgICAvLyAzTSArIDVTXG5cbiAgICAvLyBkZWx0YSA9IFoxXjJcbiAgICB2YXIgZGVsdGEgPSB0aGlzLnoucmVkU3FyKCk7XG4gICAgLy8gZ2FtbWEgPSBZMV4yXG4gICAgdmFyIGdhbW1hID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIGJldGEgPSBYMSAqIGdhbW1hXG4gICAgdmFyIGJldGEgPSB0aGlzLngucmVkTXVsKGdhbW1hKTtcbiAgICAvLyBhbHBoYSA9IDMgKiAoWDEgLSBkZWx0YSkgKiAoWDEgKyBkZWx0YSlcbiAgICB2YXIgYWxwaGEgPSB0aGlzLngucmVkU3ViKGRlbHRhKS5yZWRNdWwodGhpcy54LnJlZEFkZChkZWx0YSkpO1xuICAgIGFscGhhID0gYWxwaGEucmVkQWRkKGFscGhhKS5yZWRJQWRkKGFscGhhKTtcbiAgICAvLyBYMyA9IGFscGhhXjIgLSA4ICogYmV0YVxuICAgIHZhciBiZXRhNCA9IGJldGEucmVkSUFkZChiZXRhKTtcbiAgICBiZXRhNCA9IGJldGE0LnJlZElBZGQoYmV0YTQpO1xuICAgIHZhciBiZXRhOCA9IGJldGE0LnJlZEFkZChiZXRhNCk7XG4gICAgbnggPSBhbHBoYS5yZWRTcXIoKS5yZWRJU3ViKGJldGE4KTtcbiAgICAvLyBaMyA9IChZMSArIFoxKV4yIC0gZ2FtbWEgLSBkZWx0YVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnopLnJlZFNxcigpLnJlZElTdWIoZ2FtbWEpLnJlZElTdWIoZGVsdGEpO1xuICAgIC8vIFkzID0gYWxwaGEgKiAoNCAqIGJldGEgLSBYMykgLSA4ICogZ2FtbWFeMlxuICAgIHZhciBnZ2FtbWE4ID0gZ2FtbWEucmVkU3FyKCk7XG4gICAgZ2dhbW1hOCA9IGdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtcbiAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuICAgIGdnYW1tYTggPSBnZ2FtbWE4LnJlZElBZGQoZ2dhbW1hOCk7XG4gICAgbnkgPSBhbHBoYS5yZWRNdWwoYmV0YTQucmVkSVN1YihueCkpLnJlZElTdWIoZ2dhbW1hOCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLl9kYmwgPSBmdW5jdGlvbiBfZGJsKCkge1xuICB2YXIgYSA9IHRoaXMuY3VydmUuYTtcblxuICAvLyA0TSArIDZTICsgMTBBXG4gIHZhciBqeCA9IHRoaXMueDtcbiAgdmFyIGp5ID0gdGhpcy55O1xuICB2YXIganogPSB0aGlzLno7XG4gIHZhciBqejQgPSBqei5yZWRTcXIoKS5yZWRTcXIoKTtcblxuICB2YXIgangyID0gangucmVkU3FyKCk7XG4gIHZhciBqeTIgPSBqeS5yZWRTcXIoKTtcblxuICB2YXIgYyA9IGp4Mi5yZWRBZGQoangyKS5yZWRJQWRkKGp4MikucmVkSUFkZChhLnJlZE11bChqejQpKTtcblxuICB2YXIganhkNCA9IGp4LnJlZEFkZChqeCk7XG4gIGp4ZDQgPSBqeGQ0LnJlZElBZGQoanhkNCk7XG4gIHZhciB0MSA9IGp4ZDQucmVkTXVsKGp5Mik7XG4gIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0MS5yZWRBZGQodDEpKTtcbiAgdmFyIHQyID0gdDEucmVkSVN1YihueCk7XG5cbiAgdmFyIGp5ZDggPSBqeTIucmVkU3FyKCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIHZhciBueSA9IGMucmVkTXVsKHQyKS5yZWRJU3ViKGp5ZDgpO1xuICB2YXIgbnogPSBqeS5yZWRBZGQoankpLnJlZE11bChqeik7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS50cnBsID0gZnVuY3Rpb24gdHJwbCgpIHtcbiAgaWYgKCF0aGlzLmN1cnZlLnplcm9BKVxuICAgIHJldHVybiB0aGlzLmRibCgpLmFkZCh0aGlzKTtcblxuICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbCN0cmlwbGluZy10cGwtMjAwNy1ibFxuICAvLyA1TSArIDEwUyArIC4uLlxuXG4gIC8vIFhYID0gWDFeMlxuICB2YXIgeHggPSB0aGlzLngucmVkU3FyKCk7XG4gIC8vIFlZID0gWTFeMlxuICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gIC8vIFpaID0gWjFeMlxuICB2YXIgenogPSB0aGlzLnoucmVkU3FyKCk7XG4gIC8vIFlZWVkgPSBZWV4yXG4gIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gIC8vIE0gPSAzICogWFggKyBhICogWloyOyBhID0gMFxuICB2YXIgbSA9IHh4LnJlZEFkZCh4eCkucmVkSUFkZCh4eCk7XG4gIC8vIE1NID0gTV4yXG4gIHZhciBtbSA9IG0ucmVkU3FyKCk7XG4gIC8vIEUgPSA2ICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKSAtIE1NXG4gIHZhciBlID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgZSA9IGUucmVkSUFkZChlKTtcbiAgZSA9IGUucmVkQWRkKGUpLnJlZElBZGQoZSk7XG4gIGUgPSBlLnJlZElTdWIobW0pO1xuICAvLyBFRSA9IEVeMlxuICB2YXIgZWUgPSBlLnJlZFNxcigpO1xuICAvLyBUID0gMTYqWVlZWVxuICB2YXIgdCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgLy8gVSA9IChNICsgRSleMiAtIE1NIC0gRUUgLSBUXG4gIHZhciB1ID0gbS5yZWRJQWRkKGUpLnJlZFNxcigpLnJlZElTdWIobW0pLnJlZElTdWIoZWUpLnJlZElTdWIodCk7XG4gIC8vIFgzID0gNCAqIChYMSAqIEVFIC0gNCAqIFlZICogVSlcbiAgdmFyIHl5dTQgPSB5eS5yZWRNdWwodSk7XG4gIHl5dTQgPSB5eXU0LnJlZElBZGQoeXl1NCk7XG4gIHl5dTQgPSB5eXU0LnJlZElBZGQoeXl1NCk7XG4gIHZhciBueCA9IHRoaXMueC5yZWRNdWwoZWUpLnJlZElTdWIoeXl1NCk7XG4gIG54ID0gbngucmVkSUFkZChueCk7XG4gIG54ID0gbngucmVkSUFkZChueCk7XG4gIC8vIFkzID0gOCAqIFkxICogKFUgKiAoVCAtIFUpIC0gRSAqIEVFKVxuICB2YXIgbnkgPSB0aGlzLnkucmVkTXVsKHUucmVkTXVsKHQucmVkSVN1Yih1KSkucmVkSVN1YihlLnJlZE11bChlZSkpKTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgLy8gWjMgPSAoWjEgKyBFKV4yIC0gWlogLSBFRVxuICB2YXIgbnogPSB0aGlzLnoucmVkQWRkKGUpLnJlZFNxcigpLnJlZElTdWIoenopLnJlZElTdWIoZWUpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGssIGtiYXNlKSB7XG4gIGsgPSBuZXcgQk4oaywga2Jhc2UpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKHApIHtcbiAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpXG4gICAgcmV0dXJuIHRoaXMuZXEocC50b0ooKSk7XG5cbiAgaWYgKHRoaXMgPT09IHApXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgLy8geDEgKiB6Ml4yID09IHgyICogejFeMlxuICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciBwejIgPSBwLnoucmVkU3FyKCk7XG4gIGlmICh0aGlzLngucmVkTXVsKHB6MikucmVkSVN1YihwLngucmVkTXVsKHoyKSkuY21wbigwKSAhPT0gMClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8geTEgKiB6Ml4zID09IHkyICogejFeM1xuICB2YXIgejMgPSB6Mi5yZWRNdWwodGhpcy56KTtcbiAgdmFyIHB6MyA9IHB6Mi5yZWRNdWwocC56KTtcbiAgcmV0dXJuIHRoaXMueS5yZWRNdWwocHozKS5yZWRJU3ViKHAueS5yZWRNdWwoejMpKS5jbXBuKDApID09PSAwO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5lcVhUb1AgPSBmdW5jdGlvbiBlcVhUb1AoeCkge1xuICB2YXIgenMgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciByeCA9IHgudG9SZWQodGhpcy5jdXJ2ZS5yZWQpLnJlZE11bCh6cyk7XG4gIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB2YXIgeGMgPSB4LmNsb25lKCk7XG4gIHZhciB0ID0gdGhpcy5jdXJ2ZS5yZWROLnJlZE11bCh6cyk7XG4gIGZvciAoOzspIHtcbiAgICB4Yy5pYWRkKHRoaXMuY3VydmUubik7XG4gICAgaWYgKHhjLmNtcCh0aGlzLmN1cnZlLnApID49IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICByeC5yZWRJQWRkKHQpO1xuICAgIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuICc8RUMgSlBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIEpQb2ludCB4OiAnICsgdGhpcy54LnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHk6ICcgKyB0aGlzLnkudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgejogJyArIHRoaXMuei50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmlzSW5maW5pdHkgPSBmdW5jdGlvbiBpc0luZmluaXR5KCkge1xuICAvLyBYWFggVGhpcyBjb2RlIGFzc3VtZXMgdGhhdCB6ZXJvIGlzIGFsd2F5cyB6ZXJvIGluIHJlZFxuICByZXR1cm4gdGhpcy56LmNtcG4oMCkgPT09IDA7XG59O1xuXG52YXIgY3VydmVfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIGN1cnZlID0gZXhwb3J0cztcblxuY3VydmUuYmFzZSA9IGJhc2U7XG5jdXJ2ZS5zaG9ydCA9IHNob3J0XzE7XG5jdXJ2ZS5tb250ID0gLypSaWNNb286ZXRoZXJzOnJlcXVpcmUoLi9tb250KSovKG51bGwpO1xuY3VydmUuZWR3YXJkcyA9IC8qUmljTW9vOmV0aGVyczpyZXF1aXJlKC4vZWR3YXJkcykqLyhudWxsKTtcbn0pO1xuXG52YXIgY3VydmVzXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBjdXJ2ZXMgPSBleHBvcnRzO1xuXG5cblxuXG5cbnZhciBhc3NlcnQgPSB1dGlsc18xJDEuYXNzZXJ0O1xuXG5mdW5jdGlvbiBQcmVzZXRDdXJ2ZShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnR5cGUgPT09ICdzaG9ydCcpXG4gICAgdGhpcy5jdXJ2ZSA9IG5ldyBjdXJ2ZV8xLnNob3J0KG9wdGlvbnMpO1xuICBlbHNlIGlmIChvcHRpb25zLnR5cGUgPT09ICdlZHdhcmRzJylcbiAgICB0aGlzLmN1cnZlID0gbmV3IGN1cnZlXzEuZWR3YXJkcyhvcHRpb25zKTtcbiAgZWxzZVxuICAgIHRoaXMuY3VydmUgPSBuZXcgY3VydmVfMS5tb250KG9wdGlvbnMpO1xuICB0aGlzLmcgPSB0aGlzLmN1cnZlLmc7XG4gIHRoaXMubiA9IHRoaXMuY3VydmUubjtcbiAgdGhpcy5oYXNoID0gb3B0aW9ucy5oYXNoO1xuXG4gIGFzc2VydCh0aGlzLmcudmFsaWRhdGUoKSwgJ0ludmFsaWQgY3VydmUnKTtcbiAgYXNzZXJ0KHRoaXMuZy5tdWwodGhpcy5uKS5pc0luZmluaXR5KCksICdJbnZhbGlkIGN1cnZlLCBHKk4gIT0gTycpO1xufVxuY3VydmVzLlByZXNldEN1cnZlID0gUHJlc2V0Q3VydmU7XG5cbmZ1bmN0aW9uIGRlZmluZUN1cnZlKG5hbWUsIG9wdGlvbnMpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1cnZlcywgbmFtZSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3VydmUgPSBuZXcgUHJlc2V0Q3VydmUob3B0aW9ucyk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VydmVzLCBuYW1lLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGN1cnZlLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY3VydmU7XG4gICAgfSxcbiAgfSk7XG59XG5cbmRlZmluZUN1cnZlKCdwMTkyJywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogJ3AxOTInLFxuICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYnLFxuICBhOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmMnLFxuICBiOiAnNjQyMTA1MTkgZTU5YzgwZTcgMGZhN2U5YWIgNzIyNDMwNDkgZmViOGRlZWMgYzE0NmI5YjEnLFxuICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgOTlkZWY4MzYgMTQ2YmM5YjEgYjRkMjI4MzEnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnMTg4ZGE4MGUgYjAzMDkwZjYgN2NiZjIwZWIgNDNhMTg4MDAgZjRmZjBhZmQgODJmZjEwMTInLFxuICAgICcwNzE5MmI5NSBmZmM4ZGE3OCA2MzEwMTFlZCA2YjI0Y2RkNSA3M2Y5NzdhMSAxZTc5NDgxMScsXG4gIF0sXG59KTtcblxuZGVmaW5lQ3VydmUoJ3AyMjQnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiAncDIyNCcsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScsXG4gIGE6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZScsXG4gIGI6ICdiNDA1MGE4NSAwYzA0YjNhYiBmNTQxMzI1NiA1MDQ0YjBiNyBkN2JmZDhiYSAyNzBiMzk0MyAyMzU1ZmZiNCcsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmMTZhMiBlMGI4ZjAzZSAxM2RkMjk0NSA1YzVjMmEzZCcsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICdiNzBlMGNiZCA2YmI0YmY3ZiAzMjEzOTBiOSA0YTAzYzFkMyA1NmMyMTEyMiAzNDMyODBkNiAxMTVjMWQyMScsXG4gICAgJ2JkMzc2Mzg4IGI1ZjcyM2ZiIDRjMjJkZmU2IGNkNDM3NWEwIDVhMDc0NzY0IDQ0ZDU4MTk5IDg1MDA3ZTM0JyxcbiAgXSxcbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDI1NicsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6IG51bGwsXG4gIHA6ICdmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicsXG4gIGE6ICdmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYycsXG4gIGI6ICc1YWM2MzVkOCBhYTNhOTNlNyBiM2ViYmQ1NSA3Njk4ODZiYyA2NTFkMDZiMCBjYzUzYjBmNiAzYmNlM2MzZSAyN2QyNjA0YicsXG4gIG46ICdmZmZmZmZmZiAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBiY2U2ZmFhZCBhNzE3OWU4NCBmM2I5Y2FjMiBmYzYzMjU1MScsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICc2YjE3ZDFmMiBlMTJjNDI0NyBmOGJjZTZlNSA2M2E0NDBmMiA3NzAzN2Q4MSAyZGViMzNhMCBmNGExMzk0NSBkODk4YzI5NicsXG4gICAgJzRmZTM0MmUyIGZlMWE3ZjliIDhlZTdlYjRhIDdjMGY5ZTE2IDJiY2UzMzU3IDZiMzE1ZWNlIGNiYjY0MDY4IDM3YmY1MWY1JyxcbiAgXSxcbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDM4NCcsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6IG51bGwsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZlIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmJyxcbiAgYTogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmUgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmMnLFxuICBiOiAnYjMzMTJmYTcgZTIzZWU3ZTQgOTg4ZTA1NmIgZTNmODJkMTkgMTgxZDljNmUgZmU4MTQxMTIgMDMxNDA4OGYgJyArXG4gICAgICc1MDEzODc1YSBjNjU2Mzk4ZCA4YTJlZDE5ZCAyYTg1YzhlZCBkM2VjMmFlZicsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBjNzYzNGQ4MSAnICtcbiAgICAgJ2Y0MzcyZGRmIDU4MWEwZGIyIDQ4YjBhNzdhIGVjZWMxOTZhIGNjYzUyOTczJyxcbiAgaGFzaDogaGFzaC5zaGEzODQsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJ2FhODdjYTIyIGJlOGIwNTM3IDhlYjFjNzFlIGYzMjBhZDc0IDZlMWQzYjYyIDhiYTc5Yjk4IDU5Zjc0MWUwIDgyNTQyYTM4ICcgK1xuICAgICc1NTAyZjI1ZCBiZjU1Mjk2YyAzYTU0NWUzOCA3Mjc2MGFiNycsXG4gICAgJzM2MTdkZTRhIDk2MjYyYzZmIDVkOWU5OGJmIDkyOTJkYzI5IGY4ZjQxZGJkIDI4OWExNDdjIGU5ZGEzMTEzIGI1ZjBiOGMwICcgK1xuICAgICcwYTYwYjFjZSAxZDdlODE5ZCA3YTQzMWQ3YyA5MGVhMGU1ZicsXG4gIF0sXG59KTtcblxuZGVmaW5lQ3VydmUoJ3A1MjEnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiBudWxsLFxuICBwOiAnMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmJyxcbiAgYTogJzAwMDAwMWZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYycsXG4gIGI6ICcwMDAwMDA1MSA5NTNlYjk2MSA4ZTFjOWExZiA5MjlhMjFhMCBiNjg1NDBlZSBhMmRhNzI1YiAnICtcbiAgICAgJzk5YjMxNWYzIGI4YjQ4OTkxIDhlZjEwOWUxIDU2MTkzOTUxIGVjN2U5MzdiIDE2NTJjMGJkICcgK1xuICAgICAnM2JiMWJmMDcgMzU3M2RmODggM2QyYzM0ZjEgZWY0NTFmZDQgNmI1MDNmMDAnLFxuICBuOiAnMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYSA1MTg2ODc4MyBiZjJmOTY2YiA3ZmNjMDE0OCAnICtcbiAgICAgJ2Y3MDlhNWQwIDNiYjVjOWI4IDg5OWM0N2FlIGJiNmZiNzFlIDkxMzg2NDA5JyxcbiAgaGFzaDogaGFzaC5zaGE1MTIsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzAwMDAwMGM2IDg1OGUwNmI3IDA0MDRlOWNkIDllM2VjYjY2IDIzOTViNDQyIDljNjQ4MTM5ICcgK1xuICAgICcwNTNmYjUyMSBmODI4YWY2MCA2YjRkM2RiYSBhMTRiNWU3NyBlZmU3NTkyOCBmZTFkYzEyNyAnICtcbiAgICAnYTJmZmE4ZGUgMzM0OGIzYzEgODU2YTQyOWIgZjk3ZTdlMzEgYzJlNWJkNjYnLFxuICAgICcwMDAwMDExOCAzOTI5NmE3OCA5YTNiYzAwNCA1YzhhNWZiNCAyYzdkMWJkOSA5OGY1NDQ0OSAnICtcbiAgICAnNTc5YjQ0NjggMTdhZmJkMTcgMjczZTY2MmMgOTdlZTcyOTkgNWVmNDI2NDAgYzU1MGI5MDEgJyArXG4gICAgJzNmYWQwNzYxIDM1M2M3MDg2IGEyNzJjMjQwIDg4YmU5NDc2IDlmZDE2NjUwJyxcbiAgXSxcbn0pO1xuXG5kZWZpbmVDdXJ2ZSgnY3VydmUyNTUxOScsIHtcbiAgdHlwZTogJ21vbnQnLFxuICBwcmltZTogJ3AyNTUxOScsXG4gIHA6ICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyxcbiAgYTogJzc2ZDA2JyxcbiAgYjogJzEnLFxuICBuOiAnMTAwMDAwMDAwMDAwMDAwMCAwMDAwMDAwMDAwMDAwMDAwIDE0ZGVmOWRlYTJmNzljZDYgNTgxMjYzMWE1Y2Y1ZDNlZCcsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICc5JyxcbiAgXSxcbn0pO1xuXG5kZWZpbmVDdXJ2ZSgnZWQyNTUxOScsIHtcbiAgdHlwZTogJ2Vkd2FyZHMnLFxuICBwcmltZTogJ3AyNTUxOScsXG4gIHA6ICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyxcbiAgYTogJy0xJyxcbiAgYzogJzEnLFxuICAvLyAtMTIxNjY1ICogKDEyMTY2Nl4oLTEpKSAobW9kIFApXG4gIGQ6ICc1MjAzNmNlZTJiNmZmZTczIDhjYzc0MDc5Nzc3OWU4OTggMDA3MDBhNGQ0MTQxZDhhYiA3NWViNGRjYTEzNTk3OGEzJyxcbiAgbjogJzEwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMCAxNGRlZjlkZWEyZjc5Y2Q2IDU4MTI2MzFhNWNmNWQzZWQnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnMjE2OTM2ZDNjZDZlNTNmZWMwYTRlMjMxZmRkNmRjNWM2OTJjYzc2MDk1MjVhN2IyYzk1NjJkNjA4ZjI1ZDUxYScsXG5cbiAgICAvLyA0LzVcbiAgICAnNjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY1OCcsXG4gIF0sXG59KTtcblxudmFyIHByZTtcbnRyeSB7XG4gIHByZSA9IC8qUmljTW9vOmV0aGVyczpyZXF1aXJlKC4vcHJlY29tcHV0ZWQvc2VjcDI1NmsxKSovKG51bGwpLmNyYXNoKCk7XG59IGNhdGNoIChlKSB7XG4gIHByZSA9IHVuZGVmaW5lZDtcbn1cblxuZGVmaW5lQ3VydmUoJ3NlY3AyNTZrMScsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6ICdrMjU2JyxcbiAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmYzJmJyxcbiAgYTogJzAnLFxuICBiOiAnNycsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBiYWFlZGNlNiBhZjQ4YTAzYiBiZmQyNWU4YyBkMDM2NDE0MScsXG4gIGg6ICcxJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG5cbiAgLy8gUHJlY29tcHV0ZWQgZW5kb21vcnBoaXNtXG4gIGJldGE6ICc3YWU5NmEyYjY1N2MwNzEwNmU2NDQ3OWVhYzM0MzRlOTljZjA0OTc1MTJmNTg5OTVjMTM5NmMyODcxOTUwMWVlJyxcbiAgbGFtYmRhOiAnNTM2M2FkNGNjMDVjMzBlMGE1MjYxYzAyODgxMjY0NWExMjJlMjJlYTIwODE2Njc4ZGYwMjk2N2MxYjIzYmQ3MicsXG4gIGJhc2lzOiBbXG4gICAge1xuICAgICAgYTogJzMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1JyxcbiAgICAgIGI6ICctZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnLFxuICAgIH0sXG4gICAge1xuICAgICAgYTogJzExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcsXG4gICAgICBiOiAnMzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnLFxuICAgIH0sXG4gIF0sXG5cbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnNzliZTY2N2VmOWRjYmJhYzU1YTA2Mjk1Y2U4NzBiMDcwMjliZmNkYjJkY2UyOGQ5NTlmMjgxNWIxNmY4MTc5OCcsXG4gICAgJzQ4M2FkYTc3MjZhM2M0NjU1ZGE0ZmJmYzBlMTEwOGE4ZmQxN2I0NDhhNjg1NTQxOTljNDdkMDhmZmIxMGQ0YjgnLFxuICAgIHByZSxcbiAgXSxcbn0pO1xufSk7XG5cbid1c2Ugc3RyaWN0JztcblxuXG5cblxuXG5mdW5jdGlvbiBIbWFjRFJCRyhvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIbWFjRFJCRykpXG4gICAgcmV0dXJuIG5ldyBIbWFjRFJCRyhvcHRpb25zKTtcbiAgdGhpcy5oYXNoID0gb3B0aW9ucy5oYXNoO1xuICB0aGlzLnByZWRSZXNpc3QgPSAhIW9wdGlvbnMucHJlZFJlc2lzdDtcblxuICB0aGlzLm91dExlbiA9IHRoaXMuaGFzaC5vdXRTaXplO1xuICB0aGlzLm1pbkVudHJvcHkgPSBvcHRpb25zLm1pbkVudHJvcHkgfHwgdGhpcy5oYXNoLmhtYWNTdHJlbmd0aDtcblxuICB0aGlzLl9yZXNlZWQgPSBudWxsO1xuICB0aGlzLnJlc2VlZEludGVydmFsID0gbnVsbDtcbiAgdGhpcy5LID0gbnVsbDtcbiAgdGhpcy5WID0gbnVsbDtcblxuICB2YXIgZW50cm9weSA9IHV0aWxzXzEudG9BcnJheShvcHRpb25zLmVudHJvcHksIG9wdGlvbnMuZW50cm9weUVuYyB8fCAnaGV4Jyk7XG4gIHZhciBub25jZSA9IHV0aWxzXzEudG9BcnJheShvcHRpb25zLm5vbmNlLCBvcHRpb25zLm5vbmNlRW5jIHx8ICdoZXgnKTtcbiAgdmFyIHBlcnMgPSB1dGlsc18xLnRvQXJyYXkob3B0aW9ucy5wZXJzLCBvcHRpb25zLnBlcnNFbmMgfHwgJ2hleCcpO1xuICBtaW5pbWFsaXN0aWNBc3NlcnQoZW50cm9weS5sZW5ndGggPj0gKHRoaXMubWluRW50cm9weSAvIDgpLFxuICAgICAgICAgJ05vdCBlbm91Z2ggZW50cm9weS4gTWluaW11bSBpczogJyArIHRoaXMubWluRW50cm9weSArICcgYml0cycpO1xuICB0aGlzLl9pbml0KGVudHJvcHksIG5vbmNlLCBwZXJzKTtcbn1cbnZhciBobWFjRHJiZyA9IEhtYWNEUkJHO1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KGVudHJvcHksIG5vbmNlLCBwZXJzKSB7XG4gIHZhciBzZWVkID0gZW50cm9weS5jb25jYXQobm9uY2UpLmNvbmNhdChwZXJzKTtcblxuICB0aGlzLksgPSBuZXcgQXJyYXkodGhpcy5vdXRMZW4gLyA4KTtcbiAgdGhpcy5WID0gbmV3IEFycmF5KHRoaXMub3V0TGVuIC8gOCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5WLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5LW2ldID0gMHgwMDtcbiAgICB0aGlzLlZbaV0gPSAweDAxO1xuICB9XG5cbiAgdGhpcy5fdXBkYXRlKHNlZWQpO1xuICB0aGlzLl9yZXNlZWQgPSAxO1xuICB0aGlzLnJlc2VlZEludGVydmFsID0gMHgxMDAwMDAwMDAwMDAwOyAgLy8gMl40OFxufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLl9obWFjID0gZnVuY3Rpb24gaG1hYygpIHtcbiAgcmV0dXJuIG5ldyBoYXNoLmhtYWModGhpcy5oYXNoLCB0aGlzLkspO1xufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoc2VlZCkge1xuICB2YXIga21hYyA9IHRoaXMuX2htYWMoKVxuICAgICAgICAgICAgICAgICAudXBkYXRlKHRoaXMuVilcbiAgICAgICAgICAgICAgICAgLnVwZGF0ZShbIDB4MDAgXSk7XG4gIGlmIChzZWVkKVxuICAgIGttYWMgPSBrbWFjLnVwZGF0ZShzZWVkKTtcbiAgdGhpcy5LID0ga21hYy5kaWdlc3QoKTtcbiAgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO1xuICBpZiAoIXNlZWQpXG4gICAgcmV0dXJuO1xuXG4gIHRoaXMuSyA9IHRoaXMuX2htYWMoKVxuICAgICAgICAgICAgICAgLnVwZGF0ZSh0aGlzLlYpXG4gICAgICAgICAgICAgICAudXBkYXRlKFsgMHgwMSBdKVxuICAgICAgICAgICAgICAgLnVwZGF0ZShzZWVkKVxuICAgICAgICAgICAgICAgLmRpZ2VzdCgpO1xuICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUucmVzZWVkID0gZnVuY3Rpb24gcmVzZWVkKGVudHJvcHksIGVudHJvcHlFbmMsIGFkZCwgYWRkRW5jKSB7XG4gIC8vIE9wdGlvbmFsIGVudHJvcHkgZW5jXG4gIGlmICh0eXBlb2YgZW50cm9weUVuYyAhPT0gJ3N0cmluZycpIHtcbiAgICBhZGRFbmMgPSBhZGQ7XG4gICAgYWRkID0gZW50cm9weUVuYztcbiAgICBlbnRyb3B5RW5jID0gbnVsbDtcbiAgfVxuXG4gIGVudHJvcHkgPSB1dGlsc18xLnRvQXJyYXkoZW50cm9weSwgZW50cm9weUVuYyk7XG4gIGFkZCA9IHV0aWxzXzEudG9BcnJheShhZGQsIGFkZEVuYyk7XG5cbiAgbWluaW1hbGlzdGljQXNzZXJ0KGVudHJvcHkubGVuZ3RoID49ICh0aGlzLm1pbkVudHJvcHkgLyA4KSxcbiAgICAgICAgICdOb3QgZW5vdWdoIGVudHJvcHkuIE1pbmltdW0gaXM6ICcgKyB0aGlzLm1pbkVudHJvcHkgKyAnIGJpdHMnKTtcblxuICB0aGlzLl91cGRhdGUoZW50cm9weS5jb25jYXQoYWRkIHx8IFtdKSk7XG4gIHRoaXMuX3Jlc2VlZCA9IDE7XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiBnZW5lcmF0ZShsZW4sIGVuYywgYWRkLCBhZGRFbmMpIHtcbiAgaWYgKHRoaXMuX3Jlc2VlZCA+IHRoaXMucmVzZWVkSW50ZXJ2YWwpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXNlZWQgaXMgcmVxdWlyZWQnKTtcblxuICAvLyBPcHRpb25hbCBlbmNvZGluZ1xuICBpZiAodHlwZW9mIGVuYyAhPT0gJ3N0cmluZycpIHtcbiAgICBhZGRFbmMgPSBhZGQ7XG4gICAgYWRkID0gZW5jO1xuICAgIGVuYyA9IG51bGw7XG4gIH1cblxuICAvLyBPcHRpb25hbCBhZGRpdGlvbmFsIGRhdGFcbiAgaWYgKGFkZCkge1xuICAgIGFkZCA9IHV0aWxzXzEudG9BcnJheShhZGQsIGFkZEVuYyB8fCAnaGV4Jyk7XG4gICAgdGhpcy5fdXBkYXRlKGFkZCk7XG4gIH1cblxuICB2YXIgdGVtcCA9IFtdO1xuICB3aGlsZSAodGVtcC5sZW5ndGggPCBsZW4pIHtcbiAgICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7XG4gICAgdGVtcCA9IHRlbXAuY29uY2F0KHRoaXMuVik7XG4gIH1cblxuICB2YXIgcmVzID0gdGVtcC5zbGljZSgwLCBsZW4pO1xuICB0aGlzLl91cGRhdGUoYWRkKTtcbiAgdGhpcy5fcmVzZWVkKys7XG4gIHJldHVybiB1dGlsc18xLmVuY29kZShyZXMsIGVuYyk7XG59O1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG52YXIgYXNzZXJ0JDMgPSB1dGlsc18xJDEuYXNzZXJ0O1xuXG5mdW5jdGlvbiBLZXlQYWlyKGVjLCBvcHRpb25zKSB7XG4gIHRoaXMuZWMgPSBlYztcbiAgdGhpcy5wcml2ID0gbnVsbDtcbiAgdGhpcy5wdWIgPSBudWxsO1xuXG4gIC8vIEtleVBhaXIoZWMsIHsgcHJpdjogLi4uLCBwdWI6IC4uLiB9KVxuICBpZiAob3B0aW9ucy5wcml2KVxuICAgIHRoaXMuX2ltcG9ydFByaXZhdGUob3B0aW9ucy5wcml2LCBvcHRpb25zLnByaXZFbmMpO1xuICBpZiAob3B0aW9ucy5wdWIpXG4gICAgdGhpcy5faW1wb3J0UHVibGljKG9wdGlvbnMucHViLCBvcHRpb25zLnB1YkVuYyk7XG59XG52YXIga2V5ID0gS2V5UGFpcjtcblxuS2V5UGFpci5mcm9tUHVibGljID0gZnVuY3Rpb24gZnJvbVB1YmxpYyhlYywgcHViLCBlbmMpIHtcbiAgaWYgKHB1YiBpbnN0YW5jZW9mIEtleVBhaXIpXG4gICAgcmV0dXJuIHB1YjtcblxuICByZXR1cm4gbmV3IEtleVBhaXIoZWMsIHtcbiAgICBwdWI6IHB1YixcbiAgICBwdWJFbmM6IGVuYyxcbiAgfSk7XG59O1xuXG5LZXlQYWlyLmZyb21Qcml2YXRlID0gZnVuY3Rpb24gZnJvbVByaXZhdGUoZWMsIHByaXYsIGVuYykge1xuICBpZiAocHJpdiBpbnN0YW5jZW9mIEtleVBhaXIpXG4gICAgcmV0dXJuIHByaXY7XG5cbiAgcmV0dXJuIG5ldyBLZXlQYWlyKGVjLCB7XG4gICAgcHJpdjogcHJpdixcbiAgICBwcml2RW5jOiBlbmMsXG4gIH0pO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgdmFyIHB1YiA9IHRoaXMuZ2V0UHVibGljKCk7XG5cbiAgaWYgKHB1Yi5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgcmVhc29uOiAnSW52YWxpZCBwdWJsaWMga2V5JyB9O1xuICBpZiAoIXB1Yi52YWxpZGF0ZSgpKVxuICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIHJlYXNvbjogJ1B1YmxpYyBrZXkgaXMgbm90IGEgcG9pbnQnIH07XG4gIGlmICghcHViLm11bCh0aGlzLmVjLmN1cnZlLm4pLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCByZWFzb246ICdQdWJsaWMga2V5ICogTiAhPSBPJyB9O1xuXG4gIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgcmVhc29uOiBudWxsIH07XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRQdWJsaWMgPSBmdW5jdGlvbiBnZXRQdWJsaWMoY29tcGFjdCwgZW5jKSB7XG4gIC8vIGNvbXBhY3QgaXMgb3B0aW9uYWwgYXJndW1lbnRcbiAgaWYgKHR5cGVvZiBjb21wYWN0ID09PSAnc3RyaW5nJykge1xuICAgIGVuYyA9IGNvbXBhY3Q7XG4gICAgY29tcGFjdCA9IG51bGw7XG4gIH1cblxuICBpZiAoIXRoaXMucHViKVxuICAgIHRoaXMucHViID0gdGhpcy5lYy5nLm11bCh0aGlzLnByaXYpO1xuXG4gIGlmICghZW5jKVxuICAgIHJldHVybiB0aGlzLnB1YjtcblxuICByZXR1cm4gdGhpcy5wdWIuZW5jb2RlKGVuYywgY29tcGFjdCk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRQcml2YXRlID0gZnVuY3Rpb24gZ2V0UHJpdmF0ZShlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHRoaXMucHJpdi50b1N0cmluZygxNiwgMik7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5wcml2O1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuX2ltcG9ydFByaXZhdGUgPSBmdW5jdGlvbiBfaW1wb3J0UHJpdmF0ZShrZXksIGVuYykge1xuICB0aGlzLnByaXYgPSBuZXcgQk4oa2V5LCBlbmMgfHwgMTYpO1xuXG4gIC8vIEVuc3VyZSB0aGF0IHRoZSBwcml2IHdvbid0IGJlIGJpZ2dlciB0aGFuIG4sIG90aGVyd2lzZSB3ZSBtYXkgZmFpbFxuICAvLyBpbiBmaXhlZCBtdWx0aXBsaWNhdGlvbiBtZXRob2RcbiAgdGhpcy5wcml2ID0gdGhpcy5wcml2LnVtb2QodGhpcy5lYy5jdXJ2ZS5uKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLl9pbXBvcnRQdWJsaWMgPSBmdW5jdGlvbiBfaW1wb3J0UHVibGljKGtleSwgZW5jKSB7XG4gIGlmIChrZXkueCB8fCBrZXkueSkge1xuICAgIC8vIE1vbnRnb21lcnkgcG9pbnRzIG9ubHkgaGF2ZSBhbiBgeGAgY29vcmRpbmF0ZS5cbiAgICAvLyBXZWllcnN0cmFzcy9FZHdhcmRzIHBvaW50cyBvbiB0aGUgb3RoZXIgaGFuZCBoYXZlIGJvdGggYHhgIGFuZFxuICAgIC8vIGB5YCBjb29yZGluYXRlcy5cbiAgICBpZiAodGhpcy5lYy5jdXJ2ZS50eXBlID09PSAnbW9udCcpIHtcbiAgICAgIGFzc2VydCQzKGtleS54LCAnTmVlZCB4IGNvb3JkaW5hdGUnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZWMuY3VydmUudHlwZSA9PT0gJ3Nob3J0JyB8fFxuICAgICAgICAgICAgICAgdGhpcy5lYy5jdXJ2ZS50eXBlID09PSAnZWR3YXJkcycpIHtcbiAgICAgIGFzc2VydCQzKGtleS54ICYmIGtleS55LCAnTmVlZCBib3RoIHggYW5kIHkgY29vcmRpbmF0ZScpO1xuICAgIH1cbiAgICB0aGlzLnB1YiA9IHRoaXMuZWMuY3VydmUucG9pbnQoa2V5LngsIGtleS55KTtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5wdWIgPSB0aGlzLmVjLmN1cnZlLmRlY29kZVBvaW50KGtleSwgZW5jKTtcbn07XG5cbi8vIEVDREhcbktleVBhaXIucHJvdG90eXBlLmRlcml2ZSA9IGZ1bmN0aW9uIGRlcml2ZShwdWIpIHtcbiAgaWYoIXB1Yi52YWxpZGF0ZSgpKSB7XG4gICAgYXNzZXJ0JDMocHViLnZhbGlkYXRlKCksICdwdWJsaWMgcG9pbnQgbm90IHZhbGlkYXRlZCcpO1xuICB9XG4gIHJldHVybiBwdWIubXVsKHRoaXMucHJpdikuZ2V0WCgpO1xufTtcblxuLy8gRUNEU0FcbktleVBhaXIucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduKG1zZywgZW5jLCBvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLmVjLnNpZ24obXNnLCB0aGlzLCBlbmMsIG9wdGlvbnMpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1zZywgc2lnbmF0dXJlKSB7XG4gIHJldHVybiB0aGlzLmVjLnZlcmlmeShtc2csIHNpZ25hdHVyZSwgdGhpcyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgcmV0dXJuICc8S2V5IHByaXY6ICcgKyAodGhpcy5wcml2ICYmIHRoaXMucHJpdi50b1N0cmluZygxNiwgMikpICtcbiAgICAgICAgICcgcHViOiAnICsgKHRoaXMucHViICYmIHRoaXMucHViLmluc3BlY3QoKSkgKyAnID4nO1xufTtcblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuXG52YXIgYXNzZXJ0JDQgPSB1dGlsc18xJDEuYXNzZXJ0O1xuXG5mdW5jdGlvbiBTaWduYXR1cmUob3B0aW9ucywgZW5jKSB7XG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2YgU2lnbmF0dXJlKVxuICAgIHJldHVybiBvcHRpb25zO1xuXG4gIGlmICh0aGlzLl9pbXBvcnRERVIob3B0aW9ucywgZW5jKSlcbiAgICByZXR1cm47XG5cbiAgYXNzZXJ0JDQob3B0aW9ucy5yICYmIG9wdGlvbnMucywgJ1NpZ25hdHVyZSB3aXRob3V0IHIgb3IgcycpO1xuICB0aGlzLnIgPSBuZXcgQk4ob3B0aW9ucy5yLCAxNik7XG4gIHRoaXMucyA9IG5ldyBCTihvcHRpb25zLnMsIDE2KTtcbiAgaWYgKG9wdGlvbnMucmVjb3ZlcnlQYXJhbSA9PT0gdW5kZWZpbmVkKVxuICAgIHRoaXMucmVjb3ZlcnlQYXJhbSA9IG51bGw7XG4gIGVsc2VcbiAgICB0aGlzLnJlY292ZXJ5UGFyYW0gPSBvcHRpb25zLnJlY292ZXJ5UGFyYW07XG59XG52YXIgc2lnbmF0dXJlID0gU2lnbmF0dXJlO1xuXG5mdW5jdGlvbiBQb3NpdGlvbigpIHtcbiAgdGhpcy5wbGFjZSA9IDA7XG59XG5cbmZ1bmN0aW9uIGdldExlbmd0aChidWYsIHApIHtcbiAgdmFyIGluaXRpYWwgPSBidWZbcC5wbGFjZSsrXTtcbiAgaWYgKCEoaW5pdGlhbCAmIDB4ODApKSB7XG4gICAgcmV0dXJuIGluaXRpYWw7XG4gIH1cbiAgdmFyIG9jdGV0TGVuID0gaW5pdGlhbCAmIDB4ZjtcblxuICAvLyBJbmRlZmluaXRlIGxlbmd0aCBvciBvdmVyZmxvd1xuICBpZiAob2N0ZXRMZW4gPT09IDAgfHwgb2N0ZXRMZW4gPiA0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHZhbCA9IDA7XG4gIGZvciAodmFyIGkgPSAwLCBvZmYgPSBwLnBsYWNlOyBpIDwgb2N0ZXRMZW47IGkrKywgb2ZmKyspIHtcbiAgICB2YWwgPDw9IDg7XG4gICAgdmFsIHw9IGJ1ZltvZmZdO1xuICAgIHZhbCA+Pj49IDA7XG4gIH1cblxuICAvLyBMZWFkaW5nIHplcm9lc1xuICBpZiAodmFsIDw9IDB4N2YpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwLnBsYWNlID0gb2ZmO1xuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBybVBhZGRpbmcoYnVmKSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGggLSAxO1xuICB3aGlsZSAoIWJ1ZltpXSAmJiAhKGJ1ZltpICsgMV0gJiAweDgwKSAmJiBpIDwgbGVuKSB7XG4gICAgaSsrO1xuICB9XG4gIGlmIChpID09PSAwKSB7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuICByZXR1cm4gYnVmLnNsaWNlKGkpO1xufVxuXG5TaWduYXR1cmUucHJvdG90eXBlLl9pbXBvcnRERVIgPSBmdW5jdGlvbiBfaW1wb3J0REVSKGRhdGEsIGVuYykge1xuICBkYXRhID0gdXRpbHNfMSQxLnRvQXJyYXkoZGF0YSwgZW5jKTtcbiAgdmFyIHAgPSBuZXcgUG9zaXRpb24oKTtcbiAgaWYgKGRhdGFbcC5wbGFjZSsrXSAhPT0gMHgzMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGVuID0gZ2V0TGVuZ3RoKGRhdGEsIHApO1xuICBpZiAobGVuID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoKGxlbiArIHAucGxhY2UpICE9PSBkYXRhLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZGF0YVtwLnBsYWNlKytdICE9PSAweDAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBybGVuID0gZ2V0TGVuZ3RoKGRhdGEsIHApO1xuICBpZiAocmxlbiA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHIgPSBkYXRhLnNsaWNlKHAucGxhY2UsIHJsZW4gKyBwLnBsYWNlKTtcbiAgcC5wbGFjZSArPSBybGVuO1xuICBpZiAoZGF0YVtwLnBsYWNlKytdICE9PSAweDAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBzbGVuID0gZ2V0TGVuZ3RoKGRhdGEsIHApO1xuICBpZiAoc2xlbiA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGRhdGEubGVuZ3RoICE9PSBzbGVuICsgcC5wbGFjZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcyA9IGRhdGEuc2xpY2UocC5wbGFjZSwgc2xlbiArIHAucGxhY2UpO1xuICBpZiAoclswXSA9PT0gMCkge1xuICAgIGlmIChyWzFdICYgMHg4MCkge1xuICAgICAgciA9IHIuc2xpY2UoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExlYWRpbmcgemVyb2VzXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChzWzBdID09PSAwKSB7XG4gICAgaWYgKHNbMV0gJiAweDgwKSB7XG4gICAgICBzID0gcy5zbGljZSgxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGVhZGluZyB6ZXJvZXNcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnIgPSBuZXcgQk4ocik7XG4gIHRoaXMucyA9IG5ldyBCTihzKTtcbiAgdGhpcy5yZWNvdmVyeVBhcmFtID0gbnVsbDtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdExlbmd0aChhcnIsIGxlbikge1xuICBpZiAobGVuIDwgMHg4MCkge1xuICAgIGFyci5wdXNoKGxlbik7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBvY3RldHMgPSAxICsgKE1hdGgubG9nKGxlbikgLyBNYXRoLkxOMiA+Pj4gMyk7XG4gIGFyci5wdXNoKG9jdGV0cyB8IDB4ODApO1xuICB3aGlsZSAoLS1vY3RldHMpIHtcbiAgICBhcnIucHVzaCgobGVuID4+PiAob2N0ZXRzIDw8IDMpKSAmIDB4ZmYpO1xuICB9XG4gIGFyci5wdXNoKGxlbik7XG59XG5cblNpZ25hdHVyZS5wcm90b3R5cGUudG9ERVIgPSBmdW5jdGlvbiB0b0RFUihlbmMpIHtcbiAgdmFyIHIgPSB0aGlzLnIudG9BcnJheSgpO1xuICB2YXIgcyA9IHRoaXMucy50b0FycmF5KCk7XG5cbiAgLy8gUGFkIHZhbHVlc1xuICBpZiAoclswXSAmIDB4ODApXG4gICAgciA9IFsgMCBdLmNvbmNhdChyKTtcbiAgLy8gUGFkIHZhbHVlc1xuICBpZiAoc1swXSAmIDB4ODApXG4gICAgcyA9IFsgMCBdLmNvbmNhdChzKTtcblxuICByID0gcm1QYWRkaW5nKHIpO1xuICBzID0gcm1QYWRkaW5nKHMpO1xuXG4gIHdoaWxlICghc1swXSAmJiAhKHNbMV0gJiAweDgwKSkge1xuICAgIHMgPSBzLnNsaWNlKDEpO1xuICB9XG4gIHZhciBhcnIgPSBbIDB4MDIgXTtcbiAgY29uc3RydWN0TGVuZ3RoKGFyciwgci5sZW5ndGgpO1xuICBhcnIgPSBhcnIuY29uY2F0KHIpO1xuICBhcnIucHVzaCgweDAyKTtcbiAgY29uc3RydWN0TGVuZ3RoKGFyciwgcy5sZW5ndGgpO1xuICB2YXIgYmFja0hhbGYgPSBhcnIuY29uY2F0KHMpO1xuICB2YXIgcmVzID0gWyAweDMwIF07XG4gIGNvbnN0cnVjdExlbmd0aChyZXMsIGJhY2tIYWxmLmxlbmd0aCk7XG4gIHJlcyA9IHJlcy5jb25jYXQoYmFja0hhbGYpO1xuICByZXR1cm4gdXRpbHNfMSQxLmVuY29kZShyZXMsIGVuYyk7XG59O1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5cblxudmFyIHJhbmQgPSAvKlJpY01vbzpldGhlcnM6cmVxdWlyZShicm9yYW5kKSovKGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkJyk7IH0pO1xudmFyIGFzc2VydCQ1ID0gdXRpbHNfMSQxLmFzc2VydDtcblxuXG5cblxuZnVuY3Rpb24gRUMob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRUMpKVxuICAgIHJldHVybiBuZXcgRUMob3B0aW9ucyk7XG5cbiAgLy8gU2hvcnRjdXQgYGVsbGlwdGljLmVjKGN1cnZlLW5hbWUpYFxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgYXNzZXJ0JDUoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN1cnZlc18xLCBvcHRpb25zKSxcbiAgICAgICdVbmtub3duIGN1cnZlICcgKyBvcHRpb25zKTtcblxuICAgIG9wdGlvbnMgPSBjdXJ2ZXNfMVtvcHRpb25zXTtcbiAgfVxuXG4gIC8vIFNob3J0Y3V0IGZvciBgZWxsaXB0aWMuZWMoZWxsaXB0aWMuY3VydmVzLmN1cnZlTmFtZSlgXG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2YgY3VydmVzXzEuUHJlc2V0Q3VydmUpXG4gICAgb3B0aW9ucyA9IHsgY3VydmU6IG9wdGlvbnMgfTtcblxuICB0aGlzLmN1cnZlID0gb3B0aW9ucy5jdXJ2ZS5jdXJ2ZTtcbiAgdGhpcy5uID0gdGhpcy5jdXJ2ZS5uO1xuICB0aGlzLm5oID0gdGhpcy5uLnVzaHJuKDEpO1xuICB0aGlzLmcgPSB0aGlzLmN1cnZlLmc7XG5cbiAgLy8gUG9pbnQgb24gY3VydmVcbiAgdGhpcy5nID0gb3B0aW9ucy5jdXJ2ZS5nO1xuICB0aGlzLmcucHJlY29tcHV0ZShvcHRpb25zLmN1cnZlLm4uYml0TGVuZ3RoKCkgKyAxKTtcblxuICAvLyBIYXNoIGZvciBmdW5jdGlvbiBmb3IgRFJCR1xuICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2ggfHwgb3B0aW9ucy5jdXJ2ZS5oYXNoO1xufVxudmFyIGVjID0gRUM7XG5cbkVDLnByb3RvdHlwZS5rZXlQYWlyID0gZnVuY3Rpb24ga2V5UGFpcihvcHRpb25zKSB7XG4gIHJldHVybiBuZXcga2V5KHRoaXMsIG9wdGlvbnMpO1xufTtcblxuRUMucHJvdG90eXBlLmtleUZyb21Qcml2YXRlID0gZnVuY3Rpb24ga2V5RnJvbVByaXZhdGUocHJpdiwgZW5jKSB7XG4gIHJldHVybiBrZXkuZnJvbVByaXZhdGUodGhpcywgcHJpdiwgZW5jKTtcbn07XG5cbkVDLnByb3RvdHlwZS5rZXlGcm9tUHVibGljID0gZnVuY3Rpb24ga2V5RnJvbVB1YmxpYyhwdWIsIGVuYykge1xuICByZXR1cm4ga2V5LmZyb21QdWJsaWModGhpcywgcHViLCBlbmMpO1xufTtcblxuRUMucHJvdG90eXBlLmdlbktleVBhaXIgPSBmdW5jdGlvbiBnZW5LZXlQYWlyKG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKVxuICAgIG9wdGlvbnMgPSB7fTtcblxuICAvLyBJbnN0YW50aWF0ZSBIbWFjX0RSQkdcbiAgdmFyIGRyYmcgPSBuZXcgaG1hY0RyYmcoe1xuICAgIGhhc2g6IHRoaXMuaGFzaCxcbiAgICBwZXJzOiBvcHRpb25zLnBlcnMsXG4gICAgcGVyc0VuYzogb3B0aW9ucy5wZXJzRW5jIHx8ICd1dGY4JyxcbiAgICBlbnRyb3B5OiBvcHRpb25zLmVudHJvcHkgfHwgcmFuZCh0aGlzLmhhc2guaG1hY1N0cmVuZ3RoKSxcbiAgICBlbnRyb3B5RW5jOiBvcHRpb25zLmVudHJvcHkgJiYgb3B0aW9ucy5lbnRyb3B5RW5jIHx8ICd1dGY4JyxcbiAgICBub25jZTogdGhpcy5uLnRvQXJyYXkoKSxcbiAgfSk7XG5cbiAgdmFyIGJ5dGVzID0gdGhpcy5uLmJ5dGVMZW5ndGgoKTtcbiAgdmFyIG5zMiA9IHRoaXMubi5zdWIobmV3IEJOKDIpKTtcbiAgZm9yICg7Oykge1xuICAgIHZhciBwcml2ID0gbmV3IEJOKGRyYmcuZ2VuZXJhdGUoYnl0ZXMpKTtcbiAgICBpZiAocHJpdi5jbXAobnMyKSA+IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIHByaXYuaWFkZG4oMSk7XG4gICAgcmV0dXJuIHRoaXMua2V5RnJvbVByaXZhdGUocHJpdik7XG4gIH1cbn07XG5cbkVDLnByb3RvdHlwZS5fdHJ1bmNhdGVUb04gPSBmdW5jdGlvbiBfdHJ1bmNhdGVUb04obXNnLCB0cnVuY09ubHkpIHtcbiAgdmFyIGRlbHRhID0gbXNnLmJ5dGVMZW5ndGgoKSAqIDggLSB0aGlzLm4uYml0TGVuZ3RoKCk7XG4gIGlmIChkZWx0YSA+IDApXG4gICAgbXNnID0gbXNnLnVzaHJuKGRlbHRhKTtcbiAgaWYgKCF0cnVuY09ubHkgJiYgbXNnLmNtcCh0aGlzLm4pID49IDApXG4gICAgcmV0dXJuIG1zZy5zdWIodGhpcy5uKTtcbiAgZWxzZVxuICAgIHJldHVybiBtc2c7XG59O1xuXG5FQy5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24obXNnLCBrZXksIGVuYywgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGVuYyA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0gZW5jO1xuICAgIGVuYyA9IG51bGw7XG4gIH1cbiAgaWYgKCFvcHRpb25zKVxuICAgIG9wdGlvbnMgPSB7fTtcblxuICBrZXkgPSB0aGlzLmtleUZyb21Qcml2YXRlKGtleSwgZW5jKTtcbiAgbXNnID0gdGhpcy5fdHJ1bmNhdGVUb04obmV3IEJOKG1zZywgMTYpKTtcblxuICAvLyBaZXJvLWV4dGVuZCBrZXkgdG8gcHJvdmlkZSBlbm91Z2ggZW50cm9weVxuICB2YXIgYnl0ZXMgPSB0aGlzLm4uYnl0ZUxlbmd0aCgpO1xuICB2YXIgYmtleSA9IGtleS5nZXRQcml2YXRlKCkudG9BcnJheSgnYmUnLCBieXRlcyk7XG5cbiAgLy8gWmVyby1leHRlbmQgbm9uY2UgdG8gaGF2ZSB0aGUgc2FtZSBieXRlIHNpemUgYXMgTlxuICB2YXIgbm9uY2UgPSBtc2cudG9BcnJheSgnYmUnLCBieXRlcyk7XG5cbiAgLy8gSW5zdGFudGlhdGUgSG1hY19EUkJHXG4gIHZhciBkcmJnID0gbmV3IGhtYWNEcmJnKHtcbiAgICBoYXNoOiB0aGlzLmhhc2gsXG4gICAgZW50cm9weTogYmtleSxcbiAgICBub25jZTogbm9uY2UsXG4gICAgcGVyczogb3B0aW9ucy5wZXJzLFxuICAgIHBlcnNFbmM6IG9wdGlvbnMucGVyc0VuYyB8fCAndXRmOCcsXG4gIH0pO1xuXG4gIC8vIE51bWJlciBvZiBieXRlcyB0byBnZW5lcmF0ZVxuICB2YXIgbnMxID0gdGhpcy5uLnN1YihuZXcgQk4oMSkpO1xuXG4gIGZvciAodmFyIGl0ZXIgPSAwOyA7IGl0ZXIrKykge1xuICAgIHZhciBrID0gb3B0aW9ucy5rID9cbiAgICAgIG9wdGlvbnMuayhpdGVyKSA6XG4gICAgICBuZXcgQk4oZHJiZy5nZW5lcmF0ZSh0aGlzLm4uYnl0ZUxlbmd0aCgpKSk7XG4gICAgayA9IHRoaXMuX3RydW5jYXRlVG9OKGssIHRydWUpO1xuICAgIGlmIChrLmNtcG4oMSkgPD0gMCB8fCBrLmNtcChuczEpID49IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIHZhciBrcCA9IHRoaXMuZy5tdWwoayk7XG4gICAgaWYgKGtwLmlzSW5maW5pdHkoKSlcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIGtwWCA9IGtwLmdldFgoKTtcbiAgICB2YXIgciA9IGtwWC51bW9kKHRoaXMubik7XG4gICAgaWYgKHIuY21wbigwKSA9PT0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIHMgPSBrLmludm0odGhpcy5uKS5tdWwoci5tdWwoa2V5LmdldFByaXZhdGUoKSkuaWFkZChtc2cpKTtcbiAgICBzID0gcy51bW9kKHRoaXMubik7XG4gICAgaWYgKHMuY21wbigwKSA9PT0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIHJlY292ZXJ5UGFyYW0gPSAoa3AuZ2V0WSgpLmlzT2RkKCkgPyAxIDogMCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKGtwWC5jbXAocikgIT09IDAgPyAyIDogMCk7XG5cbiAgICAvLyBVc2UgY29tcGxlbWVudCBvZiBgc2AsIGlmIGl0IGlzID4gYG4gLyAyYFxuICAgIGlmIChvcHRpb25zLmNhbm9uaWNhbCAmJiBzLmNtcCh0aGlzLm5oKSA+IDApIHtcbiAgICAgIHMgPSB0aGlzLm4uc3ViKHMpO1xuICAgICAgcmVjb3ZlcnlQYXJhbSBePSAxO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgc2lnbmF0dXJlKHsgcjogciwgczogcywgcmVjb3ZlcnlQYXJhbTogcmVjb3ZlcnlQYXJhbSB9KTtcbiAgfVxufTtcblxuRUMucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtc2csIHNpZ25hdHVyZSQxLCBrZXksIGVuYykge1xuICBtc2cgPSB0aGlzLl90cnVuY2F0ZVRvTihuZXcgQk4obXNnLCAxNikpO1xuICBrZXkgPSB0aGlzLmtleUZyb21QdWJsaWMoa2V5LCBlbmMpO1xuICBzaWduYXR1cmUkMSA9IG5ldyBzaWduYXR1cmUoc2lnbmF0dXJlJDEsICdoZXgnKTtcblxuICAvLyBQZXJmb3JtIHByaW1pdGl2ZSB2YWx1ZXMgdmFsaWRhdGlvblxuICB2YXIgciA9IHNpZ25hdHVyZSQxLnI7XG4gIHZhciBzID0gc2lnbmF0dXJlJDEucztcbiAgaWYgKHIuY21wbigxKSA8IDAgfHwgci5jbXAodGhpcy5uKSA+PSAwKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHMuY21wbigxKSA8IDAgfHwgcy5jbXAodGhpcy5uKSA+PSAwKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBWYWxpZGF0ZSBzaWduYXR1cmVcbiAgdmFyIHNpbnYgPSBzLmludm0odGhpcy5uKTtcbiAgdmFyIHUxID0gc2ludi5tdWwobXNnKS51bW9kKHRoaXMubik7XG4gIHZhciB1MiA9IHNpbnYubXVsKHIpLnVtb2QodGhpcy5uKTtcbiAgdmFyIHA7XG5cbiAgaWYgKCF0aGlzLmN1cnZlLl9tYXh3ZWxsVHJpY2spIHtcbiAgICBwID0gdGhpcy5nLm11bEFkZCh1MSwga2V5LmdldFB1YmxpYygpLCB1Mik7XG4gICAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIHAuZ2V0WCgpLnVtb2QodGhpcy5uKS5jbXAocikgPT09IDA7XG4gIH1cblxuICAvLyBOT1RFOiBHcmVnIE1heHdlbGwncyB0cmljaywgaW5zcGlyZWQgYnk6XG4gIC8vIGh0dHBzOi8vZ2l0LmlvL3ZhZDNLXG5cbiAgcCA9IHRoaXMuZy5qbXVsQWRkKHUxLCBrZXkuZ2V0UHVibGljKCksIHUyKTtcbiAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBDb21wYXJlIGBwLnhgIG9mIEphY29iaWFuIHBvaW50IHdpdGggYHJgLFxuICAvLyB0aGlzIHdpbGwgZG8gYHAueCA9PSByICogcC56XjJgIGluc3RlYWQgb2YgbXVsdGlwbHlpbmcgYHAueGAgYnkgdGhlXG4gIC8vIGludmVyc2Ugb2YgYHAuel4yYFxuICByZXR1cm4gcC5lcVhUb1Aocik7XG59O1xuXG5FQy5wcm90b3R5cGUucmVjb3ZlclB1YktleSA9IGZ1bmN0aW9uKG1zZywgc2lnbmF0dXJlJDEsIGosIGVuYykge1xuICBhc3NlcnQkNSgoMyAmIGopID09PSBqLCAnVGhlIHJlY292ZXJ5IHBhcmFtIGlzIG1vcmUgdGhhbiB0d28gYml0cycpO1xuICBzaWduYXR1cmUkMSA9IG5ldyBzaWduYXR1cmUoc2lnbmF0dXJlJDEsIGVuYyk7XG5cbiAgdmFyIG4gPSB0aGlzLm47XG4gIHZhciBlID0gbmV3IEJOKG1zZyk7XG4gIHZhciByID0gc2lnbmF0dXJlJDEucjtcbiAgdmFyIHMgPSBzaWduYXR1cmUkMS5zO1xuXG4gIC8vIEEgc2V0IExTQiBzaWduaWZpZXMgdGhhdCB0aGUgeS1jb29yZGluYXRlIGlzIG9kZFxuICB2YXIgaXNZT2RkID0gaiAmIDE7XG4gIHZhciBpc1NlY29uZEtleSA9IGogPj4gMTtcbiAgaWYgKHIuY21wKHRoaXMuY3VydmUucC51bW9kKHRoaXMuY3VydmUubikpID49IDAgJiYgaXNTZWNvbmRLZXkpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBzZW5jb25kIGtleSBjYW5kaW5hdGUnKTtcblxuICAvLyAxLjEuIExldCB4ID0gciArIGpuLlxuICBpZiAoaXNTZWNvbmRLZXkpXG4gICAgciA9IHRoaXMuY3VydmUucG9pbnRGcm9tWChyLmFkZCh0aGlzLmN1cnZlLm4pLCBpc1lPZGQpO1xuICBlbHNlXG4gICAgciA9IHRoaXMuY3VydmUucG9pbnRGcm9tWChyLCBpc1lPZGQpO1xuXG4gIHZhciBySW52ID0gc2lnbmF0dXJlJDEuci5pbnZtKG4pO1xuICB2YXIgczEgPSBuLnN1YihlKS5tdWwockludikudW1vZChuKTtcbiAgdmFyIHMyID0gcy5tdWwockludikudW1vZChuKTtcblxuICAvLyAxLjYuMSBDb21wdXRlIFEgPSByXi0xIChzUiAtICBlRylcbiAgLy8gICAgICAgICAgICAgICBRID0gcl4tMSAoc1IgKyAtZUcpXG4gIHJldHVybiB0aGlzLmcubXVsQWRkKHMxLCByLCBzMik7XG59O1xuXG5FQy5wcm90b3R5cGUuZ2V0S2V5UmVjb3ZlcnlQYXJhbSA9IGZ1bmN0aW9uKGUsIHNpZ25hdHVyZSQxLCBRLCBlbmMpIHtcbiAgc2lnbmF0dXJlJDEgPSBuZXcgc2lnbmF0dXJlKHNpZ25hdHVyZSQxLCBlbmMpO1xuICBpZiAoc2lnbmF0dXJlJDEucmVjb3ZlcnlQYXJhbSAhPT0gbnVsbClcbiAgICByZXR1cm4gc2lnbmF0dXJlJDEucmVjb3ZlcnlQYXJhbTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHZhciBRcHJpbWU7XG4gICAgdHJ5IHtcbiAgICAgIFFwcmltZSA9IHRoaXMucmVjb3ZlclB1YktleShlLCBzaWduYXR1cmUkMSwgaSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKFFwcmltZS5lcShRKSlcbiAgICAgIHJldHVybiBpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgdmFsaWQgcmVjb3ZlcnkgZmFjdG9yJyk7XG59O1xuXG52YXIgZWxsaXB0aWNfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIGVsbGlwdGljID0gZXhwb3J0cztcblxuZWxsaXB0aWMudmVyc2lvbiA9IC8qUmljTW9vOmV0aGVycyoveyB2ZXJzaW9uOiBcIjYuNS40XCIgfS52ZXJzaW9uO1xuZWxsaXB0aWMudXRpbHMgPSB1dGlsc18xJDE7XG5lbGxpcHRpYy5yYW5kID0gLypSaWNNb286ZXRoZXJzOnJlcXVpcmUoYnJvcmFuZCkqLyhmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCcpOyB9KTtcbmVsbGlwdGljLmN1cnZlID0gY3VydmVfMTtcbmVsbGlwdGljLmN1cnZlcyA9IGN1cnZlc18xO1xuXG4vLyBQcm90b2NvbHNcbmVsbGlwdGljLmVjID0gZWM7XG5lbGxpcHRpYy5lZGRzYSA9IC8qUmljTW9vOmV0aGVyczpyZXF1aXJlKC4vZWxsaXB0aWMvZWRkc2EpKi8obnVsbCk7XG59KTtcblxudmFyIEVDJDEgPSBlbGxpcHRpY18xLmVjO1xuXG5leHBvcnQgeyBFQyQxIGFzIEVDIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbGxpcHRpYy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJCTiIsImhhc2giLCJjb21tb25qc0dsb2JhbCIsImdsb2JhbFRoaXMiLCJ3aW5kb3ciLCJnbG9iYWwiLCJzZWxmIiwiZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMiLCJ4IiwiX19lc01vZHVsZSIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImNyZWF0ZUNvbW1vbmpzTW9kdWxlIiwiZm4iLCJiYXNlZGlyIiwibW9kdWxlIiwicGF0aCIsImV4cG9ydHMiLCJyZXF1aXJlIiwiYmFzZSIsImNvbW1vbmpzUmVxdWlyZSIsInVuZGVmaW5lZCIsImdldERlZmF1bHRFeHBvcnRGcm9tTmFtZXNwYWNlSWZQcmVzZW50IiwibiIsImdldERlZmF1bHRFeHBvcnRGcm9tTmFtZXNwYWNlSWZOb3ROYW1lZCIsImtleXMiLCJsZW5ndGgiLCJnZXRBdWdtZW50ZWROYW1lc3BhY2UiLCJhIiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsImZvckVhY2giLCJrIiwiZCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldCIsImVudW1lcmFibGUiLCJFcnJvciIsIm1pbmltYWxpc3RpY0Fzc2VydCIsImFzc2VydCIsInZhbCIsIm1zZyIsImVxdWFsIiwiYXNzZXJ0RXF1YWwiLCJsIiwiciIsInV0aWxzXzEiLCJ1dGlscyIsInRvQXJyYXkiLCJlbmMiLCJBcnJheSIsImlzQXJyYXkiLCJzbGljZSIsInJlcyIsImkiLCJyZXBsYWNlIiwicHVzaCIsInBhcnNlSW50IiwiYyIsImNoYXJDb2RlQXQiLCJoaSIsImxvIiwiemVybzIiLCJ3b3JkIiwidG9IZXgiLCJ0b1N0cmluZyIsImVuY29kZSIsImFyciIsInV0aWxzXzEkMSIsImdldE5BRiIsIm51bSIsInciLCJiaXRzIiwibmFmIiwiTWF0aCIsIm1heCIsImJpdExlbmd0aCIsImZpbGwiLCJ3cyIsImNsb25lIiwieiIsIm1vZCIsImFuZGxuIiwiaXNPZGQiLCJpc3VibiIsIml1c2hybiIsImdldEpTRiIsImsxIiwiazIiLCJqc2YiLCJkMSIsImQyIiwibTgiLCJjbXBuIiwibTE0IiwibTI0IiwidTEiLCJ1MiIsImNhY2hlZFByb3BlcnR5Iiwib2JqIiwibmFtZSIsImNvbXB1dGVyIiwia2V5IiwicGFyc2VCeXRlcyIsImJ5dGVzIiwiaW50RnJvbUxFIiwiYXNzZXJ0JDEiLCJCYXNlQ3VydmUiLCJ0eXBlIiwiY29uZiIsInAiLCJyZWQiLCJwcmltZSIsIm1vbnQiLCJ6ZXJvIiwidG9SZWQiLCJvbmUiLCJ0d28iLCJnIiwicG9pbnRGcm9tSlNPTiIsImdSZWQiLCJfd25hZlQxIiwiX3duYWZUMiIsIl93bmFmVDMiLCJfd25hZlQ0IiwiX2JpdExlbmd0aCIsImFkanVzdENvdW50IiwiZGl2IiwicmVkTiIsIl9tYXh3ZWxsVHJpY2siLCJwb2ludCIsInZhbGlkYXRlIiwiX2ZpeGVkTmFmTXVsIiwicHJlY29tcHV0ZWQiLCJkb3VibGVzIiwiX2dldERvdWJsZXMiLCJJIiwic3RlcCIsInJlcHIiLCJqIiwibmFmVyIsImpwb2ludCIsImIiLCJtaXhlZEFkZCIsInBvaW50cyIsIm5lZyIsImFkZCIsInRvUCIsIl93bmFmTXVsIiwibmFmUG9pbnRzIiwiX2dldE5BRlBvaW50cyIsInduZCIsImFjYyIsImRibHAiLCJfd25hZk11bEFkZCIsImRlZlciLCJjb2VmZnMiLCJsZW4iLCJqYWNvYmlhblJlc3VsdCIsInduZFdpZHRoIiwiY29tYiIsInkiLCJjbXAiLCJ0b0oiLCJyZWROZWciLCJpbmRleCIsImphIiwiamIiLCJ0bXAiLCJCYXNlUG9pbnQiLCJjdXJ2ZSIsImVxIiwiZGVjb2RlUG9pbnQiLCJieXRlTGVuZ3RoIiwicG9pbnRGcm9tWCIsImVuY29kZUNvbXByZXNzZWQiLCJfZW5jb2RlIiwiY29tcGFjdCIsImdldFgiLCJnZXRZIiwiaXNFdmVuIiwiY29uY2F0IiwicHJlY29tcHV0ZSIsInBvd2VyIiwiYmV0YSIsIl9nZXRCZXRhIiwiX2hhc0RvdWJsZXMiLCJjZWlsIiwiZGJsIiwiaW5oZXJpdHNfYnJvd3NlciIsImNyZWF0ZSIsImluaGVyaXRzIiwiY3RvciIsInN1cGVyQ3RvciIsInN1cGVyXyIsImNvbnN0cnVjdG9yIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJUZW1wQ3RvciIsImFzc2VydCQyIiwiU2hvcnRDdXJ2ZSIsInRpbnYiLCJyZWRJbnZtIiwiemVyb0EiLCJmcm9tUmVkIiwidGhyZWVBIiwic3ViIiwiZW5kbyIsIl9nZXRFbmRvbW9ycGhpc20iLCJfZW5kb1duYWZUMSIsIl9lbmRvV25hZlQyIiwic2hvcnRfMSIsIm1vZG4iLCJsYW1iZGEiLCJiZXRhcyIsIl9nZXRFbmRvUm9vdHMiLCJsYW1iZGFzIiwibXVsIiwicmVkTXVsIiwiYmFzaXMiLCJtYXAiLCJ2ZWMiLCJfZ2V0RW5kb0Jhc2lzIiwibnRpbnYiLCJzIiwicmVkU3FydCIsImwxIiwicmVkQWRkIiwibDIiLCJyZWRTdWIiLCJhcHJ4U3FydCIsInVzaHJuIiwiZmxvb3IiLCJ1IiwidiIsIngxIiwieTEiLCJ4MiIsInkyIiwiYTAiLCJiMCIsImExIiwiYjEiLCJhMiIsImIyIiwicHJldlIiLCJxIiwibGVuMSIsInNxciIsImxlbjIiLCJuZWdhdGl2ZSIsIl9lbmRvU3BsaXQiLCJ2MSIsInYyIiwiYzEiLCJkaXZSb3VuZCIsImMyIiwicDEiLCJwMiIsInExIiwicTIiLCJvZGQiLCJyZWRTcXIiLCJyZWRJQWRkIiwiaW5mIiwiYXgiLCJyaHMiLCJyZWRJU3ViIiwiX2VuZG9XbmFmTXVsQWRkIiwibnBvaW50cyIsIm5jb2VmZnMiLCJzcGxpdCIsImluZWciLCJQb2ludCIsImlzUmVkIiwiZm9yY2VSZWQiLCJmcm9tSlNPTiIsInByZSIsImVuZG9NdWwiLCJ0b0pTT04iLCJKU09OIiwicGFyc2UiLCJvYmoycG9pbnQiLCJpbnNwZWN0IiwiaXNJbmZpbml0eSIsIm54IiwibnkiLCJ5czEiLCJkeWludiIsIm11bEFkZCIsImptdWxBZGQiLCJfcHJlY29tcHV0ZSIsIm5lZ2F0ZSIsIkpQb2ludCIsInpPbmUiLCJ6aW52IiwiemludjIiLCJheSIsInB6MiIsInoyIiwiczEiLCJzMiIsImgiLCJoMiIsImgzIiwibnoiLCJwb3ciLCJqeCIsImp5IiwianoiLCJqejQiLCJqeWQiLCJqeDIiLCJqeWQyIiwianlkNCIsInQxIiwidDIiLCJkbnkiLCJfemVyb0RibCIsIl90aHJlZURibCIsIl9kYmwiLCJ4eCIsInl5IiwieXl5eSIsIm0iLCJ0IiwieXl5eTgiLCJlIiwiZiIsImM4IiwiZGVsdGEiLCJnYW1tYSIsImFscGhhIiwiYmV0YTQiLCJiZXRhOCIsImdnYW1tYTgiLCJqeTIiLCJqeGQ0IiwianlkOCIsInRycGwiLCJ6eiIsIm1tIiwiZWUiLCJ5eXU0Iiwia2Jhc2UiLCJ6MyIsInB6MyIsImVxWFRvUCIsInpzIiwicngiLCJ4YyIsImlhZGQiLCJjdXJ2ZV8xIiwic2hvcnQiLCJlZHdhcmRzIiwiY3VydmVzXzEiLCJjdXJ2ZXMiLCJQcmVzZXRDdXJ2ZSIsIm9wdGlvbnMiLCJkZWZpbmVDdXJ2ZSIsInNoYTI1NiIsInNoYTM4NCIsInNoYTUxMiIsImNyYXNoIiwiSG1hY0RSQkciLCJwcmVkUmVzaXN0Iiwib3V0TGVuIiwib3V0U2l6ZSIsIm1pbkVudHJvcHkiLCJobWFjU3RyZW5ndGgiLCJfcmVzZWVkIiwicmVzZWVkSW50ZXJ2YWwiLCJLIiwiViIsImVudHJvcHkiLCJlbnRyb3B5RW5jIiwibm9uY2UiLCJub25jZUVuYyIsInBlcnMiLCJwZXJzRW5jIiwiX2luaXQiLCJobWFjRHJiZyIsImluaXQiLCJzZWVkIiwiX3VwZGF0ZSIsIl9obWFjIiwiaG1hYyIsInVwZGF0ZSIsImttYWMiLCJkaWdlc3QiLCJyZXNlZWQiLCJhZGRFbmMiLCJnZW5lcmF0ZSIsInRlbXAiLCJhc3NlcnQkMyIsIktleVBhaXIiLCJlYyIsInByaXYiLCJwdWIiLCJfaW1wb3J0UHJpdmF0ZSIsInByaXZFbmMiLCJfaW1wb3J0UHVibGljIiwicHViRW5jIiwiZnJvbVB1YmxpYyIsImZyb21Qcml2YXRlIiwiZ2V0UHVibGljIiwicmVzdWx0IiwicmVhc29uIiwiZ2V0UHJpdmF0ZSIsInVtb2QiLCJkZXJpdmUiLCJzaWduIiwidmVyaWZ5Iiwic2lnbmF0dXJlIiwiYXNzZXJ0JDQiLCJTaWduYXR1cmUiLCJfaW1wb3J0REVSIiwicmVjb3ZlcnlQYXJhbSIsIlBvc2l0aW9uIiwicGxhY2UiLCJnZXRMZW5ndGgiLCJidWYiLCJpbml0aWFsIiwib2N0ZXRMZW4iLCJvZmYiLCJybVBhZGRpbmciLCJkYXRhIiwicmxlbiIsInNsZW4iLCJjb25zdHJ1Y3RMZW5ndGgiLCJvY3RldHMiLCJsb2ciLCJMTjIiLCJ0b0RFUiIsImJhY2tIYWxmIiwicmFuZCIsImFzc2VydCQ1IiwiRUMiLCJuaCIsImtleVBhaXIiLCJrZXlGcm9tUHJpdmF0ZSIsImtleUZyb21QdWJsaWMiLCJnZW5LZXlQYWlyIiwiZHJiZyIsIm5zMiIsImlhZGRuIiwiX3RydW5jYXRlVG9OIiwidHJ1bmNPbmx5IiwiYmtleSIsIm5zMSIsIml0ZXIiLCJrcCIsImtwWCIsImludm0iLCJjYW5vbmljYWwiLCJzaWduYXR1cmUkMSIsInNpbnYiLCJyZWNvdmVyUHViS2V5IiwiaXNZT2RkIiwiaXNTZWNvbmRLZXkiLCJySW52IiwiZ2V0S2V5UmVjb3ZlcnlQYXJhbSIsIlEiLCJRcHJpbWUiLCJlbGxpcHRpY18xIiwiZWxsaXB0aWMiLCJ2ZXJzaW9uIiwiZWRkc2EiLCJFQyQxIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/signing-key/lib.esm/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/signing-key/lib.esm/index.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SigningKey: () => (/* binding */ SigningKey),\n/* harmony export */   computePublicKey: () => (/* binding */ computePublicKey),\n/* harmony export */   recoverPublicKey: () => (/* binding */ recoverPublicKey)\n/* harmony export */ });\n/* harmony import */ var _elliptic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./elliptic */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/signing-key/lib.esm/_version.js\");\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nlet _curve = null;\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new _elliptic__WEBPACK_IMPORTED_MODULE_2__.EC(\"secp256k1\");\n    }\n    return _curve;\n}\nclass SigningKey {\n    constructor(privateKey){\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"curve\", \"secp256k1\");\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"privateKey\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(privateKey));\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexDataLength)(this.privateKey) !== 32) {\n            logger.throwArgumentError(\"invalid private key\", \"privateKey\", \"[[ REDACTED ]]\");\n        }\n        const keyPair = getCurve().keyFromPrivate((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(this.privateKey));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_isSigningKey\", true);\n    }\n    _addPoint(other) {\n        const p0 = getCurve().keyFromPublic((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(this.publicKey));\n        const p1 = getCurve().keyFromPublic((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n    signDigest(digest) {\n        const keyPair = getCurve().keyFromPrivate((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(this.privateKey));\n        const digestBytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(digest);\n        if (digestBytes.length !== 32) {\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        const signature = keyPair.sign(digestBytes, {\n            canonical: true\n        });\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.splitSignature)({\n            recoveryParam: signature.recoveryParam,\n            r: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexZeroPad)(\"0x\" + signature.r.toString(16), 32),\n            s: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexZeroPad)(\"0x\" + signature.s.toString(16), 32)\n        });\n    }\n    computeSharedSecret(otherKey) {\n        const keyPair = getCurve().keyFromPrivate((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(computePublicKey(otherKey)));\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexZeroPad)(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n    static isSigningKey(value) {\n        return !!(value && value._isSigningKey);\n    }\n}\nfunction recoverPublicKey(digest, signature) {\n    const sig = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.splitSignature)(signature);\n    const rs = {\n        r: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(sig.r),\n        s: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(sig.s)\n    };\n    return \"0x\" + getCurve().recoverPubKey((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\nfunction computePublicKey(key, compressed) {\n    const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(key);\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n    } else if (bytes.length === 33) {\n        if (compressed) {\n            return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(bytes);\n        }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n    } else if (bytes.length === 65) {\n        if (!compressed) {\n            return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(bytes);\n        }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaWduaW5nLWtleS9saWIuZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWE7QUFDbUI7QUFDb0U7QUFDekM7QUFDWjtBQUNWO0FBQ3JDLE1BQU1TLFNBQVMsSUFBSUYseURBQU1BLENBQUNDLDZDQUFPQTtBQUNqQyxJQUFJRSxTQUFTO0FBQ2IsU0FBU0M7SUFDTCxJQUFJLENBQUNELFFBQVE7UUFDVEEsU0FBUyxJQUFJVix5Q0FBRUEsQ0FBQztJQUNwQjtJQUNBLE9BQU9VO0FBQ1g7QUFDTyxNQUFNRTtJQUNUQyxZQUFZQyxVQUFVLENBQUU7UUFDcEJSLHlFQUFjQSxDQUFDLElBQUksRUFBRSxTQUFTO1FBQzlCQSx5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsY0FBY0gsNkRBQU9BLENBQUNXO1FBQzNDLElBQUlaLG1FQUFhQSxDQUFDLElBQUksQ0FBQ1ksVUFBVSxNQUFNLElBQUk7WUFDdkNMLE9BQU9NLGtCQUFrQixDQUFDLHVCQUF1QixjQUFjO1FBQ25FO1FBQ0EsTUFBTUMsVUFBVUwsV0FBV00sY0FBYyxDQUFDaEIsOERBQVFBLENBQUMsSUFBSSxDQUFDYSxVQUFVO1FBQ2xFUix5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsYUFBYSxPQUFPVSxRQUFRRSxTQUFTLENBQUMsT0FBTztRQUNsRVoseUVBQWNBLENBQUMsSUFBSSxFQUFFLHVCQUF1QixPQUFPVSxRQUFRRSxTQUFTLENBQUMsTUFBTTtRQUMzRVoseUVBQWNBLENBQUMsSUFBSSxFQUFFLGlCQUFpQjtJQUMxQztJQUNBYSxVQUFVQyxLQUFLLEVBQUU7UUFDYixNQUFNQyxLQUFLVixXQUFXVyxhQUFhLENBQUNyQiw4REFBUUEsQ0FBQyxJQUFJLENBQUNzQixTQUFTO1FBQzNELE1BQU1DLEtBQUtiLFdBQVdXLGFBQWEsQ0FBQ3JCLDhEQUFRQSxDQUFDbUI7UUFDN0MsT0FBTyxPQUFPQyxHQUFHSSxHQUFHLENBQUNDLEdBQUcsQ0FBQ0YsR0FBR0MsR0FBRyxFQUFFRSxnQkFBZ0IsQ0FBQztJQUN0RDtJQUNBQyxXQUFXQyxNQUFNLEVBQUU7UUFDZixNQUFNYixVQUFVTCxXQUFXTSxjQUFjLENBQUNoQiw4REFBUUEsQ0FBQyxJQUFJLENBQUNhLFVBQVU7UUFDbEUsTUFBTWdCLGNBQWM3Qiw4REFBUUEsQ0FBQzRCO1FBQzdCLElBQUlDLFlBQVlDLE1BQU0sS0FBSyxJQUFJO1lBQzNCdEIsT0FBT00sa0JBQWtCLENBQUMscUJBQXFCLFVBQVVjO1FBQzdEO1FBQ0EsTUFBTUcsWUFBWWhCLFFBQVFpQixJQUFJLENBQUNILGFBQWE7WUFBRUksV0FBVztRQUFLO1FBQzlELE9BQU83QixvRUFBY0EsQ0FBQztZQUNsQjhCLGVBQWVILFVBQVVHLGFBQWE7WUFDdENDLEdBQUdoQyxnRUFBVUEsQ0FBQyxPQUFPNEIsVUFBVUksQ0FBQyxDQUFDQyxRQUFRLENBQUMsS0FBSztZQUMvQ0MsR0FBR2xDLGdFQUFVQSxDQUFDLE9BQU80QixVQUFVTSxDQUFDLENBQUNELFFBQVEsQ0FBQyxLQUFLO1FBQ25EO0lBQ0o7SUFDQUUsb0JBQW9CQyxRQUFRLEVBQUU7UUFDMUIsTUFBTXhCLFVBQVVMLFdBQVdNLGNBQWMsQ0FBQ2hCLDhEQUFRQSxDQUFDLElBQUksQ0FBQ2EsVUFBVTtRQUNsRSxNQUFNMkIsZUFBZTlCLFdBQVdXLGFBQWEsQ0FBQ3JCLDhEQUFRQSxDQUFDeUMsaUJBQWlCRjtRQUN4RSxPQUFPcEMsZ0VBQVVBLENBQUMsT0FBT1ksUUFBUTJCLE1BQU0sQ0FBQ0YsYUFBYXZCLFNBQVMsSUFBSW1CLFFBQVEsQ0FBQyxLQUFLO0lBQ3BGO0lBQ0EsT0FBT08sYUFBYUMsS0FBSyxFQUFFO1FBQ3ZCLE9BQU8sQ0FBQyxDQUFFQSxDQUFBQSxTQUFTQSxNQUFNQyxhQUFhO0lBQzFDO0FBQ0o7QUFDTyxTQUFTQyxpQkFBaUJsQixNQUFNLEVBQUVHLFNBQVM7SUFDOUMsTUFBTWdCLE1BQU0zQyxvRUFBY0EsQ0FBQzJCO0lBQzNCLE1BQU1pQixLQUFLO1FBQUViLEdBQUduQyw4REFBUUEsQ0FBQytDLElBQUlaLENBQUM7UUFBR0UsR0FBR3JDLDhEQUFRQSxDQUFDK0MsSUFBSVYsQ0FBQztJQUFFO0lBQ3BELE9BQU8sT0FBTzNCLFdBQVd1QyxhQUFhLENBQUNqRCw4REFBUUEsQ0FBQzRCLFNBQVNvQixJQUFJRCxJQUFJYixhQUFhLEVBQUVnQixNQUFNLENBQUMsT0FBTztBQUNsRztBQUNPLFNBQVNULGlCQUFpQlUsR0FBRyxFQUFFQyxVQUFVO0lBQzVDLE1BQU1DLFFBQVFyRCw4REFBUUEsQ0FBQ21EO0lBQ3ZCLElBQUlFLE1BQU12QixNQUFNLEtBQUssSUFBSTtRQUNyQixNQUFNd0IsYUFBYSxJQUFJM0MsV0FBVzBDO1FBQ2xDLElBQUlELFlBQVk7WUFDWixPQUFPLE9BQU8xQyxXQUFXTSxjQUFjLENBQUNxQyxPQUFPcEMsU0FBUyxDQUFDLE1BQU07UUFDbkU7UUFDQSxPQUFPcUMsV0FBV2hDLFNBQVM7SUFDL0IsT0FDSyxJQUFJK0IsTUFBTXZCLE1BQU0sS0FBSyxJQUFJO1FBQzFCLElBQUlzQixZQUFZO1lBQ1osT0FBT2xELDZEQUFPQSxDQUFDbUQ7UUFDbkI7UUFDQSxPQUFPLE9BQU8zQyxXQUFXVyxhQUFhLENBQUNnQyxPQUFPcEMsU0FBUyxDQUFDLE9BQU87SUFDbkUsT0FDSyxJQUFJb0MsTUFBTXZCLE1BQU0sS0FBSyxJQUFJO1FBQzFCLElBQUksQ0FBQ3NCLFlBQVk7WUFDYixPQUFPbEQsNkRBQU9BLENBQUNtRDtRQUNuQjtRQUNBLE9BQU8sT0FBTzNDLFdBQVdXLGFBQWEsQ0FBQ2dDLE9BQU9wQyxTQUFTLENBQUMsTUFBTTtJQUNsRTtJQUNBLE9BQU9ULE9BQU9NLGtCQUFrQixDQUFDLGlDQUFpQyxPQUFPO0FBQzdFLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2xpbWUtYmV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc2lnbmluZy1rZXkvbGliLmVzbS9pbmRleC5qcz85ZTZhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgRUMgfSBmcm9tIFwiLi9lbGxpcHRpY1wiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGhleERhdGFMZW5ndGgsIGhleGxpZnksIGhleFplcm9QYWQsIHNwbGl0U2lnbmF0dXJlIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5sZXQgX2N1cnZlID0gbnVsbDtcbmZ1bmN0aW9uIGdldEN1cnZlKCkge1xuICAgIGlmICghX2N1cnZlKSB7XG4gICAgICAgIF9jdXJ2ZSA9IG5ldyBFQyhcInNlY3AyNTZrMVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIF9jdXJ2ZTtcbn1cbmV4cG9ydCBjbGFzcyBTaWduaW5nS2V5IHtcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlS2V5KSB7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiY3VydmVcIiwgXCJzZWNwMjU2azFcIik7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJpdmF0ZUtleVwiLCBoZXhsaWZ5KHByaXZhdGVLZXkpKTtcbiAgICAgICAgaWYgKGhleERhdGFMZW5ndGgodGhpcy5wcml2YXRlS2V5KSAhPT0gMzIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHByaXZhdGUga2V5XCIsIFwicHJpdmF0ZUtleVwiLCBcIltbIFJFREFDVEVEIF1dXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleVBhaXIgPSBnZXRDdXJ2ZSgpLmtleUZyb21Qcml2YXRlKGFycmF5aWZ5KHRoaXMucHJpdmF0ZUtleSkpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInB1YmxpY0tleVwiLCBcIjB4XCIgKyBrZXlQYWlyLmdldFB1YmxpYyhmYWxzZSwgXCJoZXhcIikpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImNvbXByZXNzZWRQdWJsaWNLZXlcIiwgXCIweFwiICsga2V5UGFpci5nZXRQdWJsaWModHJ1ZSwgXCJoZXhcIikpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9pc1NpZ25pbmdLZXlcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIF9hZGRQb2ludChvdGhlcikge1xuICAgICAgICBjb25zdCBwMCA9IGdldEN1cnZlKCkua2V5RnJvbVB1YmxpYyhhcnJheWlmeSh0aGlzLnB1YmxpY0tleSkpO1xuICAgICAgICBjb25zdCBwMSA9IGdldEN1cnZlKCkua2V5RnJvbVB1YmxpYyhhcnJheWlmeShvdGhlcikpO1xuICAgICAgICByZXR1cm4gXCIweFwiICsgcDAucHViLmFkZChwMS5wdWIpLmVuY29kZUNvbXByZXNzZWQoXCJoZXhcIik7XG4gICAgfVxuICAgIHNpZ25EaWdlc3QoZGlnZXN0KSB7XG4gICAgICAgIGNvbnN0IGtleVBhaXIgPSBnZXRDdXJ2ZSgpLmtleUZyb21Qcml2YXRlKGFycmF5aWZ5KHRoaXMucHJpdmF0ZUtleSkpO1xuICAgICAgICBjb25zdCBkaWdlc3RCeXRlcyA9IGFycmF5aWZ5KGRpZ2VzdCk7XG4gICAgICAgIGlmIChkaWdlc3RCeXRlcy5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYmFkIGRpZ2VzdCBsZW5ndGhcIiwgXCJkaWdlc3RcIiwgZGlnZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBrZXlQYWlyLnNpZ24oZGlnZXN0Qnl0ZXMsIHsgY2Fub25pY2FsOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gc3BsaXRTaWduYXR1cmUoe1xuICAgICAgICAgICAgcmVjb3ZlcnlQYXJhbTogc2lnbmF0dXJlLnJlY292ZXJ5UGFyYW0sXG4gICAgICAgICAgICByOiBoZXhaZXJvUGFkKFwiMHhcIiArIHNpZ25hdHVyZS5yLnRvU3RyaW5nKDE2KSwgMzIpLFxuICAgICAgICAgICAgczogaGV4WmVyb1BhZChcIjB4XCIgKyBzaWduYXR1cmUucy50b1N0cmluZygxNiksIDMyKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbXB1dGVTaGFyZWRTZWNyZXQob3RoZXJLZXkpIHtcbiAgICAgICAgY29uc3Qga2V5UGFpciA9IGdldEN1cnZlKCkua2V5RnJvbVByaXZhdGUoYXJyYXlpZnkodGhpcy5wcml2YXRlS2V5KSk7XG4gICAgICAgIGNvbnN0IG90aGVyS2V5UGFpciA9IGdldEN1cnZlKCkua2V5RnJvbVB1YmxpYyhhcnJheWlmeShjb21wdXRlUHVibGljS2V5KG90aGVyS2V5KSkpO1xuICAgICAgICByZXR1cm4gaGV4WmVyb1BhZChcIjB4XCIgKyBrZXlQYWlyLmRlcml2ZShvdGhlcktleVBhaXIuZ2V0UHVibGljKCkpLnRvU3RyaW5nKDE2KSwgMzIpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNTaWduaW5nS2V5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNTaWduaW5nS2V5KTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleShkaWdlc3QsIHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHNpZyA9IHNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgY29uc3QgcnMgPSB7IHI6IGFycmF5aWZ5KHNpZy5yKSwgczogYXJyYXlpZnkoc2lnLnMpIH07XG4gICAgcmV0dXJuIFwiMHhcIiArIGdldEN1cnZlKCkucmVjb3ZlclB1YktleShhcnJheWlmeShkaWdlc3QpLCBycywgc2lnLnJlY292ZXJ5UGFyYW0pLmVuY29kZShcImhleFwiLCBmYWxzZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVB1YmxpY0tleShrZXksIGNvbXByZXNzZWQpIHtcbiAgICBjb25zdCBieXRlcyA9IGFycmF5aWZ5KGtleSk7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMzIpIHtcbiAgICAgICAgY29uc3Qgc2lnbmluZ0tleSA9IG5ldyBTaWduaW5nS2V5KGJ5dGVzKTtcbiAgICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjB4XCIgKyBnZXRDdXJ2ZSgpLmtleUZyb21Qcml2YXRlKGJ5dGVzKS5nZXRQdWJsaWModHJ1ZSwgXCJoZXhcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpZ25pbmdLZXkucHVibGljS2V5O1xuICAgIH1cbiAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggPT09IDMzKSB7XG4gICAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4bGlmeShieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiMHhcIiArIGdldEN1cnZlKCkua2V5RnJvbVB1YmxpYyhieXRlcykuZ2V0UHVibGljKGZhbHNlLCBcImhleFwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NSkge1xuICAgICAgICBpZiAoIWNvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCIweFwiICsgZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGJ5dGVzKS5nZXRQdWJsaWModHJ1ZSwgXCJoZXhcIik7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBwdWJsaWMgb3IgcHJpdmF0ZSBrZXlcIiwgXCJrZXlcIiwgXCJbUkVEQUNURURdXCIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIkVDIiwiYXJyYXlpZnkiLCJoZXhEYXRhTGVuZ3RoIiwiaGV4bGlmeSIsImhleFplcm9QYWQiLCJzcGxpdFNpZ25hdHVyZSIsImRlZmluZVJlYWRPbmx5IiwiTG9nZ2VyIiwidmVyc2lvbiIsImxvZ2dlciIsIl9jdXJ2ZSIsImdldEN1cnZlIiwiU2lnbmluZ0tleSIsImNvbnN0cnVjdG9yIiwicHJpdmF0ZUtleSIsInRocm93QXJndW1lbnRFcnJvciIsImtleVBhaXIiLCJrZXlGcm9tUHJpdmF0ZSIsImdldFB1YmxpYyIsIl9hZGRQb2ludCIsIm90aGVyIiwicDAiLCJrZXlGcm9tUHVibGljIiwicHVibGljS2V5IiwicDEiLCJwdWIiLCJhZGQiLCJlbmNvZGVDb21wcmVzc2VkIiwic2lnbkRpZ2VzdCIsImRpZ2VzdCIsImRpZ2VzdEJ5dGVzIiwibGVuZ3RoIiwic2lnbmF0dXJlIiwic2lnbiIsImNhbm9uaWNhbCIsInJlY292ZXJ5UGFyYW0iLCJyIiwidG9TdHJpbmciLCJzIiwiY29tcHV0ZVNoYXJlZFNlY3JldCIsIm90aGVyS2V5Iiwib3RoZXJLZXlQYWlyIiwiY29tcHV0ZVB1YmxpY0tleSIsImRlcml2ZSIsImlzU2lnbmluZ0tleSIsInZhbHVlIiwiX2lzU2lnbmluZ0tleSIsInJlY292ZXJQdWJsaWNLZXkiLCJzaWciLCJycyIsInJlY292ZXJQdWJLZXkiLCJlbmNvZGUiLCJrZXkiLCJjb21wcmVzc2VkIiwiYnl0ZXMiLCJzaWduaW5nS2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/signing-key/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib.esm/_version.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/strings/lib.esm/_version.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"strings/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zdHJpbmdzL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLFVBQVUsZ0JBQWdCLENBQ3ZDLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NsaW1lLWJldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3N0cmluZ3MvbGliLmVzbS9fdmVyc2lvbi5qcz9iM2YwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJzdHJpbmdzLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib.esm/utf8.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/strings/lib.esm/utf8.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UnicodeNormalizationForm: () => (/* binding */ UnicodeNormalizationForm),\n/* harmony export */   Utf8ErrorFuncs: () => (/* binding */ Utf8ErrorFuncs),\n/* harmony export */   Utf8ErrorReason: () => (/* binding */ Utf8ErrorReason),\n/* harmony export */   _toEscapedUtf8String: () => (/* binding */ _toEscapedUtf8String),\n/* harmony export */   _toUtf8String: () => (/* binding */ _toUtf8String),\n/* harmony export */   toUtf8Bytes: () => (/* binding */ toUtf8Bytes),\n/* harmony export */   toUtf8CodePoints: () => (/* binding */ toUtf8CodePoints),\n/* harmony export */   toUtf8String: () => (/* binding */ toUtf8String)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib.esm/_version.js\");\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n///////////////////////////////\nvar UnicodeNormalizationForm;\n(function(UnicodeNormalizationForm) {\n    UnicodeNormalizationForm[\"current\"] = \"\";\n    UnicodeNormalizationForm[\"NFC\"] = \"NFC\";\n    UnicodeNormalizationForm[\"NFD\"] = \"NFD\";\n    UnicodeNormalizationForm[\"NFKC\"] = \"NFKC\";\n    UnicodeNormalizationForm[\"NFKD\"] = \"NFKD\";\n})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));\n;\nvar Utf8ErrorReason;\n(function(Utf8ErrorReason) {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"UNEXPECTED_CONTINUE\"] = \"unexpected continuation byte\";\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"BAD_PREFIX\"] = \"bad codepoint prefix\";\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"OVERRUN\"] = \"string overrun\";\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    Utf8ErrorReason[\"MISSING_CONTINUE\"] = \"missing continuation byte\";\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    Utf8ErrorReason[\"OUT_OF_RANGE\"] = \"out of UTF-8 range\";\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    Utf8ErrorReason[\"UTF16_SURROGATE\"] = \"UTF-16 surrogate\";\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    Utf8ErrorReason[\"OVERLONG\"] = \"overlong representation\";\n})(Utf8ErrorReason || (Utf8ErrorReason = {}));\n;\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n    return logger.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, \"bytes\", bytes);\n}\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for(let o = offset + 1; o < bytes.length; o++){\n            if (bytes[o] >> 6 !== 0x02) {\n                break;\n            }\n            i++;\n        }\n        return i;\n    }\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n    // Nothing to skip\n    return 0;\n}\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n    // Put the replacement character into the output\n    output.push(0xfffd);\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n// Common error handing strategies\nconst Utf8ErrorFuncs = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes, onError) {\n    if (onError == null) {\n        onError = Utf8ErrorFuncs.error;\n    }\n    bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(bytes);\n    const result = [];\n    let i = 0;\n    // Invalid bytes are ignored\n    while(i < bytes.length){\n        const c = bytes[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n        // Remove the length prefix from the char\n        let res = c & (1 << 8 - extraLength - 1) - 1;\n        for(let j = 0; j < extraLength; j++){\n            let nextChar = bytes[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            }\n            ;\n            res = res << 6 | nextChar & 0x3f;\n            i++;\n        }\n        // See above loop for invalid continuation byte\n        if (res === null) {\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        result.push(res);\n    }\n    return result;\n}\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nfunction toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n    let result = [];\n    for(let i = 0; i < str.length; i++){\n        const c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        } else if (c < 0x800) {\n            result.push(c >> 6 | 0xc0);\n            result.push(c & 0x3f | 0x80);\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push(pair >> 18 | 0xf0);\n            result.push(pair >> 12 & 0x3f | 0x80);\n            result.push(pair >> 6 & 0x3f | 0x80);\n            result.push(pair & 0x3f | 0x80);\n        } else {\n            result.push(c >> 12 | 0xe0);\n            result.push(c >> 6 & 0x3f | 0x80);\n            result.push(c & 0x3f | 0x80);\n        }\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(result);\n}\n;\nfunction escapeChar(value) {\n    const hex = \"0000\" + value.toString(16);\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\nfunction _toEscapedUtf8String(bytes, onError) {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint)=>{\n        if (codePoint < 256) {\n            switch(codePoint){\n                case 8:\n                    return \"\\\\b\";\n                case 9:\n                    return \"\\\\t\";\n                case 10:\n                    return \"\\\\n\";\n                case 13:\n                    return \"\\\\r\";\n                case 34:\n                    return '\\\\\"';\n                case 92:\n                    return \"\\\\\\\\\";\n            }\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n        codePoint -= 0x10000;\n        return escapeChar((codePoint >> 10 & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\nfunction _toUtf8String(codePoints) {\n    return codePoints.map((codePoint)=>{\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode((codePoint >> 10 & 0x3ff) + 0xd800, (codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\");\n}\nfunction toUtf8String(bytes, onError) {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\nfunction toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n} //# sourceMappingURL=utf8.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zdHJpbmdzL2xpYi5lc20vdXRmOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFhO0FBQ21DO0FBQ0Q7QUFDVjtBQUNyQyxNQUFNRyxTQUFTLElBQUlGLHlEQUFNQSxDQUFDQyw2Q0FBT0E7QUFDakMsK0JBQStCO0FBQ3hCLElBQUlFLHlCQUF5QjtBQUNuQyxVQUFVQSx3QkFBd0I7SUFDL0JBLHdCQUF3QixDQUFDLFVBQVUsR0FBRztJQUN0Q0Esd0JBQXdCLENBQUMsTUFBTSxHQUFHO0lBQ2xDQSx3QkFBd0IsQ0FBQyxNQUFNLEdBQUc7SUFDbENBLHdCQUF3QixDQUFDLE9BQU8sR0FBRztJQUNuQ0Esd0JBQXdCLENBQUMsT0FBTyxHQUFHO0FBQ3ZDLEdBQUdBLDRCQUE2QkEsQ0FBQUEsMkJBQTJCLENBQUM7O0FBRXJELElBQUlDLGdCQUFnQjtBQUMxQixVQUFVQSxlQUFlO0lBQ3RCLHNFQUFzRTtJQUN0RSw4Q0FBOEM7SUFDOUNBLGVBQWUsQ0FBQyxzQkFBc0IsR0FBRztJQUN6QywwRUFBMEU7SUFDMUUsOENBQThDO0lBQzlDQSxlQUFlLENBQUMsYUFBYSxHQUFHO0lBQ2hDLDREQUE0RDtJQUM1RCw4Q0FBOEM7SUFDOUNBLGVBQWUsQ0FBQyxVQUFVLEdBQUc7SUFDN0IseURBQXlEO0lBQ3pELDZEQUE2RDtJQUM3REEsZUFBZSxDQUFDLG1CQUFtQixHQUFHO0lBQ3RDLHlEQUF5RDtJQUN6RCwyQ0FBMkM7SUFDM0MsbUVBQW1FO0lBQ25FQSxlQUFlLENBQUMsZUFBZSxHQUFHO0lBQ2xDLHVEQUF1RDtJQUN2RCwyQ0FBMkM7SUFDM0MsNkVBQTZFO0lBQzdFQSxlQUFlLENBQUMsa0JBQWtCLEdBQUc7SUFDckMsMkNBQTJDO0lBQzNDLDJDQUEyQztJQUMzQyxrRUFBa0U7SUFDbEVBLGVBQWUsQ0FBQyxXQUFXLEdBQUc7QUFDbEMsR0FBR0EsbUJBQW9CQSxD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QUFPO0lBQ3ZDLE9BQU9nQyxjQUFjakMsa0JBQWtCcEIsT0FBT3FCO0FBQ2xEO0FBQ08sU0FBU21DLGlCQUFpQnZCLEdBQUcsRUFBRUMsT0FBT3ZDLHlCQUF5QndDLE9BQU87SUFDekUsT0FBT2Ysa0JBQWtCWSxZQUFZQyxLQUFLQztBQUM5QyxFQUNBLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NsaW1lLWJldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3N0cmluZ3MvbGliLmVzbS91dGY4LmpzPzJjMDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBhcnJheWlmeSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IHZhciBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm07XG4oZnVuY3Rpb24gKFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybSkge1xuICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcImN1cnJlbnRcIl0gPSBcIlwiO1xuICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcIk5GQ1wiXSA9IFwiTkZDXCI7XG4gICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiTkZEXCJdID0gXCJORkRcIjtcbiAgICBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORktDXCJdID0gXCJORktDXCI7XG4gICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiTkZLRFwiXSA9IFwiTkZLRFwiO1xufSkoVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtIHx8IChVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0gPSB7fSkpO1xuO1xuZXhwb3J0IHZhciBVdGY4RXJyb3JSZWFzb247XG4oZnVuY3Rpb24gKFV0ZjhFcnJvclJlYXNvbikge1xuICAgIC8vIEEgY29udGludWF0aW9uIGJ5dGUgd2FzIHByZXNlbnQgd2hlcmUgdGhlcmUgd2FzIG5vdGhpbmcgdG8gY29udGludWVcbiAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29kZXBvaW50IGJlZ2FuIGluXG4gICAgVXRmOEVycm9yUmVhc29uW1wiVU5FWFBFQ1RFRF9DT05USU5VRVwiXSA9IFwidW5leHBlY3RlZCBjb250aW51YXRpb24gYnl0ZVwiO1xuICAgIC8vIEFuIGludmFsaWQgKG5vbi1jb250aW51YXRpb24pIGJ5dGUgdG8gc3RhcnQgYSBVVEYtOCBjb2RlcG9pbnQgd2FzIGZvdW5kXG4gICAgLy8gLSBvZmZzZXQgPSB0aGUgaW5kZXggdGhlIGNvZGVwb2ludCBiZWdhbiBpblxuICAgIFV0ZjhFcnJvclJlYXNvbltcIkJBRF9QUkVGSVhcIl0gPSBcImJhZCBjb2RlcG9pbnQgcHJlZml4XCI7XG4gICAgLy8gVGhlIHN0cmluZyBpcyB0b28gc2hvcnQgdG8gcHJvY2VzcyB0aGUgZXhwZWN0ZWQgY29kZXBvaW50XG4gICAgLy8gLSBvZmZzZXQgPSB0aGUgaW5kZXggdGhlIGNvZGVwb2ludCBiZWdhbiBpblxuICAgIFV0ZjhFcnJvclJlYXNvbltcIk9WRVJSVU5cIl0gPSBcInN0cmluZyBvdmVycnVuXCI7XG4gICAgLy8gQSBtaXNzaW5nIGNvbnRpbnVhdGlvbiBieXRlIHdhcyBleHBlY3RlZCBidXQgbm90IGZvdW5kXG4gICAgLy8gLSBvZmZzZXQgPSB0aGUgaW5kZXggdGhlIGNvbnRpbnVhdGlvbiBieXRlIHdhcyBleHBlY3RlZCBhdFxuICAgIFV0ZjhFcnJvclJlYXNvbltcIk1JU1NJTkdfQ09OVElOVUVcIl0gPSBcIm1pc3NpbmcgY29udGludWF0aW9uIGJ5dGVcIjtcbiAgICAvLyBUaGUgY29tcHV0ZWQgY29kZSBwb2ludCBpcyBvdXRzaWRlIHRoZSByYW5nZSBmb3IgVVRGLThcbiAgICAvLyAtIG9mZnNldCAgICAgICA9IHN0YXJ0IG9mIHRoaXMgY29kZXBvaW50XG4gICAgLy8gLSBiYWRDb2RlcG9pbnQgPSB0aGUgY29tcHV0ZWQgY29kZXBvaW50OyBvdXRzaWRlIHRoZSBVVEYtOCByYW5nZVxuICAgIFV0ZjhFcnJvclJlYXNvbltcIk9VVF9PRl9SQU5HRVwiXSA9IFwib3V0IG9mIFVURi04IHJhbmdlXCI7XG4gICAgLy8gVVRGLTggc3RyaW5ncyBtYXkgbm90IGNvbnRhaW4gVVRGLTE2IHN1cnJvZ2F0ZSBwYWlyc1xuICAgIC8vIC0gb2Zmc2V0ICAgICAgID0gc3RhcnQgb2YgdGhpcyBjb2RlcG9pbnRcbiAgICAvLyAtIGJhZENvZGVwb2ludCA9IHRoZSBjb21wdXRlZCBjb2RlcG9pbnQ7IGluc2lkZSB0aGUgVVRGLTE2IHN1cnJvZ2F0ZSByYW5nZVxuICAgIFV0ZjhFcnJvclJlYXNvbltcIlVURjE2X1NVUlJPR0FURVwiXSA9IFwiVVRGLTE2IHN1cnJvZ2F0ZVwiO1xuICAgIC8vIFRoZSBzdHJpbmcgaXMgYW4gb3ZlcmxvbmcgcmVwcmVzZW50YXRpb25cbiAgICAvLyAtIG9mZnNldCAgICAgICA9IHN0YXJ0IG9mIHRoaXMgY29kZXBvaW50XG4gICAgLy8gLSBiYWRDb2RlcG9pbnQgPSB0aGUgY29tcHV0ZWQgY29kZXBvaW50OyBhbHJlYWR5IGJvdW5kcyBjaGVja2VkXG4gICAgVXRmOEVycm9yUmVhc29uW1wiT1ZFUkxPTkdcIl0gPSBcIm92ZXJsb25nIHJlcHJlc2VudGF0aW9uXCI7XG59KShVdGY4RXJyb3JSZWFzb24gfHwgKFV0ZjhFcnJvclJlYXNvbiA9IHt9KSk7XG47XG5mdW5jdGlvbiBlcnJvckZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIGNvZGVwb2ludCBhdCBvZmZzZXQgJHtvZmZzZXR9OyAke3JlYXNvbn1gLCBcImJ5dGVzXCIsIGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIGlnbm9yZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIGludmFsaWQgcHJlZml4IChpbmNsdWRpbmcgc3RyYXkgY29udGludWF0aW9uKSwgc2tpcCBhbnkgYWRkaXRpb25hbCBjb250aW51YXRpb24gYnl0ZXNcbiAgICBpZiAocmVhc29uID09PSBVdGY4RXJyb3JSZWFzb24uQkFEX1BSRUZJWCB8fCByZWFzb24gPT09IFV0ZjhFcnJvclJlYXNvbi5VTkVYUEVDVEVEX0NPTlRJTlVFKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgbyA9IG9mZnNldCArIDE7IG8gPCBieXRlcy5sZW5ndGg7IG8rKykge1xuICAgICAgICAgICAgaWYgKGJ5dGVzW29dID4+IDYgIT09IDB4MDIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgLy8gVGhpcyBieXRlIHJ1bnMgdXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHNvIGp1c3QganVtcCB0byB0aGUgZW5kXG4gICAgLy8gKGJ1dCB0aGUgZmlyc3QgYnl0ZSB3YXMgcmVhZCBhbHJlYWR5IHJlYWQgYW5kIHRoZXJlZm9yZSBza2lwcGVkKVxuICAgIGlmIChyZWFzb24gPT09IFV0ZjhFcnJvclJlYXNvbi5PVkVSUlVOKSB7XG4gICAgICAgIHJldHVybiBieXRlcy5sZW5ndGggLSBvZmZzZXQgLSAxO1xuICAgIH1cbiAgICAvLyBOb3RoaW5nIHRvIHNraXBcbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpIHtcbiAgICAvLyBPdmVybG9uZyByZXByZXNlbnRhdGlvbnMgYXJlIG90aGVyd2lzZSBcInZhbGlkXCIgY29kZSBwb2ludHM7IGp1c3Qgbm9uLWRlaXN0aW5ndGlzaGVkXG4gICAgaWYgKHJlYXNvbiA9PT0gVXRmOEVycm9yUmVhc29uLk9WRVJMT05HKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKGJhZENvZGVwb2ludCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvLyBQdXQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpbnRvIHRoZSBvdXRwdXRcbiAgICBvdXRwdXQucHVzaCgweGZmZmQpO1xuICAgIC8vIE90aGVyd2lzZSwgcHJvY2VzcyBhcyBpZiBpZ25vcmluZyBlcnJvcnNcbiAgICByZXR1cm4gaWdub3JlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KTtcbn1cbi8vIENvbW1vbiBlcnJvciBoYW5kaW5nIHN0cmF0ZWdpZXNcbmV4cG9ydCBjb25zdCBVdGY4RXJyb3JGdW5jcyA9IE9iamVjdC5mcmVlemUoe1xuICAgIGVycm9yOiBlcnJvckZ1bmMsXG4gICAgaWdub3JlOiBpZ25vcmVGdW5jLFxuICAgIHJlcGxhY2U6IHJlcGxhY2VGdW5jXG59KTtcbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTMzNTY0OTMvZGVjb2RlLXV0Zi04LXdpdGgtamF2YXNjcmlwdCMxMzY5MTQ5OVxuZnVuY3Rpb24gZ2V0VXRmOENvZGVQb2ludHMoYnl0ZXMsIG9uRXJyb3IpIHtcbiAgICBpZiAob25FcnJvciA9PSBudWxsKSB7XG4gICAgICAgIG9uRXJyb3IgPSBVdGY4RXJyb3JGdW5jcy5lcnJvcjtcbiAgICB9XG4gICAgYnl0ZXMgPSBhcnJheWlmeShieXRlcyk7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIC8vIEludmFsaWQgYnl0ZXMgYXJlIGlnbm9yZWRcbiAgICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjID0gYnl0ZXNbaSsrXTtcbiAgICAgICAgLy8gMHh4eCB4eHh4XG4gICAgICAgIGlmIChjID4+IDcgPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlieXRlOyBob3cgbWFueSBieXRlcyBsZWZ0IGZvciB0aGlzIGNoYXJhY3Rlcj9cbiAgICAgICAgbGV0IGV4dHJhTGVuZ3RoID0gbnVsbDtcbiAgICAgICAgbGV0IG92ZXJsb25nTWFzayA9IG51bGw7XG4gICAgICAgIC8vIDExMHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgaWYgKChjICYgMHhlMCkgPT09IDB4YzApIHtcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMTtcbiAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4N2Y7XG4gICAgICAgICAgICAvLyAxMTEwIHh4eHggMTB4eCB4eHh4IDEweHggeHh4eFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMjtcbiAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4N2ZmO1xuICAgICAgICAgICAgLy8gMTExMSAweHh4IDEweHggeHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGY4KSA9PT0gMHhmMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAzO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHhmZmZmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKChjICYgMHhjMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLlVORVhQRUNURURfQ09OVElOVUUsIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uQkFEX1BSRUZJWCwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gd2UgaGF2ZSBlbm91Z2ggYnl0ZXMgaW4gb3VyIGRhdGE/XG4gICAgICAgIGlmIChpIC0gMSArIGV4dHJhTGVuZ3RoID49IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5PVkVSUlVOLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIGxlbmd0aCBwcmVmaXggZnJvbSB0aGUgY2hhclxuICAgICAgICBsZXQgcmVzID0gYyAmICgoMSA8PCAoOCAtIGV4dHJhTGVuZ3RoIC0gMSkpIC0gMSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZXh0cmFMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IG5leHRDaGFyID0gYnl0ZXNbaV07XG4gICAgICAgICAgICAvLyBJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXG4gICAgICAgICAgICBpZiAoKG5leHRDaGFyICYgMHhjMCkgIT0gMHg4MCkge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uTUlTU0lOR19DT05USU5VRSwgaSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmVzID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHJlcyA9IChyZXMgPDwgNikgfCAobmV4dENoYXIgJiAweDNmKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWUgYWJvdmUgbG9vcCBmb3IgaW52YWxpZCBjb250aW51YXRpb24gYnl0ZVxuICAgICAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXhpbXVtIGNvZGUgcG9pbnRcbiAgICAgICAgaWYgKHJlcyA+IDB4MTBmZmZmKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLk9VVF9PRl9SQU5HRSwgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2VydmVkIGZvciBVVEYtMTYgc3Vycm9nYXRlIGhhbHZlc1xuICAgICAgICBpZiAocmVzID49IDB4ZDgwMCAmJiByZXMgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLlVURjE2X1NVUlJPR0FURSwgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciBvdmVybG9uZyBzZXF1ZW5jZXMgKG1vcmUgYnl0ZXMgdGhhbiBuZWVkZWQpXG4gICAgICAgIGlmIChyZXMgPD0gb3ZlcmxvbmdNYXNrKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLk9WRVJMT05HLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2gocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTg3Mjk0MDUvaG93LXRvLWNvbnZlcnQtdXRmOC1zdHJpbmctdG8tYnl0ZS1hcnJheVxuZXhwb3J0IGZ1bmN0aW9uIHRvVXRmOEJ5dGVzKHN0ciwgZm9ybSA9IFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5jdXJyZW50KSB7XG4gICAgaWYgKGZvcm0gIT0gVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLmN1cnJlbnQpIHtcbiAgICAgICAgbG9nZ2VyLmNoZWNrTm9ybWFsaXplKCk7XG4gICAgICAgIHN0ciA9IHN0ci5ub3JtYWxpemUoZm9ybSk7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyA+PiA2KSB8IDB4YzApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmYzAwKSA9PSAweGQ4MDApIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnN0IGMyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoaSA+PSBzdHIubGVuZ3RoIHx8IChjMiAmIDB4ZmMwMCkgIT09IDB4ZGMwMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdXRmLTggc3RyaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIFBhaXJcbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSAweDEwMDAwICsgKChjICYgMHgwM2ZmKSA8PCAxMCkgKyAoYzIgJiAweDAzZmYpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKHBhaXIgPj4gMTgpIHwgMHhmMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoKHBhaXIgPj4gMTIpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgocGFpciA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgocGFpciAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyA+PiAxMikgfCAweGUwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgoYyA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5aWZ5KHJlc3VsdCk7XG59XG47XG5mdW5jdGlvbiBlc2NhcGVDaGFyKHZhbHVlKSB7XG4gICAgY29uc3QgaGV4ID0gKFwiMDAwMFwiICsgdmFsdWUudG9TdHJpbmcoMTYpKTtcbiAgICByZXR1cm4gXCJcXFxcdVwiICsgaGV4LnN1YnN0cmluZyhoZXgubGVuZ3RoIC0gNCk7XG59XG5leHBvcnQgZnVuY3Rpb24gX3RvRXNjYXBlZFV0ZjhTdHJpbmcoYnl0ZXMsIG9uRXJyb3IpIHtcbiAgICByZXR1cm4gJ1wiJyArIGdldFV0ZjhDb2RlUG9pbnRzKGJ5dGVzLCBvbkVycm9yKS5tYXAoKGNvZGVQb2ludCkgPT4ge1xuICAgICAgICBpZiAoY29kZVBvaW50IDwgMjU2KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNvZGVQb2ludCkge1xuICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFwiXFxcXGJcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDk6IHJldHVybiBcIlxcXFx0XCI7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFwiXFxcXG5cIjtcbiAgICAgICAgICAgICAgICBjYXNlIDEzOiByZXR1cm4gXCJcXFxcclwiO1xuICAgICAgICAgICAgICAgIGNhc2UgMzQ6IHJldHVybiBcIlxcXFxcXFwiXCI7XG4gICAgICAgICAgICAgICAgY2FzZSA5MjogcmV0dXJuIFwiXFxcXFxcXFxcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPj0gMzIgJiYgY29kZVBvaW50IDwgMTI3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4ZmZmZikge1xuICAgICAgICAgICAgcmV0dXJuIGVzY2FwZUNoYXIoY29kZVBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcbiAgICAgICAgcmV0dXJuIGVzY2FwZUNoYXIoKChjb2RlUG9pbnQgPj4gMTApICYgMHgzZmYpICsgMHhkODAwKSArIGVzY2FwZUNoYXIoKGNvZGVQb2ludCAmIDB4M2ZmKSArIDB4ZGMwMCk7XG4gICAgfSkuam9pbihcIlwiKSArICdcIic7XG59XG5leHBvcnQgZnVuY3Rpb24gX3RvVXRmOFN0cmluZyhjb2RlUG9pbnRzKSB7XG4gICAgcmV0dXJuIGNvZGVQb2ludHMubWFwKChjb2RlUG9pbnQpID0+IHtcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweGZmZmYpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoKGNvZGVQb2ludCA+PiAxMCkgJiAweDNmZikgKyAweGQ4MDApLCAoKGNvZGVQb2ludCAmIDB4M2ZmKSArIDB4ZGMwMCkpO1xuICAgIH0pLmpvaW4oXCJcIik7XG59XG5leHBvcnQgZnVuY3Rpb24gdG9VdGY4U3RyaW5nKGJ5dGVzLCBvbkVycm9yKSB7XG4gICAgcmV0dXJuIF90b1V0ZjhTdHJpbmcoZ2V0VXRmOENvZGVQb2ludHMoYnl0ZXMsIG9uRXJyb3IpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b1V0ZjhDb2RlUG9pbnRzKHN0ciwgZm9ybSA9IFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5jdXJyZW50KSB7XG4gICAgcmV0dXJuIGdldFV0ZjhDb2RlUG9pbnRzKHRvVXRmOEJ5dGVzKHN0ciwgZm9ybSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRmOC5qcy5tYXAiXSwibmFtZXMiOlsiYXJyYXlpZnkiLCJMb2dnZXIiLCJ2ZXJzaW9uIiwibG9nZ2VyIiwiVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtIiwiVXRmOEVycm9yUmVhc29uIiwiZXJyb3JGdW5jIiwicmVhc29uIiwib2Zmc2V0IiwiYnl0ZXMiLCJvdXRwdXQiLCJiYWRDb2RlcG9pbnQiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJpZ25vcmVGdW5jIiwiQkFEX1BSRUZJWCIsIlVORVhQRUNURURfQ09OVElOVUUiLCJpIiwibyIsImxlbmd0aCIsIk9WRVJSVU4iLCJyZXBsYWNlRnVuYyIsIk9WRVJMT05HIiwicHVzaCIsIlV0ZjhFcnJvckZ1bmNzIiwiT2JqZWN0IiwiZnJlZXplIiwiZXJyb3IiLCJpZ25vcmUiLCJyZXBsYWNlIiwiZ2V0VXRmOENvZGVQb2ludHMiLCJvbkVycm9yIiwicmVzdWx0IiwiYyIsImV4dHJhTGVuZ3RoIiwib3ZlcmxvbmdNYXNrIiwicmVzIiwiaiIsIm5leHRDaGFyIiwiTUlTU0lOR19DT05USU5VRSIsIk9VVF9PRl9SQU5HRSIsIlVURjE2X1NVUlJPR0FURSIsInRvVXRmOEJ5dGVzIiwic3RyIiwiZm9ybSIsImN1cnJlbnQiLCJjaGVja05vcm1hbGl6ZSIsIm5vcm1hbGl6ZSIsImNoYXJDb2RlQXQiLCJjMiIsIkVycm9yIiwicGFpciIsImVzY2FwZUNoYXIiLCJ2YWx1ZSIsImhleCIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwiX3RvRXNjYXBlZFV0ZjhTdHJpbmciLCJtYXAiLCJjb2RlUG9pbnQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJqb2luIiwiX3RvVXRmOFN0cmluZyIsImNvZGVQb2ludHMiLCJ0b1V0ZjhTdHJpbmciLCJ0b1V0ZjhDb2RlUG9pbnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib.esm/utf8.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/transactions/lib.esm/_version.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/transactions/lib.esm/_version.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"transactions/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC90cmFuc2FjdGlvbnMvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsVUFBVSxxQkFBcUIsQ0FDNUMsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2xpbWUtYmV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zL2xpYi5lc20vX3ZlcnNpb24uanM/YjBiMCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwidHJhbnNhY3Rpb25zLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/transactions/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/transactions/lib.esm/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/transactions/lib.esm/index.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TransactionTypes: () => (/* binding */ TransactionTypes),\n/* harmony export */   accessListify: () => (/* binding */ accessListify),\n/* harmony export */   computeAddress: () => (/* binding */ computeAddress),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   recoverAddress: () => (/* binding */ recoverAddress),\n/* harmony export */   serialize: () => (/* binding */ serialize)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/constants */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib.esm/bignumbers.js\");\n/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/keccak256/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/rlp */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/rlp/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/signing-key */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/signing-key/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/transactions/lib.esm/_version.js\");\n\n\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nvar TransactionTypes;\n(function(TransactionTypes) {\n    TransactionTypes[TransactionTypes[\"legacy\"] = 0] = \"legacy\";\n    TransactionTypes[TransactionTypes[\"eip2930\"] = 1] = \"eip2930\";\n    TransactionTypes[TransactionTypes[\"eip1559\"] = 2] = \"eip1559\";\n})(TransactionTypes || (TransactionTypes = {}));\n;\n///////////////////////////////\nfunction handleAddress(value) {\n    if (value === \"0x\") {\n        return null;\n    }\n    return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(value);\n}\nfunction handleNumber(value) {\n    if (value === \"0x\") {\n        return _ethersproject_constants__WEBPACK_IMPORTED_MODULE_3__.Zero;\n    }\n    return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value);\n}\n// Legacy Transaction Fields\nconst transactionFields = [\n    {\n        name: \"nonce\",\n        maxLength: 32,\n        numeric: true\n    },\n    {\n        name: \"gasPrice\",\n        maxLength: 32,\n        numeric: true\n    },\n    {\n        name: \"gasLimit\",\n        maxLength: 32,\n        numeric: true\n    },\n    {\n        name: \"to\",\n        length: 20\n    },\n    {\n        name: \"value\",\n        maxLength: 32,\n        numeric: true\n    },\n    {\n        name: \"data\"\n    }\n];\nconst allowedTransactionKeys = {\n    chainId: true,\n    data: true,\n    gasLimit: true,\n    gasPrice: true,\n    nonce: true,\n    to: true,\n    type: true,\n    value: true\n};\nfunction computeAddress(key) {\n    const publicKey = (0,_ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_5__.computePublicKey)(key);\n    return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexDataSlice)((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexDataSlice)(publicKey, 1)), 12));\n}\nfunction recoverAddress(digest, signature) {\n    return computeAddress((0,_ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_5__.recoverPublicKey)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(digest), signature));\n}\nfunction formatNumber(value, name) {\n    const result = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value).toHexString());\n    if (result.length > 32) {\n        logger.throwArgumentError(\"invalid length for \" + name, \"transaction:\" + name, value);\n    }\n    return result;\n}\nfunction accessSetify(addr, storageKeys) {\n    return {\n        address: (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(addr),\n        storageKeys: (storageKeys || []).map((storageKey, index)=>{\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexDataLength)(storageKey) !== 32) {\n                logger.throwArgumentError(\"invalid access list storageKey\", `accessList[${addr}:${index}]`, storageKey);\n            }\n            return storageKey.toLowerCase();\n        })\n    };\n}\nfunction accessListify(value) {\n    if (Array.isArray(value)) {\n        return value.map((set, index)=>{\n            if (Array.isArray(set)) {\n                if (set.length > 2) {\n                    logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", `value[${index}]`, set);\n                }\n                return accessSetify(set[0], set[1]);\n            }\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n    const result = Object.keys(value).map((addr)=>{\n        const storageKeys = value[addr].reduce((accum, storageKey)=>{\n            accum[storageKey] = true;\n            return accum;\n        }, {});\n        return accessSetify(addr, Object.keys(storageKeys).sort());\n    });\n    result.sort((a, b)=>a.address.localeCompare(b.address));\n    return result;\n}\nfunction formatAccessList(value) {\n    return accessListify(value).map((set)=>[\n            set.address,\n            set.storageKeys\n        ]);\n}\nfunction _serializeEip1559(transaction, signature) {\n    // If there is an explicit gasPrice, make sure it matches the\n    // EIP-1559 fees; otherwise they may not understand what they\n    // think they are setting in terms of fee.\n    if (transaction.gasPrice != null) {\n        const gasPrice = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction.gasPrice);\n        const maxFeePerGas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction.maxFeePerGas || 0);\n        if (!gasPrice.eq(maxFeePerGas)) {\n            logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n                gasPrice,\n                maxFeePerGas\n            });\n        }\n    }\n    const fields = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        transaction.to != null ? (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(transaction.to) : \"0x\",\n        formatNumber(transaction.value || 0, \"value\"),\n        transaction.data || \"0x\",\n        formatAccessList(transaction.accessList || [])\n    ];\n    if (signature) {\n        const sig = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.splitSignature)(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(sig.r));\n        fields.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(sig.s));\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexConcat)([\n        \"0x02\",\n        _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.encode(fields)\n    ]);\n}\nfunction _serializeEip2930(transaction, signature) {\n    const fields = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.gasPrice || 0, \"gasPrice\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        transaction.to != null ? (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(transaction.to) : \"0x\",\n        formatNumber(transaction.value || 0, \"value\"),\n        transaction.data || \"0x\",\n        formatAccessList(transaction.accessList || [])\n    ];\n    if (signature) {\n        const sig = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.splitSignature)(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(sig.r));\n        fields.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(sig.s));\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexConcat)([\n        \"0x01\",\n        _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.encode(fields)\n    ]);\n}\n// Legacy Transactions and EIP-155\nfunction _serialize(transaction, signature) {\n    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__.checkProperties)(transaction, allowedTransactionKeys);\n    const raw = [];\n    transactionFields.forEach(function(fieldInfo) {\n        let value = transaction[fieldInfo.name] || [];\n        const options = {};\n        if (fieldInfo.numeric) {\n            options.hexPad = \"left\";\n        }\n        value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(value, options));\n        // Fixed-width field\n        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n            logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, \"transaction:\" + fieldInfo.name, value);\n        }\n        // Variable-width (with a maximum)\n        if (fieldInfo.maxLength) {\n            value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(value);\n            if (value.length > fieldInfo.maxLength) {\n                logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, \"transaction:\" + fieldInfo.name, value);\n            }\n        }\n        raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(value));\n    });\n    let chainId = 0;\n    if (transaction.chainId != null) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = transaction.chainId;\n        if (typeof chainId !== \"number\") {\n            logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n        }\n    } else if (signature && !(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.isBytesLike)(signature) && signature.v > 28) {\n        // No chainId provided, but the signature is signing with EIP-155; derive chainId\n        chainId = Math.floor((signature.v - 35) / 2);\n    }\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== 0) {\n        raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(chainId)); // @TODO: hexValue?\n        raw.push(\"0x\");\n        raw.push(\"0x\");\n    }\n    // Requesting an unsigned transaction\n    if (!signature) {\n        return _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.encode(raw);\n    }\n    // The splitSignature will ensure the transaction has a recoveryParam in the\n    // case that the signTransaction function only adds a v.\n    const sig = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.splitSignature)(signature);\n    // We pushed a chainId and null r, s on for hashing only; remove those\n    let v = 27 + sig.recoveryParam;\n    if (chainId !== 0) {\n        raw.pop();\n        raw.pop();\n        raw.pop();\n        v += chainId * 2 + 8;\n        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n        if (sig.v > 28 && sig.v !== v) {\n            logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n        }\n    } else if (sig.v !== v) {\n        logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n    raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(v));\n    raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(sig.r)));\n    raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(sig.s)));\n    return _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.encode(raw);\n}\nfunction serialize(transaction, signature) {\n    // Legacy and EIP-155 Transactions\n    if (transaction.type == null || transaction.type === 0) {\n        if (transaction.accessList != null) {\n            logger.throwArgumentError(\"untyped transactions do not support accessList; include type: 1\", \"transaction\", transaction);\n        }\n        return _serialize(transaction, signature);\n    }\n    // Typed Transactions (EIP-2718)\n    switch(transaction.type){\n        case 1:\n            return _serializeEip2930(transaction, signature);\n        case 2:\n            return _serializeEip1559(transaction, signature);\n        default:\n            break;\n    }\n    return logger.throwError(`unsupported transaction type: ${transaction.type}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"serializeTransaction\",\n        transactionType: transaction.type\n    });\n}\nfunction _parseEipSignature(tx, fields, serialize) {\n    try {\n        const recid = handleNumber(fields[0]).toNumber();\n        if (recid !== 0 && recid !== 1) {\n            throw new Error(\"bad recid\");\n        }\n        tx.v = recid;\n    } catch (error) {\n        logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n    }\n    tx.r = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexZeroPad)(fields[1], 32);\n    tx.s = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexZeroPad)(fields[2], 32);\n    try {\n        const digest = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)(serialize(tx));\n        tx.from = recoverAddress(digest, {\n            r: tx.r,\n            s: tx.s,\n            recoveryParam: tx.v\n        });\n    } catch (error) {}\n}\nfunction _parseEip1559(payload) {\n    const transaction = _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.decode(payload.slice(1));\n    if (transaction.length !== 9 && transaction.length !== 12) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 2\", \"payload\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(payload));\n    }\n    const maxPriorityFeePerGas = handleNumber(transaction[2]);\n    const maxFeePerGas = handleNumber(transaction[3]);\n    const tx = {\n        type: 2,\n        chainId: handleNumber(transaction[0]).toNumber(),\n        nonce: handleNumber(transaction[1]).toNumber(),\n        maxPriorityFeePerGas: maxPriorityFeePerGas,\n        maxFeePerGas: maxFeePerGas,\n        gasPrice: null,\n        gasLimit: handleNumber(transaction[4]),\n        to: handleAddress(transaction[5]),\n        value: handleNumber(transaction[6]),\n        data: transaction[7],\n        accessList: accessListify(transaction[8])\n    };\n    // Unsigned EIP-1559 Transaction\n    if (transaction.length === 9) {\n        return tx;\n    }\n    tx.hash = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)(payload);\n    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);\n    return tx;\n}\nfunction _parseEip2930(payload) {\n    const transaction = _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.decode(payload.slice(1));\n    if (transaction.length !== 8 && transaction.length !== 11) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(payload));\n    }\n    const tx = {\n        type: 1,\n        chainId: handleNumber(transaction[0]).toNumber(),\n        nonce: handleNumber(transaction[1]).toNumber(),\n        gasPrice: handleNumber(transaction[2]),\n        gasLimit: handleNumber(transaction[3]),\n        to: handleAddress(transaction[4]),\n        value: handleNumber(transaction[5]),\n        data: transaction[6],\n        accessList: accessListify(transaction[7])\n    };\n    // Unsigned EIP-2930 Transaction\n    if (transaction.length === 8) {\n        return tx;\n    }\n    tx.hash = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)(payload);\n    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);\n    return tx;\n}\n// Legacy Transactions and EIP-155\nfunction _parse(rawTransaction) {\n    const transaction = _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.decode(rawTransaction);\n    if (transaction.length !== 9 && transaction.length !== 6) {\n        logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n    }\n    const tx = {\n        nonce: handleNumber(transaction[0]).toNumber(),\n        gasPrice: handleNumber(transaction[1]),\n        gasLimit: handleNumber(transaction[2]),\n        to: handleAddress(transaction[3]),\n        value: handleNumber(transaction[4]),\n        data: transaction[5],\n        chainId: 0\n    };\n    // Legacy unsigned transaction\n    if (transaction.length === 6) {\n        return tx;\n    }\n    try {\n        tx.v = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction[6]).toNumber();\n    } catch (error) {\n        // @TODO: What makes snese to do? The v is too big\n        return tx;\n    }\n    tx.r = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexZeroPad)(transaction[7], 32);\n    tx.s = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexZeroPad)(transaction[8], 32);\n    if (_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(tx.r).isZero() && _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(tx.s).isZero()) {\n        // EIP-155 unsigned transaction\n        tx.chainId = tx.v;\n        tx.v = 0;\n    } else {\n        // Signed Transaction\n        tx.chainId = Math.floor((tx.v - 35) / 2);\n        if (tx.chainId < 0) {\n            tx.chainId = 0;\n        }\n        let recoveryParam = tx.v - 27;\n        const raw = transaction.slice(0, 6);\n        if (tx.chainId !== 0) {\n            raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(tx.chainId));\n            raw.push(\"0x\");\n            raw.push(\"0x\");\n            recoveryParam -= tx.chainId * 2 + 8;\n        }\n        const digest = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)(_ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.encode(raw));\n        try {\n            tx.from = recoverAddress(digest, {\n                r: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(tx.r),\n                s: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(tx.s),\n                recoveryParam: recoveryParam\n            });\n        } catch (error) {}\n        tx.hash = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)(rawTransaction);\n    }\n    tx.type = null;\n    return tx;\n}\nfunction parse(rawTransaction) {\n    const payload = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(rawTransaction);\n    // Legacy and EIP-155 Transactions\n    if (payload[0] > 0x7f) {\n        return _parse(payload);\n    }\n    // Typed Transaction (EIP-2718)\n    switch(payload[0]){\n        case 1:\n            return _parseEip2930(payload);\n        case 2:\n            return _parseEip1559(payload);\n        default:\n            break;\n    }\n    return logger.throwError(`unsupported transaction type: ${payload[0]}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"parseTransaction\",\n        transactionType: payload[0]\n    });\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC90cmFuc2FjdGlvbnMvbGliLmVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWE7QUFDdUM7QUFDQztBQUNrRztBQUN2RztBQUNLO0FBQ087QUFDbEI7QUFDc0M7QUFDakM7QUFDVjtBQUNyQyxNQUFNbUIsU0FBUyxJQUFJRix5REFBTUEsQ0FBQ0MsNkNBQU9BO0FBQzFCLElBQUlFLGlCQUFpQjtBQUMzQixVQUFVQSxnQkFBZ0I7SUFDdkJBLGdCQUFnQixDQUFDQSxnQkFBZ0IsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0lBQ25EQSxnQkFBZ0IsQ0FBQ0EsZ0JBQWdCLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUNwREEsZ0JBQWdCLENBQUNBLGdCQUFnQixDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7QUFDeEQsR0FBR0Esb0JBQXFCQSxDQUFBQSxtQkFBbUIsQ0FBQzs7QUFFNUMsK0JBQStCO0FBQy9CLFNBQVNDLGNBQWNDLEtBQUs7SUFDeEIsSUFBSUEsVUFBVSxNQUFNO1FBQ2hCLE9BQU87SUFDWDtJQUNBLE9BQU90QixrRUFBVUEsQ0FBQ3NCO0FBQ3RCO0FBQ0EsU0FBU0MsYUFBYUQsS0FBSztJQUN2QixJQUFJQSxVQUFVLE1BQU07UUFDaEIsT0FBT1gsMERBQUlBO0lBQ2Y7SUFDQSxPQUFPViwrREFBU0EsQ0FBQ3VCLElBQUksQ0FBQ0Y7QUFDMUI7QUFDQSw0QkFBNEI7QUFDNUIsTUFBTUcsb0JBQW9CO0lBQ3RCO1FBQUVDLE1BQU07UUFBU0MsV0FBVztRQUFJQyxTQUFTO0lBQUs7SUFDOUM7UUFBRUYsTUFBTTtRQUFZQyxXQUFXO1FBQUlDLFNBQVM7SUFBSztJQUNqRDtRQUFFRixNQUFNO1FBQVlDLFdBQVc7UUFBSUMsU0FBUztJQUFLO0lBQ2pEO1FBQUVGLE1BQU07UUFBTUcsUUFBUTtJQUFHO0lBQ3pCO1FBQUVI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d2VicGFjazovL3NsaW1lLWJldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3RyYW5zYWN0aW9ucy9saWIuZXNtL2luZGV4LmpzPzdlMzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2FkZHJlc3NcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGFycmF5aWZ5LCBoZXhDb25jYXQsIGhleERhdGFMZW5ndGgsIGhleERhdGFTbGljZSwgaGV4bGlmeSwgaGV4WmVyb1BhZCwgaXNCeXRlc0xpa2UsIHNwbGl0U2lnbmF0dXJlLCBzdHJpcFplcm9zLCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgWmVybyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9jb25zdGFudHNcIjtcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9rZWNjYWsyNTZcIjtcbmltcG9ydCB7IGNoZWNrUHJvcGVydGllcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSTFAgZnJvbSBcIkBldGhlcnNwcm9qZWN0L3JscFwiO1xuaW1wb3J0IHsgY29tcHV0ZVB1YmxpY0tleSwgcmVjb3ZlclB1YmxpY0tleSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9zaWduaW5nLWtleVwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuZXhwb3J0IHZhciBUcmFuc2FjdGlvblR5cGVzO1xuKGZ1bmN0aW9uIChUcmFuc2FjdGlvblR5cGVzKSB7XG4gICAgVHJhbnNhY3Rpb25UeXBlc1tUcmFuc2FjdGlvblR5cGVzW1wibGVnYWN5XCJdID0gMF0gPSBcImxlZ2FjeVwiO1xuICAgIFRyYW5zYWN0aW9uVHlwZXNbVHJhbnNhY3Rpb25UeXBlc1tcImVpcDI5MzBcIl0gPSAxXSA9IFwiZWlwMjkzMFwiO1xuICAgIFRyYW5zYWN0aW9uVHlwZXNbVHJhbnNhY3Rpb25UeXBlc1tcImVpcDE1NTlcIl0gPSAyXSA9IFwiZWlwMTU1OVwiO1xufSkoVHJhbnNhY3Rpb25UeXBlcyB8fCAoVHJhbnNhY3Rpb25UeXBlcyA9IHt9KSk7XG47XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5mdW5jdGlvbiBoYW5kbGVBZGRyZXNzKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBnZXRBZGRyZXNzKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU51bWJlcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBaZXJvO1xuICAgIH1cbiAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20odmFsdWUpO1xufVxuLy8gTGVnYWN5IFRyYW5zYWN0aW9uIEZpZWxkc1xuY29uc3QgdHJhbnNhY3Rpb25GaWVsZHMgPSBbXG4gICAgeyBuYW1lOiBcIm5vbmNlXCIsIG1heExlbmd0aDogMzIsIG51bWVyaWM6IHRydWUgfSxcbiAgICB7IG5hbWU6IFwiZ2FzUHJpY2VcIiwgbWF4TGVuZ3RoOiAzMiwgbnVtZXJpYzogdHJ1ZSB9LFxuICAgIHsgbmFtZTogXCJnYXNMaW1pdFwiLCBtYXhMZW5ndGg6IDMyLCBudW1lcmljOiB0cnVlIH0sXG4gICAgeyBuYW1lOiBcInRvXCIsIGxlbmd0aDogMjAgfSxcbiAgICB7IG5hbWU6IFwidmFsdWVcIiwgbWF4TGVuZ3RoOiAzMiwgbnVtZXJpYzogdHJ1ZSB9LFxuICAgIHsgbmFtZTogXCJkYXRhXCIgfSxcbl07XG5jb25zdCBhbGxvd2VkVHJhbnNhY3Rpb25LZXlzID0ge1xuICAgIGNoYWluSWQ6IHRydWUsIGRhdGE6IHRydWUsIGdhc0xpbWl0OiB0cnVlLCBnYXNQcmljZTogdHJ1ZSwgbm9uY2U6IHRydWUsIHRvOiB0cnVlLCB0eXBlOiB0cnVlLCB2YWx1ZTogdHJ1ZVxufTtcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQWRkcmVzcyhrZXkpIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBjb21wdXRlUHVibGljS2V5KGtleSk7XG4gICAgcmV0dXJuIGdldEFkZHJlc3MoaGV4RGF0YVNsaWNlKGtlY2NhazI1NihoZXhEYXRhU2xpY2UocHVibGljS2V5LCAxKSksIDEyKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVjb3ZlckFkZHJlc3MoZGlnZXN0LCBzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gY29tcHV0ZUFkZHJlc3MocmVjb3ZlclB1YmxpY0tleShhcnJheWlmeShkaWdlc3QpLCBzaWduYXR1cmUpKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcih2YWx1ZSwgbmFtZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHN0cmlwWmVyb3MoQmlnTnVtYmVyLmZyb20odmFsdWUpLnRvSGV4U3RyaW5nKCkpO1xuICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMzIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbGVuZ3RoIGZvciBcIiArIG5hbWUsIChcInRyYW5zYWN0aW9uOlwiICsgbmFtZSksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGFjY2Vzc1NldGlmeShhZGRyLCBzdG9yYWdlS2V5cykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IGdldEFkZHJlc3MoYWRkciksXG4gICAgICAgIHN0b3JhZ2VLZXlzOiAoc3RvcmFnZUtleXMgfHwgW10pLm1hcCgoc3RvcmFnZUtleSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChoZXhEYXRhTGVuZ3RoKHN0b3JhZ2VLZXkpICE9PSAzMikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFjY2VzcyBsaXN0IHN0b3JhZ2VLZXlcIiwgYGFjY2Vzc0xpc3RbJHthZGRyfToke2luZGV4fV1gLCBzdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlS2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhY2Nlc3NMaXN0aWZ5KHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHNldCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNldCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFjY2VzcyBsaXN0IGV4cGVjdGVkIHRvIGJlIFsgYWRkcmVzcywgc3RvcmFnZUtleXNbXSBdXCIsIGB2YWx1ZVske2luZGV4fV1gLCBzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjZXNzU2V0aWZ5KHNldFswXSwgc2V0WzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoc2V0LmFkZHJlc3MsIHNldC5zdG9yYWdlS2V5cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3Qua2V5cyh2YWx1ZSkubWFwKChhZGRyKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VLZXlzID0gdmFsdWVbYWRkcl0ucmVkdWNlKChhY2N1bSwgc3RvcmFnZUtleSkgPT4ge1xuICAgICAgICAgICAgYWNjdW1bc3RvcmFnZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoYWRkciwgT2JqZWN0LmtleXMoc3RvcmFnZUtleXMpLnNvcnQoKSk7XG4gICAgfSk7XG4gICAgcmVzdWx0LnNvcnQoKGEsIGIpID0+IChhLmFkZHJlc3MubG9jYWxlQ29tcGFyZShiLmFkZHJlc3MpKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZvcm1hdEFjY2Vzc0xpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gYWNjZXNzTGlzdGlmeSh2YWx1ZSkubWFwKChzZXQpID0+IFtzZXQuYWRkcmVzcywgc2V0LnN0b3JhZ2VLZXlzXSk7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwMTU1OSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gZXhwbGljaXQgZ2FzUHJpY2UsIG1ha2Ugc3VyZSBpdCBtYXRjaGVzIHRoZVxuICAgIC8vIEVJUC0xNTU5IGZlZXM7IG90aGVyd2lzZSB0aGV5IG1heSBub3QgdW5kZXJzdGFuZCB3aGF0IHRoZXlcbiAgICAvLyB0aGluayB0aGV5IGFyZSBzZXR0aW5nIGluIHRlcm1zIG9mIGZlZS5cbiAgICBpZiAodHJhbnNhY3Rpb24uZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBnYXNQcmljZSA9IEJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uLmdhc1ByaWNlKTtcbiAgICAgICAgY29uc3QgbWF4RmVlUGVyR2FzID0gQmlnTnVtYmVyLmZyb20odHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzIHx8IDApO1xuICAgICAgICBpZiAoIWdhc1ByaWNlLmVxKG1heEZlZVBlckdhcykpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNtYXRjaCBFSVAtMTU1OSBnYXNQcmljZSAhPSBtYXhGZWVQZXJHYXNcIiwgXCJ0eFwiLCB7XG4gICAgICAgICAgICAgICAgZ2FzUHJpY2UsIG1heEZlZVBlckdhc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24uY2hhaW5JZCB8fCAwLCBcImNoYWluSWRcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi5ub25jZSB8fCAwLCBcIm5vbmNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24ubWF4UHJpb3JpdHlGZWVQZXJHYXMgfHwgMCwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLm1heEZlZVBlckdhcyB8fCAwLCBcIm1heEZlZVBlckdhc1wiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLmdhc0xpbWl0IHx8IDAsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICgodHJhbnNhY3Rpb24udG8gIT0gbnVsbCkgPyBnZXRBZGRyZXNzKHRyYW5zYWN0aW9uLnRvKSA6IFwiMHhcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi52YWx1ZSB8fCAwLCBcInZhbHVlXCIpLFxuICAgICAgICAodHJhbnNhY3Rpb24uZGF0YSB8fCBcIjB4XCIpLFxuICAgICAgICAoZm9ybWF0QWNjZXNzTGlzdCh0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0IHx8IFtdKSlcbiAgICBdO1xuICAgIGlmIChzaWduYXR1cmUpIHtcbiAgICAgICAgY29uc3Qgc2lnID0gc3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy5yZWNvdmVyeVBhcmFtLCBcInJlY292ZXJ5UGFyYW1cIikpO1xuICAgICAgICBmaWVsZHMucHVzaChzdHJpcFplcm9zKHNpZy5yKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHN0cmlwWmVyb3Moc2lnLnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleENvbmNhdChbXCIweDAyXCIsIFJMUC5lbmNvZGUoZmllbGRzKV0pO1xufVxuZnVuY3Rpb24gX3NlcmlhbGl6ZUVpcDI5MzAodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLmNoYWluSWQgfHwgMCwgXCJjaGFpbklkXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24ubm9uY2UgfHwgMCwgXCJub25jZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLmdhc1ByaWNlIHx8IDAsIFwiZ2FzUHJpY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi5nYXNMaW1pdCB8fCAwLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICAoKHRyYW5zYWN0aW9uLnRvICE9IG51bGwpID8gZ2V0QWRkcmVzcyh0cmFuc2FjdGlvbi50bykgOiBcIjB4XCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24udmFsdWUgfHwgMCwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgKHRyYW5zYWN0aW9uLmRhdGEgfHwgXCIweFwiKSxcbiAgICAgICAgKGZvcm1hdEFjY2Vzc0xpc3QodHJhbnNhY3Rpb24uYWNjZXNzTGlzdCB8fCBbXSkpXG4gICAgXTtcbiAgICBpZiAoc2lnbmF0dXJlKSB7XG4gICAgICAgIGNvbnN0IHNpZyA9IHNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKGZvcm1hdE51bWJlcihzaWcucmVjb3ZlcnlQYXJhbSwgXCJyZWNvdmVyeVBhcmFtXCIpKTtcbiAgICAgICAgZmllbGRzLnB1c2goc3RyaXBaZXJvcyhzaWcucikpO1xuICAgICAgICBmaWVsZHMucHVzaChzdHJpcFplcm9zKHNpZy5zKSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhDb25jYXQoW1wiMHgwMVwiLCBSTFAuZW5jb2RlKGZpZWxkcyldKTtcbn1cbi8vIExlZ2FjeSBUcmFuc2FjdGlvbnMgYW5kIEVJUC0xNTVcbmZ1bmN0aW9uIF9zZXJpYWxpemUodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSkge1xuICAgIGNoZWNrUHJvcGVydGllcyh0cmFuc2FjdGlvbiwgYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyk7XG4gICAgY29uc3QgcmF3ID0gW107XG4gICAgdHJhbnNhY3Rpb25GaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGRJbmZvKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRyYW5zYWN0aW9uW2ZpZWxkSW5mby5uYW1lXSB8fCAoW10pO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgIGlmIChmaWVsZEluZm8ubnVtZXJpYykge1xuICAgICAgICAgICAgb3B0aW9ucy5oZXhQYWQgPSBcImxlZnRcIjtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IGFycmF5aWZ5KGhleGxpZnkodmFsdWUsIG9wdGlvbnMpKTtcbiAgICAgICAgLy8gRml4ZWQtd2lkdGggZmllbGRcbiAgICAgICAgaWYgKGZpZWxkSW5mby5sZW5ndGggJiYgdmFsdWUubGVuZ3RoICE9PSBmaWVsZEluZm8ubGVuZ3RoICYmIHZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGxlbmd0aCBmb3IgXCIgKyBmaWVsZEluZm8ubmFtZSwgKFwidHJhbnNhY3Rpb246XCIgKyBmaWVsZEluZm8ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBWYXJpYWJsZS13aWR0aCAod2l0aCBhIG1heGltdW0pXG4gICAgICAgIGlmIChmaWVsZEluZm8ubWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHN0cmlwWmVyb3ModmFsdWUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IGZpZWxkSW5mby5tYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBsZW5ndGggZm9yIFwiICsgZmllbGRJbmZvLm5hbWUsIChcInRyYW5zYWN0aW9uOlwiICsgZmllbGRJbmZvLm5hbWUpLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmF3LnB1c2goaGV4bGlmeSh2YWx1ZSkpO1xuICAgIH0pO1xuICAgIGxldCBjaGFpbklkID0gMDtcbiAgICBpZiAodHJhbnNhY3Rpb24uY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgIC8vIEEgY2hhaW5JZCB3YXMgcHJvdmlkZWQ7IGlmIG5vbi16ZXJvIHdlJ2xsIHVzZSBFSVAtMTU1XG4gICAgICAgIGNoYWluSWQgPSB0cmFuc2FjdGlvbi5jaGFpbklkO1xuICAgICAgICBpZiAodHlwZW9mIChjaGFpbklkKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHJhbnNhY3Rpb24uY2hhaW5JZFwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzaWduYXR1cmUgJiYgIWlzQnl0ZXNMaWtlKHNpZ25hdHVyZSkgJiYgc2lnbmF0dXJlLnYgPiAyOCkge1xuICAgICAgICAvLyBObyBjaGFpbklkIHByb3ZpZGVkLCBidXQgdGhlIHNpZ25hdHVyZSBpcyBzaWduaW5nIHdpdGggRUlQLTE1NTsgZGVyaXZlIGNoYWluSWRcbiAgICAgICAgY2hhaW5JZCA9IE1hdGguZmxvb3IoKHNpZ25hdHVyZS52IC0gMzUpIC8gMik7XG4gICAgfVxuICAgIC8vIFdlIGhhdmUgYW4gRUlQLTE1NSB0cmFuc2FjdGlvbiAoY2hhaW5JZCB3YXMgc3BlY2lmaWVkIGFuZCBub24temVybylcbiAgICBpZiAoY2hhaW5JZCAhPT0gMCkge1xuICAgICAgICByYXcucHVzaChoZXhsaWZ5KGNoYWluSWQpKTsgLy8gQFRPRE86IGhleFZhbHVlP1xuICAgICAgICByYXcucHVzaChcIjB4XCIpO1xuICAgICAgICByYXcucHVzaChcIjB4XCIpO1xuICAgIH1cbiAgICAvLyBSZXF1ZXN0aW5nIGFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgaWYgKCFzaWduYXR1cmUpIHtcbiAgICAgICAgcmV0dXJuIFJMUC5lbmNvZGUocmF3KTtcbiAgICB9XG4gICAgLy8gVGhlIHNwbGl0U2lnbmF0dXJlIHdpbGwgZW5zdXJlIHRoZSB0cmFuc2FjdGlvbiBoYXMgYSByZWNvdmVyeVBhcmFtIGluIHRoZVxuICAgIC8vIGNhc2UgdGhhdCB0aGUgc2lnblRyYW5zYWN0aW9uIGZ1bmN0aW9uIG9ubHkgYWRkcyBhIHYuXG4gICAgY29uc3Qgc2lnID0gc3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICAvLyBXZSBwdXNoZWQgYSBjaGFpbklkIGFuZCBudWxsIHIsIHMgb24gZm9yIGhhc2hpbmcgb25seTsgcmVtb3ZlIHRob3NlXG4gICAgbGV0IHYgPSAyNyArIHNpZy5yZWNvdmVyeVBhcmFtO1xuICAgIGlmIChjaGFpbklkICE9PSAwKSB7XG4gICAgICAgIHJhdy5wb3AoKTtcbiAgICAgICAgcmF3LnBvcCgpO1xuICAgICAgICByYXcucG9wKCk7XG4gICAgICAgIHYgKz0gY2hhaW5JZCAqIDIgKyA4O1xuICAgICAgICAvLyBJZiBhbiBFSVAtMTU1IHYgKGRpcmVjdGx5IG9yIGluZGlyZWN0bHk7IG1heWJlIF92cykgd2FzIHByb3ZpZGVkLCBjaGVjayBpdCFcbiAgICAgICAgaWYgKHNpZy52ID4gMjggJiYgc2lnLnYgIT09IHYpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0cmFuc2FjdGlvbi5jaGFpbklkL3NpZ25hdHVyZS52IG1pc21hdGNoXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc2lnLnYgIT09IHYpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInRyYW5zYWN0aW9uLmNoYWluSWQvc2lnbmF0dXJlLnYgbWlzbWF0Y2hcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgcmF3LnB1c2goaGV4bGlmeSh2KSk7XG4gICAgcmF3LnB1c2goc3RyaXBaZXJvcyhhcnJheWlmeShzaWcucikpKTtcbiAgICByYXcucHVzaChzdHJpcFplcm9zKGFycmF5aWZ5KHNpZy5zKSkpO1xuICAgIHJldHVybiBSTFAuZW5jb2RlKHJhdyk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpIHtcbiAgICAvLyBMZWdhY3kgYW5kIEVJUC0xNTUgVHJhbnNhY3Rpb25zXG4gICAgaWYgKHRyYW5zYWN0aW9uLnR5cGUgPT0gbnVsbCB8fCB0cmFuc2FjdGlvbi50eXBlID09PSAwKSB7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnR5cGVkIHRyYW5zYWN0aW9ucyBkbyBub3Qgc3VwcG9ydCBhY2Nlc3NMaXN0OyBpbmNsdWRlIHR5cGU6IDFcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zZXJpYWxpemUodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSk7XG4gICAgfVxuICAgIC8vIFR5cGVkIFRyYW5zYWN0aW9ucyAoRUlQLTI3MTgpXG4gICAgc3dpdGNoICh0cmFuc2FjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwMjkzMCh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXAxNTU5KHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihgdW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZTogJHt0cmFuc2FjdGlvbi50eXBlfWAsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJzZXJpYWxpemVUcmFuc2FjdGlvblwiLFxuICAgICAgICB0cmFuc2FjdGlvblR5cGU6IHRyYW5zYWN0aW9uLnR5cGVcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzLCBzZXJpYWxpemUpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZWNpZCA9IGhhbmRsZU51bWJlcihmaWVsZHNbMF0pLnRvTnVtYmVyKCk7XG4gICAgICAgIGlmIChyZWNpZCAhPT0gMCAmJiByZWNpZCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHJlY2lkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHR4LnYgPSByZWNpZDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHYgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDFcIiwgXCJ2XCIsIGZpZWxkc1swXSk7XG4gICAgfVxuICAgIHR4LnIgPSBoZXhaZXJvUGFkKGZpZWxkc1sxXSwgMzIpO1xuICAgIHR4LnMgPSBoZXhaZXJvUGFkKGZpZWxkc1syXSwgMzIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRpZ2VzdCA9IGtlY2NhazI1NihzZXJpYWxpemUodHgpKTtcbiAgICAgICAgdHguZnJvbSA9IHJlY292ZXJBZGRyZXNzKGRpZ2VzdCwgeyByOiB0eC5yLCBzOiB0eC5zLCByZWNvdmVyeVBhcmFtOiB0eC52IH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxufVxuZnVuY3Rpb24gX3BhcnNlRWlwMTU1OShwYXlsb2FkKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBSTFAuZGVjb2RlKHBheWxvYWQuc2xpY2UoMSkpO1xuICAgIGlmICh0cmFuc2FjdGlvbi5sZW5ndGggIT09IDkgJiYgdHJhbnNhY3Rpb24ubGVuZ3RoICE9PSAxMikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjb21wb25lbnQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDJcIiwgXCJwYXlsb2FkXCIsIGhleGxpZnkocGF5bG9hZCkpO1xuICAgIH1cbiAgICBjb25zdCBtYXhQcmlvcml0eUZlZVBlckdhcyA9IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsyXSk7XG4gICAgY29uc3QgbWF4RmVlUGVyR2FzID0gaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzNdKTtcbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgdHlwZTogMixcbiAgICAgICAgY2hhaW5JZDogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzBdKS50b051bWJlcigpLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzFdKS50b051bWJlcigpLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogbWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgIG1heEZlZVBlckdhczogbWF4RmVlUGVyR2FzLFxuICAgICAgICBnYXNQcmljZTogbnVsbCxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvbls0XSksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKHRyYW5zYWN0aW9uWzVdKSxcbiAgICAgICAgdmFsdWU6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvbls2XSksXG4gICAgICAgIGRhdGE6IHRyYW5zYWN0aW9uWzddLFxuICAgICAgICBhY2Nlc3NMaXN0OiBhY2Nlc3NMaXN0aWZ5KHRyYW5zYWN0aW9uWzhdKSxcbiAgICB9O1xuICAgIC8vIFVuc2lnbmVkIEVJUC0xNTU5IFRyYW5zYWN0aW9uXG4gICAgaWYgKHRyYW5zYWN0aW9uLmxlbmd0aCA9PT0gOSkge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIHR4Lmhhc2ggPSBrZWNjYWsyNTYocGF5bG9hZCk7XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCB0cmFuc2FjdGlvbi5zbGljZSg5KSwgX3NlcmlhbGl6ZUVpcDE1NTkpO1xuICAgIHJldHVybiB0eDtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcDI5MzAocGF5bG9hZCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gUkxQLmRlY29kZShwYXlsb2FkLnNsaWNlKDEpKTtcbiAgICBpZiAodHJhbnNhY3Rpb24ubGVuZ3RoICE9PSA4ICYmIHRyYW5zYWN0aW9uLmxlbmd0aCAhPT0gMTEpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgY29tcG9uZW50IGNvdW50IGZvciB0cmFuc2FjdGlvbiB0eXBlOiAxXCIsIFwicGF5bG9hZFwiLCBoZXhsaWZ5KHBheWxvYWQpKTtcbiAgICB9XG4gICAgY29uc3QgdHggPSB7XG4gICAgICAgIHR5cGU6IDEsXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblswXSkudG9OdW1iZXIoKSxcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsxXSkudG9OdW1iZXIoKSxcbiAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsyXSksXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bM10pLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyh0cmFuc2FjdGlvbls0XSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bNV0pLFxuICAgICAgICBkYXRhOiB0cmFuc2FjdGlvbls2XSxcbiAgICAgICAgYWNjZXNzTGlzdDogYWNjZXNzTGlzdGlmeSh0cmFuc2FjdGlvbls3XSlcbiAgICB9O1xuICAgIC8vIFVuc2lnbmVkIEVJUC0yOTMwIFRyYW5zYWN0aW9uXG4gICAgaWYgKHRyYW5zYWN0aW9uLmxlbmd0aCA9PT0gOCkge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIHR4Lmhhc2ggPSBrZWNjYWsyNTYocGF5bG9hZCk7XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCB0cmFuc2FjdGlvbi5zbGljZSg4KSwgX3NlcmlhbGl6ZUVpcDI5MzApO1xuICAgIHJldHVybiB0eDtcbn1cbi8vIExlZ2FjeSBUcmFuc2FjdGlvbnMgYW5kIEVJUC0xNTVcbmZ1bmN0aW9uIF9wYXJzZShyYXdUcmFuc2FjdGlvbikge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gUkxQLmRlY29kZShyYXdUcmFuc2FjdGlvbik7XG4gICAgaWYgKHRyYW5zYWN0aW9uLmxlbmd0aCAhPT0gOSAmJiB0cmFuc2FjdGlvbi5sZW5ndGggIT09IDYpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcmF3IHRyYW5zYWN0aW9uXCIsIFwicmF3VHJhbnNhY3Rpb25cIiwgcmF3VHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblswXSkudG9OdW1iZXIoKSxcbiAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsxXSksXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bMl0pLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyh0cmFuc2FjdGlvblszXSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bNF0pLFxuICAgICAgICBkYXRhOiB0cmFuc2FjdGlvbls1XSxcbiAgICAgICAgY2hhaW5JZDogMFxuICAgIH07XG4gICAgLy8gTGVnYWN5IHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgaWYgKHRyYW5zYWN0aW9uLmxlbmd0aCA9PT0gNikge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHR4LnYgPSBCaWdOdW1iZXIuZnJvbSh0cmFuc2FjdGlvbls2XSkudG9OdW1iZXIoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIEBUT0RPOiBXaGF0IG1ha2VzIHNuZXNlIHRvIGRvPyBUaGUgdiBpcyB0b28gYmlnXG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgdHguciA9IGhleFplcm9QYWQodHJhbnNhY3Rpb25bN10sIDMyKTtcbiAgICB0eC5zID0gaGV4WmVyb1BhZCh0cmFuc2FjdGlvbls4XSwgMzIpO1xuICAgIGlmIChCaWdOdW1iZXIuZnJvbSh0eC5yKS5pc1plcm8oKSAmJiBCaWdOdW1iZXIuZnJvbSh0eC5zKS5pc1plcm8oKSkge1xuICAgICAgICAvLyBFSVAtMTU1IHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgICAgIHR4LmNoYWluSWQgPSB0eC52O1xuICAgICAgICB0eC52ID0gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFNpZ25lZCBUcmFuc2FjdGlvblxuICAgICAgICB0eC5jaGFpbklkID0gTWF0aC5mbG9vcigodHgudiAtIDM1KSAvIDIpO1xuICAgICAgICBpZiAodHguY2hhaW5JZCA8IDApIHtcbiAgICAgICAgICAgIHR4LmNoYWluSWQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZWNvdmVyeVBhcmFtID0gdHgudiAtIDI3O1xuICAgICAgICBjb25zdCByYXcgPSB0cmFuc2FjdGlvbi5zbGljZSgwLCA2KTtcbiAgICAgICAgaWYgKHR4LmNoYWluSWQgIT09IDApIHtcbiAgICAgICAgICAgIHJhdy5wdXNoKGhleGxpZnkodHguY2hhaW5JZCkpO1xuICAgICAgICAgICAgcmF3LnB1c2goXCIweFwiKTtcbiAgICAgICAgICAgIHJhdy5wdXNoKFwiMHhcIik7XG4gICAgICAgICAgICByZWNvdmVyeVBhcmFtIC09IHR4LmNoYWluSWQgKiAyICsgODtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaWdlc3QgPSBrZWNjYWsyNTYoUkxQLmVuY29kZShyYXcpKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHR4LmZyb20gPSByZWNvdmVyQWRkcmVzcyhkaWdlc3QsIHsgcjogaGV4bGlmeSh0eC5yKSwgczogaGV4bGlmeSh0eC5zKSwgcmVjb3ZlcnlQYXJhbTogcmVjb3ZlcnlQYXJhbSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB0eC5oYXNoID0ga2VjY2FrMjU2KHJhd1RyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgdHgudHlwZSA9IG51bGw7XG4gICAgcmV0dXJuIHR4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHJhd1RyYW5zYWN0aW9uKSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IGFycmF5aWZ5KHJhd1RyYW5zYWN0aW9uKTtcbiAgICAvLyBMZWdhY3kgYW5kIEVJUC0xNTUgVHJhbnNhY3Rpb25zXG4gICAgaWYgKHBheWxvYWRbMF0gPiAweDdmKSB7XG4gICAgICAgIHJldHVybiBfcGFyc2UocGF5bG9hZCk7XG4gICAgfVxuICAgIC8vIFR5cGVkIFRyYW5zYWN0aW9uIChFSVAtMjcxOClcbiAgICBzd2l0Y2ggKHBheWxvYWRbMF0pIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIF9wYXJzZUVpcDI5MzAocGF5bG9hZCk7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBfcGFyc2VFaXAxNTU5KHBheWxvYWQpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihgdW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZTogJHtwYXlsb2FkWzBdfWAsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJwYXJzZVRyYW5zYWN0aW9uXCIsXG4gICAgICAgIHRyYW5zYWN0aW9uVHlwZTogcGF5bG9hZFswXVxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbImdldEFkZHJlc3MiLCJCaWdOdW1iZXIiLCJhcnJheWlmeSIsImhleENvbmNhdCIsImhleERhdGFMZW5ndGgiLCJoZXhEYXRhU2xpY2UiLCJoZXhsaWZ5IiwiaGV4WmVyb1BhZCIsImlzQnl0ZXNMaWtlIiwic3BsaXRTaWduYXR1cmUiLCJzdHJpcFplcm9zIiwiWmVybyIsImtlY2NhazI1NiIsImNoZWNrUHJvcGVydGllcyIsIlJMUCIsImNvbXB1dGVQdWJsaWNLZXkiLCJyZWNvdmVyUHVibGljS2V5IiwiTG9nZ2VyIiwidmVyc2lvbiIsImxvZ2dlciIsIlRyYW5zYWN0aW9uVHlwZXMiLCJoYW5kbGVBZGRyZXNzIiwidmFsdWUiLCJoYW5kbGVOdW1iZXIiLCJmcm9tIiwidHJhbnNhY3Rpb25GaWVsZHMiLCJuYW1lIiwibWF4TGVuZ3RoIiwibnVtZXJpYyIsImxlbmd0aCIsImFsbG93ZWRUcmFuc2FjdGlvbktleXMiLCJjaGFpbklkIiwiZGF0YSIsImdhc0xpbWl0IiwiZ2FzUHJpY2UiLCJub25jZSIsInRvIiwidHlwZSIsImNvbXB1dGVBZGRyZXNzIiwia2V5IiwicHVibGljS2V5IiwicmVjb3ZlckFkZHJlc3MiLCJkaWdlc3QiLCJzaWduYXR1cmUiLCJmb3JtYXROdW1iZXIiLCJyZXN1bHQiLCJ0b0hleFN0cmluZyIsInRocm93QXJndW1lbnRFcnJvciIsImFjY2Vzc1NldGlmeSIsImFkZHIiLCJzdG9yYWdlS2V5cyIsImFkZHJlc3MiLCJtYXAiLCJzdG9yYWdlS2V5IiwiaW5kZXgiLCJ0b0xvd2VyQ2FzZSIsImFjY2Vzc0xpc3RpZnkiLCJBcnJheSIsImlzQXJyYXkiLCJzZXQiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwiYWNjdW0iLCJzb3J0IiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwiZm9ybWF0QWNjZXNzTGlzdCIsIl9zZXJpYWxpemVFaXAxNTU5IiwidHJhbnNhY3Rpb24iLCJtYXhGZWVQZXJHYXMiLCJlcSIsImZpZWxkcyIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwiYWNjZXNzTGlzdCIsInNpZyIsInB1c2giLCJyZWNvdmVyeVBhcmFtIiwiciIsInMiLCJlbmNvZGUiLCJfc2VyaWFsaXplRWlwMjkzMCIsIl9zZXJpYWxpemUiLCJyYXciLCJmb3JFYWNoIiwiZmllbGRJbmZvIiwib3B0aW9ucyIsImhleFBhZCIsInYiLCJNYXRoIiwiZmxvb3IiLCJwb3AiLCJzZXJpYWxpemUiLCJ0aHJvd0Vycm9yIiwiZXJyb3JzIiwiVU5TVVBQT1JURURfT1BFUkFUSU9OIiwib3BlcmF0aW9uIiwidHJhbnNhY3Rpb25UeXBlIiwiX3BhcnNlRWlwU2lnbmF0dXJlIiwidHgiLCJyZWNpZCIsInRvTnVtYmVyIiwiRXJyb3IiLCJlcnJvciIsIl9wYXJzZUVpcDE1NTkiLCJwYXlsb2FkIiwiZGVjb2RlIiwic2xpY2UiLCJoYXNoIiwiX3BhcnNlRWlwMjkzMCIsIl9wYXJzZSIsInJhd1RyYW5zYWN0aW9uIiwiaXNaZXJvIiwicGFyc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/transactions/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/units/lib.esm/_version.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/units/lib.esm/_version.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"units/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC91bml0cy9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxNQUFNQSxVQUFVLGNBQWMsQ0FDckMsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2xpbWUtYmV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvdW5pdHMvbGliLmVzbS9fdmVyc2lvbi5qcz83NGUwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJ1bml0cy81LjcuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/units/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/units/lib.esm/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/units/lib.esm/index.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   commify: () => (/* binding */ commify),\n/* harmony export */   formatEther: () => (/* binding */ formatEther),\n/* harmony export */   formatUnits: () => (/* binding */ formatUnits),\n/* harmony export */   parseEther: () => (/* binding */ parseEther),\n/* harmony export */   parseUnits: () => (/* binding */ parseUnits)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/units/lib.esm/_version.js\");\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nconst names = [\n    \"wei\",\n    \"kwei\",\n    \"mwei\",\n    \"gwei\",\n    \"szabo\",\n    \"finney\",\n    \"ether\"\n];\n// Some environments have issues with RegEx that contain back-tracking, so we cannot\n// use them.\nfunction commify(value) {\n    const comps = String(value).split(\".\");\n    if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === \".\" || value === \"-.\") {\n        logger.throwArgumentError(\"invalid value\", \"value\", value);\n    }\n    // Make sure we have at least one whole digit (0 if none)\n    let whole = comps[0];\n    let negative = \"\";\n    if (whole.substring(0, 1) === \"-\") {\n        negative = \"-\";\n        whole = whole.substring(1);\n    }\n    // Make sure we have at least 1 whole digit with no leading zeros\n    while(whole.substring(0, 1) === \"0\"){\n        whole = whole.substring(1);\n    }\n    if (whole === \"\") {\n        whole = \"0\";\n    }\n    let suffix = \"\";\n    if (comps.length === 2) {\n        suffix = \".\" + (comps[1] || \"0\");\n    }\n    while(suffix.length > 2 && suffix[suffix.length - 1] === \"0\"){\n        suffix = suffix.substring(0, suffix.length - 1);\n    }\n    const formatted = [];\n    while(whole.length){\n        if (whole.length <= 3) {\n            formatted.unshift(whole);\n            break;\n        } else {\n            const index = whole.length - 3;\n            formatted.unshift(whole.substring(index));\n            whole = whole.substring(0, index);\n        }\n    }\n    return negative + formatted.join(\",\") + suffix;\n}\nfunction formatUnits(value, unitName) {\n    if (typeof unitName === \"string\") {\n        const index = names.indexOf(unitName);\n        if (index !== -1) {\n            unitName = 3 * index;\n        }\n    }\n    return (0,_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.formatFixed)(value, unitName != null ? unitName : 18);\n}\nfunction parseUnits(value, unitName) {\n    if (typeof value !== \"string\") {\n        logger.throwArgumentError(\"value must be a string\", \"value\", value);\n    }\n    if (typeof unitName === \"string\") {\n        const index = names.indexOf(unitName);\n        if (index !== -1) {\n            unitName = 3 * index;\n        }\n    }\n    return (0,_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.parseFixed)(value, unitName != null ? unitName : 18);\n}\nfunction formatEther(wei) {\n    return formatUnits(wei, 18);\n}\nfunction parseEther(ether) {\n    return parseUnits(ether, 18);\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC91bml0cy9saWIuZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWE7QUFDc0Q7QUFDcEI7QUFDVjtBQUNyQyxNQUFNSSxTQUFTLElBQUlGLHlEQUFNQSxDQUFDQyw2Q0FBT0E7QUFDakMsTUFBTUUsUUFBUTtJQUNWO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRCxvRkFBb0Y7QUFDcEYsWUFBWTtBQUNMLFNBQVNDLFFBQVFDLEtBQUs7SUFDekIsTUFBTUMsUUFBUUMsT0FBT0YsT0FBT0csS0FBSyxDQUFDO0lBQ2xDLElBQUlGLE1BQU1HLE1BQU0sR0FBRyxLQUFLLENBQUNILEtBQUssQ0FBQyxFQUFFLENBQUNJLEtBQUssQ0FBQyxpQkFBa0JKLEtBQUssQ0FBQyxFQUFFLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEVBQUUsQ0FBQ0ksS0FBSyxDQUFDLGVBQWdCTCxVQUFVLE9BQU9BLFVBQVUsTUFBTTtRQUNuSUgsT0FBT1Msa0JBQWtCLENBQUMsaUJBQWlCLFNBQVNOO0lBQ3hEO0lBQ0EseURBQXlEO0lBQ3pELElBQUlPLFFBQVFOLEtBQUssQ0FBQyxFQUFFO0lBQ3BCLElBQUlPLFdBQVc7SUFDZixJQUFJRCxNQUFNRSxTQUFTLENBQUMsR0FBRyxPQUFPLEtBQUs7UUFDL0JELFdBQVc7UUFDWEQsUUFBUUEsTUFBTUUsU0FBUyxDQUFDO0lBQzVCO0lBQ0EsaUVBQWlFO0lBQ2pFLE1BQU9GLE1BQU1FLFNBQVMsQ0FBQyxHQUFHLE9BQU8sSUFBSztRQUNsQ0YsUUFBUUEsTUFBTUUsU0FBUyxDQUFDO0lBQzVCO0lBQ0EsSUFBSUYsVUFBVSxJQUFJO1FBQ2RBLFFBQVE7SUFDWjtJQUNBLElBQUlHLFNBQVM7SUFDYixJQUFJVCxNQUFNRyxNQUFNLEtBQUssR0FBRztRQUNwQk0sU0FBUyxNQUFPVCxDQUFBQSxLQUFLLENBQUMsRUFBRSxJQUFJLEdBQUU7SUFDbEM7SUFDQSxNQUFPUyxPQUFPTixNQUFNLEdBQUcsS0FBS00sTUFBTSxDQUFDQSxPQUFPTixNQUFNLEdBQUcsRUFBRSxLQUFLLElBQUs7UUFDM0RNLFNBQVNBLE9BQU9ELFNBQVMsQ0FBQyxHQUFHQyxPQUFPTixNQUFNLEdBQUc7SUFDakQ7SUFDQSxNQUFNTyxZQUFZLEVBQUU7SUFDcEIsTUFBT0osTUFBTUgsTUFBTSxDQUFFO1FBQ2pCLElBQUlHLE1BQU1ILE1BQU0sSUFBSSxHQUFHO1lBQ25CTyxVQUFVQyxPQUFPLENBQUNMO1lBQ2xCO1FBQ0osT0FDSztZQUNELE1BQU1NLFFBQVFOLE1BQU1ILE1BQU0sR0FBRztZQUM3Qk8sVUFBVUMsT0FBTyxDQUFDTCxNQUFNRSxTQUFTLENBQUNJO1lBQ2xDTixRQUFRQSxNQUFNRSxTQUFTLENBQUMsR0FBR0k7UUFDL0I7SUFDSjtJQUNBLE9BQU9MLFdBQVdHLFVBQVVHLElBQUksQ0FBQyxPQUFPSjtBQUM1QztBQUNPLFNBQVNLLFlBQVlmLEtBQUssRUFBRWdCLFFBQVE7SUFDdkMsSUFBSSxPQUFRQSxhQUFjLFVBQVU7UUFDaEMsTUFBTUgsUUFBUWYsTUFBTW1CLE9BQU8sQ0FBQ0Q7UUFDNUIsSUFBSUgsVUFBVSxDQUFDLEdBQUc7WUFDZEcsV0FBVyxJQUFJSDtRQUNuQjtJQUNKO0lBQ0EsT0FBT3BCLHFFQUFXQSxDQUFDTyxPQUFPLFlBQWEsT0FBUWdCLFdBQVc7QUFDOUQ7QUFDTyxTQUFTRSxXQUFXbEIsS0FBSyxFQUFFZ0IsUUFBUTtJQUN0QyxJQUFJLE9BQVFoQixVQUFXLFVBQVU7UUFDN0JILE9BQU9TLGtCQUFrQixDQUFDLDBCQUEwQixTQUFTTjtJQUNqRTtJQUNBLElBQUksT0FBUWdCLGFBQWMsVUFBVTtRQUNoQyxNQUFNSCxRQUFRZixNQUFNbUIsT0FBTyxDQUFDRDtRQUM1QixJQUFJSCxVQUFVLENBQUMsR0FBRztZQUNkRyxXQUFXLElBQUlIO1FBQ25CO0lBQ0o7SUFDQSxPQUFPbkIsb0VBQVVBLENBQUNNLE9BQU8sWUFBYSxPQUFRZ0IsV0FBVztBQUM3RDtBQUNPLFNBQVNHLFlBQVlDLEdBQUc7SUFDM0IsT0FBT0wsWUFBWUssS0FBSztBQUM1QjtBQUNPLFNBQVNDLFdBQVdDLEtBQUs7SUFDNUIsT0FBT0osV0FBV0ksT0FBTztBQUM3QixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NsaW1lLWJldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3VuaXRzL2xpYi5lc20vaW5kZXguanM/N2VmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGZvcm1hdEZpeGVkLCBwYXJzZUZpeGVkIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuY29uc3QgbmFtZXMgPSBbXG4gICAgXCJ3ZWlcIixcbiAgICBcImt3ZWlcIixcbiAgICBcIm13ZWlcIixcbiAgICBcImd3ZWlcIixcbiAgICBcInN6YWJvXCIsXG4gICAgXCJmaW5uZXlcIixcbiAgICBcImV0aGVyXCIsXG5dO1xuLy8gU29tZSBlbnZpcm9ubWVudHMgaGF2ZSBpc3N1ZXMgd2l0aCBSZWdFeCB0aGF0IGNvbnRhaW4gYmFjay10cmFja2luZywgc28gd2UgY2Fubm90XG4vLyB1c2UgdGhlbS5cbmV4cG9ydCBmdW5jdGlvbiBjb21taWZ5KHZhbHVlKSB7XG4gICAgY29uc3QgY29tcHMgPSBTdHJpbmcodmFsdWUpLnNwbGl0KFwiLlwiKTtcbiAgICBpZiAoY29tcHMubGVuZ3RoID4gMiB8fCAhY29tcHNbMF0ubWF0Y2goL14tP1swLTldKiQvKSB8fCAoY29tcHNbMV0gJiYgIWNvbXBzWzFdLm1hdGNoKC9eWzAtOV0qJC8pKSB8fCB2YWx1ZSA9PT0gXCIuXCIgfHwgdmFsdWUgPT09IFwiLS5cIikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYXQgbGVhc3Qgb25lIHdob2xlIGRpZ2l0ICgwIGlmIG5vbmUpXG4gICAgbGV0IHdob2xlID0gY29tcHNbMF07XG4gICAgbGV0IG5lZ2F0aXZlID0gXCJcIjtcbiAgICBpZiAod2hvbGUuc3Vic3RyaW5nKDAsIDEpID09PSBcIi1cIikge1xuICAgICAgICBuZWdhdGl2ZSA9IFwiLVwiO1xuICAgICAgICB3aG9sZSA9IHdob2xlLnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYXQgbGVhc3QgMSB3aG9sZSBkaWdpdCB3aXRoIG5vIGxlYWRpbmcgemVyb3NcbiAgICB3aGlsZSAod2hvbGUuc3Vic3RyaW5nKDAsIDEpID09PSBcIjBcIikge1xuICAgICAgICB3aG9sZSA9IHdob2xlLnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgaWYgKHdob2xlID09PSBcIlwiKSB7XG4gICAgICAgIHdob2xlID0gXCIwXCI7XG4gICAgfVxuICAgIGxldCBzdWZmaXggPSBcIlwiO1xuICAgIGlmIChjb21wcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgc3VmZml4ID0gXCIuXCIgKyAoY29tcHNbMV0gfHwgXCIwXCIpO1xuICAgIH1cbiAgICB3aGlsZSAoc3VmZml4Lmxlbmd0aCA+IDIgJiYgc3VmZml4W3N1ZmZpeC5sZW5ndGggLSAxXSA9PT0gXCIwXCIpIHtcbiAgICAgICAgc3VmZml4ID0gc3VmZml4LnN1YnN0cmluZygwLCBzdWZmaXgubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGNvbnN0IGZvcm1hdHRlZCA9IFtdO1xuICAgIHdoaWxlICh3aG9sZS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHdob2xlLmxlbmd0aCA8PSAzKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWQudW5zaGlmdCh3aG9sZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gd2hvbGUubGVuZ3RoIC0gMztcbiAgICAgICAgICAgIGZvcm1hdHRlZC51bnNoaWZ0KHdob2xlLnN1YnN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgd2hvbGUgPSB3aG9sZS5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZWdhdGl2ZSArIGZvcm1hdHRlZC5qb2luKFwiLFwiKSArIHN1ZmZpeDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRVbml0cyh2YWx1ZSwgdW5pdE5hbWUpIHtcbiAgICBpZiAodHlwZW9mICh1bml0TmFtZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBuYW1lcy5pbmRleE9mKHVuaXROYW1lKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdW5pdE5hbWUgPSAzICogaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdEZpeGVkKHZhbHVlLCAodW5pdE5hbWUgIT0gbnVsbCkgPyB1bml0TmFtZSA6IDE4KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVVuaXRzKHZhbHVlLCB1bml0TmFtZSkge1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidmFsdWUgbXVzdCBiZSBhIHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodW5pdE5hbWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmFtZXMuaW5kZXhPZih1bml0TmFtZSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHVuaXROYW1lID0gMyAqIGluZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUZpeGVkKHZhbHVlLCAodW5pdE5hbWUgIT0gbnVsbCkgPyB1bml0TmFtZSA6IDE4KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRFdGhlcih3ZWkpIHtcbiAgICByZXR1cm4gZm9ybWF0VW5pdHMod2VpLCAxOCk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VFdGhlcihldGhlcikge1xuICAgIHJldHVybiBwYXJzZVVuaXRzKGV0aGVyLCAxOCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiZm9ybWF0Rml4ZWQiLCJwYXJzZUZpeGVkIiwiTG9nZ2VyIiwidmVyc2lvbiIsImxvZ2dlciIsIm5hbWVzIiwiY29tbWlmeSIsInZhbHVlIiwiY29tcHMiLCJTdHJpbmciLCJzcGxpdCIsImxlbmd0aCIsIm1hdGNoIiwidGhyb3dBcmd1bWVudEVycm9yIiwid2hvbGUiLCJuZWdhdGl2ZSIsInN1YnN0cmluZyIsInN1ZmZpeCIsImZvcm1hdHRlZCIsInVuc2hpZnQiLCJpbmRleCIsImpvaW4iLCJmb3JtYXRVbml0cyIsInVuaXROYW1lIiwiaW5kZXhPZiIsInBhcnNlVW5pdHMiLCJmb3JtYXRFdGhlciIsIndlaSIsInBhcnNlRXRoZXIiLCJldGhlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/units/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/web/lib.esm/_version.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/web/lib.esm/_version.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"web/5.7.1\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC93ZWIvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsVUFBVSxZQUFZLENBQ25DLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NsaW1lLWJldC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3dlYi9saWIuZXNtL192ZXJzaW9uLmpzPzMwNzgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcIndlYi81LjcuMVwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/web/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/web/lib.esm/geturl.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/web/lib.esm/geturl.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getUrl: () => (/* binding */ getUrl)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nfunction getUrl(href, options) {\n    return __awaiter(this, void 0, void 0, function*() {\n        if (options == null) {\n            options = {};\n        }\n        const request = {\n            method: options.method || \"GET\",\n            headers: options.headers || {},\n            body: options.body || undefined\n        };\n        if (options.skipFetchSetup !== true) {\n            request.mode = \"cors\"; // no-cors, cors, *same-origin\n            request.cache = \"no-cache\"; // *default, no-cache, reload, force-cache, only-if-cached\n            request.credentials = \"same-origin\"; // include, *same-origin, omit\n            request.redirect = \"follow\"; // manual, *follow, error\n            request.referrer = \"client\"; // no-referrer, *client\n        }\n        ;\n        if (options.fetchOptions != null) {\n            const opts = options.fetchOptions;\n            if (opts.mode) {\n                request.mode = opts.mode;\n            }\n            if (opts.cache) {\n                request.cache = opts.cache;\n            }\n            if (opts.credentials) {\n                request.credentials = opts.credentials;\n            }\n            if (opts.redirect) {\n                request.redirect = opts.redirect;\n            }\n            if (opts.referrer) {\n                request.referrer = opts.referrer;\n            }\n        }\n        const response = yield fetch(href, request);\n        const body = yield response.arrayBuffer();\n        const headers = {};\n        if (response.headers.forEach) {\n            response.headers.forEach((value, key)=>{\n                headers[key.toLowerCase()] = value;\n            });\n        } else {\n            response.headers.keys().forEach((key)=>{\n                headers[key.toLowerCase()] = response.headers.get(key);\n            });\n        }\n        return {\n            headers: headers,\n            statusCode: response.status,\n            statusMessage: response.statusText,\n            body: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.arrayify)(new Uint8Array(body))\n        };\n    });\n} //# sourceMappingURL=geturl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC93ZWIvbGliLmVzbS9nZXR1cmwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBYTtBQUNiLElBQUlBLFlBQVksU0FBSyxJQUFJLFNBQUksQ0FBQ0EsU0FBUyxJQUFLLFNBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDbkYsU0FBU0MsTUFBTUMsS0FBSztRQUFJLE9BQU9BLGlCQUFpQkgsSUFBSUcsUUFBUSxJQUFJSCxFQUFFLFNBQVVJLE9BQU87WUFBSUEsUUFBUUQ7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFBS0gsQ0FBQUEsS0FBTUEsQ0FBQUEsSUFBSUssT0FBTSxDQUFDLEVBQUcsU0FBVUQsT0FBTyxFQUFFRSxNQUFNO1FBQ3JELFNBQVNDLFVBQVVKLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxVQUFVUSxJQUFJLENBQUNOO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDMUYsU0FBU0MsU0FBU1IsS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFNBQVMsQ0FBQyxRQUFRLENBQUNFO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDN0YsU0FBU0YsS0FBS0ksTUFBTTtZQUFJQSxPQUFPQyxJQUFJLEdBQUdULFFBQVFRLE9BQU9ULEtBQUssSUFBSUQsTUFBTVUsT0FBT1QsS0FBSyxFQUFFVyxJQUFJLENBQUNQLFdBQVdJO1FBQVc7UUFDN0dILEtBQUssQ0FBQ1AsWUFBWUEsVUFBVWMsS0FBSyxDQUFDakIsU0FBU0MsY0FBYyxFQUFFLEdBQUdVLElBQUk7SUFDdEU7QUFDSjtBQUNnRDtBQUN6QyxTQUFTUSxPQUFPQyxJQUFJLEVBQUVDLE9BQU87SUFDaEMsT0FBT3RCLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7UUFDbkMsSUFBSXNCLFdBQVcsTUFBTTtZQUNqQkEsVUFBVSxDQUFDO1FBQ2Y7UUFDQSxNQUFNQyxVQUFVO1lBQ1pDLFFBQVNGLFFBQVFFLE1BQU0sSUFBSTtZQUMzQkMsU0FBVUgsUUFBUUcsT0FBTyxJQUFJLENBQUM7WUFDOUJDLE1BQU9KLFFBQVFJLElBQUksSUFBSUM7UUFDM0I7UUFDQSxJQUFJTCxRQUFRTSxjQUFjLEtBQUssTUFBTTtZQUNqQ0wsUUFBUU0sSUFBSSxHQUFHLFFBQVEsOEJBQThCO1lBQ3JETixRQUFRTyxLQUFLLEdBQUcsWUFBWSwwREFBMEQ7WUFDdEZQLFFBQVFRLFdBQVcsR0FBRyxlQUFlLDhCQUE4QjtZQUNuRVIsUUFBUVMsUUFBUSxHQUFHLFVBQVUseUJBQXlCO1lBQ3REVCxRQUFRVSxRQUFRLEdBQUcsVUFBVSx1QkFBdUI7UUFDeEQ7O1FBRUEsSUFBSVgsUUFBUVksWUFBWSxJQUFJLE1BQU07WUFDOUIsTUFBTUMsT0FBT2IsUUFBUVksWUFBWTtZQUNqQyxJQUFJQyxLQUFLTixJQUFJLEVBQUU7Z0JBQ1hOLFFBQVFNLElBQUksR0FBSU0sS0FBS04sSUFBSTtZQUM3QjtZQUNBLElBQUlNLEtBQUtMLEtBQUssRUFBRTtnQkFDWlAsUUFBUU8sS0FBSyxHQUFJSyxLQUFLTCxLQUFLO1lBQy9CO1lBQ0EsSUFBSUssS0FBS0osV0FBVyxFQUFFO2dCQUNsQlIsUUFBUVEsV0FBVyxHQUFJSSxLQUFLSixXQUFXO1lBQzNDO1lBQ0EsSUFBSUksS0FBS0gsUUFBUSxFQUFFO2dCQUNmVCxRQUFRUyxRQUFRLEdBQUlHLEtBQUtILFFBQVE7WUFDckM7WUFDQSxJQUFJRyxLQUFLRixRQUFRLEVBQUU7Z0JBQ2ZWLFFBQVFVLFFBQVEsR0FBR0UsS0FBS0YsUUFBUTtZQUNwQztRQUNKO1FBQ0EsTUFBTUcsV0FBVyxNQUFNQyxNQUFNaEIsTUFBTUU7UUFDbkMsTUFBTUcsT0FBTyxNQUFNVSxTQUFTRSxXQUFXO1FBQ3ZDLE1BQU1iLFVBQVUsQ0FBQztRQUNqQixJQUFJVyxTQUFTWCxPQUFPLENBQUNjLE9BQU8sRUFBRTtZQUMxQkgsU0FBU1gsT0FBTyxDQUFDYyxPQUFPLENBQUMsQ0FBQ2pDLE9BQU9rQztnQkFDN0JmLE9BQU8sQ0FBQ2UsSUFBSUMsV0FBVyxHQUFHLEdBQUduQztZQUNqQztRQUNKLE9BQ0s7WUFDQzhCLFNBQVNYLE9BQU8sQ0FBRWlCLElBQUksR0FBSUgsT0FBTyxDQUFDLENBQUNDO2dCQUNqQ2YsT0FBTyxDQUFDZSxJQUFJQyxXQUFXLEdBQUcsR0FBR0wsU0FBU1gsT0FBTyxDQUFDa0IsR0FBRyxDQUFDSDtZQUN0RDtRQUNKO1FBQ0EsT0FBTztZQUNIZixTQUFTQTtZQUNUbUIsWUFBWVIsU0FBU1MsTUFBTTtZQUMzQkMsZUFBZVYsU0FBU1csVUFBVTtZQUNsQ3JCLE1BQU1QLDhEQUFRQSxDQUFDLElBQUk2QixXQUFXdEI7UUFDbEM7SUFDSjtBQUNKLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2xpbWUtYmV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvd2ViL2xpYi5lc20vZ2V0dXJsLmpzP2IzODMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IGFycmF5aWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5leHBvcnQgZnVuY3Rpb24gZ2V0VXJsKGhyZWYsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogKG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCIpLFxuICAgICAgICAgICAgaGVhZGVyczogKG9wdGlvbnMuaGVhZGVycyB8fCB7fSksXG4gICAgICAgICAgICBib2R5OiAob3B0aW9ucy5ib2R5IHx8IHVuZGVmaW5lZCksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLnNraXBGZXRjaFNldHVwICE9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXF1ZXN0Lm1vZGUgPSBcImNvcnNcIjsgLy8gbm8tY29ycywgY29ycywgKnNhbWUtb3JpZ2luXG4gICAgICAgICAgICByZXF1ZXN0LmNhY2hlID0gXCJuby1jYWNoZVwiOyAvLyAqZGVmYXVsdCwgbm8tY2FjaGUsIHJlbG9hZCwgZm9yY2UtY2FjaGUsIG9ubHktaWYtY2FjaGVkXG4gICAgICAgICAgICByZXF1ZXN0LmNyZWRlbnRpYWxzID0gXCJzYW1lLW9yaWdpblwiOyAvLyBpbmNsdWRlLCAqc2FtZS1vcmlnaW4sIG9taXRcbiAgICAgICAgICAgIHJlcXVlc3QucmVkaXJlY3QgPSBcImZvbGxvd1wiOyAvLyBtYW51YWwsICpmb2xsb3csIGVycm9yXG4gICAgICAgICAgICByZXF1ZXN0LnJlZmVycmVyID0gXCJjbGllbnRcIjsgLy8gbm8tcmVmZXJyZXIsICpjbGllbnRcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGlmIChvcHRpb25zLmZldGNoT3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRzID0gb3B0aW9ucy5mZXRjaE9wdGlvbnM7XG4gICAgICAgICAgICBpZiAob3B0cy5tb2RlKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5tb2RlID0gKG9wdHMubW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5jYWNoZSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuY2FjaGUgPSAob3B0cy5jYWNoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5jcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuY3JlZGVudGlhbHMgPSAob3B0cy5jcmVkZW50aWFscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5yZWRpcmVjdCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVkaXJlY3QgPSAob3B0cy5yZWRpcmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5yZWZlcnJlcikge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVmZXJyZXIgPSBvcHRzLnJlZmVycmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgZmV0Y2goaHJlZiwgcmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB5aWVsZCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICAgIGlmIChyZXNwb25zZS5oZWFkZXJzLmZvckVhY2gpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICgocmVzcG9uc2UuaGVhZGVycykua2V5cykoKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KGtleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c01lc3NhZ2U6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICBib2R5OiBhcnJheWlmeShuZXcgVWludDhBcnJheShib2R5KSksXG4gICAgICAgIH07XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXR1cmwuanMubWFwIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsImFycmF5aWZ5IiwiZ2V0VXJsIiwiaHJlZiIsIm9wdGlvbnMiLCJyZXF1ZXN0IiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJ1bmRlZmluZWQiLCJza2lwRmV0Y2hTZXR1cCIsIm1vZGUiLCJjYWNoZSIsImNyZWRlbnRpYWxzIiwicmVkaXJlY3QiLCJyZWZlcnJlciIsImZldGNoT3B0aW9ucyIsIm9wdHMiLCJyZXNwb25zZSIsImZldGNoIiwiYXJyYXlCdWZmZXIiLCJmb3JFYWNoIiwia2V5IiwidG9Mb3dlckNhc2UiLCJrZXlzIiwiZ2V0Iiwic3RhdHVzQ29kZSIsInN0YXR1cyIsInN0YXR1c01lc3NhZ2UiLCJzdGF0dXNUZXh0IiwiVWludDhBcnJheSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/web/lib.esm/geturl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/web/lib.esm/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/web/lib.esm/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _fetchData: () => (/* binding */ _fetchData),\n/* harmony export */   fetchJson: () => (/* binding */ fetchJson),\n/* harmony export */   poll: () => (/* binding */ poll)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_base64__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/base64 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/base64/lib.esm/base64.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/web/lib.esm/_version.js\");\n/* harmony import */ var _geturl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./geturl */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/web/lib.esm/geturl.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nfunction staller(duration) {\n    return new Promise((resolve)=>{\n        setTimeout(resolve, duration);\n    });\n}\nfunction bodyify(value, type) {\n    if (value == null) {\n        return null;\n    }\n    if (typeof value === \"string\") {\n        return value;\n    }\n    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isBytesLike)(value)) {\n        if (type && (type.split(\"/\")[0] === \"text\" || type.split(\";\")[0].trim() === \"application/json\")) {\n            try {\n                return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8String)(value);\n            } catch (error) {}\n            ;\n        }\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(value);\n    }\n    return value;\n}\nfunction unpercent(value) {\n    return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code)=>{\n        return String.fromCharCode(parseInt(code, 16));\n    }));\n}\n// This API is still a work in progress; the future changes will likely be:\n// - ConnectionInfo => FetchDataRequest<T = any>\n// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }\n//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)\n// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T\n// For this reason, it should be considered internal until the API is finalized\nfunction _fetchData(connection, body, processFunc) {\n    // How many times to retry in the event of a throttle\n    const attemptLimit = typeof connection === \"object\" && connection.throttleLimit != null ? connection.throttleLimit : 12;\n    logger.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, \"invalid connection throttle limit\", \"connection.throttleLimit\", attemptLimit);\n    const throttleCallback = typeof connection === \"object\" ? connection.throttleCallback : null;\n    const throttleSlotInterval = typeof connection === \"object\" && typeof connection.throttleSlotInterval === \"number\" ? connection.throttleSlotInterval : 100;\n    logger.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, \"invalid connection throttle slot interval\", \"connection.throttleSlotInterval\", throttleSlotInterval);\n    const errorPassThrough = typeof connection === \"object\" ? !!connection.errorPassThrough : false;\n    const headers = {};\n    let url = null;\n    // @TODO: Allow ConnectionInfo to override some of these values\n    const options = {\n        method: \"GET\"\n    };\n    let allow304 = false;\n    let timeout = 2 * 60 * 1000;\n    if (typeof connection === \"string\") {\n        url = connection;\n    } else if (typeof connection === \"object\") {\n        if (connection == null || connection.url == null) {\n            logger.throwArgumentError(\"missing URL\", \"connection.url\", connection);\n        }\n        url = connection.url;\n        if (typeof connection.timeout === \"number\" && connection.timeout > 0) {\n            timeout = connection.timeout;\n        }\n        if (connection.headers) {\n            for(const key in connection.headers){\n                headers[key.toLowerCase()] = {\n                    key: key,\n                    value: String(connection.headers[key])\n                };\n                if ([\n                    \"if-none-match\",\n                    \"if-modified-since\"\n                ].indexOf(key.toLowerCase()) >= 0) {\n                    allow304 = true;\n                }\n            }\n        }\n        options.allowGzip = !!connection.allowGzip;\n        if (connection.user != null && connection.password != null) {\n            if (url.substring(0, 6) !== \"https:\" && connection.allowInsecureAuthentication !== true) {\n                logger.throwError(\"basic authentication requires a secure https url\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"url\",\n                    url: url,\n                    user: connection.user,\n                    password: \"[REDACTED]\"\n                });\n            }\n            const authorization = connection.user + \":\" + connection.password;\n            headers[\"authorization\"] = {\n                key: \"Authorization\",\n                value: \"Basic \" + (0,_ethersproject_base64__WEBPACK_IMPORTED_MODULE_4__.encode)((0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(authorization))\n            };\n        }\n        if (connection.skipFetchSetup != null) {\n            options.skipFetchSetup = !!connection.skipFetchSetup;\n        }\n        if (connection.fetchOptions != null) {\n            options.fetchOptions = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.shallowCopy)(connection.fetchOptions);\n        }\n    }\n    const reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\n    const dataMatch = url ? url.match(reData) : null;\n    if (dataMatch) {\n        try {\n            const response = {\n                statusCode: 200,\n                statusMessage: \"OK\",\n                headers: {\n                    \"content-type\": dataMatch[1] || \"text/plain\"\n                },\n                body: dataMatch[2] ? (0,_ethersproject_base64__WEBPACK_IMPORTED_MODULE_4__.decode)(dataMatch[3]) : unpercent(dataMatch[3])\n            };\n            let result = response.body;\n            if (processFunc) {\n                result = processFunc(response.body, response);\n            }\n            return Promise.resolve(result);\n        } catch (error) {\n            logger.throwError(\"processing response error\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {\n                body: bodyify(dataMatch[1], dataMatch[2]),\n                error: error,\n                requestBody: null,\n                requestMethod: \"GET\",\n                url: url\n            });\n        }\n    }\n    if (body) {\n        options.method = \"POST\";\n        options.body = body;\n        if (headers[\"content-type\"] == null) {\n            headers[\"content-type\"] = {\n                key: \"Content-Type\",\n                value: \"application/octet-stream\"\n            };\n        }\n        if (headers[\"content-length\"] == null) {\n            headers[\"content-length\"] = {\n                key: \"Content-Length\",\n                value: String(body.length)\n            };\n        }\n    }\n    const flatHeaders = {};\n    Object.keys(headers).forEach((key)=>{\n        const header = headers[key];\n        flatHeaders[header.key] = header.value;\n    });\n    options.headers = flatHeaders;\n    const runningTimeout = function() {\n        let timer = null;\n        const promise = new Promise(function(resolve, reject) {\n            if (timeout) {\n                timer = setTimeout(()=>{\n                    if (timer == null) {\n                        return;\n                    }\n                    timer = null;\n                    reject(logger.makeError(\"timeout\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.TIMEOUT, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        timeout: timeout,\n                        url: url\n                    }));\n                }, timeout);\n            }\n        });\n        const cancel = function() {\n            if (timer == null) {\n                return;\n            }\n            clearTimeout(timer);\n            timer = null;\n        };\n        return {\n            promise,\n            cancel\n        };\n    }();\n    const runningFetch = function() {\n        return __awaiter(this, void 0, void 0, function*() {\n            for(let attempt = 0; attempt < attemptLimit; attempt++){\n                let response = null;\n                try {\n                    response = yield (0,_geturl__WEBPACK_IMPORTED_MODULE_6__.getUrl)(url, options);\n                    if (attempt < attemptLimit) {\n                        if (response.statusCode === 301 || response.statusCode === 302) {\n                            // Redirection; for now we only support absolute locataions\n                            const location = response.headers.location || \"\";\n                            if (options.method === \"GET\" && location.match(/^https:/)) {\n                                url = response.headers.location;\n                                continue;\n                            }\n                        } else if (response.statusCode === 429) {\n                            // Exponential back-off throttling\n                            let tryAgain = true;\n                            if (throttleCallback) {\n                                tryAgain = yield throttleCallback(attempt, url);\n                            }\n                            if (tryAgain) {\n                                let stall = 0;\n                                const retryAfter = response.headers[\"retry-after\"];\n                                if (typeof retryAfter === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                                    stall = parseInt(retryAfter) * 1000;\n                                } else {\n                                    stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                                }\n                                //console.log(\"Stalling 429\");\n                                yield staller(stall);\n                                continue;\n                            }\n                        }\n                    }\n                } catch (error) {\n                    response = error.response;\n                    if (response == null) {\n                        runningTimeout.cancel();\n                        logger.throwError(\"missing response\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {\n                            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                            requestMethod: options.method,\n                            serverError: error,\n                            url: url\n                        });\n                    }\n                }\n                let body = response.body;\n                if (allow304 && response.statusCode === 304) {\n                    body = null;\n                } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {\n                    runningTimeout.cancel();\n                    logger.throwError(\"bad response\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {\n                        status: response.statusCode,\n                        headers: response.headers,\n                        body: bodyify(body, response.headers ? response.headers[\"content-type\"] : null),\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        url: url\n                    });\n                }\n                if (processFunc) {\n                    try {\n                        const result = yield processFunc(body, response);\n                        runningTimeout.cancel();\n                        return result;\n                    } catch (error) {\n                        // Allow the processFunc to trigger a throttle\n                        if (error.throttleRetry && attempt < attemptLimit) {\n                            let tryAgain = true;\n                            if (throttleCallback) {\n                                tryAgain = yield throttleCallback(attempt, url);\n                            }\n                            if (tryAgain) {\n                                const timeout = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                                //console.log(\"Stalling callback\");\n                                yield staller(timeout);\n                                continue;\n                            }\n                        }\n                        runningTimeout.cancel();\n                        logger.throwError(\"processing response error\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {\n                            body: bodyify(body, response.headers ? response.headers[\"content-type\"] : null),\n                            error: error,\n                            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                            requestMethod: options.method,\n                            url: url\n                        });\n                    }\n                }\n                runningTimeout.cancel();\n                // If we had a processFunc, it either returned a T or threw above.\n                // The \"body\" is now a Uint8Array.\n                return body;\n            }\n            return logger.throwError(\"failed response\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {\n                requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                requestMethod: options.method,\n                url: url\n            });\n        });\n    }();\n    return Promise.race([\n        runningTimeout.promise,\n        runningFetch\n    ]);\n}\nfunction fetchJson(connection, json, processFunc) {\n    let processJsonFunc = (value, response)=>{\n        let result = null;\n        if (value != null) {\n            try {\n                result = JSON.parse((0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8String)(value));\n            } catch (error) {\n                logger.throwError(\"invalid JSON\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {\n                    body: value,\n                    error: error\n                });\n            }\n        }\n        if (processFunc) {\n            result = processFunc(result, response);\n        }\n        return result;\n    };\n    // If we have json to send, we must\n    // - add content-type of application/json (unless already overridden)\n    // - convert the json to bytes\n    let body = null;\n    if (json != null) {\n        body = (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(json);\n        // Create a connection with the content-type set for JSON\n        const updated = typeof connection === \"string\" ? {\n            url: connection\n        } : (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.shallowCopy)(connection);\n        if (updated.headers) {\n            const hasContentType = Object.keys(updated.headers).filter((k)=>k.toLowerCase() === \"content-type\").length !== 0;\n            if (!hasContentType) {\n                updated.headers = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.shallowCopy)(updated.headers);\n                updated.headers[\"content-type\"] = \"application/json\";\n            }\n        } else {\n            updated.headers = {\n                \"content-type\": \"application/json\"\n            };\n        }\n        connection = updated;\n    }\n    return _fetchData(connection, body, processJsonFunc);\n}\nfunction poll(func, options) {\n    if (!options) {\n        options = {};\n    }\n    options = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.shallowCopy)(options);\n    if (options.floor == null) {\n        options.floor = 0;\n    }\n    if (options.ceiling == null) {\n        options.ceiling = 10000;\n    }\n    if (options.interval == null) {\n        options.interval = 250;\n    }\n    return new Promise(function(resolve, reject) {\n        let timer = null;\n        let done = false;\n        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.\n        const cancel = ()=>{\n            if (done) {\n                return false;\n            }\n            done = true;\n            if (timer) {\n                clearTimeout(timer);\n            }\n            return true;\n        };\n        if (options.timeout) {\n            timer = setTimeout(()=>{\n                if (cancel()) {\n                    reject(new Error(\"timeout\"));\n                }\n            }, options.timeout);\n        }\n        const retryLimit = options.retryLimit;\n        let attempt = 0;\n        function check() {\n            return func().then(function(result) {\n                // If we have a result, or are allowed null then we're done\n                if (result !== undefined) {\n                    if (cancel()) {\n                        resolve(result);\n                    }\n                } else if (options.oncePoll) {\n                    options.oncePoll.once(\"poll\", check);\n                } else if (options.onceBlock) {\n                    options.onceBlock.once(\"block\", check);\n                // Otherwise, exponential back-off (up to 10s) our next request\n                } else if (!done) {\n                    attempt++;\n                    if (attempt > retryLimit) {\n                        if (cancel()) {\n                            reject(new Error(\"retry limit reached\"));\n                        }\n                        return;\n                    }\n                    let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                    if (timeout < options.floor) {\n                        timeout = options.floor;\n                    }\n                    if (timeout > options.ceiling) {\n                        timeout = options.ceiling;\n                    }\n                    setTimeout(check, timeout);\n                }\n                return null;\n            }, function(error) {\n                if (cancel()) {\n                    reject(error);\n                }\n            });\n        }\n        check();\n    });\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC93ZWIvbGliLmVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQWE7QUFDYixJQUFJQSxZQUFZLFNBQUssSUFBSSxTQUFJLENBQUNBLFNBQVMsSUFBSyxTQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ25GLFNBQVNDLE1BQU1DLEtBQUs7UUFBSSxPQUFPQSxpQkFBaUJILElBQUlHLFFBQVEsSUFBSUgsRUFBRSxTQUFVSSxPQUFPO1lBQUlBLFFBQVFEO1FBQVE7SUFBSTtJQUMzRyxPQUFPLElBQUtILENBQUFBLEtBQU1BLENBQUFBLElBQUlLLE9BQU0sQ0FBQyxFQUFHLFNBQVVELE9BQU8sRUFBRUUsTUFBTTtRQUNyRCxTQUFTQyxVQUFVSixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsVUFBVVEsSUFBSSxDQUFDTjtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzFGLFNBQVNDLFNBQVNSLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxTQUFTLENBQUMsUUFBUSxDQUFDRTtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzdGLFNBQVNGLEtBQUtJLE1BQU07WUFBSUEsT0FBT0MsSUFBSSxHQUFHVCxRQUFRUSxPQUFPVCxLQUFLLElBQUlELE1BQU1VLE9BQU9ULEtBQUssRUFBRVcsSUFBSSxDQUFDUCxXQUFXSTtRQUFXO1FBQzdHSCxLQUFLLENBQUNQLFlBQVlBLFVBQVVjLEtBQUssQ0FBQ2pCLFNBQVNDLGNBQWMsRUFBRSxHQUFHVSxJQUFJO0lBQ3RFO0FBQ0o7QUFDdUY7QUFDM0I7QUFDSjtBQUNXO0FBQ3BCO0FBQ1Y7QUFDckMsTUFBTWtCLFNBQVMsSUFBSUYseURBQU1BLENBQUNDLDZDQUFPQTtBQUNDO0FBQ2xDLFNBQVNH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QUs7b0JBQzNCO29CQUNBLElBQUloRSxVQUFVSCxRQUFRb0UsT0FBTyxFQUFFO3dCQUMzQmpFLFVBQVVILFFBQVFvRSxPQUFPO29CQUM3QjtvQkFDQTdGLFdBQVdpRyxPQUFPckU7Z0JBQ3RCO2dCQUNBLE9BQU87WUFDWCxHQUFHLFNBQVV2QixLQUFLO2dCQUNkLElBQUk2RCxVQUFVO29CQUNWM0YsT0FBTzhCO2dCQUNYO1lBQ0o7UUFDSjtRQUNBNEY7SUFDSjtBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2xpbWUtYmV0Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvd2ViL2xpYi5lc20vaW5kZXguanM/YTYyNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgZGVjb2RlIGFzIGJhc2U2NERlY29kZSwgZW5jb2RlIGFzIGJhc2U2NEVuY29kZSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iYXNlNjRcIjtcbmltcG9ydCB7IGhleGxpZnksIGlzQnl0ZXNMaWtlIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBzaGFsbG93Q29weSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcywgdG9VdGY4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3N0cmluZ3NcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IGdldFVybCB9IGZyb20gXCIuL2dldHVybFwiO1xuZnVuY3Rpb24gc3RhbGxlcihkdXJhdGlvbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGJvZHlpZnkodmFsdWUsIHR5cGUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzQnl0ZXNMaWtlKHZhbHVlKSkge1xuICAgICAgICBpZiAodHlwZSAmJiAodHlwZS5zcGxpdChcIi9cIilbMF0gPT09IFwidGV4dFwiIHx8IHR5cGUuc3BsaXQoXCI7XCIpWzBdLnRyaW0oKSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b1V0ZjhTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4bGlmeSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHVucGVyY2VudCh2YWx1ZSkge1xuICAgIHJldHVybiB0b1V0ZjhCeXRlcyh2YWx1ZS5yZXBsYWNlKC8lKFswLTlhLWZdWzAtOWEtZl0pL2dpLCAoYWxsLCBjb2RlKSA9PiB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGNvZGUsIDE2KSk7XG4gICAgfSkpO1xufVxuLy8gVGhpcyBBUEkgaXMgc3RpbGwgYSB3b3JrIGluIHByb2dyZXNzOyB0aGUgZnV0dXJlIGNoYW5nZXMgd2lsbCBsaWtlbHkgYmU6XG4vLyAtIENvbm5lY3Rpb25JbmZvID0+IEZldGNoRGF0YVJlcXVlc3Q8VCA9IGFueT5cbi8vIC0gRmV0Y2hEYXRhUmVxdWVzdC5ib2R5PyA9IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCB7IGNvbnRlbnRUeXBlOiBzdHJpbmcsIGRhdGE6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfVxuLy8gICAtIElmIHN0cmluZyA9PiB0ZXh0L3BsYWluLCBVaW50OEFycmF5ID0+IGFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSAoaWYgY29udGVudC10eXBlIHVuc3BlY2lmaWVkKVxuLy8gLSBGZXRjaERhdGFSZXF1ZXN0LnByb2Nlc3NGdW5jID0gKGJvZHk6IFVpbnQ4QXJyYXksIHJlc3BvbnNlOiBGZXRjaERhdGFSZXNwb25zZSkgPT4gVFxuLy8gRm9yIHRoaXMgcmVhc29uLCBpdCBzaG91bGQgYmUgY29uc2lkZXJlZCBpbnRlcm5hbCB1bnRpbCB0aGUgQVBJIGlzIGZpbmFsaXplZFxuZXhwb3J0IGZ1bmN0aW9uIF9mZXRjaERhdGEoY29ubmVjdGlvbiwgYm9keSwgcHJvY2Vzc0Z1bmMpIHtcbiAgICAvLyBIb3cgbWFueSB0aW1lcyB0byByZXRyeSBpbiB0aGUgZXZlbnQgb2YgYSB0aHJvdHRsZVxuICAgIGNvbnN0IGF0dGVtcHRMaW1pdCA9ICh0eXBlb2YgKGNvbm5lY3Rpb24pID09PSBcIm9iamVjdFwiICYmIGNvbm5lY3Rpb24udGhyb3R0bGVMaW1pdCAhPSBudWxsKSA/IGNvbm5lY3Rpb24udGhyb3R0bGVMaW1pdCA6IDEyO1xuICAgIGxvZ2dlci5hc3NlcnRBcmd1bWVudCgoYXR0ZW1wdExpbWl0ID4gMCAmJiAoYXR0ZW1wdExpbWl0ICUgMSkgPT09IDApLCBcImludmFsaWQgY29ubmVjdGlvbiB0aHJvdHRsZSBsaW1pdFwiLCBcImNvbm5lY3Rpb24udGhyb3R0bGVMaW1pdFwiLCBhdHRlbXB0TGltaXQpO1xuICAgIGNvbnN0IHRocm90dGxlQ2FsbGJhY2sgPSAoKHR5cGVvZiAoY29ubmVjdGlvbikgPT09IFwib2JqZWN0XCIpID8gY29ubmVjdGlvbi50aHJvdHRsZUNhbGxiYWNrIDogbnVsbCk7XG4gICAgY29uc3QgdGhyb3R0bGVTbG90SW50ZXJ2YWwgPSAoKHR5cGVvZiAoY29ubmVjdGlvbikgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIChjb25uZWN0aW9uLnRocm90dGxlU2xvdEludGVydmFsKSA9PT0gXCJudW1iZXJcIikgPyBjb25uZWN0aW9uLnRocm90dGxlU2xvdEludGVydmFsIDogMTAwKTtcbiAgICBsb2dnZXIuYXNzZXJ0QXJndW1lbnQoKHRocm90dGxlU2xvdEludGVydmFsID4gMCAmJiAodGhyb3R0bGVTbG90SW50ZXJ2YWwgJSAxKSA9PT0gMCksIFwiaW52YWxpZCBjb25uZWN0aW9uIHRocm90dGxlIHNsb3QgaW50ZXJ2YWxcIiwgXCJjb25uZWN0aW9uLnRocm90dGxlU2xvdEludGVydmFsXCIsIHRocm90dGxlU2xvdEludGVydmFsKTtcbiAgICBjb25zdCBlcnJvclBhc3NUaHJvdWdoID0gKCh0eXBlb2YgKGNvbm5lY3Rpb24pID09PSBcIm9iamVjdFwiKSA/ICEhKGNvbm5lY3Rpb24uZXJyb3JQYXNzVGhyb3VnaCkgOiBmYWxzZSk7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgIGxldCB1cmwgPSBudWxsO1xuICAgIC8vIEBUT0RPOiBBbGxvdyBDb25uZWN0aW9uSW5mbyB0byBvdmVycmlkZSBzb21lIG9mIHRoZXNlIHZhbHVlc1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICB9O1xuICAgIGxldCBhbGxvdzMwNCA9IGZhbHNlO1xuICAgIGxldCB0aW1lb3V0ID0gMiAqIDYwICogMTAwMDtcbiAgICBpZiAodHlwZW9mIChjb25uZWN0aW9uKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB1cmwgPSBjb25uZWN0aW9uO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgKGNvbm5lY3Rpb24pID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChjb25uZWN0aW9uID09IG51bGwgfHwgY29ubmVjdGlvbi51cmwgPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgVVJMXCIsIFwiY29ubmVjdGlvbi51cmxcIiwgY29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdXJsID0gY29ubmVjdGlvbi51cmw7XG4gICAgICAgIGlmICh0eXBlb2YgKGNvbm5lY3Rpb24udGltZW91dCkgPT09IFwibnVtYmVyXCIgJiYgY29ubmVjdGlvbi50aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgdGltZW91dCA9IGNvbm5lY3Rpb24udGltZW91dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ubmVjdGlvbi5oZWFkZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb25uZWN0aW9uLmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHsga2V5OiBrZXksIHZhbHVlOiBTdHJpbmcoY29ubmVjdGlvbi5oZWFkZXJzW2tleV0pIH07XG4gICAgICAgICAgICAgICAgaWYgKFtcImlmLW5vbmUtbWF0Y2hcIiwgXCJpZi1tb2RpZmllZC1zaW5jZVwiXS5pbmRleE9mKGtleS50b0xvd2VyQ2FzZSgpKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93MzA0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5hbGxvd0d6aXAgPSAhIWNvbm5lY3Rpb24uYWxsb3dHemlwO1xuICAgICAgICBpZiAoY29ubmVjdGlvbi51c2VyICE9IG51bGwgJiYgY29ubmVjdGlvbi5wYXNzd29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodXJsLnN1YnN0cmluZygwLCA2KSAhPT0gXCJodHRwczpcIiAmJiBjb25uZWN0aW9uLmFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbiAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFzaWMgYXV0aGVudGljYXRpb24gcmVxdWlyZXMgYSBzZWN1cmUgaHR0cHMgdXJsXCIsIExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwgeyBhcmd1bWVudDogXCJ1cmxcIiwgdXJsOiB1cmwsIHVzZXI6IGNvbm5lY3Rpb24udXNlciwgcGFzc3dvcmQ6IFwiW1JFREFDVEVEXVwiIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXV0aG9yaXphdGlvbiA9IGNvbm5lY3Rpb24udXNlciArIFwiOlwiICsgY29ubmVjdGlvbi5wYXNzd29yZDtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJhdXRob3JpemF0aW9uXCJdID0ge1xuICAgICAgICAgICAgICAgIGtleTogXCJBdXRob3JpemF0aW9uXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwiQmFzaWMgXCIgKyBiYXNlNjRFbmNvZGUodG9VdGY4Qnl0ZXMoYXV0aG9yaXphdGlvbikpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25uZWN0aW9uLnNraXBGZXRjaFNldHVwICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2tpcEZldGNoU2V0dXAgPSAhIWNvbm5lY3Rpb24uc2tpcEZldGNoU2V0dXA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbm5lY3Rpb24uZmV0Y2hPcHRpb25zICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZmV0Y2hPcHRpb25zID0gc2hhbGxvd0NvcHkoY29ubmVjdGlvbi5mZXRjaE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlRGF0YSA9IG5ldyBSZWdFeHAoXCJeZGF0YTooW147Ol0qKT8oO2Jhc2U2NCk/LCguKikkXCIsIFwiaVwiKTtcbiAgICBjb25zdCBkYXRhTWF0Y2ggPSAoKHVybCkgPyB1cmwubWF0Y2gocmVEYXRhKSA6IG51bGwpO1xuICAgIGlmIChkYXRhTWF0Y2gpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgICAgICAgICAgICBzdGF0dXNNZXNzYWdlOiBcIk9LXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyBcImNvbnRlbnQtdHlwZVwiOiAoZGF0YU1hdGNoWzFdIHx8IFwidGV4dC9wbGFpblwiKSB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IChkYXRhTWF0Y2hbMl0gPyBiYXNlNjREZWNvZGUoZGF0YU1hdGNoWzNdKSA6IHVucGVyY2VudChkYXRhTWF0Y2hbM10pKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSByZXNwb25zZS5ib2R5O1xuICAgICAgICAgICAgaWYgKHByb2Nlc3NGdW5jKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcHJvY2Vzc0Z1bmMocmVzcG9uc2UuYm9keSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJwcm9jZXNzaW5nIHJlc3BvbnNlIGVycm9yXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keWlmeShkYXRhTWF0Y2hbMV0sIGRhdGFNYXRjaFsyXSksXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5OiBudWxsLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RNZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChib2R5KSB7XG4gICAgICAgIG9wdGlvbnMubWV0aG9kID0gXCJQT1NUXCI7XG4gICAgICAgIG9wdGlvbnMuYm9keSA9IGJvZHk7XG4gICAgICAgIGlmIChoZWFkZXJzW1wiY29udGVudC10eXBlXCJdID09IG51bGwpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSB7IGtleTogXCJDb250ZW50LVR5cGVcIiwgdmFsdWU6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGVyc1tcImNvbnRlbnQtbGVuZ3RoXCJdID09IG51bGwpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJjb250ZW50LWxlbmd0aFwiXSA9IHsga2V5OiBcIkNvbnRlbnQtTGVuZ3RoXCIsIHZhbHVlOiBTdHJpbmcoYm9keS5sZW5ndGgpIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmxhdEhlYWRlcnMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhoZWFkZXJzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gaGVhZGVyc1trZXldO1xuICAgICAgICBmbGF0SGVhZGVyc1toZWFkZXIua2V5XSA9IGhlYWRlci52YWx1ZTtcbiAgICB9KTtcbiAgICBvcHRpb25zLmhlYWRlcnMgPSBmbGF0SGVhZGVycztcbiAgICBjb25zdCBydW5uaW5nVGltZW91dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobG9nZ2VyLm1ha2VFcnJvcihcInRpbWVvdXRcIiwgTG9nZ2VyLmVycm9ycy5USU1FT1VULCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Qm9keTogYm9keWlmeShvcHRpb25zLmJvZHksIGZsYXRIZWFkZXJzW1wiY29udGVudC10eXBlXCJdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RNZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dDogdGltZW91dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aW1lciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgcHJvbWlzZSwgY2FuY2VsIH07XG4gICAgfSkoKTtcbiAgICBjb25zdCBydW5uaW5nRmV0Y2ggPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBhdHRlbXB0TGltaXQ7IGF0dGVtcHQrKykge1xuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB5aWVsZCBnZXRVcmwodXJsLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGVtcHQgPCBhdHRlbXB0TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDEgfHwgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVkaXJlY3Rpb247IGZvciBub3cgd2Ugb25seSBzdXBwb3J0IGFic29sdXRlIGxvY2F0YWlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb24gfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tZXRob2QgPT09IFwiR0VUXCIgJiYgbG9jYXRpb24ubWF0Y2goL15odHRwczovKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MjkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHBvbmVudGlhbCBiYWNrLW9mZiB0aHJvdHRsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRyeUFnYWluID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhyb3R0bGVDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlBZ2FpbiA9IHlpZWxkIHRocm90dGxlQ2FsbGJhY2soYXR0ZW1wdCwgdXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyeUFnYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGFsbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXIgPSByZXNwb25zZS5oZWFkZXJzW1wicmV0cnktYWZ0ZXJcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHJldHJ5QWZ0ZXIpID09PSBcInN0cmluZ1wiICYmIHJldHJ5QWZ0ZXIubWF0Y2goL15bMS05XVswLTldKiQvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhbGwgPSBwYXJzZUludChyZXRyeUFmdGVyKSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFsbCA9IHRocm90dGxlU2xvdEludGVydmFsICogcGFyc2VJbnQoU3RyaW5nKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJTdGFsbGluZyA0MjlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHN0YWxsZXIoc3RhbGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gZXJyb3IucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nVGltZW91dC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibWlzc2luZyByZXNwb25zZVwiLCBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5OiBib2R5aWZ5KG9wdGlvbnMuYm9keSwgZmxhdEhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RNZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGJvZHkgPSByZXNwb25zZS5ib2R5O1xuICAgICAgICAgICAgICAgIGlmIChhbGxvdzMwNCAmJiByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDQpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFlcnJvclBhc3NUaHJvdWdoICYmIChyZXNwb25zZS5zdGF0dXNDb2RlIDwgMjAwIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gMzAwKSkge1xuICAgICAgICAgICAgICAgICAgICBydW5uaW5nVGltZW91dC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJiYWQgcmVzcG9uc2VcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5aWZ5KGJvZHksICgocmVzcG9uc2UuaGVhZGVycykgPyByZXNwb25zZS5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdIDogbnVsbCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IGJvZHlpZnkob3B0aW9ucy5ib2R5LCBmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0TWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHByb2Nlc3NGdW5jKGJvZHksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdUaW1lb3V0LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHRoZSBwcm9jZXNzRnVuYyB0byB0cmlnZ2VyIGEgdGhyb3R0bGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci50aHJvdHRsZVJldHJ5ICYmIGF0dGVtcHQgPCBhdHRlbXB0TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHJ5QWdhaW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aHJvdHRsZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeUFnYWluID0geWllbGQgdGhyb3R0bGVDYWxsYmFjayhhdHRlbXB0LCB1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJ5QWdhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IHRocm90dGxlU2xvdEludGVydmFsICogcGFyc2VJbnQoU3RyaW5nKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiU3RhbGxpbmcgY2FsbGJhY2tcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHN0YWxsZXIodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdUaW1lb3V0LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJwcm9jZXNzaW5nIHJlc3BvbnNlIGVycm9yXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogYm9keWlmeShib2R5LCAoKHJlc3BvbnNlLmhlYWRlcnMpID8gcmVzcG9uc2UuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA6IG51bGwpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IGJvZHlpZnkob3B0aW9ucy5ib2R5LCBmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJ1bm5pbmdUaW1lb3V0LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhZCBhIHByb2Nlc3NGdW5jLCBpdCBlaXRoZXIgcmV0dXJuZWQgYSBUIG9yIHRocmV3IGFib3ZlLlxuICAgICAgICAgICAgICAgIC8vIFRoZSBcImJvZHlcIiBpcyBub3cgYSBVaW50OEFycmF5LlxuICAgICAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiZmFpbGVkIHJlc3BvbnNlXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IGJvZHlpZnkob3B0aW9ucy5ib2R5LCBmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSksXG4gICAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KSgpO1xuICAgIHJldHVybiBQcm9taXNlLnJhY2UoW3J1bm5pbmdUaW1lb3V0LnByb21pc2UsIHJ1bm5pbmdGZXRjaF0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZldGNoSnNvbihjb25uZWN0aW9uLCBqc29uLCBwcm9jZXNzRnVuYykge1xuICAgIGxldCBwcm9jZXNzSnNvbkZ1bmMgPSAodmFsdWUsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKHRvVXRmOFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJpbnZhbGlkIEpTT05cIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzRnVuYykge1xuICAgICAgICAgICAgcmVzdWx0ID0gcHJvY2Vzc0Z1bmMocmVzdWx0LCByZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8vIElmIHdlIGhhdmUganNvbiB0byBzZW5kLCB3ZSBtdXN0XG4gICAgLy8gLSBhZGQgY29udGVudC10eXBlIG9mIGFwcGxpY2F0aW9uL2pzb24gKHVubGVzcyBhbHJlYWR5IG92ZXJyaWRkZW4pXG4gICAgLy8gLSBjb252ZXJ0IHRoZSBqc29uIHRvIGJ5dGVzXG4gICAgbGV0IGJvZHkgPSBudWxsO1xuICAgIGlmIChqc29uICE9IG51bGwpIHtcbiAgICAgICAgYm9keSA9IHRvVXRmOEJ5dGVzKGpzb24pO1xuICAgICAgICAvLyBDcmVhdGUgYSBjb25uZWN0aW9uIHdpdGggdGhlIGNvbnRlbnQtdHlwZSBzZXQgZm9yIEpTT05cbiAgICAgICAgY29uc3QgdXBkYXRlZCA9ICh0eXBlb2YgKGNvbm5lY3Rpb24pID09PSBcInN0cmluZ1wiKSA/ICh7IHVybDogY29ubmVjdGlvbiB9KSA6IHNoYWxsb3dDb3B5KGNvbm5lY3Rpb24pO1xuICAgICAgICBpZiAodXBkYXRlZC5oZWFkZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBoYXNDb250ZW50VHlwZSA9IChPYmplY3Qua2V5cyh1cGRhdGVkLmhlYWRlcnMpLmZpbHRlcigoaykgPT4gKGsudG9Mb3dlckNhc2UoKSA9PT0gXCJjb250ZW50LXR5cGVcIikpLmxlbmd0aCkgIT09IDA7XG4gICAgICAgICAgICBpZiAoIWhhc0NvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlZC5oZWFkZXJzID0gc2hhbGxvd0NvcHkodXBkYXRlZC5oZWFkZXJzKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVkLmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZWQuaGVhZGVycyA9IHsgXCJjb250ZW50LXR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0aW9uID0gdXBkYXRlZDtcbiAgICB9XG4gICAgcmV0dXJuIF9mZXRjaERhdGEoY29ubmVjdGlvbiwgYm9keSwgcHJvY2Vzc0pzb25GdW5jKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb2xsKGZ1bmMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBvcHRpb25zID0gc2hhbGxvd0NvcHkob3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuZmxvb3IgPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLmZsb29yID0gMDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY2VpbGluZyA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMuY2VpbGluZyA9IDEwMDAwO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pbnRlcnZhbCA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMuaW50ZXJ2YWwgPSAyNTA7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBjYW5jZWwgd2FzIHN1Y2Nlc3NmdWwuIFVuc3VjY2Vzc2Z1bCBjYW5jZWwgbWVhbnMgd2UncmUgYWxyZWFkeSBkb25lLlxuICAgICAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy50aW1lb3V0KSB7XG4gICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjYW5jZWwoKSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwidGltZW91dFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgb3B0aW9ucy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXRyeUxpbWl0ID0gb3B0aW9ucy5yZXRyeUxpbWl0O1xuICAgICAgICBsZXQgYXR0ZW1wdCA9IDA7XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmMoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcmVzdWx0LCBvciBhcmUgYWxsb3dlZCBudWxsIHRoZW4gd2UncmUgZG9uZVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuY2VsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9uY2VQb2xsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25jZVBvbGwub25jZShcInBvbGxcIiwgY2hlY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9uY2VCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uY2VCbG9jay5vbmNlKFwiYmxvY2tcIiwgY2hlY2spO1xuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGV4cG9uZW50aWFsIGJhY2stb2ZmICh1cCB0byAxMHMpIG91ciBuZXh0IHJlcXVlc3RcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdCA+IHJldHJ5TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5jZWwoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJyZXRyeSBsaW1pdCByZWFjaGVkXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgdGltZW91dCA9IG9wdGlvbnMuaW50ZXJ2YWwgKiBwYXJzZUludChTdHJpbmcoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIGF0dGVtcHQpKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0IDwgb3B0aW9ucy5mbG9vcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IG9wdGlvbnMuZmxvb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQgPiBvcHRpb25zLmNlaWxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBvcHRpb25zLmNlaWxpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjaGVjaywgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2soKTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJkZWNvZGUiLCJiYXNlNjREZWNvZGUiLCJlbmNvZGUiLCJiYXNlNjRFbmNvZGUiLCJoZXhsaWZ5IiwiaXNCeXRlc0xpa2UiLCJzaGFsbG93Q29weSIsInRvVXRmOEJ5dGVzIiwidG9VdGY4U3RyaW5nIiwiTG9nZ2VyIiwidmVyc2lvbiIsImxvZ2dlciIsImdldFVybCIsInN0YWxsZXIiLCJkdXJhdGlvbiIsInNldFRpbWVvdXQiLCJib2R5aWZ5IiwidHlwZSIsInNwbGl0IiwidHJpbSIsImVycm9yIiwidW5wZXJjZW50IiwicmVwbGFjZSIsImFsbCIsImNvZGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJwYXJzZUludCIsIl9mZXRjaERhdGEiLCJjb25uZWN0aW9uIiwiYm9keSIsInByb2Nlc3NGdW5jIiwiYXR0ZW1wdExpbWl0IiwidGhyb3R0bGVMaW1pdCIsImFzc2VydEFyZ3VtZW50IiwidGhyb3R0bGVDYWxsYmFjayIsInRocm90dGxlU2xvdEludGVydmFsIiwiZXJyb3JQYXNzVGhyb3VnaCIsImhlYWRlcnMiLCJ1cmwiLCJvcHRpb25zIiwibWV0aG9kIiwiYWxsb3czMDQiLCJ0aW1lb3V0IiwidGhyb3dBcmd1bWVudEVycm9yIiwia2V5IiwidG9Mb3dlckNhc2UiLCJpbmRleE9mIiwiYWxsb3dHemlwIiwidXNlciIsInBhc3N3b3JkIiwic3Vic3RyaW5nIiwiYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uIiwidGhyb3dFcnJvciIsImVycm9ycyIsIklOVkFMSURfQVJHVU1FTlQiLCJhcmd1bWVudCIsImF1dGhvcml6YXRpb24iLCJza2lwRmV0Y2hTZXR1cCIsImZldGNoT3B0aW9ucyIsInJlRGF0YSIsIlJlZ0V4cCIsImRhdGFNYXRjaCIsIm1hdGNoIiwicmVzcG9uc2UiLCJzdGF0dXNDb2RlIiwic3RhdHVzTWVzc2FnZSIsIlNFUlZFUl9FUlJPUiIsInJlcXVlc3RCb2R5IiwicmVxdWVzdE1ldGhvZCIsImxlbmd0aCIsImZsYXRIZWFkZXJzIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJoZWFkZXIiLCJydW5uaW5nVGltZW91dCIsInRpbWVyIiwicHJvbWlzZSIsIm1ha2VFcnJvciIsIlRJTUVPVVQiLCJjYW5jZWwiLCJjbGVhclRpbWVvdXQiLCJydW5uaW5nRmV0Y2giLCJhdHRlbXB0IiwibG9jYXRpb24iLCJ0cnlBZ2FpbiIsInN0YWxsIiwicmV0cnlBZnRlciIsIk1hdGgiLCJyYW5kb20iLCJwb3ciLCJzZXJ2ZXJFcnJvciIsInN0YXR1cyIsInRocm90dGxlUmV0cnkiLCJyYWNlIiwiZmV0Y2hKc29uIiwianNvbiIsInByb2Nlc3NKc29uRnVuYyIsIkpTT04iLCJwYXJzZSIsInVwZGF0ZWQiLCJoYXNDb250ZW50VHlwZSIsImZpbHRlciIsImsiLCJwb2xsIiwiZnVuYyIsImZsb29yIiwiY2VpbGluZyIsImludGVydmFsIiwiRXJyb3IiLCJyZXRyeUxpbWl0IiwiY2hlY2siLCJ1bmRlZmluZWQiLCJvbmNlUG9sbCIsIm9uY2UiLCJvbmNlQmxvY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/web/lib.esm/index.js\n");

/***/ })

};
;